\doxysection{igl\+::copyleft\+::cgal Namespace Reference}
\hypertarget{namespaceigl_1_1copyleft_1_1cgal}{}\label{namespaceigl_1_1copyleft_1_1cgal}\index{igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}
\begin{DoxyCompactList}\small\item\em Binary winding number operations. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__INTERSECT_01_4}{Binary\+Winding\+Number\+Operations$<$ MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+INTERSECT $>$}}
\begin{DoxyCompactList}\small\item\em A ∩ B ∩ ... ∩ Z. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__MINUS_01_4}{Binary\+Winding\+Number\+Operations$<$ MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+MINUS $>$}}
\begin{DoxyCompactList}\small\item\em A \textbackslash{} B \textbackslash{} ... \textbackslash{} Z = A \textbackslash{} (B ∪ ... ∪ Z) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__RESOLVE_01_4}{Binary\+Winding\+Number\+Operations$<$ MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+RESOLVE $>$}}
\begin{DoxyCompactList}\small\item\em Resolve all intersections without removing non-\/coplanar faces. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__UNION_01_4}{Binary\+Winding\+Number\+Operations$<$ MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+UNION $>$}}
\begin{DoxyCompactList}\small\item\em A ∪ B ∪ ... ∪ Z. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__XOR_01_4}{Binary\+Winding\+Number\+Operations$<$ MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+XOR $>$}}
\begin{DoxyCompactList}\small\item\em A ∆ B ∆ ... ∆ Z (equivalent to set inside odd number of objects) \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1CSGTree}{CSGTree}}
\begin{DoxyCompactList}\small\item\em Class for defining and computing a constructive solid geometry result out of a tree of boolean operations on \"{}solid\"{} triangle meshes. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam}{Remesh\+Self\+Intersections\+Param}}
\begin{DoxyCompactList}\small\item\em Parameters for \doxylink{classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh}{Self\+Intersect\+Mesh}, remesh\+\_\+self\+\_\+intersections and remesh\+\_\+intersections, and intersect\+\_\+other. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh}{Self\+Intersect\+Mesh}}
\begin{DoxyCompactList}\small\item\em Class for computing the self-\/intersections of a mesh. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter}{Winding\+Number\+Filter}}
\begin{DoxyCompactList}\small\item\em Filter winding numbers according to keep policy. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter_3_01KEEP__ALL_01_4}{Winding\+Number\+Filter$<$ KEEP\+\_\+\+ALL $>$}}
\begin{DoxyCompactList}\small\item\em Keep all policy. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter_3_01KEEP__INSIDE_01_4}{Winding\+Number\+Filter$<$ KEEP\+\_\+\+INSIDE $>$}}
\begin{DoxyCompactList}\small\item\em Keep inside policy. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$ \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+UNION}} $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a41dc481531d9dd2585c545308a2937d7}{Binary\+Union}}
\item 
typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$ \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+INTERSECT}} $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3cad0d59d1e687e9faa8c93e15957b95}{Binary\+Intersect}}
\item 
typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$ \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+MINUS}} $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_adb0880ae718ceaa681706d8b827d54fe}{Binary\+Minus}}
\item 
typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$ \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+XOR}} $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_acda076539de2c25a135eda9462171d87}{Binary\+Xor}}
\item 
typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$ \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+RESOLVE}} $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac06a2805099d616ad29e497091315ac0}{Binary\+Resolve}}
\item 
using \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aca810a2d57eab3749b7a4f9379a9f008}{Keep\+Inside}} = \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter}{Winding\+Number\+Filter}}$<$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce}{KEEP\+\_\+\+INSIDE}} $>$
\item 
using \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aaab770fd7d59c9d5b18d15351d8c13d1}{Keep\+All}} = \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter}{Winding\+Number\+Filter}}$<$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844}{KEEP\+\_\+\+ALL}} $>$
\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2}{Keeper\+Type}} \{ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce}{KEEP\+\_\+\+INSIDE}}
, \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844}{KEEP\+\_\+\+ALL}}
 \}
\begin{DoxyCompactList}\small\item\em Types of Keep policies. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename DerivedC , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a12c0c03c36999f6c7b35421c59ac9ca4}{assign}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const bool slow\+\_\+and\+\_\+more\+\_\+precise, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em Vector version of assign\+\_\+scalar. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedC , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a76ac4bd4ebabba6c96eb47d91a52bf2b}{assign}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Return\+Scalar , typename DerivedC $>$ }\\Eigen\+::\+Matrix$<$ Return\+Scalar, Derived\+C\+::\+Rows\+At\+Compile\+Time, Derived\+C\+::\+Cols\+At\+Compile\+Time, 1, Derived\+C\+::\+Max\+Rows\+At\+Compile\+Time, Derived\+C\+::\+Max\+Cols\+At\+Compile\+Time $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ab463bca3955e73d59383a31bdff724db}{assign}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename RHS , typename LHS $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a5ed0cef244df8ed5e76d2d55af9d57a8}{assign\+\_\+scalar}} (const RHS \&rhs, const bool \&slow\+\_\+and\+\_\+more\+\_\+precise, LHS \&lhs)
\begin{DoxyCompactList}\small\item\em Conduct the casting copy\+: lhs = rhs using {\ttfamily slow\+\_\+and\+\_\+more\+\_\+precise} rounding if more desired. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a9be1cc14112217171bd19402c493b3f6}{assign\+\_\+scalar}} (const CGAL\+::\+Epeck\+::\+FT \&cgal, CGAL\+::\+Epeck\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_abd4577690cb751eced5a7579f08f0573}{assign\+\_\+scalar}} (const CGAL\+::\+Epeck\+::\+FT \&cgal, double \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a335662495e808c70886c2e4d908c3e4f}{assign\+\_\+scalar}} (const CGAL\+::\+Epeck\+::\+FT \&cgal, float \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a6f9ac29ce05a74a311e52206293f83f7}{assign\+\_\+scalar}} (const double \&c, double \&d)
\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7eeb4c3f3e9b2e4b546bad7d1864f9ad}{assign\+\_\+scalar}} (const float \&c, float \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3ec2e0dfa178eeb9a6fb563eda548073}{assign\+\_\+scalar}} (const float \&c, double \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a0c75726a89edabf3602ab1bdc4b1a6f8}{assign\+\_\+scalar}} (const CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&cgal, CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7a0a277a5e9ae4b929373f8a4b812caa}{assign\+\_\+scalar}} (const CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&cgal, double \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a76b2bca21db0d19d293a93ff87246d3a}{assign\+\_\+scalar}} (const CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&cgal, float \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ab1927287ea1fac749a475615e452d8b3}{assign\+\_\+scalar}} (const CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&cgal, CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a268e7b784c30482867d062cdf2bd4235}{assign\+\_\+scalar}} (const CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&cgal, double \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a376e3a13203eae4eb9d3749dfb98e8f7}{assign\+\_\+scalar}} (const CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&cgal, float \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a5f57dae2a4485cc2651abfb51f55cf0e}{cell\+\_\+adjacency}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&per\+\_\+patch\+\_\+cells, const size\+\_\+t num\+\_\+cells, std\+::vector$<$ std\+::set$<$ std\+::tuple$<$ typename Derived\+C\+::\+Scalar, bool, size\+\_\+t $>$ $>$ $>$ \&\mbox{\hyperlink{namespaceigl_a4c905c0e9124bb38a79769497fa9b48b}{adjacency\+\_\+list}})
\begin{DoxyCompactList}\small\item\em Determine adjacency of cells. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename Kernel , typename DerivedR , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a288a0d884f994aadcf7d8058b35113d8}{closest\+\_\+facet}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE, const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&VF, const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&VFi, const CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$\+::iterator $>$ $>$ $>$ \&tree, const std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$ \&triangles, const std\+::vector$<$ bool $>$ \&in\+\_\+I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Determine the closest facet for each of the input points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedR , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac948de3c14554d16b33cc16d7131a5f2}{closest\+\_\+facet}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedR , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_af97e3b6b93bfa938e1f0a7bc2308ca40}{closest\+\_\+facet}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tr , typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a1ccff123c73356ecd24f15f90143a4b7}{complex\+\_\+to\+\_\+mesh}} (const CGAL\+::\+Complex\+\_\+2\+\_\+in\+\_\+triangulation\+\_\+3$<$ Tr $>$ \&c2t3, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Convert a CGAL\+::\+Complex\+\_\+2\+\_\+in\+\_\+triangulation\+\_\+3 to a mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a9135f1c36fb37be3a3dc9a924ef40fe6}{component\+\_\+inside\+\_\+component}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V1, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F1, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I1, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V2, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F2, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I2)
\begin{DoxyCompactList}\small\item\em Determine if connected facet component (V1, F1, I1) is inside of connected facet component (V2, F2, I2). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac01406d0fbbda3a765535e66ed8ee95a}{component\+\_\+inside\+\_\+component}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V1, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F1, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V2, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F2)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedW , typename DerivedG $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ae28edab222791aa6fba773fb1216f592}{convex\+\_\+hull}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G)
\begin{DoxyCompactList}\small\item\em Given a set of points (V), compute the convex hull as a triangle mesh (W,G) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac3d6357a7a4ea861133f2983359ec4ef}{convex\+\_\+hull}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a84ac00710a1dcb3c5d4a26e102f0f422}{coplanar}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em Test whether all points are on same plane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7a07bdc787f5318cc08c6496b4d72fa7}{delaunay\+\_\+triangulation}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Given a set of points in 2D, return a Delaunay triangulation of these points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedC $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a140437f716d88d5a00c55ff4e126f450}{extract\+\_\+cells}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&cells)
\begin{DoxyCompactList}\small\item\em Extract connected 3D space partitioned by mesh (V, F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aca7332bc7dbe6723fc063783c66439b1}{extract\+\_\+cells}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&cells)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedC $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a8f9418b46711333539b0fa6fc3a579c2}{extract\+\_\+cells\+\_\+single\+\_\+component}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&cells)
\begin{DoxyCompactList}\small\item\em Extract connected 3D space partitioned by mesh (V,F) composed of {\bfseries{possibly multiple components}} (the name of this function is dubious). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7b1ff11d15adb5cbb276b8fc71ff17f6}{extract\+\_\+feature}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const double tol, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&feature\+\_\+edges)
\begin{DoxyCompactList}\small\item\em Extract feature edges based on dihedral angle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a1e4c041811adea444b0825237453985c}{extract\+\_\+feature}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const double tol, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&uE, const std\+::vector$<$ std\+::vector$<$ typename Derived\+E\+::\+Scalar $>$ $>$ \&u\+E2E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&feature\+\_\+edges)
\item 
{\footnotesize template$<$typename DerivedP , typename DerivedN , typename DerivedQ , typename Beta\+Type , typename Derived\+WN $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aa9825eec87220923c563797c7119485e}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, const int expansion\+\_\+order, const Beta\+Type beta, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&WN)
\begin{DoxyCompactList}\small\item\em Evaluate the fast winding number for point data, without known areas. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedN , typename DerivedQ , typename Derived\+WN $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_abed4986e59db067d2f048150af7ca39f}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&WN)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a9139148a9ac6f9b4b152790a827c0427}{half\+\_\+space\+\_\+box}} (const CGAL\+::\+Plane\+\_\+3$<$ CGAL\+::\+Epeck $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Matrix$<$ CGAL\+::\+Epeck\+::\+FT, 8, 3 $>$ \&BV, Eigen\+::\+Matrix$<$ int, 12, 3 $>$ \&BF)
\begin{DoxyCompactList}\small\item\em Construct a mesh of box (BV,BF) so that it contains the intersection of the half-\/space under the plane (P) and the bounding box of V, and does not contain any of the half-\/space above (P). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedp , typename Derivedn , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aa7726e6100f1c5c7645949fa2156cf2a}{half\+\_\+space\+\_\+box}} (const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&p, const Eigen\+::\+Matrix\+Base$<$ Derivedn $>$ \&n, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Matrix$<$ CGAL\+::\+Epeck\+::\+FT, 8, 3 $>$ \&BV, Eigen\+::\+Matrix$<$ int, 12, 3 $>$ \&BF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedequ , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ad92813e51e83af95eb0961bf8756b557}{half\+\_\+space\+\_\+box}} (const Eigen\+::\+Matrix\+Base$<$ Derivedequ $>$ \&equ, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Matrix$<$ CGAL\+::\+Epeck\+::\+FT, 8, 3 $>$ \&BV, Eigen\+::\+Matrix$<$ int, 12, 3 $>$ \&BF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Kernel , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3ac0ac630b70601fd761c3f55877c178}{hausdorff}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$\+::iterator $>$ $>$ $>$ \&treeB, const std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&TB, Scalar \&l, Scalar \&u)
\begin{DoxyCompactList}\small\item\em Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.\+g., mesh, triangle soup) given by a distance function handle (dist\+\_\+to\+\_\+B). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\short \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3cbee8698ddf7b0868d3b433b6d5bd77}{incircle}} (const Scalar \texorpdfstring{$\ast$}{*}pa, const Scalar \texorpdfstring{$\ast$}{*}pb, const Scalar \texorpdfstring{$\ast$}{*}pc, const Scalar \texorpdfstring{$\ast$}{*}pd)
\begin{DoxyCompactList}\small\item\em Test whether point is in a given circle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ada1796699e0d1f0830cc933d704cc918}{insert\+\_\+into\+\_\+cdt}} (const CGAL\+::\+Object \&obj, const CGAL\+::\+Plane\+\_\+3$<$ Kernel $>$ \&P, CGAL\+::\+Constrained\+\_\+triangulation\+\_\+plus\+\_\+2$<$ CGAL\+::\+Constrained\+\_\+\+Delaunay\+\_\+triangulation\+\_\+2$<$ Kernel, CGAL\+::\+Triangulation\+\_\+data\+\_\+structure\+\_\+2$<$ CGAL\+::\+Triangulation\+\_\+vertex\+\_\+base\+\_\+2$<$ Kernel $>$, CGAL\+::\+Constrained\+\_\+triangulation\+\_\+face\+\_\+base\+\_\+2$<$ Kernel $>$ $>$, CGAL\+::\+Exact\+\_\+intersections\+\_\+tag $>$ $>$ \&cdt)
\begin{DoxyCompactList}\small\item\em Given a current 2D constrained Delaunay triangulation (cdt), insert a 3D \"{}object\"{} (e.\+g., resulting from intersecting two triangles) into the cdt, by projecting it via the given plane (P) and adding appropriate constraints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\short \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a296c297c8c29baf446426fb8e72e4974}{insphere}} (const Scalar pa\mbox{[}3\mbox{]}, const Scalar pb\mbox{[}3\mbox{]}, const Scalar pc\mbox{[}3\mbox{]}, const Scalar pd\mbox{[}3\mbox{]}, const Scalar pe\mbox{[}3\mbox{]})
\begin{DoxyCompactList}\small\item\em Test whether point is in a given sphere. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+IF , typename Derived\+VVAB , typename Derived\+FFAB , typename Derived\+JAB , typename Derived\+IMAB $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aad0ee9bfc55573ac2ac722c5d6e6d8bc}{intersect\+\_\+other}} (const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FB $>$ \&FB, const \mbox{\hyperlink{structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam}{Remesh\+Self\+Intersections\+Param}} \&params, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IF $>$ \&IF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VVAB $>$ \&VVAB, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FFAB $>$ \&FFAB, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+JAB $>$ \&JAB, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IMAB $>$ \&IMAB)
\begin{DoxyCompactList}\small\item\em Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a0d884b824ed6773fde6de21ce4178b1a}{intersect\+\_\+other}} (const Eigen\+::\+Matrix\+Xd \&VA, const Eigen\+::\+Matrix\+Xi \&FA, const Eigen\+::\+Matrix\+Xd \&VB, const Eigen\+::\+Matrix\+Xi \&FB, const bool first\+\_\+only, Eigen\+::\+Matrix\+Xi \&IF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedp , typename Derivedn , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_acbf85761952ab999a6d3a69e91017ee1}{intersect\+\_\+with\+\_\+half\+\_\+space}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&p, const Eigen\+::\+Matrix\+Base$<$ Derivedn $>$ \&n, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Intersect a PWN mesh with a half-\/space. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedequ , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_afc6b67a7451e027f0c39d1ae171fd1dc}{intersect\+\_\+with\+\_\+half\+\_\+space}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedequ $>$ \&equ, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a28d4989493710230161702638797c2af}{intersect\+\_\+with\+\_\+half\+\_\+space}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const CGAL\+::\+Plane\+\_\+3$<$ CGAL\+::\+Epeck $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a15d7510126e3d13d597b9c2dbe0bac28}{lexicographic\+\_\+triangulation}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Given a set of points in 2D, return a lexicographic triangulation of these points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a06c593a5aedf52ccb8234edccc484607}{mesh\+\_\+boolean}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&FB, const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&type, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Compute Boolean csg operations on \"{}solid\"{}, consistently oriented meshes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ada8cdea765193ffb966531a02372dfd6}{mesh\+\_\+boolean}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&FB, const std\+::string \&type\+\_\+str, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_af80e3892da699c718eebaec432e26db5}{mesh\+\_\+boolean}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&FB, const std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&wind\+\_\+num\+\_\+op, const std\+::function$<$ int(const int, const int)$>$ \&keep, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a2cbd1329be2838714aeed904875b7a39}{mesh\+\_\+boolean}} (const std\+::vector$<$ DerivedV $>$ \&Vlist, const std\+::vector$<$ DerivedF $>$ \&Flist, const std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&wind\+\_\+num\+\_\+op, const std\+::function$<$ int(const int, const int)$>$ \&keep, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Variadic mesh Boolean operations. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a2365a0f9b66688565308b8c431321390}{mesh\+\_\+boolean}} (const std\+::vector$<$ DerivedV $>$ \&Vlist, const std\+::vector$<$ DerivedF $>$ \&Flist, const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&type, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VV , typename Derived\+FF , typename Derivedsizes , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ae3ca56172ae354965d5ec22690a6f488}{mesh\+\_\+boolean}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VV $>$ \&VV, const Eigen\+::\+Matrix\+Base$<$ Derived\+FF $>$ \&FF, const Eigen\+::\+Matrix\+Base$<$ Derivedsizes $>$ \&sizes, const std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&wind\+\_\+num\+\_\+op, const std\+::function$<$ int(const int, const int)$>$ \&keep, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aa93f53bb9649aefd700d76e8fbbc628c}{mesh\+\_\+boolean}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&FB, const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&type, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&VC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&FC)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a4a7a5d1111aea73ba095a0af9bf39153}{mesh\+\_\+boolean\+\_\+type\+\_\+to\+\_\+funcs}} (const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&type, std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&wind\+\_\+num\+\_\+op, std\+::function$<$ int(const int, const int)$>$ \&keep)
\begin{DoxyCompactList}\small\item\em Convert a Mesh\+Boolean\+Type enum to a pair of winding number conversion function and \"{}keep\"{} function used by mesh\+\_\+boolean. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Kernel $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac9d72d2b7b5a3aa61b67b44df084c7db}{mesh\+\_\+to\+\_\+cgal\+\_\+triangle\+\_\+list}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&T)
\begin{DoxyCompactList}\small\item\em Convert a mesh (V,F) to a list of CGAL triangles. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Polyhedron $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a02acbbee9fc0e71fecf7e1f3ee5a58a8}{mesh\+\_\+to\+\_\+polyhedron}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Polyhedron \&poly)
\begin{DoxyCompactList}\small\item\em Convert a mesh (V,F) to a CGAL Polyhedron. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename DerivedW , typename DerivedG , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aae36641a8877fe6384673c10bef5d05c}{minkowski\+\_\+sum}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&FB, const bool resolve\+\_\+overlaps, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Compute the Minkowski sum of a closed triangle mesh (V,F) and a set of simplices in 3D. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename s\+Type , int s\+Cols, int s\+Options, typename d\+Type , int d\+Cols, int d\+Options, typename DerivedW , typename DerivedG , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac24439be4f8127484eeecd0dbf9f0ded}{minkowski\+\_\+sum}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix$<$ s\+Type, 1, s\+Cols, s\+Options $>$ \&s, const Eigen\+::\+Matrix$<$ d\+Type, 1, d\+Cols, d\+Options $>$ \&d, const bool resolve\+\_\+overlaps, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename s\+Type , int s\+Cols, int s\+Options, typename d\+Type , int d\+Cols, int d\+Options, typename DerivedW , typename DerivedG , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aa7a270ca1724856eb95f5d2a31056f99}{minkowski\+\_\+sum}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix$<$ s\+Type, 1, s\+Cols, s\+Options $>$ \&s, const Eigen\+::\+Matrix$<$ d\+Type, 1, d\+Cols, d\+Options $>$ \&d, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a8689344acbbb3e7bec33eb425d59cdde}{order\+\_\+facets\+\_\+around\+\_\+edge}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, size\+\_\+t s, size\+\_\+t d, const std\+::vector$<$ int $>$ \&adj\+\_\+faces, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&order, bool debug=false)
\begin{DoxyCompactList}\small\item\em Given a directed edge, sort its adjacent faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aa24fb4d258316354531a7d02652cf1f3}{order\+\_\+facets\+\_\+around\+\_\+edge}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, size\+\_\+t s, size\+\_\+t d, const std\+::vector$<$ int $>$ \&adj\+\_\+faces, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&pivot\+\_\+point, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&order)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename u\+E2\+EType , typename u\+E2o\+EType , typename u\+E2\+CType $>$ }\\std\+::enable\+\_\+if$<$!std\+::is\+\_\+same$<$ typename\+Derived\+V\+::\+Scalar, typename\+CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+::\+FT $>$\+::value, void $>$\+::type \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_afc6ed199484566caed79fdc9ca79d92a}{order\+\_\+facets\+\_\+around\+\_\+edges}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, std\+::vector$<$ std\+::vector$<$ u\+E2o\+EType $>$ $>$ \&u\+E2oE, std\+::vector$<$ std\+::vector$<$ u\+E2\+CType $>$ $>$ \&u\+E2C)
\begin{DoxyCompactList}\small\item\em For each undirected edge, sort its adjacent faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename u\+E2\+EType , typename u\+E2o\+EType , typename u\+E2\+CType $>$ }\\std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ typename\+Derived\+V\+::\+Scalar, typename\+CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+::\+FT $>$\+::value, void $>$\+::type \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a77808bfdbb9a20091bf1403f0df54225}{order\+\_\+facets\+\_\+around\+\_\+edges}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, std\+::vector$<$ std\+::vector$<$ u\+E2o\+EType $>$ $>$ \&u\+E2oE, std\+::vector$<$ std\+::vector$<$ u\+E2\+CType $>$ $>$ \&u\+E2C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DeriveduE , typename u\+E2\+EType , typename u\+E2o\+EType , typename u\+E2\+CType $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac9d848d80df05abbc188abf9410eff26}{order\+\_\+facets\+\_\+around\+\_\+edges}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, std\+::vector$<$ std\+::vector$<$ u\+E2o\+EType $>$ $>$ \&u\+E2oE, std\+::vector$<$ std\+::vector$<$ u\+E2\+CType $>$ $>$ \&u\+E2C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\short \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_afc46637c226f5ef8f24214ecf37fa2dc}{orient2D}} (const Scalar \texorpdfstring{$\ast$}{*}pa, const Scalar \texorpdfstring{$\ast$}{*}pb, const Scalar \texorpdfstring{$\ast$}{*}pc)
\begin{DoxyCompactList}\small\item\em Tests whether a point is above, on, or below a line. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\short \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ad5b50178318855b0ef08301aabb646e1}{orient3D}} (const Scalar pa\mbox{[}3\mbox{]}, const Scalar pb\mbox{[}3\mbox{]}, const Scalar pc\mbox{[}3\mbox{]}, const Scalar pd\mbox{[}3\mbox{]})
\begin{DoxyCompactList}\small\item\em Tests whether a point is above, on, or below a plane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a8612a06da5a83f2d0eb5234eb996a099}{outer\+\_\+edge}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Index\+Type \&v1, Index\+Type \&v2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Find an edge that is reachable from infinity without crossing any faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename Index\+Type $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_af01d429e270d88b1c279c860631ad5a7}{outer\+\_\+facet}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Index\+Type \&f, bool \&flipped)
\begin{DoxyCompactList}\small\item\em Find a facet that is reachable from infinity without crossing any faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a075bcb6ea0a7e4bd56f56d57255422f7}{outer\+\_\+facet}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Index\+Type \&f, bool \&flipped)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+HV , typename Derived\+HF , typename DerivedJ , typename Derivedflip $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_abf86c29b557c7341d5d6a2ae734273d4}{outer\+\_\+hull}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+HV $>$ \&HV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+HF $>$ \&HF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derivedflip $>$ \&flip)
\begin{DoxyCompactList}\small\item\em Compute the \"{}outer hull\"{} of a piecewise constant winding number induce triangle mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedG , typename DerivedJ , typename Derivedflip $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a0a69c0cfdf86cb14a3a1af742b322257}{outer\+\_\+hull\+\_\+legacy}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derivedflip $>$ \&flip)
\begin{DoxyCompactList}\small\item\em Compute the \"{}outer hull\"{} of a potentially non-\/manifold mesh (V,F) whose intersections have been \"{}resolved\"{} (e.\+g. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a978bd4e32580644accd9602fafec9c3d}{outer\+\_\+vertex}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Index\+Type \&v\+\_\+index, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Find a vertex that is reachable from infinite without crossing any faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Derivedflip $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a1a3a5e1ab834f987bb22bceea2d29f36}{peel\+\_\+outer\+\_\+hull\+\_\+layers}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ Derivedflip $>$ \&flip)
\begin{DoxyCompactList}\small\item\em Computes necessary generic information for boolean operations by successively \"{}peeling\"{} off the \"{}outer hull\"{} of a mesh (V,F) resulting from \"{}resolving\"{} all (self-\/)intersections. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedW $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac1f61d0bdf6d687737bc08b5fa72111a}{peel\+\_\+winding\+\_\+number\+\_\+layers}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Peel Winding number layers from a mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a55276c7ddaadbfad9b0ddf0beeb756fe}{piecewise\+\_\+constant\+\_\+winding\+\_\+number}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Determine if a given mesh induces a piecewise constant winding number field\+: Is this mesh valid input to solid set operations. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a1240cef3d039ac518baca44025fe1adc}{point\+\_\+areas}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em Given a 3D set of points P, each with a list of k-\/nearest-\/neighbours, estimate the geodesic voronoi area associated with each point. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3b9e1a72f57d4b751d6ad9a482a00e36}{point\+\_\+areas}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedsqrD , typename DerivedI , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a538a22d0da720af8d4bc8943eeb78ccd}{point\+\_\+mesh\+\_\+squared\+\_\+distance}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&sqrD, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute distances from a set of points P to a triangle mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7079694987005d32d246369f638930a2}{point\+\_\+mesh\+\_\+squared\+\_\+distance\+\_\+precompute}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$\+::iterator $>$ $>$ $>$ \&tree, std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&T)
\begin{DoxyCompactList}\small\item\em precomputation for point\+\_\+mesh\+\_\+squared\+\_\+distance \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename DerivedP , typename DerivedsqrD , typename DerivedI , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a4b06702d1399da65b7d57a7883a903cd}{point\+\_\+mesh\+\_\+squared\+\_\+distance}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$\+::iterator $>$ $>$ $>$ \&tree, const std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&sqrD, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute distances from a set of points P to a triangle mesh (V,F) using precomputed trees. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aeb0f63485251c67fe5632d5177cf3cf8}{point\+\_\+segment\+\_\+squared\+\_\+distance}} (const CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P1, const CGAL\+::\+Segment\+\_\+3$<$ Kernel $>$ \&S2, CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P2, typename Kernel\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em Given a point P1 and segment S2 find the points on each of closest approach and the squared distance thereof. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedQ , typename Derived\+VB , typename Derived\+FB , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aba6c0e12a671c3facc2b5129904c738e}{point\+\_\+solid\+\_\+signed\+\_\+squared\+\_\+distance}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FB $>$ \&FB, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em Given a set of points (Q) and the boundary mesh (VB,FB) of a solid (as defined in \mbox{[}Zhou et al. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a27577e36f63f566d05abe10135706585}{point\+\_\+triangle\+\_\+squared\+\_\+distance}} (const CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P1, const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&T2, CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P2, typename Kernel\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em Given a point P1 and triangle T2 find the points on each of closest approach and the squared distance thereof. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a41473b3f595af6326c481f3be623b95d}{points\+\_\+inside\+\_\+component}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&inside)
\begin{DoxyCompactList}\small\item\em Determine if queries points P are inside of connected facet component (V, F, I), where I indicates a subset of facets that forms the component. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aa361bd05fcdd8ce7cc09059a90a71397}{points\+\_\+inside\+\_\+component}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&inside)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Polyhedron , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a9163b384abc034cb8ef2c61e545c1da0}{polyhedron\+\_\+to\+\_\+mesh}} (const Polyhedron \&poly, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Convert a CGAL Polyhedron to a mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ad6b773fa54359274318604d433dd2e9a}{projected\+\_\+cdt}} (const std\+::vector$<$ CGAL\+::\+Object $>$ \&objects, const CGAL\+::\+Plane\+\_\+3$<$ Kernel $>$ \&P, std\+::vector$<$ CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ $>$ \&vertices, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&faces)
\begin{DoxyCompactList}\small\item\em Given a list of objects (e.\+g., resulting from intersecting a triangle with many other triangles), construct a constrained Delaunay triangulation on a given plane (P), by inersting constraints for each object projected onto that plane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a45607f6c08fba2fc4a797244d7c75b81}{projected\+\_\+cdt}} (const std\+::vector$<$ CGAL\+::\+Object $>$ \&objects, const CGAL\+::\+Plane\+\_\+3$<$ Kernel $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7a62d282e26f8a1b91722dd9da3b5bd2}{projected\+\_\+delaunay}} (const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&A, const std\+::vector$<$ CGAL\+::\+Object $>$ \&A\+\_\+objects\+\_\+3, CGAL\+::\+Constrained\+\_\+triangulation\+\_\+plus\+\_\+2$<$ CGAL\+::\+Constrained\+\_\+\+Delaunay\+\_\+triangulation\+\_\+2$<$ Kernel, CGAL\+::\+Triangulation\+\_\+data\+\_\+structure\+\_\+2$<$ CGAL\+::\+Triangulation\+\_\+vertex\+\_\+base\+\_\+2$<$ Kernel $>$, CGAL\+::\+Constrained\+\_\+triangulation\+\_\+face\+\_\+base\+\_\+2$<$ Kernel $>$ $>$, CGAL\+::\+Exact\+\_\+intersections\+\_\+tag $>$ $>$ \&cdt)
\begin{DoxyCompactList}\small\item\em Compute 2D delaunay triangulation of a given 3d triangle and a list of intersection objects (points,segments,triangles). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedL , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ab29a1ce9ef6539d66c1400a27db655d0}{propagate\+\_\+winding\+\_\+numbers}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&labels, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Compute winding number on each side of the face. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DeriveduE , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedP , typename DerivedC , typename DerivedL , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a55a2fbf8152086bfb9f61740ebdec358}{propagate\+\_\+winding\+\_\+numbers}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE, const size\+\_\+t num\+\_\+patches, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const size\+\_\+t num\+\_\+cells, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&labels, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ae8359e73ff0ee8149c314d3816b5958f}{read\+\_\+triangle\+\_\+mesh}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Simple wrapper, reads floating point precision but assigns to Derived\+V\+::\+Scalar which may be a CGAL type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedC , typename FT , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3d3dc739f900eb1f9479e974de035d2c}{relabel\+\_\+small\+\_\+immersed\+\_\+cells}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const size\+\_\+t num\+\_\+patches, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const size\+\_\+t num\+\_\+cells, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, const FT vol\+\_\+threashold, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Relabel winding numbers of small immersed cells. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Kernel , typename Derived\+VV , typename Derived\+FF , typename DerivedJ , typename Derived\+IM $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a99d687331f910fef280e3a0e5f5370c7}{remesh\+\_\+intersections}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&T, const std\+::map$<$ typename Derived\+F\+::\+Index, std\+::vector$<$ std\+::pair$<$ typename Derived\+F\+::\+Index, CGAL\+::\+Object $>$ $>$ $>$ \&offending, bool stitch\+\_\+all, bool slow\+\_\+and\+\_\+more\+\_\+precise\+\_\+rounding, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&VV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&IM)
\begin{DoxyCompactList}\small\item\em Remesh faces according to results of intersection detection and construction (e.\+g. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VV , typename Derived\+FF , typename Derived\+IF , typename DerivedJ , typename Derived\+IM $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7169f4ae2fe2c11f7e878b41aa747fc2}{remesh\+\_\+self\+\_\+intersections}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam}{Remesh\+Self\+Intersections\+Param}} \&params, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&VV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IF $>$ \&IF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&IM)
\begin{DoxyCompactList}\small\item\em Given a triangle mesh (V,F) compute a new mesh (VV,FF) which is the same as (V,F) except that any self-\/intersecting triangles in (V,F) have been subdivided (new vertices and face created) so that the self-\/intersection contour lies exactly on edges in (VV,FF). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedE , typename Derived\+VI , typename Derived\+EI , typename DerivedJ , typename Derived\+IM $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a4711ebc19670232979ddfafeea023a6c}{resolve\+\_\+intersections}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&VI, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EI $>$ \&EI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&IM)
\begin{DoxyCompactList}\small\item\em Given a list of possible intersecting segments with endpoints, split segments to overlap only at endpoints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename DerivedV $>$ }\\CGAL\+::\+Point\+\_\+2$<$ Kernel $>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aacfa81a78943385b9146fe53e121b380}{row\+\_\+to\+\_\+point}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const typename Derived\+V\+::\+Index \&i)
\begin{DoxyCompactList}\small\item\em Extract a row from V and treat as a 2D cgal point (only first two columns of V are used). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a1cd33a114c5e272d9d444bea740c4cfc}{segment\+\_\+segment\+\_\+squared\+\_\+distance}} (const CGAL\+::\+Segment\+\_\+3$<$ Kernel $>$ \&S1, const CGAL\+::\+Segment\+\_\+3$<$ Kernel $>$ \&S2, CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P1, CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P2, typename Kernel\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em Given two segments S1 and S2 find the points on each of closest approach and the squared distance thereof. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a240ec71bf9ed8497cca131ce80e30045}{signed\+\_\+distance\+\_\+isosurface}} (const Eigen\+::\+Matrix\+Xd \&IV, const Eigen\+::\+Matrix\+Xi \&IF, const double level, const double angle\+\_\+bound, const double radius\+\_\+bound, const double distance\+\_\+bound, const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}} sign\+\_\+type, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F)
\begin{DoxyCompactList}\small\item\em Compute the contour of an iso-\/level of the signed distance field to a given mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedE , typename Derived\+VI , typename Derived\+EI , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a56339aee719b66761234276a14d7003f}{snap\+\_\+rounding}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&VI, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EI $>$ \&EI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Snap a list of possible intersecting segments with endpoints in any precision to {\itshape the} integer grid. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac105fc714db9b51b1c3945c51e6e5a19}{string\+\_\+to\+\_\+mesh\+\_\+boolean\+\_\+type}} (const std\+::string \&s, \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&type)
\begin{DoxyCompactList}\small\item\em Convert string to boolean type. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a5cb4ded3fe8818156a5f7c540d771835}{string\+\_\+to\+\_\+mesh\+\_\+boolean\+\_\+type}} (const std\+::string \&s)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedE , typename Kernel , typename Derived\+VI , typename Derived\+EI , typename DerivedJ , typename Derived\+IM $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a347c87769a3b67d0bee379fb78705679}{subdivide\+\_\+segments}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, const std\+::vector$<$ std\+::vector$<$ CGAL\+::\+Point\+\_\+2$<$ Kernel $>$ $>$ $>$ \&steiner, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&VI, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EI $>$ \&EI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&IM)
\begin{DoxyCompactList}\small\item\em Insert steiner points to subdivide a given set of line segments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Kernel $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3b5cc8bbbcee4ed4567bc754a4e939c0}{submesh\+\_\+aabb\+\_\+tree}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$\+::iterator $>$ $>$ $>$ \&tree, std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$ \&triangles, std\+::vector$<$ bool $>$ \&in\+\_\+I)
\begin{DoxyCompactList}\small\item\em Build an \doxylink{classigl_1_1AABB}{AABB} tree for a submesh indicated by a face selection list I of a full mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel $>$ }\\bool \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a745c9671e98e82bb4f285b028c1aa8c9}{triangle\+\_\+triangle\+\_\+squared\+\_\+distance}} (const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&T1, const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&T2, CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P1, CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&P2, typename Kernel\+::\+FT \&d)
\begin{DoxyCompactList}\small\item\em Given two triangles T1 and T2 find the points on each of closest approach and the squared distance thereof. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Kernel , typename DerivedV , typename DerivedE , typename DerivedH , typename Derived\+V2 , typename Derived\+F2 $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a2c5d9c112aaddddfc00781eb000fddd4}{triangulate}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedH $>$ \&H, const bool retain\+\_\+convex\+\_\+hull, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V2 $>$ \&V2, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F2 $>$ \&F2)
\begin{DoxyCompactList}\small\item\em Triangulate the interior of a polygon using CGAL. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename DerivedV , typename DerivedF , typename DerivedD , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a6dca57f7cfcb9b65b561d5d3ccec99be}{trim\+\_\+with\+\_\+solid}} (const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FB $>$ \&FB, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&Vd, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Given an arbitrary mesh (VA,FA) and the boundary mesh (VB,FB) of a solid (as defined in \mbox{[}Zhou et al. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+WV , typename Derived\+WE , typename Derivedth , typename DerivedV , typename DerivedF , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a1da8adecc2e7b09a987748532fb975d2}{wire\+\_\+mesh}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+WV $>$ \&WV, const Eigen\+::\+Matrix\+Base$<$ Derived\+WE $>$ \&WE, const Eigen\+::\+Matrix\+Base$<$ Derivedth $>$ \&th, const int poly\+\_\+size, const bool solid, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Construct a \"{}wire\"{} or \"{}wireframe\"{} or \"{}strut\"{} surface mesh, given a one-\/dimensional network of straight edges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+WV , typename Derived\+WE , typename DerivedV , typename DerivedF , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a7dc5cdc053c1f25a930d46be790a7c74}{wire\+\_\+mesh}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+WV $>$ \&WV, const Eigen\+::\+Matrix\+Base$<$ Derived\+WE $>$ \&WE, const double th, const int poly\+\_\+size, const bool solid, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+WV , typename Derived\+WE , typename DerivedV , typename DerivedF , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a88a350d009b191ea77e7bb454a2936d7}{wire\+\_\+mesh}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+WV $>$ \&WV, const Eigen\+::\+Matrix\+Base$<$ Derived\+WE $>$ \&WE, const double th, const int poly\+\_\+size, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a41dc481531d9dd2585c545308a2937d7}\label{namespaceigl_1_1copyleft_1_1cgal_a41dc481531d9dd2585c545308a2937d7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!BinaryUnion@{BinaryUnion}}
\index{BinaryUnion@{BinaryUnion}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{BinaryUnion}{BinaryUnion}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+UNION}}$>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a41dc481531d9dd2585c545308a2937d7}{igl\+::copyleft\+::cgal\+::\+Binary\+Union}}}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3cad0d59d1e687e9faa8c93e15957b95}\label{namespaceigl_1_1copyleft_1_1cgal_a3cad0d59d1e687e9faa8c93e15957b95} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!BinaryIntersect@{BinaryIntersect}}
\index{BinaryIntersect@{BinaryIntersect}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{BinaryIntersect}{BinaryIntersect}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+INTERSECT}}$>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a3cad0d59d1e687e9faa8c93e15957b95}{igl\+::copyleft\+::cgal\+::\+Binary\+Intersect}}}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_adb0880ae718ceaa681706d8b827d54fe}\label{namespaceigl_1_1copyleft_1_1cgal_adb0880ae718ceaa681706d8b827d54fe} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!BinaryMinus@{BinaryMinus}}
\index{BinaryMinus@{BinaryMinus}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{BinaryMinus}{BinaryMinus}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+MINUS}}$>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_adb0880ae718ceaa681706d8b827d54fe}{igl\+::copyleft\+::cgal\+::\+Binary\+Minus}}}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_acda076539de2c25a135eda9462171d87}\label{namespaceigl_1_1copyleft_1_1cgal_acda076539de2c25a135eda9462171d87} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!BinaryXor@{BinaryXor}}
\index{BinaryXor@{BinaryXor}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{BinaryXor}{BinaryXor}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+XOR}}$>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_acda076539de2c25a135eda9462171d87}{igl\+::copyleft\+::cgal\+::\+Binary\+Xor}}}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac06a2805099d616ad29e497091315ac0}\label{namespaceigl_1_1copyleft_1_1cgal_ac06a2805099d616ad29e497091315ac0} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!BinaryResolve@{BinaryResolve}}
\index{BinaryResolve@{BinaryResolve}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{BinaryResolve}{BinaryResolve}}
{\footnotesize\ttfamily typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations}{Binary\+Winding\+Number\+Operations}}$<$\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+RESOLVE}}$>$ \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_ac06a2805099d616ad29e497091315ac0}{igl\+::copyleft\+::cgal\+::\+Binary\+Resolve}}}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aca810a2d57eab3749b7a4f9379a9f008}\label{namespaceigl_1_1copyleft_1_1cgal_aca810a2d57eab3749b7a4f9379a9f008} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!KeepInside@{KeepInside}}
\index{KeepInside@{KeepInside}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{KeepInside}{KeepInside}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aca810a2d57eab3749b7a4f9379a9f008}{igl\+::copyleft\+::cgal\+::\+Keep\+Inside}} = typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter}{Winding\+Number\+Filter}}$<$\mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce}{KEEP\+\_\+\+INSIDE}}$>$}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aaab770fd7d59c9d5b18d15351d8c13d1}\label{namespaceigl_1_1copyleft_1_1cgal_aaab770fd7d59c9d5b18d15351d8c13d1} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!KeepAll@{KeepAll}}
\index{KeepAll@{KeepAll}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{KeepAll}{KeepAll}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_aaab770fd7d59c9d5b18d15351d8c13d1}{igl\+::copyleft\+::cgal\+::\+Keep\+All}} = typedef \mbox{\hyperlink{classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter}{Winding\+Number\+Filter}}$<$\mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844}{KEEP\+\_\+\+ALL}}$>$}



\doxysubsection{Enumeration Type Documentation}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2}\label{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!KeeperType@{KeeperType}}
\index{KeeperType@{KeeperType}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{KeeperType}{KeeperType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2}{igl\+::copyleft\+::cgal\+::\+Keeper\+Type}}}



Types of Keep policies. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{KEEP\_INSIDE@{KEEP\_INSIDE}!igl::copyleft::cgal@{igl::copyleft::cgal}}\index{igl::copyleft::cgal@{igl::copyleft::cgal}!KEEP\_INSIDE@{KEEP\_INSIDE}}}\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce}\label{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce} 
KEEP\+\_\+\+INSIDE&Keep only inside. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{KEEP\_ALL@{KEEP\_ALL}!igl::copyleft::cgal@{igl::copyleft::cgal}}\index{igl::copyleft::cgal@{igl::copyleft::cgal}!KEEP\_ALL@{KEEP\_ALL}}}\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844}\label{namespaceigl_1_1copyleft_1_1cgal_a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844} 
KEEP\+\_\+\+ALL&Keep everything. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a12c0c03c36999f6c7b35421c59ac9ca4}\label{namespaceigl_1_1copyleft_1_1cgal_a12c0c03c36999f6c7b35421c59ac9ca4} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign@{assign}}
\index{assign@{assign}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedC , typename DerivedD $>$ \\
void igl\+::copyleft\+::cgal\+::assign (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const bool}]{slow\+\_\+and\+\_\+more\+\_\+precise,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



Vector version of assign\+\_\+scalar. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em C} & matrix of scalars \\
\hline
\mbox{\texttt{ in}}  & {\em slow\+\_\+and\+\_\+more\+\_\+precise} & see assign\+\_\+scalar \\
\hline
\mbox{\texttt{ out}}  & {\em D} & matrix same size as C\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1copyleft_1_1cgal_a5ed0cef244df8ed5e76d2d55af9d57a8}{assign\+\_\+scalar} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a76ac4bd4ebabba6c96eb47d91a52bf2b}\label{namespaceigl_1_1copyleft_1_1cgal_a76ac4bd4ebabba6c96eb47d91a52bf2b} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign@{assign}}
\index{assign@{assign}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedC , typename DerivedD $>$ \\
void igl\+::copyleft\+::cgal\+::assign (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ab463bca3955e73d59383a31bdff724db}\label{namespaceigl_1_1copyleft_1_1cgal_ab463bca3955e73d59383a31bdff724db} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign@{assign}}
\index{assign@{assign}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign()}{assign()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Return\+Scalar , typename DerivedC $>$ \\
Eigen\+::\+Matrix$<$ Return\+Scalar, Derived\+C\+::\+Rows\+At\+Compile\+Time, Derived\+C\+::\+Cols\+At\+Compile\+Time, 1, Derived\+C\+::\+Max\+Rows\+At\+Compile\+Time, Derived\+C\+::\+Max\+Cols\+At\+Compile\+Time $>$ igl\+::copyleft\+::cgal\+::assign (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a5ed0cef244df8ed5e76d2d55af9d57a8}\label{namespaceigl_1_1copyleft_1_1cgal_a5ed0cef244df8ed5e76d2d55af9d57a8} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [1/13]}}
{\footnotesize\ttfamily template$<$typename RHS , typename LHS $>$ \\
void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const RHS \&}]{rhs,  }\item[{const bool \&}]{slow\+\_\+and\+\_\+more\+\_\+precise,  }\item[{LHS \&}]{lhs }\end{DoxyParamCaption})}



Conduct the casting copy\+: lhs = rhs using {\ttfamily slow\+\_\+and\+\_\+more\+\_\+precise} rounding if more desired. 


\begin{DoxyTemplParams}{Template Parameters}
{\em RHS} & right-\/hand side scalar type \\
\hline
{\em LHS} & left-\/hand side scalar type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em rhs} & right-\/hand side scalar \\
\hline
\mbox{\texttt{ in}}  & {\em slow\+\_\+and\+\_\+more\+\_\+precise} & when appropriate use more elaborate rounding guaranteed to find a closest lhs value in an absolute value sense. Think of {\ttfamily slow\+\_\+and\+\_\+more\+\_\+precise=true} as \"{}round to closest number\"{} and {\ttfamily slow\+\_\+and\+\_\+more\+\_\+precise=false} as \"{}round down/up\"{}. CGAL\textquotesingle{}s number types are bit mysterious about how exactly rounding is conducted. For example, the rationals created during remesh\+\_\+intersections on floating point input appear to be tightly rounded up or down so the difference with the {\ttfamily slow\+\_\+and\+\_\+more\+\_\+precise=true} will be exactly zero 50\% of the time and \"{}one floating point unit\"{} (at whatever scale) the other 50\% of the time. \\
\hline
\mbox{\texttt{ out}}  & {\em lhs} & left-\/hand side scalar \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a9be1cc14112217171bd19402c493b3f6}\label{namespaceigl_1_1copyleft_1_1cgal_a9be1cc14112217171bd19402c493b3f6} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [2/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Epeck\+::\+FT \&}]{cgal,  }\item[{CGAL\+::\+Epeck\+::\+FT \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

For legacy reasons, all of these overload uses {\ttfamily slow\+\_\+and\+\_\+more\+\_\+precise=true}. This is subject to change if we determine it is sufficiently overkill. In that case, we\textquotesingle{}d create a new non-\/overloaded function. \Hypertarget{namespaceigl_1_1copyleft_1_1cgal_abd4577690cb751eced5a7579f08f0573}\label{namespaceigl_1_1copyleft_1_1cgal_abd4577690cb751eced5a7579f08f0573} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [3/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Epeck\+::\+FT \&}]{cgal,  }\item[{double \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a335662495e808c70886c2e4d908c3e4f}\label{namespaceigl_1_1copyleft_1_1cgal_a335662495e808c70886c2e4d908c3e4f} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [4/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Epeck\+::\+FT \&}]{cgal,  }\item[{float \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}{Parameters}
{\em cgal} & This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a6f9ac29ce05a74a311e52206293f83f7}\label{namespaceigl_1_1copyleft_1_1cgal_a6f9ac29ce05a74a311e52206293f83f7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [5/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const double \&}]{c,  }\item[{double \&}]{d }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em c} & This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7eeb4c3f3e9b2e4b546bad7d1864f9ad}\label{namespaceigl_1_1copyleft_1_1cgal_a7eeb4c3f3e9b2e4b546bad7d1864f9ad} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [6/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const float \&}]{c,  }\item[{float \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3ec2e0dfa178eeb9a6fb563eda548073}\label{namespaceigl_1_1copyleft_1_1cgal_a3ec2e0dfa178eeb9a6fb563eda548073} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [7/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const float \&}]{c,  }\item[{double \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a0c75726a89edabf3602ab1bdc4b1a6f8}\label{namespaceigl_1_1copyleft_1_1cgal_a0c75726a89edabf3602ab1bdc4b1a6f8} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [8/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&}]{cgal,  }\item[{CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7a0a277a5e9ae4b929373f8a4b812caa}\label{namespaceigl_1_1copyleft_1_1cgal_a7a0a277a5e9ae4b929373f8a4b812caa} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [9/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&}]{cgal,  }\item[{double \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a76b2bca21db0d19d293a93ff87246d3a}\label{namespaceigl_1_1copyleft_1_1cgal_a76b2bca21db0d19d293a93ff87246d3a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [10/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+\_\+with\+\_\+sqrt\+::\+FT \&}]{cgal,  }\item[{float \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ab1927287ea1fac749a475615e452d8b3}\label{namespaceigl_1_1copyleft_1_1cgal_ab1927287ea1fac749a475615e452d8b3} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [11/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&}]{cgal,  }\item[{CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a268e7b784c30482867d062cdf2bd4235}\label{namespaceigl_1_1copyleft_1_1cgal_a268e7b784c30482867d062cdf2bd4235} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [12/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&}]{cgal,  }\item[{double \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a376e3a13203eae4eb9d3749dfb98e8f7}\label{namespaceigl_1_1copyleft_1_1cgal_a376e3a13203eae4eb9d3749dfb98e8f7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!assign\_scalar@{assign\_scalar}}
\index{assign\_scalar@{assign\_scalar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{assign\_scalar()}{assign\_scalar()}\hspace{0.1cm}{\footnotesize\ttfamily [13/13]}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::assign\+\_\+scalar (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Simple\+\_\+cartesian$<$ mpq\+\_\+class $>$\+::\+FT \&}]{cgal,  }\item[{float \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a5f57dae2a4485cc2651abfb51f55cf0e}\label{namespaceigl_1_1copyleft_1_1cgal_a5f57dae2a4485cc2651abfb51f55cf0e} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!cell\_adjacency@{cell\_adjacency}}
\index{cell\_adjacency@{cell\_adjacency}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{cell\_adjacency()}{cell\_adjacency()}}
{\footnotesize\ttfamily template$<$typename DerivedC $>$ \\
void igl\+::copyleft\+::cgal\+::cell\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{per\+\_\+patch\+\_\+cells,  }\item[{const size\+\_\+t}]{num\+\_\+cells,  }\item[{std\+::vector$<$ std\+::set$<$ std\+::tuple$<$ typename Derived\+C\+::\+Scalar, bool, size\+\_\+t $>$ $>$ $>$ \&}]{adjacency\+\_\+list }\end{DoxyParamCaption})}



Determine adjacency of cells. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em per\+\_\+patch\+\_\+cells} & \#P by 2 list of cell labels on each side of each patch. Cell labels are assumed to be continuous from 0 to \#C. \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+cells} & number of cells. \\
\hline
\mbox{\texttt{ out}}  & {\em adjacency\+\_\+list} & \#C array of list of adjcent cell information. If cell i and cell j are adjacent via patch x, where i is on the positive side of x, and j is on the negative side. Then, adjacency\+\_\+list\mbox{[}i\mbox{]} will contain the entry \{j, false, x\} and adjacency\+\_\+list\mbox{[}j\mbox{]} will contain the entry \{i, true, x\} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a288a0d884f994aadcf7d8058b35113d8}\label{namespaceigl_1_1copyleft_1_1cgal_a288a0d884f994aadcf7d8058b35113d8} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!closest\_facet@{closest\_facet}}
\index{closest\_facet@{closest\_facet}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{closest\_facet()}{closest\_facet()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename Kernel , typename DerivedR , typename DerivedS $>$ \\
void igl\+::copyleft\+::cgal\+::closest\+\_\+facet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{VF,  }\item[{const std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{VFi,  }\item[{const CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$\+::iterator $>$ $>$ $>$ \&}]{tree,  }\item[{const std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$ \&}]{triangles,  }\item[{const std\+::vector$<$ bool $>$ \&}]{in\+\_\+I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Determine the closest facet for each of the input points. 

This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 array of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 array of faces. \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of triangle indices to consider. \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 array of query points. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumsums of directed edges sharing each unique edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#E list of indices into E (see {\ttfamily \doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{igl\+::unique\+\_\+edge\+\_\+map}}) \\
\hline
\mbox{\texttt{ in}}  & {\em VF} & \#V list of lists of incident faces (adjacency list) \\
\hline
\mbox{\texttt{ in}}  & {\em VFi} & \#V list of lists of index of incidence within incident faces listed in VF \\
\hline
\mbox{\texttt{ in}}  & {\em tree} & \doxylink{classigl_1_1AABB}{AABB} containing triangles of (V,F(\+I,\+:)) \\
\hline
\mbox{\texttt{ in}}  & {\em triangles} & \#I list of cgal triangles \\
\hline
\mbox{\texttt{ in}}  & {\em in\+\_\+I} & \#F list of whether in submesh \\
\hline
\mbox{\texttt{ out}}  & {\em R} & \#P list of closest facet indices. \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of bools indicating on which side of the closest facet each query point lies.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The use of {\ttfamily size\+\_\+t} here is a bad idea. These should just be int to avoid nonsense with windows. 
\end{DoxyNote}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac948de3c14554d16b33cc16d7131a5f2}\label{namespaceigl_1_1copyleft_1_1cgal_ac948de3c14554d16b33cc16d7131a5f2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!closest\_facet@{closest\_facet}}
\index{closest\_facet@{closest\_facet}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{closest\_facet()}{closest\_facet()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedR , typename DerivedS $>$ \\
void igl\+::copyleft\+::cgal\+::closest\+\_\+facet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_af97e3b6b93bfa938e1f0a7bc2308ca40}\label{namespaceigl_1_1copyleft_1_1cgal_af97e3b6b93bfa938e1f0a7bc2308ca40} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!closest\_facet@{closest\_facet}}
\index{closest\_facet@{closest\_facet}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{closest\_facet()}{closest\_facet()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedR , typename DerivedS $>$ \\
void igl\+::copyleft\+::cgal\+::closest\+\_\+facet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a1ccff123c73356ecd24f15f90143a4b7}\label{namespaceigl_1_1copyleft_1_1cgal_a1ccff123c73356ecd24f15f90143a4b7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!complex\_to\_mesh@{complex\_to\_mesh}}
\index{complex\_to\_mesh@{complex\_to\_mesh}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{complex\_to\_mesh()}{complex\_to\_mesh()}}
{\footnotesize\ttfamily template$<$typename Tr , typename DerivedV , typename DerivedF $>$ \\
bool igl\+::copyleft\+::cgal\+::complex\+\_\+to\+\_\+mesh (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Complex\+\_\+2\+\_\+in\+\_\+triangulation\+\_\+3$<$ Tr $>$ \&}]{c2t3,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Convert a CGAL\+::\+Complex\+\_\+2\+\_\+in\+\_\+triangulation\+\_\+3 to a mesh (V,F) 


\begin{DoxyTemplParams}{Template Parameters}
{\em Tr} & CGAL triangulation type, e.\+g. CGAL\+::\+Surface\+\_\+mesh\+\_\+default\+\_\+triangulation\+\_\+3 \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em c2t3} & 2-\/complex (surface) living in a 3d triangulation (e.\+g. result of CGAL\+::make\+\_\+surface\+\_\+mesh) \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff conversion was successful, failure can ok if CGAL code can\textquotesingle{}t figure out ordering. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a9135f1c36fb37be3a3dc9a924ef40fe6}\label{namespaceigl_1_1copyleft_1_1cgal_a9135f1c36fb37be3a3dc9a924ef40fe6} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!component\_inside\_component@{component\_inside\_component}}
\index{component\_inside\_component@{component\_inside\_component}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{component\_inside\_component()}{component\_inside\_component()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ \\
bool igl\+::copyleft\+::cgal\+::component\+\_\+inside\+\_\+component (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V1,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F1,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I1,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V2,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F2,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I2 }\end{DoxyParamCaption})}



Determine if connected facet component (V1, F1, I1) is inside of connected facet component (V2, F2, I2). 

\begin{DoxyPrecond}{Precondition}
Both components must represent closed, self-\/intersection free, non-\/degenerated surfaces that are the boundary of 3D volumes. In addition, (V1, F1, I1) must not intersect with (V2, F2, I2).
\end{DoxyPrecond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V1} & \#\+V1 by 3 list of vertex position of mesh 1 \\
\hline
\mbox{\texttt{ in}}  & {\em F1} & \#\+F1 by 3 list of triangles indices into V1 \\
\hline
\mbox{\texttt{ in}}  & {\em I1} & \#\+I1 list of indices into F1, indicate the facets of component \\
\hline
\mbox{\texttt{ in}}  & {\em V2} & \#\+V2 by 3 list of vertex position of mesh 2 \\
\hline
\mbox{\texttt{ in}}  & {\em F2} & \#\+F2 by 3 list of triangles indices into V2 \\
\hline
\mbox{\texttt{ in}}  & {\em I2} & \#\+I2 list of indices into F2, indicate the facets of component \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff (V1, F1, I1) is entirely inside of (V2, F2, I2). 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac01406d0fbbda3a765535e66ed8ee95a}\label{namespaceigl_1_1copyleft_1_1cgal_ac01406d0fbbda3a765535e66ed8ee95a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!component\_inside\_component@{component\_inside\_component}}
\index{component\_inside\_component@{component\_inside\_component}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{component\_inside\_component()}{component\_inside\_component()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::copyleft\+::cgal\+::component\+\_\+inside\+\_\+component (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V1,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F1,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V2,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F2 }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ae28edab222791aa6fba773fb1216f592}\label{namespaceigl_1_1copyleft_1_1cgal_ae28edab222791aa6fba773fb1216f592} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!convex\_hull@{convex\_hull}}
\index{convex\_hull@{convex\_hull}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{convex\_hull()}{convex\_hull()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedW , typename DerivedG $>$ \\
void igl\+::copyleft\+::cgal\+::convex\+\_\+hull (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G }\end{DoxyParamCaption})}



Given a set of points (V), compute the convex hull as a triangle mesh (W,G) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of input points \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#W by 3 list of convex hull points \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of triangle indices into W \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac3d6357a7a4ea861133f2983359ec4ef}\label{namespaceigl_1_1copyleft_1_1cgal_ac3d6357a7a4ea861133f2983359ec4ef} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!convex\_hull@{convex\_hull}}
\index{convex\_hull@{convex\_hull}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{convex\_hull()}{convex\_hull()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::copyleft\+::cgal\+::convex\+\_\+hull (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a84ac00710a1dcb3c5d4a26e102f0f422}\label{namespaceigl_1_1copyleft_1_1cgal_a84ac00710a1dcb3c5d4a26e102f0f422} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!coplanar@{coplanar}}
\index{coplanar@{coplanar}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{coplanar()}{coplanar()}}
{\footnotesize\ttfamily template$<$typename DerivedV $>$ \\
bool igl\+::copyleft\+::cgal\+::coplanar (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



Test whether all points are on same plane. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of 3D vertex positions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if all points lie on the same plane 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7a07bdc787f5318cc08c6496b4d72fa7}\label{namespaceigl_1_1copyleft_1_1cgal_a7a07bdc787f5318cc08c6496b4d72fa7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!delaunay\_triangulation@{delaunay\_triangulation}}
\index{delaunay\_triangulation@{delaunay\_triangulation}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{delaunay\_triangulation()}{delaunay\_triangulation()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::copyleft\+::cgal\+::delaunay\+\_\+triangulation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Given a set of points in 2D, return a Delaunay triangulation of these points. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 of faces in Delaunay triangulation. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a140437f716d88d5a00c55ff4e126f450}\label{namespaceigl_1_1copyleft_1_1cgal_a140437f716d88d5a00c55ff4e126f450} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!extract\_cells@{extract\_cells}}
\index{extract\_cells@{extract\_cells}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{extract\_cells()}{extract\_cells()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedC $>$ \\
size\+\_\+t igl\+::copyleft\+::cgal\+::extract\+\_\+cells (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{cells }\end{DoxyParamCaption})}



Extract connected 3D space partitioned by mesh (V, F). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 array of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 array of faces. \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#F list of patch indices. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 array of vertex indices, one edge per row. \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of vertex\+\_\+indices, represents undirected edges. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumsums of directed edges sharing each unique edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#E list of indices into E (see {\ttfamily \doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{igl\+::unique\+\_\+edge\+\_\+map}}) \\
\hline
\mbox{\texttt{ out}}  & {\em cells} & \#F by 2 array of cell indices. cells(i,0) represents the cell index on the positive side of face i, and cells(i,1) represents cell index of the negqtive side. By convension cell with index 0 is the infinite cell. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of cells 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aca7332bc7dbe6723fc063783c66439b1}\label{namespaceigl_1_1copyleft_1_1cgal_aca7332bc7dbe6723fc063783c66439b1} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!extract\_cells@{extract\_cells}}
\index{extract\_cells@{extract\_cells}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{extract\_cells()}{extract\_cells()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ \\
size\+\_\+t igl\+::copyleft\+::cgal\+::extract\+\_\+cells (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{cells }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a8f9418b46711333539b0fa6fc3a579c2}\label{namespaceigl_1_1copyleft_1_1cgal_a8f9418b46711333539b0fa6fc3a579c2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!extract\_cells\_single\_component@{extract\_cells\_single\_component}}
\index{extract\_cells\_single\_component@{extract\_cells\_single\_component}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{extract\_cells\_single\_component()}{extract\_cells\_single\_component()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedC $>$ \\
size\+\_\+t igl\+::copyleft\+::cgal\+::extract\+\_\+cells\+\_\+single\+\_\+component (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{cells }\end{DoxyParamCaption})}



Extract connected 3D space partitioned by mesh (V,F) composed of {\bfseries{possibly multiple components}} (the name of this function is dubious). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 array of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 array of faces. \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#F list of patch indices. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 array of vertex indices, one edge per row. \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of vertex\+\_\+indices, represents undirected edges. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumsums of directed edges sharing each unique edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#E list of indices into E (see {\ttfamily \doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{igl\+::unique\+\_\+edge\+\_\+map}}) \\
\hline
\mbox{\texttt{ out}}  & {\em cells} & \#P by 2 array of cell indices. cells(i,0) represents the cell index on the positive side of patch i, and cells(i,1) represents cell index of the negative side. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of components 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7b1ff11d15adb5cbb276b8fc71ff17f6}\label{namespaceigl_1_1copyleft_1_1cgal_a7b1ff11d15adb5cbb276b8fc71ff17f6} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!extract\_feature@{extract\_feature}}
\index{extract\_feature@{extract\_feature}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{extract\_feature()}{extract\_feature()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ \\
void igl\+::copyleft\+::cgal\+::extract\+\_\+feature (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const double}]{tol,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{feature\+\_\+edges }\end{DoxyParamCaption})}



Extract feature edges based on dihedral angle. 

Here, dihedral angle is defined as the angle between surface {\bfseries{normals}} as described in \href{http://mathworld.wolfram.com/DihedralAngle.html}{\texttt{ http\+://mathworld.\+wolfram.\+com/\+Dihedral\+Angle.\+html}}

Non-\/manifold and boundary edges are automatically considered as features.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 array of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 array of faces. \\
\hline
\mbox{\texttt{ in}}  & {\em tol} & Edges with dihedral angle larger than this are considered as features. Angle is measured in radian. \\
\hline
\mbox{\texttt{ out}}  & {\em feature\+\_\+edges} & \#E by 2 array of edges. Each edge satisfies at least one of the following criteria\+:
\begin{DoxyItemize}
\item Edge has dihedral angle larger than tol.
\item Edge is boundary.
\item Edge is non-\/manifold (i.\+e. it has more than 2 adjacent faces). 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a1e4c041811adea444b0825237453985c}\label{namespaceigl_1_1copyleft_1_1cgal_a1e4c041811adea444b0825237453985c} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!extract\_feature@{extract\_feature}}
\index{extract\_feature@{extract\_feature}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{extract\_feature()}{extract\_feature()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ \\
void igl\+::copyleft\+::cgal\+::extract\+\_\+feature (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const double}]{tol,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{uE,  }\item[{const std\+::vector$<$ std\+::vector$<$ typename Derived\+E\+::\+Scalar $>$ $>$ \&}]{u\+E2E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{feature\+\_\+edges }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aa9825eec87220923c563797c7119485e}\label{namespaceigl_1_1copyleft_1_1cgal_aa9825eec87220923c563797c7119485e} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedN , typename DerivedQ , typename Beta\+Type , typename Derived\+WN $>$ \\
void igl\+::copyleft\+::cgal\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{const int}]{expansion\+\_\+order,  }\item[{const Beta\+Type}]{beta,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&}]{WN }\end{DoxyParamCaption})}



Evaluate the fast winding number for point data, without known areas. 

The areas are calculated using \doxylink{namespaceigl_a6f2969bd735df2588ce37026375ddefe}{igl\+::knn} and \doxylink{namespaceigl_1_1copyleft_1_1cgal_a1240cef3d039ac518baca44025fe1adc}{igl\+::copyleft\+::cgal\+::point\+\_\+areas}.

This function performes the precomputation and evaluation all in one. If you need to acess the precomuptation for repeated evaluations, use the two functions designed for exposed precomputation, which are the first two functions see in \doxylink{fast__winding__number_8h}{igl/fast\+\_\+winding\+\_\+number.\+h}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of point locations \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of point normals \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & \#Q by 3 list of query points for the winding number \\
\hline
\mbox{\texttt{ in}}  & {\em beta} & This is a Barnes-\/\+Hut style accuracy term that separates near feild from far field. The higher the beta, the more accurate and slower the evaluation. We reccommend using a beta value of 2. \\
\hline
\mbox{\texttt{ in}}  & {\em expansion\+\_\+order} & the order of the taylor expansion. We support 0,1,2. \\
\hline
\mbox{\texttt{ out}}  & {\em WN} & \#Q by 1 list of windinng number values at each query point \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_abed4986e59db067d2f048150af7ca39f}\label{namespaceigl_1_1copyleft_1_1cgal_abed4986e59db067d2f048150af7ca39f} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedN , typename DerivedQ , typename Derived\+WN $>$ \\
void igl\+::copyleft\+::cgal\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&}]{WN }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a9139148a9ac6f9b4b152790a827c0427}\label{namespaceigl_1_1copyleft_1_1cgal_a9139148a9ac6f9b4b152790a827c0427} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!half\_space\_box@{half\_space\_box}}
\index{half\_space\_box@{half\_space\_box}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{half\_space\_box()}{half\_space\_box()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV $>$ \\
void igl\+::copyleft\+::cgal\+::half\+\_\+space\+\_\+box (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Plane\+\_\+3$<$ CGAL\+::\+Epeck $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Matrix$<$ CGAL\+::\+Epeck\+::\+FT, 8, 3 $>$ \&}]{BV,  }\item[{Eigen\+::\+Matrix$<$ int, 12, 3 $>$ \&}]{BF }\end{DoxyParamCaption})}



Construct a mesh of box (BV,BF) so that it contains the intersection of the half-\/space under the plane (P) and the bounding box of V, and does not contain any of the half-\/space above (P). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & plane so that normal points away from half-\/space \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em BV} & \#\+BV by 3 list of box vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em BF} & \#\+BF b3 list of box triangle indices into BV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aa7726e6100f1c5c7645949fa2156cf2a}\label{namespaceigl_1_1copyleft_1_1cgal_aa7726e6100f1c5c7645949fa2156cf2a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!half\_space\_box@{half\_space\_box}}
\index{half\_space\_box@{half\_space\_box}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{half\_space\_box()}{half\_space\_box()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Derivedp , typename Derivedn , typename DerivedV $>$ \\
void igl\+::copyleft\+::cgal\+::half\+\_\+space\+\_\+box (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&}]{p,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedn $>$ \&}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Matrix$<$ CGAL\+::\+Epeck\+::\+FT, 8, 3 $>$ \&}]{BV,  }\item[{Eigen\+::\+Matrix$<$ int, 12, 3 $>$ \&}]{BF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em p} & 3d point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em n} & 3d vector of normal of plane pointing away from inside \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ad92813e51e83af95eb0961bf8756b557}\label{namespaceigl_1_1copyleft_1_1cgal_ad92813e51e83af95eb0961bf8756b557} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!half\_space\_box@{half\_space\_box}}
\index{half\_space\_box@{half\_space\_box}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{half\_space\_box()}{half\_space\_box()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Derivedequ , typename DerivedV $>$ \\
void igl\+::copyleft\+::cgal\+::half\+\_\+space\+\_\+box (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedequ $>$ \&}]{equ,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Matrix$<$ CGAL\+::\+Epeck\+::\+FT, 8, 3 $>$ \&}]{BV,  }\item[{Eigen\+::\+Matrix$<$ int, 12, 3 $>$ \&}]{BF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em equ} & plane equation\+: a\texorpdfstring{$\ast$}{*}x+b\texorpdfstring{$\ast$}{*}y+c\texorpdfstring{$\ast$}{*}z + d = 0 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3ac0ac630b70601fd761c3f55877c178}\label{namespaceigl_1_1copyleft_1_1cgal_a3ac0ac630b70601fd761c3f55877c178} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!hausdorff@{hausdorff}}
\index{hausdorff@{hausdorff}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{hausdorff()}{hausdorff()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Kernel , typename Scalar $>$ \\
void igl\+::copyleft\+::cgal\+::hausdorff (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$\+::iterator $>$ $>$ $>$ \&}]{treeB,  }\item[{const std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&}]{TB,  }\item[{Scalar \&}]{l,  }\item[{Scalar \&}]{u }\end{DoxyParamCaption})}



Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.\+g., mesh, triangle soup) given by a distance function handle (dist\+\_\+to\+\_\+B). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & 3 by 3 list of corner positions so that V.\+row(i) is the position of the ith corner \\
\hline
\mbox{\texttt{ in}}  & {\em treeB} & CGAL\textquotesingle{}s \doxylink{classigl_1_1AABB}{AABB} tree containing triangle soup (VB,FB) \\
\hline
\mbox{\texttt{ in}}  & {\em TB} & list of CGAL triangles in order of FB (for determining which was found in computation) \\
\hline
\mbox{\texttt{ out}}  & {\em l} & lower bound on Hausdorff distance \\
\hline
\mbox{\texttt{ out}}  & {\em u} & upper bound on Hausdorff distance \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3cbee8698ddf7b0868d3b433b6d5bd77}\label{namespaceigl_1_1copyleft_1_1cgal_a3cbee8698ddf7b0868d3b433b6d5bd77} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!incircle@{incircle}}
\index{incircle@{incircle}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{incircle()}{incircle()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
short igl\+::copyleft\+::cgal\+::incircle (\begin{DoxyParamCaption}\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pa,  }\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pb,  }\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pc,  }\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pd }\end{DoxyParamCaption})}



Test whether point is in a given circle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pa} & 2D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pb} & 2D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pc} & 2D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pd} & 2D point to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if pd is inside of the oriented circle formed by pa,pb,pc. 0 if pd is co-\/circular with pa,pb,pc. -\/1 if pd is outside of the oriented circle formed by pa,pb,pc. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ada1796699e0d1f0830cc933d704cc918}\label{namespaceigl_1_1copyleft_1_1cgal_ada1796699e0d1f0830cc933d704cc918} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!insert\_into\_cdt@{insert\_into\_cdt}}
\index{insert\_into\_cdt@{insert\_into\_cdt}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{insert\_into\_cdt()}{insert\_into\_cdt()}}
{\footnotesize\ttfamily template$<$typename Kernel $>$ \\
void igl\+::copyleft\+::cgal\+::insert\+\_\+into\+\_\+cdt (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Object \&}]{obj,  }\item[{const CGAL\+::\+Plane\+\_\+3$<$ Kernel $>$ \&}]{P,  }\item[{CGAL\+::\+Constrained\+\_\+triangulation\+\_\+plus\+\_\+2$<$ CGAL\+::\+Constrained\+\_\+\+Delaunay\+\_\+triangulation\+\_\+2$<$ Kernel, CGAL\+::\+Triangulation\+\_\+data\+\_\+structure\+\_\+2$<$ CGAL\+::\+Triangulation\+\_\+vertex\+\_\+base\+\_\+2$<$ Kernel $>$, CGAL\+::\+Constrained\+\_\+triangulation\+\_\+face\+\_\+base\+\_\+2$<$ Kernel $>$ $>$, CGAL\+::\+Exact\+\_\+intersections\+\_\+tag $>$ $>$ \&}]{cdt }\end{DoxyParamCaption})}



Given a current 2D constrained Delaunay triangulation (cdt), insert a 3D \"{}object\"{} (e.\+g., resulting from intersecting two triangles) into the cdt, by projecting it via the given plane (P) and adding appropriate constraints. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & CGAL\+::\+Object representing a vertex, segment, or (convex) polygon. All vertices should lie on the plane P. If not, then this adds the {\itshape projection} of this object to the cdt and that might not be what you wanted to do. \\
\hline
\mbox{\texttt{ in}}  & {\em P} & plane obj lies on and upon which the cdt is being performed \\
\hline
\mbox{\texttt{ in}}  & {\em cdt} & current CDT, see output \\
\hline
\mbox{\texttt{ out}}  & {\em cdt} & CDT updated to contain constraints for the given object \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a296c297c8c29baf446426fb8e72e4974}\label{namespaceigl_1_1copyleft_1_1cgal_a296c297c8c29baf446426fb8e72e4974} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!insphere@{insphere}}
\index{insphere@{insphere}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{insphere()}{insphere()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
short igl\+::copyleft\+::cgal\+::insphere (\begin{DoxyParamCaption}\item[{const Scalar}]{pa\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pb\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pc\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pd\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pe\mbox{[}3\mbox{]} }\end{DoxyParamCaption})}



Test whether point is in a given sphere. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pa} & 3D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pb} & 3D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pc} & 3D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pd} & 3D point on sphere \\
\hline
\mbox{\texttt{ in}}  & {\em pe} & 3D point to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if pe is inside of the oriented sphere formed by pa,pb,pc,pd, 0 if pe is co-\/spherical with pa,pb,pc,pd, -\/1 if pe is outside of the oriented sphere formed by pa,pb,pc,pd. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aad0ee9bfc55573ac2ac722c5d6e6d8bc}\label{namespaceigl_1_1copyleft_1_1cgal_aad0ee9bfc55573ac2ac722c5d6e6d8bc} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!intersect\_other@{intersect\_other}}
\index{intersect\_other@{intersect\_other}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{intersect\_other()}{intersect\_other()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+IF , typename Derived\+VVAB , typename Derived\+FFAB , typename Derived\+JAB , typename Derived\+IMAB $>$ \\
bool igl\+::copyleft\+::cgal\+::intersect\+\_\+other (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{const \mbox{\hyperlink{structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam}{Remesh\+Self\+Intersections\+Param}} \&}]{params,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IF $>$ \&}]{IF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VVAB $>$ \&}]{VVAB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FFAB $>$ \&}]{FFAB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+JAB $>$ \&}]{JAB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IMAB $>$ \&}]{IMAB }\end{DoxyParamCaption})}



Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces. 

Note that self-\/intersections are ignored.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VA} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em FA} & \#F by 3 list of triangle indices into VA \\
\hline
\mbox{\texttt{ in}}  & {\em VB} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em FB} & \#F by 3 list of triangle indices into VB \\
\hline
\mbox{\texttt{ in}}  & {\em params} & whether to detect only and then whether to only find first intersection \\
\hline
\mbox{\texttt{ out}}  & {\em IF} & \#intersecting face pairs by 2 list of intersecting face pairs, indexing FA and FB \\
\hline
\mbox{\texttt{ out}}  & {\em VVAB} & \#\+VVAB by 3 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em FFAB} & \#\+FFAB by 3 list of triangle indices into VVA \\
\hline
\mbox{\texttt{ out}}  & {\em JAB} & \#\+FFAB list of indices into \mbox{[}FA;FB\mbox{]} denoting birth triangle \\
\hline
\mbox{\texttt{ out}}  & {\em IMAB} & \#\+VVAB list of indices stitching duplicates (resulting from mesh intersections) together \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a0d884b824ed6773fde6de21ce4178b1a}\label{namespaceigl_1_1copyleft_1_1cgal_a0d884b824ed6773fde6de21ce4178b1a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!intersect\_other@{intersect\_other}}
\index{intersect\_other@{intersect\_other}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{intersect\_other()}{intersect\_other()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::copyleft\+::cgal\+::intersect\+\_\+other (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{FB,  }\item[{const bool}]{first\+\_\+only,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{IF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em first\+\_\+only} & whether to only find first intersection \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_acbf85761952ab999a6d3a69e91017ee1}\label{namespaceigl_1_1copyleft_1_1cgal_acbf85761952ab999a6d3a69e91017ee1} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!intersect\_with\_half\_space@{intersect\_with\_half\_space}}
\index{intersect\_with\_half\_space@{intersect\_with\_half\_space}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{intersect\_with\_half\_space()}{intersect\_with\_half\_space()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedp , typename Derivedn , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::intersect\+\_\+with\+\_\+half\+\_\+space (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&}]{p,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedn $>$ \&}]{n,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Intersect a PWN mesh with a half-\/space. 

Point on plane, normal pointing outward.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em p} & 3d point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em n} & 3d vector of normal of plane pointing away from inside \\
\hline
\mbox{\texttt{ out}}  & {\em VC} & \#\+VC by 3 list of vertex positions of boolean result mesh \\
\hline
\mbox{\texttt{ out}}  & {\em FC} & \#\+FC by 3 list of triangle indices into VC \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+FC list of indices into \mbox{[}F;F.\+rows()+\mbox{[}1;2\mbox{]}\mbox{]} revealing \"{}birth\"{} facet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if mesh\+\_\+boolean was succsesful 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_afc6b67a7451e027f0c39d1ae171fd1dc}\label{namespaceigl_1_1copyleft_1_1cgal_afc6b67a7451e027f0c39d1ae171fd1dc} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!intersect\_with\_half\_space@{intersect\_with\_half\_space}}
\index{intersect\_with\_half\_space@{intersect\_with\_half\_space}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{intersect\_with\_half\_space()}{intersect\_with\_half\_space()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedequ , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::intersect\+\_\+with\+\_\+half\+\_\+space (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedequ $>$ \&}]{equ,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em equ} & plane equation\+: P(x,y,z) = a\texorpdfstring{$\ast$}{*}x+b\texorpdfstring{$\ast$}{*}y+c\texorpdfstring{$\ast$}{*}z + d = 0, P(x,y,z) \texorpdfstring{$<$}{<} 0 is {\itshape inside}. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a28d4989493710230161702638797c2af}\label{namespaceigl_1_1copyleft_1_1cgal_a28d4989493710230161702638797c2af} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!intersect\_with\_half\_space@{intersect\_with\_half\_space}}
\index{intersect\_with\_half\_space@{intersect\_with\_half\_space}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{intersect\_with\_half\_space()}{intersect\_with\_half\_space()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::intersect\+\_\+with\+\_\+half\+\_\+space (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const CGAL\+::\+Plane\+\_\+3$<$ CGAL\+::\+Epeck $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & plane ~\newline
 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a15d7510126e3d13d597b9c2dbe0bac28}\label{namespaceigl_1_1copyleft_1_1cgal_a15d7510126e3d13d597b9c2dbe0bac28} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!lexicographic\_triangulation@{lexicographic\_triangulation}}
\index{lexicographic\_triangulation@{lexicographic\_triangulation}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{lexicographic\_triangulation()}{lexicographic\_triangulation()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedF $>$ \\
void igl\+::copyleft\+::cgal\+::lexicographic\+\_\+triangulation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Given a set of points in 2D, return a lexicographic triangulation of these points. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 2 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 of faces in lexicographic triangulation. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a06c593a5aedf52ccb8234edccc484607}\label{namespaceigl_1_1copyleft_1_1cgal_a06c593a5aedf52ccb8234edccc484607} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&}]{type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Compute Boolean csg operations on \"{}solid\"{}, consistently oriented meshes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VA} & \#\+VA by 3 list of vertex positions of first mesh \\
\hline
\mbox{\texttt{ in}}  & {\em FA} & \#\+FA by 3 list of triangle indices into VA \\
\hline
\mbox{\texttt{ in}}  & {\em VB} & \#\+VB by 3 list of vertex positions of second mesh \\
\hline
\mbox{\texttt{ in}}  & {\em FB} & \#\+FB by 3 list of triangle indices into VB \\
\hline
\mbox{\texttt{ in}}  & {\em type} & type of boolean operation \\
\hline
\mbox{\texttt{ out}}  & {\em VC} & \#\+VC by 3 list of vertex positions of boolean result mesh \\
\hline
\mbox{\texttt{ out}}  & {\em FC} & \#\+FC by 3 list of triangle indices into VC \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+FC list of indices into \mbox{[}FA;FA.\+rows()+FB\mbox{]} revealing \"{}birth\"{} facet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if inputs induce a piecewise constant winding number field and type is valid
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
mesh\+\_\+boolean\+\_\+cork, \doxylink{namespaceigl_1_1copyleft_1_1cgal_aad0ee9bfc55573ac2ac722c5d6e6d8bc}{intersect\+\_\+other}, \doxylink{namespaceigl_1_1copyleft_1_1cgal_a7169f4ae2fe2c11f7e878b41aa747fc2}{remesh\+\_\+self\+\_\+intersections} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ada8cdea765193ffb966531a02372dfd6}\label{namespaceigl_1_1copyleft_1_1cgal_ada8cdea765193ffb966531a02372dfd6} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{const std\+::string \&}]{type\+\_\+str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em type\+\_\+str} & string describing type of boolean operation see mesh\+\_\+boolean\+\_\+type\+\_\+to\+\_\+funcs \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_af80e3892da699c718eebaec432e26db5}\label{namespaceigl_1_1copyleft_1_1cgal_af80e3892da699c718eebaec432e26db5} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{const std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&}]{wind\+\_\+num\+\_\+op,  }\item[{const std\+::function$<$ int(const int, const int)$>$ \&}]{keep,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em wind\+\_\+num\+\_\+op} & function handle for filtering winding numbers from tuples of integer values to \mbox{[}0,1\mbox{]} outside/inside values \\
\hline
\mbox{\texttt{ in}}  & {\em keep} & function handle for determining if a patch should be \"{}kept\"{} in the output based on the winding number on either side \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a2cbd1329be2838714aeed904875b7a39}\label{namespaceigl_1_1copyleft_1_1cgal_a2cbd1329be2838714aeed904875b7a39} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ DerivedV $>$ \&}]{Vlist,  }\item[{const std\+::vector$<$ DerivedF $>$ \&}]{Flist,  }\item[{const std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&}]{wind\+\_\+num\+\_\+op,  }\item[{const std\+::function$<$ int(const int, const int)$>$ \&}]{keep,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Variadic mesh Boolean operations. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Vlist} & k-\/long list of lists of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em Flist} & k-\/long list of lists of mesh face indices, so that Flist\mbox{[}i\mbox{]} indexes vertices in Vlist\mbox{[}i\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em wind\+\_\+num\+\_\+op} & function handle for filtering winding numbers from n-\/tuples of integer values to \mbox{[}0,1\mbox{]} outside/inside values \\
\hline
\mbox{\texttt{ in}}  & {\em keep} & function handle for determining if a patch should be \"{}kept\"{} in the output based on the winding number on either side \\
\hline
\mbox{\texttt{ out}}  & {\em VC} & \#\+VC by 3 list of vertex positions of boolean result mesh \\
\hline
\mbox{\texttt{ out}}  & {\em FC} & \#\+FC by 3 list of triangle indices into VC \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+FC list of indices into \mbox{[}Flist\mbox{[}0\mbox{]};Flist\mbox{[}1\mbox{]};...;Flist\mbox{[}k\mbox{]}\mbox{]} revealing \"{}birth\"{} facet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff inputs induce a piecewise constant winding number field 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a2365a0f9b66688565308b8c431321390}\label{namespaceigl_1_1copyleft_1_1cgal_a2365a0f9b66688565308b8c431321390} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ DerivedV $>$ \&}]{Vlist,  }\item[{const std\+::vector$<$ DerivedF $>$ \&}]{Flist,  }\item[{const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&}]{type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ae3ca56172ae354965d5ec22690a6f488}\label{namespaceigl_1_1copyleft_1_1cgal_ae3ca56172ae354965d5ec22690a6f488} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename Derived\+VV , typename Derived\+FF , typename Derivedsizes , typename Derived\+VC , typename Derived\+FC , typename DerivedJ $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VV $>$ \&}]{VV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedsizes $>$ \&}]{sizes,  }\item[{const std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&}]{wind\+\_\+num\+\_\+op,  }\item[{const std\+::function$<$ int(const int, const int)$>$ \&}]{keep,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Given a merged mesh (V,F) and list of sizes of inputs


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of merged mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of merged mesh face indices so that first sizes(0) faces come from the first input, and the next sizes(1) faces come from the second input, and so on. \\
\hline
\mbox{\texttt{ in}}  & {\em sizes} & \#inputs list of sizes so that sizes(i) is the \#faces in the ith input \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aa93f53bb9649aefd700d76e8fbbc628c}\label{namespaceigl_1_1copyleft_1_1cgal_aa93f53bb9649aefd700d76e8fbbc628c} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean@{mesh\_boolean}}
\index{mesh\_boolean@{mesh\_boolean}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean()}{mesh\_boolean()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Derived\+VC , typename Derived\+FC $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&}]{type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VC $>$ \&}]{VC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FC $>$ \&}]{FC }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a4a7a5d1111aea73ba095a0af9bf39153}\label{namespaceigl_1_1copyleft_1_1cgal_a4a7a5d1111aea73ba095a0af9bf39153} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_boolean\_type\_to\_funcs@{mesh\_boolean\_type\_to\_funcs}}
\index{mesh\_boolean\_type\_to\_funcs@{mesh\_boolean\_type\_to\_funcs}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_boolean\_type\_to\_funcs()}{mesh\_boolean\_type\_to\_funcs()}}
{\footnotesize\ttfamily void igl\+::copyleft\+::cgal\+::mesh\+\_\+boolean\+\_\+type\+\_\+to\+\_\+funcs (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&}]{type,  }\item[{std\+::function$<$ int(const Eigen\+::\+Matrix$<$ int, 1, Eigen\+::\+Dynamic $>$) $>$ \&}]{wind\+\_\+num\+\_\+op,  }\item[{std\+::function$<$ int(const int, const int)$>$ \&}]{keep }\end{DoxyParamCaption})}



Convert a Mesh\+Boolean\+Type enum to a pair of winding number conversion function and \"{}keep\"{} function used by mesh\+\_\+boolean. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em type} & Mesh\+Boolean\+Type enum value \\
\hline
\mbox{\texttt{ out}}  & {\em wind\+\_\+num\+\_\+op} & function handle for filtering winding numbers from tuples of integer values to \mbox{[}0,1\mbox{]} outside/inside values \\
\hline
\mbox{\texttt{ out}}  & {\em keep} & function handle for determining if a patch should be \"{}kept\"{} in the output based on the winding number on either side\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1copyleft_1_1cgal_ac105fc714db9b51b1c3945c51e6e5a19}{string\+\_\+to\+\_\+mesh\+\_\+boolean\+\_\+type} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac9d72d2b7b5a3aa61b67b44df084c7db}\label{namespaceigl_1_1copyleft_1_1cgal_ac9d72d2b7b5a3aa61b67b44df084c7db} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_to\_cgal\_triangle\_list@{mesh\_to\_cgal\_triangle\_list}}
\index{mesh\_to\_cgal\_triangle\_list@{mesh\_to\_cgal\_triangle\_list}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_to\_cgal\_triangle\_list()}{mesh\_to\_cgal\_triangle\_list()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Kernel $>$ \\
void igl\+::copyleft\+::cgal\+::mesh\+\_\+to\+\_\+cgal\+\_\+triangle\+\_\+list (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&}]{T }\end{DoxyParamCaption})}



Convert a mesh (V,F) to a list of CGAL triangles. 

@2tparam Kernal CGAL computation and construction kernel (e.\+g. CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel) 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em T} & \#F list of CGAL triangles \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a02acbbee9fc0e71fecf7e1f3ee5a58a8}\label{namespaceigl_1_1copyleft_1_1cgal_a02acbbee9fc0e71fecf7e1f3ee5a58a8} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!mesh\_to\_polyhedron@{mesh\_to\_polyhedron}}
\index{mesh\_to\_polyhedron@{mesh\_to\_polyhedron}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{mesh\_to\_polyhedron()}{mesh\_to\_polyhedron()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Polyhedron $>$ \\
bool igl\+::copyleft\+::cgal\+::mesh\+\_\+to\+\_\+polyhedron (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Polyhedron \&}]{poly }\end{DoxyParamCaption})}



Convert a mesh (V,F) to a CGAL Polyhedron. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Polyhedron} & CGAL Polyhedron type (e.\+g. Polyhedron\+\_\+3) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em poly} & cgal polyhedron \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only if (V,F) can be converted to a valid polyhedron (i.\+e. if (V,F) is vertex and edge manifold). 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aae36641a8877fe6384673c10bef5d05c}\label{namespaceigl_1_1copyleft_1_1cgal_aae36641a8877fe6384673c10bef5d05c} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!minkowski\_sum@{minkowski\_sum}}
\index{minkowski\_sum@{minkowski\_sum}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{minkowski\_sum()}{minkowski\_sum()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename DerivedW , typename DerivedG , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::minkowski\+\_\+sum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{const bool}]{resolve\+\_\+overlaps,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Compute the Minkowski sum of a closed triangle mesh (V,F) and a set of simplices in 3D. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VA} & \#\+VA by 3 list of mesh vertices in 3D \\
\hline
\mbox{\texttt{ in}}  & {\em FA} & \#\+FA by 3 list of triangle indices into VA \\
\hline
\mbox{\texttt{ in}}  & {\em VB} & \#\+VB by 3 list of mesh vertices in 3D \\
\hline
\mbox{\texttt{ in}}  & {\em FB} & \#\+FB by ss list of simplex indices into VB, ss\texorpdfstring{$<$}{<}=3 \\
\hline
\mbox{\texttt{ in}}  & {\em resolve\+\_\+overlaps} & whether or not to resolve self-\/union. If false then result may contain self-\/intersections if input mesh is non-\/convex. \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#W by 3 list of mesh vertices in 3D \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of triangle indices into W \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#G by 2 list of indices into \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac24439be4f8127484eeecd0dbf9f0ded}\label{namespaceigl_1_1copyleft_1_1cgal_ac24439be4f8127484eeecd0dbf9f0ded} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!minkowski\_sum@{minkowski\_sum}}
\index{minkowski\_sum@{minkowski\_sum}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{minkowski\_sum()}{minkowski\_sum()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename s\+Type , int s\+Cols, int s\+Options, typename d\+Type , int d\+Cols, int d\+Options, typename DerivedW , typename DerivedG , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::minkowski\+\_\+sum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix$<$ s\+Type, 1, s\+Cols, s\+Options $>$ \&}]{s,  }\item[{const Eigen\+::\+Matrix$<$ d\+Type, 1, d\+Cols, d\+Options $>$ \&}]{d,  }\item[{const bool}]{resolve\+\_\+overlaps,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Compute the Minkowski sum of a closed triangle mesh (V,F) and a segment \mbox{[}s,d\mbox{]} in 3D.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em s} & segment source endpoint in 3D \\
\hline
\mbox{\texttt{ in}}  & {\em d} & segment source endpoint in 3D \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aa7a270ca1724856eb95f5d2a31056f99}\label{namespaceigl_1_1copyleft_1_1cgal_aa7a270ca1724856eb95f5d2a31056f99} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!minkowski\_sum@{minkowski\_sum}}
\index{minkowski\_sum@{minkowski\_sum}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{minkowski\_sum()}{minkowski\_sum()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename s\+Type , int s\+Cols, int s\+Options, typename d\+Type , int d\+Cols, int d\+Options, typename DerivedW , typename DerivedG , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::minkowski\+\_\+sum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix$<$ s\+Type, 1, s\+Cols, s\+Options $>$ \&}]{s,  }\item[{const Eigen\+::\+Matrix$<$ d\+Type, 1, d\+Cols, d\+Options $>$ \&}]{d,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a8689344acbbb3e7bec33eb425d59cdde}\label{namespaceigl_1_1copyleft_1_1cgal_a8689344acbbb3e7bec33eb425d59cdde} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!order\_facets\_around\_edge@{order\_facets\_around\_edge}}
\index{order\_facets\_around\_edge@{order\_facets\_around\_edge}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{order\_facets\_around\_edge()}{order\_facets\_around\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ \\
void igl\+::copyleft\+::cgal\+::order\+\_\+facets\+\_\+around\+\_\+edge (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{size\+\_\+t}]{s,  }\item[{size\+\_\+t}]{d,  }\item[{const std\+::vector$<$ int $>$ \&}]{adj\+\_\+faces,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{order,  }\item[{bool}]{debug = {\ttfamily false} }\end{DoxyParamCaption})}



Given a directed edge, sort its adjacent faces. 

Assuming the directed edge is (s, d). Sort the adjacent faces clockwise around the axis (d -\/ s), i.\+e. left-\/hand rule. An adjacent face is consistently oriented if it contains (d, s) as a directed edge.

For overlapping faces, break the tie using signed face index, smaller signed index comes before the larger signed index. Signed index is computed as (consistent? 1\+:-\/1) \texorpdfstring{$\ast$}{*} (face\+\_\+index + 1).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of faces \\
\hline
\mbox{\texttt{ in}}  & {\em s} & Index of source vertex. \\
\hline
\mbox{\texttt{ in}}  & {\em d} & Index of destination vertex. \\
\hline
\mbox{\texttt{ in}}  & {\em adj\+\_\+faces} & List of adjacent face signed indices. \\
\hline
\mbox{\texttt{ out}}  & {\em order} & List of face indices that orders adjacent faces around edge (s, d) clockwise. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aa24fb4d258316354531a7d02652cf1f3}\label{namespaceigl_1_1copyleft_1_1cgal_aa24fb4d258316354531a7d02652cf1f3} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!order\_facets\_around\_edge@{order\_facets\_around\_edge}}
\index{order\_facets\_around\_edge@{order\_facets\_around\_edge}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{order\_facets\_around\_edge()}{order\_facets\_around\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ \\
void igl\+::copyleft\+::cgal\+::order\+\_\+facets\+\_\+around\+\_\+edge (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{size\+\_\+t}]{s,  }\item[{size\+\_\+t}]{d,  }\item[{const std\+::vector$<$ int $>$ \&}]{adj\+\_\+faces,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{pivot\+\_\+point,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{order }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

This function is a wrapper around the one above. Since the ordering is circular, the pivot point is used to define a starting point. So order\mbox{[}0\mbox{]} is the index into adj\+\_\+face that is immediately after the pivot face (s, d, pivot point) in clockwise order.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pivot\+\_\+point} & A point that forms pivot with edge (s,d) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_afc6ed199484566caed79fdc9ca79d92a}\label{namespaceigl_1_1copyleft_1_1cgal_afc6ed199484566caed79fdc9ca79d92a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!order\_facets\_around\_edges@{order\_facets\_around\_edges}}
\index{order\_facets\_around\_edges@{order\_facets\_around\_edges}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{order\_facets\_around\_edges()}{order\_facets\_around\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename u\+E2\+EType , typename u\+E2o\+EType , typename u\+E2\+CType $>$ \\
std\+::enable\+\_\+if$<$!std\+::is\+\_\+same$<$ typename\+Derived\+V\+::\+Scalar, typename\+CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+::\+FT $>$\+::value, void $>$\+::type igl\+::copyleft\+::cgal\+::order\+\_\+facets\+\_\+around\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2o\+EType $>$ $>$ \&}]{u\+E2oE,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+CType $>$ $>$ \&}]{u\+E2C }\end{DoxyParamCaption})}



For each undirected edge, sort its adjacent faces. 

Assuming the undirected edge is (s, d). Sort the adjacent faces clockwise around the axis (d -\/ s), i.\+e. left-\/hand rule. An adjacent face is consistently oriented if it contains (d, s) as a directed edge.

For overlapping faces, break the tie using signed face index, smaller signed index comes before the larger signed index. Signed index is computed as (consistent? 1\+:-\/1) \texorpdfstring{$\ast$}{*} index.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of faces \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#F by 3 list of face normals. \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of vertex\+\_\+indices, represents undirected edges. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists that maps uE to E. (a one-\/to-\/many map) \\
\hline
\mbox{\texttt{ out}}  & {\em u\+E2oE} & \#uE list of lists that maps uE to an ordered list of E. (a one-\/to-\/many map) \\
\hline
\mbox{\texttt{ out}}  & {\em u\+E2C} & \#uE list of lists of bools indicates whether each face in u\+E2oE\mbox{[}i\mbox{]} is consistently orientated as the ordering. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a77808bfdbb9a20091bf1403f0df54225}\label{namespaceigl_1_1copyleft_1_1cgal_a77808bfdbb9a20091bf1403f0df54225} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!order\_facets\_around\_edges@{order\_facets\_around\_edges}}
\index{order\_facets\_around\_edges@{order\_facets\_around\_edges}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{order\_facets\_around\_edges()}{order\_facets\_around\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename u\+E2\+EType , typename u\+E2o\+EType , typename u\+E2\+CType $>$ \\
std\+::enable\+\_\+if$<$ std\+::is\+\_\+same$<$ typename\+Derived\+V\+::\+Scalar, typename\+CGAL\+::\+Exact\+\_\+predicates\+\_\+exact\+\_\+constructions\+\_\+kernel\+::\+FT $>$\+::value, void $>$\+::type igl\+::copyleft\+::cgal\+::order\+\_\+facets\+\_\+around\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2o\+EType $>$ $>$ \&}]{u\+E2oE,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+CType $>$ $>$ \&}]{u\+E2C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac9d848d80df05abbc188abf9410eff26}\label{namespaceigl_1_1copyleft_1_1cgal_ac9d848d80df05abbc188abf9410eff26} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!order\_facets\_around\_edges@{order\_facets\_around\_edges}}
\index{order\_facets\_around\_edges@{order\_facets\_around\_edges}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{order\_facets\_around\_edges()}{order\_facets\_around\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DeriveduE , typename u\+E2\+EType , typename u\+E2o\+EType , typename u\+E2\+CType $>$ \\
void igl\+::copyleft\+::cgal\+::order\+\_\+facets\+\_\+around\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2o\+EType $>$ $>$ \&}]{u\+E2oE,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+CType $>$ $>$ \&}]{u\+E2C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Order faces around each edge. Only exact predicate is used in the algorithm. Normal is not needed. \Hypertarget{namespaceigl_1_1copyleft_1_1cgal_afc46637c226f5ef8f24214ecf37fa2dc}\label{namespaceigl_1_1copyleft_1_1cgal_afc46637c226f5ef8f24214ecf37fa2dc} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!orient2D@{orient2D}}
\index{orient2D@{orient2D}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{orient2D()}{orient2D()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
short igl\+::copyleft\+::cgal\+::orient2D (\begin{DoxyParamCaption}\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pa,  }\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pb,  }\item[{const Scalar \texorpdfstring{$\ast$}{*}}]{pc }\end{DoxyParamCaption})}



Tests whether a point is above, on, or below a line. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pa} & 2D point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em pb} & 2D point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em pc} & 2D point to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if pa,pb,pc,pd forms a triangle of positive area. 0 if pa,pb,pc,pd are coplanar. -\/1 if pa,pb,pc,pd forms a tet of negative area. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ad5b50178318855b0ef08301aabb646e1}\label{namespaceigl_1_1copyleft_1_1cgal_ad5b50178318855b0ef08301aabb646e1} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!orient3D@{orient3D}}
\index{orient3D@{orient3D}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{orient3D()}{orient3D()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
short igl\+::copyleft\+::cgal\+::orient3D (\begin{DoxyParamCaption}\item[{const Scalar}]{pa\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pb\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pc\mbox{[}3\mbox{]},  }\item[{const Scalar}]{pd\mbox{[}3\mbox{]} }\end{DoxyParamCaption})}



Tests whether a point is above, on, or below a plane. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pa} & 3D point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em pb} & 3D point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em pc} & 3D point on plane \\
\hline
\mbox{\texttt{ in}}  & {\em pd} & 3D point to test \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if pa,pb,pc,pd forms a tet of positive volume. 0 if pa,pb,pc,pd are coplanar. -\/1 if pa,pb,pc,pd forms a tet of negative volume. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a8612a06da5a83f2d0eb5234eb996a099}\label{namespaceigl_1_1copyleft_1_1cgal_a8612a06da5a83f2d0eb5234eb996a099} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!outer\_edge@{outer\_edge}}
\index{outer\_edge@{outer\_edge}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{outer\_edge()}{outer\_edge()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ \\
void igl\+::copyleft\+::cgal\+::outer\+\_\+edge (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{v1,  }\item[{Index\+Type \&}]{v2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Find an edge that is reachable from infinity without crossing any faces. 

Such edge is called \"{}outer edge.\"{}

\begin{DoxyPrecond}{Precondition}
The input mesh must have all self-\/intersection resolved and no duplicated vertices. The correctness of the output depends on the fact that there is no edge overlap. See cgal\+::remesh\+\_\+self\+\_\+intersections.\+h for how to obtain such input.
\end{DoxyPrecond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of facets to consider \\
\hline
\mbox{\texttt{ out}}  & {\em v1} & index of the first end point of outer edge \\
\hline
\mbox{\texttt{ out}}  & {\em v2} & index of the second end point of outer edge \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#A list of facets incident to the outer edge \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_af01d429e270d88b1c279c860631ad5a7}\label{namespaceigl_1_1copyleft_1_1cgal_af01d429e270d88b1c279c860631ad5a7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!outer\_facet@{outer\_facet}}
\index{outer\_facet@{outer\_facet}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{outer\_facet()}{outer\_facet()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename Index\+Type $>$ \\
void igl\+::copyleft\+::cgal\+::outer\+\_\+facet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{f,  }\item[{bool \&}]{flipped }\end{DoxyParamCaption})}



Find a facet that is reachable from infinity without crossing any faces. 

Such facet is called \"{}outer facet.\"{}

\begin{DoxyPrecond}{Precondition}
The input mesh must have all self-\/intersection resolved. I.\+e there is no duplicated vertices, no overlapping edge and no intersecting faces (the only exception is there could be topologically duplicated faces). See cgal\+::remesh\+\_\+self\+\_\+intersections.\+h for how to obtain such input.
\end{DoxyPrecond}
This function differ from \doxylink{namespaceigl_ab8ea262d61548f3946263a5c00ed0192}{igl\+::outer\+\_\+facet()} in the fact this function is more robust because it does not rely on facet normals.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of facets to consider \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#N by 3 list of face normals \\
\hline
\mbox{\texttt{ out}}  & {\em f} & Index of the outer facet. \\
\hline
\mbox{\texttt{ out}}  & {\em flipped} & true iff the normal of f points inwards. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a075bcb6ea0a7e4bd56f56d57255422f7}\label{namespaceigl_1_1copyleft_1_1cgal_a075bcb6ea0a7e4bd56f56d57255422f7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!outer\_facet@{outer\_facet}}
\index{outer\_facet@{outer\_facet}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{outer\_facet()}{outer\_facet()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type $>$ \\
void igl\+::copyleft\+::cgal\+::outer\+\_\+facet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{f,  }\item[{bool \&}]{flipped }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_abf86c29b557c7341d5d6a2ae734273d4}\label{namespaceigl_1_1copyleft_1_1cgal_abf86c29b557c7341d5d6a2ae734273d4} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!outer\_hull@{outer\_hull}}
\index{outer\_hull@{outer\_hull}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{outer\_hull()}{outer\_hull()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+HV , typename Derived\+HF , typename DerivedJ , typename Derivedflip $>$ \\
void igl\+::copyleft\+::cgal\+::outer\+\_\+hull (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+HV $>$ \&}]{HV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+HF $>$ \&}]{HF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedflip $>$ \&}]{flip }\end{DoxyParamCaption})}



Compute the \"{}outer hull\"{} of a piecewise constant winding number induce triangle mesh (V,F). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em HV} & \#\+HV by 3 list of output vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em HF} & \#\+HF by 3 list of output triangle indices into HV \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+HF list of indices into F \\
\hline
\mbox{\texttt{ out}}  & {\em flip} & \#\+HF list of whether facet was flipped when added to HF \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a0a69c0cfdf86cb14a3a1af742b322257}\label{namespaceigl_1_1copyleft_1_1cgal_a0a69c0cfdf86cb14a3a1af742b322257} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!outer\_hull\_legacy@{outer\_hull\_legacy}}
\index{outer\_hull\_legacy@{outer\_hull\_legacy}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{outer\_hull\_legacy()}{outer\_hull\_legacy()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedG , typename DerivedJ , typename Derivedflip $>$ \\
void igl\+::copyleft\+::cgal\+::outer\+\_\+hull\+\_\+legacy (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedflip $>$ \&}]{flip }\end{DoxyParamCaption})}



Compute the \"{}outer hull\"{} of a potentially non-\/manifold mesh (V,F) whose intersections have been \"{}resolved\"{} (e.\+g. 

using {\ttfamily cork} or {\ttfamily igl\+::copyleft\+::cgal\+::selfintersect}). The outer hull is defined to be all facets (regardless of orientation) for which there exists some path from infinity to the face without intersecting any other facets. For solids, this is the surface of the solid. In general this includes any thin \"{}wings\"{} or \"{}flaps\"{}. This implementation largely follows Section 3.\+6 of \"{}\+Direct repair of self-\/intersecting meshes\"{} \mbox{[}Attene 2014\mbox{]}.

\begin{DoxyNote}{Note}
This doesn\textquotesingle{}t require the input mesh to be piecewise constant winding number, but won\textquotesingle{}t handle multiple non-\/nested connected components.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of output triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#G list of indices into F \\
\hline
\mbox{\texttt{ out}}  & {\em flip} & \#F list of whether facet was added to G {\bfseries{and}} flipped orientation (false for faces not added to G) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a978bd4e32580644accd9602fafec9c3d}\label{namespaceigl_1_1copyleft_1_1cgal_a978bd4e32580644accd9602fafec9c3d} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!outer\_vertex@{outer\_vertex}}
\index{outer\_vertex@{outer\_vertex}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{outer\_vertex()}{outer\_vertex()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ \\
void igl\+::copyleft\+::cgal\+::outer\+\_\+vertex (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{v\+\_\+index,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Find a vertex that is reachable from infinite without crossing any faces. 

Such vertex is called \"{}outer vertex.\"{}

\begin{DoxyPrecond}{Precondition}
The input mesh must have all self-\/intersection resolved and no duplicated vertices. See cgal\+::remesh\+\_\+self\+\_\+intersections.\+h for how to obtain such input.
\end{DoxyPrecond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of facets to consider \\
\hline
\mbox{\texttt{ out}}  & {\em v\+\_\+index} & index of outer vertex \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#A list of facets incident to the outer vertex \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a1a3a5e1ab834f987bb22bceea2d29f36}\label{namespaceigl_1_1copyleft_1_1cgal_a1a3a5e1ab834f987bb22bceea2d29f36} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!peel\_outer\_hull\_layers@{peel\_outer\_hull\_layers}}
\index{peel\_outer\_hull\_layers@{peel\_outer\_hull\_layers}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{peel\_outer\_hull\_layers()}{peel\_outer\_hull\_layers()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Derivedflip $>$ \\
size\+\_\+t igl\+::copyleft\+::cgal\+::peel\+\_\+outer\+\_\+hull\+\_\+layers (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedflip $>$ \&}]{flip }\end{DoxyParamCaption})}



Computes necessary generic information for boolean operations by successively \"{}peeling\"{} off the \"{}outer hull\"{} of a mesh (V,F) resulting from \"{}resolving\"{} all (self-\/)intersections. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#F list of which peel Iation a facet belongs \\
\hline
\mbox{\texttt{ out}}  & {\em flip} & \#F list of whether a facet\textquotesingle{}s orientation was flipped when facet \"{}peeled\"{} into its associated outer hull layer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of peels 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac1f61d0bdf6d687737bc08b5fa72111a}\label{namespaceigl_1_1copyleft_1_1cgal_ac1f61d0bdf6d687737bc08b5fa72111a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!peel\_winding\_number\_layers@{peel\_winding\_number\_layers}}
\index{peel\_winding\_number\_layers@{peel\_winding\_number\_layers}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{peel\_winding\_number\_layers()}{peel\_winding\_number\_layers()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedW $>$ \\
size\+\_\+t igl\+::copyleft\+::cgal\+::peel\+\_\+winding\+\_\+number\+\_\+layers (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Peel Winding number layers from a mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by 1 list of winding numbers \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a55276c7ddaadbfad9b0ddf0beeb756fe}\label{namespaceigl_1_1copyleft_1_1cgal_a55276c7ddaadbfad9b0ddf0beeb756fe} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!piecewise\_constant\_winding\_number@{piecewise\_constant\_winding\_number}}
\index{piecewise\_constant\_winding\_number@{piecewise\_constant\_winding\_number}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{piecewise\_constant\_winding\_number()}{piecewise\_constant\_winding\_number()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::copyleft\+::cgal\+::piecewise\+\_\+constant\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Determine if a given mesh induces a piecewise constant winding number field\+: Is this mesh valid input to solid set operations. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the mesh {\itshape combinatorially} induces a piecewise constant winding number field. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a1240cef3d039ac518baca44025fe1adc}\label{namespaceigl_1_1copyleft_1_1cgal_a1240cef3d039ac518baca44025fe1adc} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_areas@{point\_areas}}
\index{point\_areas@{point\_areas}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_areas()}{point\_areas()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA , typename DerivedT $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+areas (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



Given a 3D set of points P, each with a list of k-\/nearest-\/neighbours, estimate the geodesic voronoi area associated with each point. 

The k nearest neighbours may be known from running igl\+::knn\+\_\+octree on the output data from \doxylink{namespaceigl_a3ff69240d0614e6f4ab20ff15b2f21a4}{igl\+::octree}. We reccomend using a k value between 15 and 20 inclusive for accurate area estimation.

N is used filter the neighbours, to ensure area estimation only occurs using neighbors that are on the same side of the surface (ie for thin sheets), as well as to solve the orientation ambiguity of the tangent plane normal.

\begin{DoxyNote}{Note}
This function {\itshape should} be implemented by pre-\/filtering I, rather than filtering in this function using N. In this case, the function would only take P and I as input.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of point locations \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#P by k list of k-\/nearest-\/neighbor indices into P \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of point normals \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#P list of estimated areas \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a6f2969bd735df2588ce37026375ddefe}{igl\+::knn} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3b9e1a72f57d4b751d6ad9a482a00e36}\label{namespaceigl_1_1copyleft_1_1cgal_a3b9e1a72f57d4b751d6ad9a482a00e36} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_areas@{point\_areas}}
\index{point\_areas@{point\_areas}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_areas()}{point\_areas()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+areas (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a538a22d0da720af8d4bc8943eeb78ccd}\label{namespaceigl_1_1copyleft_1_1cgal_a538a22d0da720af8d4bc8943eeb78ccd} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_mesh\_squared\_distance@{point\_mesh\_squared\_distance}}
\index{point\_mesh\_squared\_distance@{point\_mesh\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_mesh\_squared\_distance()}{point\_mesh\_squared\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Kernel , typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedsqrD , typename DerivedI , typename DerivedC $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+mesh\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&}]{sqrD,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute distances from a set of points P to a triangle mesh (V,F) 


\begin{DoxyTemplParams}{Template Parameters}
{\em Kernal} & CGAL computation and construction kernel (e.\+g. CGAL\+::\+Simple\+\_\+cartesian$<$double$>$) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em sqrD} & \#P list of smallest squared distances \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#P list of facet indices corresponding to smallest distances \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#P by 3 list of closest points\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7079694987005d32d246369f638930a2}\label{namespaceigl_1_1copyleft_1_1cgal_a7079694987005d32d246369f638930a2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_mesh\_squared\_distance\_precompute@{point\_mesh\_squared\_distance\_precompute}}
\index{point\_mesh\_squared\_distance\_precompute@{point\_mesh\_squared\_distance\_precompute}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_mesh\_squared\_distance\_precompute()}{point\_mesh\_squared\_distance\_precompute()}}
{\footnotesize\ttfamily template$<$typename Kernel , typename DerivedV , typename DerivedF $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+mesh\+\_\+squared\+\_\+distance\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$\+::iterator $>$ $>$ $>$ \&}]{tree,  }\item[{std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&}]{T }\end{DoxyParamCaption})}



precomputation for point\+\_\+mesh\+\_\+squared\+\_\+distance 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em tree} & CGAL\textquotesingle{}s \doxylink{classigl_1_1AABB}{AABB} tree \\
\hline
\mbox{\texttt{ out}}  & {\em T} & list of CGAL triangles in order of F (for determining which was found in computation)\\
\hline
\end{DoxyParams}
\doxylink{copyleft_2cgal_2point__mesh__squared__distance_8h}{include/igl/copyleft/cgal/point\+\_\+mesh\+\_\+squared\+\_\+distance.\+h} \Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a4b06702d1399da65b7d57a7883a903cd}\label{namespaceigl_1_1copyleft_1_1cgal_a4b06702d1399da65b7d57a7883a903cd} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_mesh\_squared\_distance@{point\_mesh\_squared\_distance}}
\index{point\_mesh\_squared\_distance@{point\_mesh\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_mesh\_squared\_distance()}{point\_mesh\_squared\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Kernel , typename DerivedP , typename DerivedsqrD , typename DerivedI , typename DerivedC $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+mesh\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$\+::iterator $>$ $>$ $>$ \&}]{tree,  }\item[{const std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&}]{sqrD,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute distances from a set of points P to a triangle mesh (V,F) using precomputed trees. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em tree} & CGAL\textquotesingle{}s \doxylink{classigl_1_1AABB}{AABB} tree \\
\hline
\mbox{\texttt{ in}}  & {\em T} & list of CGAL triangles in order of F (for determining which was found in computation) \\
\hline
\mbox{\texttt{ out}}  & {\em sqrD} & \#P list of smallest squared distances \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#P list of facet indices corresponding to smallest distances \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#P by 3 list of closest points \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aeb0f63485251c67fe5632d5177cf3cf8}\label{namespaceigl_1_1copyleft_1_1cgal_aeb0f63485251c67fe5632d5177cf3cf8} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_segment\_squared\_distance@{point\_segment\_squared\_distance}}
\index{point\_segment\_squared\_distance@{point\_segment\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_segment\_squared\_distance()}{point\_segment\_squared\_distance()}}
{\footnotesize\ttfamily template$<$typename Kernel $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+segment\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P1,  }\item[{const CGAL\+::\+Segment\+\_\+3$<$ Kernel $>$ \&}]{S2,  }\item[{CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P2,  }\item[{typename Kernel\+::\+FT \&}]{d }\end{DoxyParamCaption})}



Given a point P1 and segment S2 find the points on each of closest approach and the squared distance thereof. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P1} & point \\
\hline
\mbox{\texttt{ in}}  & {\em S2} & segment \\
\hline
\mbox{\texttt{ out}}  & {\em P2} & point on S2 closest to P1 \\
\hline
\mbox{\texttt{ out}}  & {\em d} & distance betwee P1 and S2 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aba6c0e12a671c3facc2b5129904c738e}\label{namespaceigl_1_1copyleft_1_1cgal_aba6c0e12a671c3facc2b5129904c738e} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_solid\_signed\_squared\_distance@{point\_solid\_signed\_squared\_distance}}
\index{point\_solid\_signed\_squared\_distance@{point\_solid\_signed\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_solid\_signed\_squared\_distance()}{point\_solid\_signed\_squared\_distance()}}
{\footnotesize\ttfamily template$<$typename DerivedQ , typename Derived\+VB , typename Derived\+FB , typename DerivedD $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+solid\+\_\+signed\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



Given a set of points (Q) and the boundary mesh (VB,FB) of a solid (as defined in \mbox{[}Zhou et al. 

2016\mbox{]}, determine the signed squared distance for each point q in Q so that d(q,\+B) is negative if inside and positive if outside.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Q} & \#Q by 3 list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em VB} & \#\+VB by 3 list of mesh vertex positions of B \\
\hline
\mbox{\texttt{ in}}  & {\em FB} & \#\+FB by 3 list of mesh triangle indices into VB \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#Q list of signed squared distances \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a27577e36f63f566d05abe10135706585}\label{namespaceigl_1_1copyleft_1_1cgal_a27577e36f63f566d05abe10135706585} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!point\_triangle\_squared\_distance@{point\_triangle\_squared\_distance}}
\index{point\_triangle\_squared\_distance@{point\_triangle\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{point\_triangle\_squared\_distance()}{point\_triangle\_squared\_distance()}}
{\footnotesize\ttfamily template$<$typename Kernel $>$ \\
void igl\+::copyleft\+::cgal\+::point\+\_\+triangle\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P1,  }\item[{const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&}]{T2,  }\item[{CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P2,  }\item[{typename Kernel\+::\+FT \&}]{d }\end{DoxyParamCaption})}



Given a point P1 and triangle T2 find the points on each of closest approach and the squared distance thereof. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P1} & point \\
\hline
\mbox{\texttt{ in}}  & {\em T2} & triangle \\
\hline
\mbox{\texttt{ out}}  & {\em P2} & point on T2 closest to P1 \\
\hline
\mbox{\texttt{ out}}  & {\em d} & distance betwee P1 and T2 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a41473b3f595af6326c481f3be623b95d}\label{namespaceigl_1_1copyleft_1_1cgal_a41473b3f595af6326c481f3be623b95d} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!points\_inside\_component@{points\_inside\_component}}
\index{points\_inside\_component@{points\_inside\_component}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{points\_inside\_component()}{points\_inside\_component()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedB $>$ \\
void igl\+::copyleft\+::cgal\+::points\+\_\+inside\+\_\+component (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{inside }\end{DoxyParamCaption})}



Determine if queries points P are inside of connected facet component (V, F, I), where I indicates a subset of facets that forms the component. 

\begin{DoxyPrecond}{Precondition}
The input mesh must be a closed, self-\/intersection free, non-\/degenerated surface. Queries points must be either inside or outside of the mesh (i.\+e. not on the surface of the mesh).
\end{DoxyPrecond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 array of vertex positions. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 array of triangles. \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of triangle indices to consider. \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 array of query points. \\
\hline
\mbox{\texttt{ out}}  & {\em inside} & \#P list of booleans that is true iff the corresponding query point is inside of the mesh. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aa361bd05fcdd8ce7cc09059a90a71397}\label{namespaceigl_1_1copyleft_1_1cgal_aa361bd05fcdd8ce7cc09059a90a71397} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!points\_inside\_component@{points\_inside\_component}}
\index{points\_inside\_component@{points\_inside\_component}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{points\_inside\_component()}{points\_inside\_component()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedB $>$ \\
void igl\+::copyleft\+::cgal\+::points\+\_\+inside\+\_\+component (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{inside }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a9163b384abc034cb8ef2c61e545c1da0}\label{namespaceigl_1_1copyleft_1_1cgal_a9163b384abc034cb8ef2c61e545c1da0} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!polyhedron\_to\_mesh@{polyhedron\_to\_mesh}}
\index{polyhedron\_to\_mesh@{polyhedron\_to\_mesh}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{polyhedron\_to\_mesh()}{polyhedron\_to\_mesh()}}
{\footnotesize\ttfamily template$<$typename Polyhedron , typename DerivedV , typename DerivedF $>$ \\
void igl\+::copyleft\+::cgal\+::polyhedron\+\_\+to\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Polyhedron \&}]{poly,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Convert a CGAL Polyhedron to a mesh (V,F) 


\begin{DoxyTemplParams}{Template Parameters}
{\em Polyhedron} & CGAL Polyhedron type (e.\+g. Polyhedron\+\_\+3) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em poly} & cgal polyhedron \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ad6b773fa54359274318604d433dd2e9a}\label{namespaceigl_1_1copyleft_1_1cgal_ad6b773fa54359274318604d433dd2e9a} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!projected\_cdt@{projected\_cdt}}
\index{projected\_cdt@{projected\_cdt}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{projected\_cdt()}{projected\_cdt()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Kernel , typename Index $>$ \\
void igl\+::copyleft\+::cgal\+::projected\+\_\+cdt (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ CGAL\+::\+Object $>$ \&}]{objects,  }\item[{const CGAL\+::\+Plane\+\_\+3$<$ Kernel $>$ \&}]{P,  }\item[{std\+::vector$<$ CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ $>$ \&}]{vertices,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{faces }\end{DoxyParamCaption})}



Given a list of objects (e.\+g., resulting from intersecting a triangle with many other triangles), construct a constrained Delaunay triangulation on a given plane (P), by inersting constraints for each object projected onto that plane. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em objects} & list of objects. This should lie on the given plane (P), otherwise they are added to the cdt {\itshape after} their non-\/trivial projection \\
\hline
\mbox{\texttt{ in}}  & {\em P} & plane upon which all objects lie and upon which the CDT is conducted \\
\hline
\mbox{\texttt{ out}}  & {\em vertices} & list of vertices of the CDT mesh {\itshape back on the 3D plane} \\
\hline
\mbox{\texttt{ out}}  & {\em faces} & list of list of triangle indices into vertices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a45607f6c08fba2fc4a797244d7c75b81}\label{namespaceigl_1_1copyleft_1_1cgal_a45607f6c08fba2fc4a797244d7c75b81} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!projected\_cdt@{projected\_cdt}}
\index{projected\_cdt@{projected\_cdt}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{projected\_cdt()}{projected\_cdt()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Kernel , typename DerivedV , typename DerivedF $>$ \\
void igl\+::copyleft\+::cgal\+::projected\+\_\+cdt (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ CGAL\+::\+Object $>$ \&}]{objects,  }\item[{const CGAL\+::\+Plane\+\_\+3$<$ Kernel $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of vertices of the CDT mesh {\itshape back on the 3D plane}, {\bfseries{cast}} from the number type of Kernel to the number type of DerivedV \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7a62d282e26f8a1b91722dd9da3b5bd2}\label{namespaceigl_1_1copyleft_1_1cgal_a7a62d282e26f8a1b91722dd9da3b5bd2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!projected\_delaunay@{projected\_delaunay}}
\index{projected\_delaunay@{projected\_delaunay}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{projected\_delaunay()}{projected\_delaunay()}}
{\footnotesize\ttfamily template$<$typename Kernel $>$ \\
void igl\+::copyleft\+::cgal\+::projected\+\_\+delaunay (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&}]{A,  }\item[{const std\+::vector$<$ CGAL\+::\+Object $>$ \&}]{A\+\_\+objects\+\_\+3,  }\item[{CGAL\+::\+Constrained\+\_\+triangulation\+\_\+plus\+\_\+2$<$ CGAL\+::\+Constrained\+\_\+\+Delaunay\+\_\+triangulation\+\_\+2$<$ Kernel, CGAL\+::\+Triangulation\+\_\+data\+\_\+structure\+\_\+2$<$ CGAL\+::\+Triangulation\+\_\+vertex\+\_\+base\+\_\+2$<$ Kernel $>$, CGAL\+::\+Constrained\+\_\+triangulation\+\_\+face\+\_\+base\+\_\+2$<$ Kernel $>$ $>$, CGAL\+::\+Exact\+\_\+intersections\+\_\+tag $>$ $>$ \&}]{cdt }\end{DoxyParamCaption})}



Compute 2D delaunay triangulation of a given 3d triangle and a list of intersection objects (points,segments,triangles). 

CGAL uses an affine projection rather than an isometric projection, so we\textquotesingle{}re not guaranteed that the 2D delaunay triangulation here will be a delaunay triangulation in 3D.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & triangle in 3D \\
\hline
\mbox{\texttt{ in}}  & {\em A\+\_\+objects\+\_\+3} & updated list of intersection objects for A \\
\hline
\mbox{\texttt{ out}}  & {\em cdt} & Contrained delaunay triangulation in projected 2D plane \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ab29a1ce9ef6539d66c1400a27db655d0}\label{namespaceigl_1_1copyleft_1_1cgal_ab29a1ce9ef6539d66c1400a27db655d0} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!propagate\_winding\_numbers@{propagate\_winding\_numbers}}
\index{propagate\_winding\_numbers@{propagate\_winding\_numbers}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{propagate\_winding\_numbers()}{propagate\_winding\_numbers()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedL , typename DerivedW $>$ \\
bool igl\+::copyleft\+::cgal\+::propagate\+\_\+winding\+\_\+numbers (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{labels,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Compute winding number on each side of the face. 

The input mesh could contain multiple connected components. The input mesh must represent the boundary of a valid 3D volume, which means it is closed, consistently oriented and induces integer winding numbers.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em labels} & \#F list of facet labels ranging from 0 to k-\/1. \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#F by k\texorpdfstring{$\ast$}{*}2 list of winding numbers. {\ttfamily W(i,j\texorpdfstring{$\ast$}{*}2)} is the winding number on the positive side of facet {\ttfamily i} with respect to the facets labeled {\ttfamily j}. Similarly, {\ttfamily W(i,j\texorpdfstring{$\ast$}{*}2+1)} is the winding number on the negative side of facet {\ttfamily i} with respect to the facets labeled {\ttfamily j}. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff the input induces a piecewise-\/constant winding number field.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
This shouldn\textquotesingle{}t need to be in \doxylink{namespaceigl_1_1copyleft_1_1cgal}{igl\+::copyleft\+::cgal}, it should instead take as input an index of the ambient cell and the winding number vector there. 
\end{DoxyNote}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a55a2fbf8152086bfb9f61740ebdec358}\label{namespaceigl_1_1copyleft_1_1cgal_a55a2fbf8152086bfb9f61740ebdec358} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!propagate\_winding\_numbers@{propagate\_winding\_numbers}}
\index{propagate\_winding\_numbers@{propagate\_winding\_numbers}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{propagate\_winding\_numbers()}{propagate\_winding\_numbers()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DeriveduE , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedP , typename DerivedC , typename DerivedL , typename DerivedW $>$ \\
bool igl\+::copyleft\+::cgal\+::propagate\+\_\+winding\+\_\+numbers (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{const size\+\_\+t}]{num\+\_\+patches,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const size\+\_\+t}]{num\+\_\+cells,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{labels,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ae8359e73ff0ee8149c314d3816b5958f}\label{namespaceigl_1_1copyleft_1_1cgal_ae8359e73ff0ee8149c314d3816b5958f} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!read\_triangle\_mesh@{read\_triangle\_mesh}}
\index{read\_triangle\_mesh@{read\_triangle\_mesh}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{read\_triangle\_mesh()}{read\_triangle\_mesh()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::copyleft\+::cgal\+::read\+\_\+triangle\+\_\+mesh (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Simple wrapper, reads floating point precision but assigns to Derived\+V\+::\+Scalar which may be a CGAL type. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & eigen double matrix \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em F} & eigen int matrix \#F by 3 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff success
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a6bd18b073b51beb1500c10c4f2825aba}{igl\+::read\+\_\+triangle\+\_\+mesh} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3d3dc739f900eb1f9479e974de035d2c}\label{namespaceigl_1_1copyleft_1_1cgal_a3d3dc739f900eb1f9479e974de035d2c} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!relabel\_small\_immersed\_cells@{relabel\_small\_immersed\_cells}}
\index{relabel\_small\_immersed\_cells@{relabel\_small\_immersed\_cells}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{relabel\_small\_immersed\_cells()}{relabel\_small\_immersed\_cells()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedC , typename FT , typename DerivedW $>$ \\
void igl\+::copyleft\+::cgal\+::relabel\+\_\+small\+\_\+immersed\+\_\+cells (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const size\+\_\+t}]{num\+\_\+patches,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const size\+\_\+t}]{num\+\_\+cells,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const FT}]{vol\+\_\+threashold,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Relabel winding numbers of small immersed cells. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+patches} & number of patches \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#F list of patch ids. \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+cells} & number of cells \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#P by 2 list of cell ids on each side of each patch. \\
\hline
\mbox{\texttt{ in}}  & {\em vol\+\_\+threshold} & Volume threshold, cells smaller than this and is completely immersed will be relabeled. \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#F by 2 cell labels. W(i,0) is the label on the positive side of face i, W(i,1) is the label on the negative side of face i. W will be modified in place by this method. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a99d687331f910fef280e3a0e5f5370c7}\label{namespaceigl_1_1copyleft_1_1cgal_a99d687331f910fef280e3a0e5f5370c7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!remesh\_intersections@{remesh\_intersections}}
\index{remesh\_intersections@{remesh\_intersections}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{remesh\_intersections()}{remesh\_intersections()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Kernel , typename Derived\+VV , typename Derived\+FF , typename DerivedJ , typename Derived\+IM $>$ \\
void igl\+::copyleft\+::cgal\+::remesh\+\_\+intersections (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const std\+::vector$<$ CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ $>$ \&}]{T,  }\item[{const std\+::map$<$ typename Derived\+F\+::\+Index, std\+::vector$<$ std\+::pair$<$ typename Derived\+F\+::\+Index, CGAL\+::\+Object $>$ $>$ $>$ \&}]{offending,  }\item[{bool}]{stitch\+\_\+all,  }\item[{bool}]{slow\+\_\+and\+\_\+more\+\_\+precise\+\_\+rounding,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&}]{VV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&}]{IM }\end{DoxyParamCaption})}



Remesh faces according to results of intersection detection and construction (e.\+g. 

from {\ttfamily \doxylink{namespaceigl_1_1copyleft_1_1cgal_aad0ee9bfc55573ac2ac722c5d6e6d8bc}{igl\+::copyleft\+::cgal\+::intersect\+\_\+other}} or {\ttfamily \doxylink{classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh}{igl\+::copyleft\+::cgal\+::\+Self\+Intersect\+Mesh}})


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#F list of cgal triangles \\
\hline
\mbox{\texttt{ in}}  & {\em offending} & \#offending map taking face indices into F to pairs of order of first finding and list of intersection objects from all intersections \\
\hline
\mbox{\texttt{ in}}  & {\em stitch\+\_\+all} & if true, merge all vertices with the same coordinate. \\
\hline
\mbox{\texttt{ out}}  & {\em VV} & \#\+VV by 3 list of vertex positions, if stitch\+\_\+all = false then first \#V vertices will always be V \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#\+FF by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em IF} & \#intersecting face pairs by 2 list of intersecting face pairs, indexing F \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+FF list of indices into F denoting birth triangle \\
\hline
\mbox{\texttt{ out}}  & {\em IM} & if stitch\+\_\+all = true \#\+VV list from 0 to \#\+VV-\/1 elseif stitch\+\_\+all = false \#\+VV list of indices into VV of unique vertices. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7169f4ae2fe2c11f7e878b41aa747fc2}\label{namespaceigl_1_1copyleft_1_1cgal_a7169f4ae2fe2c11f7e878b41aa747fc2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!remesh\_self\_intersections@{remesh\_self\_intersections}}
\index{remesh\_self\_intersections@{remesh\_self\_intersections}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{remesh\_self\_intersections()}{remesh\_self\_intersections()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VV , typename Derived\+FF , typename Derived\+IF , typename DerivedJ , typename Derived\+IM $>$ \\
void igl\+::copyleft\+::cgal\+::remesh\+\_\+self\+\_\+intersections (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam}{Remesh\+Self\+Intersections\+Param}} \&}]{params,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&}]{VV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IF $>$ \&}]{IF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&}]{IM }\end{DoxyParamCaption})}



Given a triangle mesh (V,F) compute a new mesh (VV,FF) which is the same as (V,F) except that any self-\/intersecting triangles in (V,F) have been subdivided (new vertices and face created) so that the self-\/intersection contour lies exactly on edges in (VV,FF). 

New vertices will appear in original faces or on original edges. New vertices on edges are \"{}merged\"{} only across original faces sharing that edge. This means that if the input triangle mesh is a closed manifold the output will be too.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em params} & struct of optional parameters \\
\hline
\mbox{\texttt{ out}}  & {\em VV} & \#\+VV by 3 list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#\+FF by 3 list of triangle indices into VV \\
\hline
\mbox{\texttt{ out}}  & {\em IF} & \#intersecting face pairs by 2 list of intersecting face pairs, indexing F \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+FF list of indices into F denoting birth triangle \\
\hline
\mbox{\texttt{ out}}  & {\em IM} & \#\+VV list of indices into VV of unique vertices.\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_1_1copyleft_1_1cgal_autotoc_md6}{}\doxyparagraph{\texorpdfstring{Example.}{Example.}}\label{namespaceigl_1_1copyleft_1_1cgal_autotoc_md6}
// resolve intersections igl\+::copyleft\+::cgal\+::remesh\+\_\+self\+\_\+intersections(\+V,\+F,params,\+VV,\+FF,\+IF,\+J,\+IM); // {\itshape apply} duplicate vertex mapping IM to FF for\+\_\+each(FF.\+data(),FF.\+data()+FF.\+size(),\mbox{[}\&IM\mbox{]}(int \& a)\{a=IM(a);\}); // remove any vertices now unreferenced after duplicate mapping. igl\+::remove\+\_\+unreferenced(\+VV,\+FF,\+SV,\+SF,\+UIM); // Now (SV,SF) is ready to extract outer hull igl\+::copyleft\+::cgal\+::outer\+\_\+hull(\+SV,\+SF,\+G,\+J,flip); \Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a4711ebc19670232979ddfafeea023a6c}\label{namespaceigl_1_1copyleft_1_1cgal_a4711ebc19670232979ddfafeea023a6c} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!resolve\_intersections@{resolve\_intersections}}
\index{resolve\_intersections@{resolve\_intersections}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{resolve\_intersections()}{resolve\_intersections()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedE , typename Derived\+VI , typename Derived\+EI , typename DerivedJ , typename Derived\+IM $>$ \\
void igl\+::copyleft\+::cgal\+::resolve\+\_\+intersections (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&}]{VI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EI $>$ \&}]{EI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&}]{IM }\end{DoxyParamCaption})}



Given a list of possible intersecting segments with endpoints, split segments to overlap only at endpoints. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of segment indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em VI} & \#\+VI by 2 list of output vertex positions, copies of V are always the first \#V vertices \\
\hline
\mbox{\texttt{ out}}  & {\em EI} & \#\+EI by 2 list of segment indices into V, \#\+EI ≥ \#E \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+EI list of indices into E revealing \"{}parent segments\"{} \\
\hline
\mbox{\texttt{ out}}  & {\em IM} & \#\+VI list of indices into VV of unique vertices. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_aacfa81a78943385b9146fe53e121b380}\label{namespaceigl_1_1copyleft_1_1cgal_aacfa81a78943385b9146fe53e121b380} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!row\_to\_point@{row\_to\_point}}
\index{row\_to\_point@{row\_to\_point}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{row\_to\_point()}{row\_to\_point()}}
{\footnotesize\ttfamily template$<$typename Kernel , typename DerivedV $>$ \\
CGAL\+::\+Point\+\_\+2$<$ Kernel $>$ igl\+::copyleft\+::cgal\+::row\+\_\+to\+\_\+point (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const typename Derived\+V\+::\+Index \&}]{i }\end{DoxyParamCaption})}



Extract a row from V and treat as a 2D cgal point (only first two columns of V are used). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em i} & row index \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
2D cgal point 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a1cd33a114c5e272d9d444bea740c4cfc}\label{namespaceigl_1_1copyleft_1_1cgal_a1cd33a114c5e272d9d444bea740c4cfc} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!segment\_segment\_squared\_distance@{segment\_segment\_squared\_distance}}
\index{segment\_segment\_squared\_distance@{segment\_segment\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{segment\_segment\_squared\_distance()}{segment\_segment\_squared\_distance()}}
{\footnotesize\ttfamily template$<$typename Kernel $>$ \\
bool igl\+::copyleft\+::cgal\+::segment\+\_\+segment\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Segment\+\_\+3$<$ Kernel $>$ \&}]{S1,  }\item[{const CGAL\+::\+Segment\+\_\+3$<$ Kernel $>$ \&}]{S2,  }\item[{CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P1,  }\item[{CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P2,  }\item[{typename Kernel\+::\+FT \&}]{d }\end{DoxyParamCaption})}



Given two segments S1 and S2 find the points on each of closest approach and the squared distance thereof. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S1} & first segment \\
\hline
\mbox{\texttt{ in}}  & {\em S2} & second segment \\
\hline
 & {\em \mbox{[}oout\mbox{]}} & P1 point on S1 closest to S2 \\
\hline
 & {\em \mbox{[}oout\mbox{]}} & P2 point on S2 closest to S1 \\
\hline
 & {\em \mbox{[}oout\mbox{]}} & d distance betwee P1 and S2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the closest approach is unique. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a240ec71bf9ed8497cca131ce80e30045}\label{namespaceigl_1_1copyleft_1_1cgal_a240ec71bf9ed8497cca131ce80e30045} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!signed\_distance\_isosurface@{signed\_distance\_isosurface}}
\index{signed\_distance\_isosurface@{signed\_distance\_isosurface}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_isosurface()}{signed\_distance\_isosurface()}}
{\footnotesize\ttfamily bool igl\+::copyleft\+::cgal\+::signed\+\_\+distance\+\_\+isosurface (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{IV,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{IF,  }\item[{const double}]{level,  }\item[{const double}]{angle\+\_\+bound,  }\item[{const double}]{radius\+\_\+bound,  }\item[{const double}]{distance\+\_\+bound,  }\item[{const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}}}]{sign\+\_\+type,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F }\end{DoxyParamCaption})}



Compute the contour of an iso-\/level of the signed distance field to a given mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em IV} & \#\+IV by 3 list of input mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em IF} & \#\+IF by 3 list of input triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em level} & iso-\/level to contour in world coords, negative is inside. \\
\hline
\mbox{\texttt{ in}}  & {\em angle\+\_\+bound} & lower bound on triangle angles (mesh quality) (e.\+g. 28) \\
\hline
\mbox{\texttt{ in}}  & {\em radius\+\_\+bound} & upper bound on triangle size (mesh density?) (e.\+g. 0.\+02) \\
\hline
\mbox{\texttt{ in}}  & {\em distance\+\_\+bound} & cgal mysterious parameter (mesh density?) (e.\+g. 0.\+01) \\
\hline
\mbox{\texttt{ in}}  & {\em sign\+\_\+type} & method for computing distance {\itshape sign} (see ../signed\+\_\+distance.h) \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of input mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of input triangle indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if complex\+\_\+to\+\_\+mesh is successful 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a56339aee719b66761234276a14d7003f}\label{namespaceigl_1_1copyleft_1_1cgal_a56339aee719b66761234276a14d7003f} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!snap\_rounding@{snap\_rounding}}
\index{snap\_rounding@{snap\_rounding}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{snap\_rounding()}{snap\_rounding()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedE , typename Derived\+VI , typename Derived\+EI , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::snap\+\_\+rounding (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&}]{VI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EI $>$ \&}]{EI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Snap a list of possible intersecting segments with endpoints in any precision to {\itshape the} integer grid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of segment indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em VI} & \#\+VI by 2 list of output integer vertex positions, rounded copies of V are always the first \#V vertices \\
\hline
\mbox{\texttt{ out}}  & {\em EI} & \#\+EI by 2 list of segment indices into V, \#\+EI ≥ \#E \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+EI list of indices into E revealing \"{}parent segments\"{} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_ac105fc714db9b51b1c3945c51e6e5a19}\label{namespaceigl_1_1copyleft_1_1cgal_ac105fc714db9b51b1c3945c51e6e5a19} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!string\_to\_mesh\_boolean\_type@{string\_to\_mesh\_boolean\_type}}
\index{string\_to\_mesh\_boolean\_type@{string\_to\_mesh\_boolean\_type}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{string\_to\_mesh\_boolean\_type()}{string\_to\_mesh\_boolean\_type()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::copyleft\+::cgal\+::string\+\_\+to\+\_\+mesh\+\_\+boolean\+\_\+type (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s,  }\item[{\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \&}]{type }\end{DoxyParamCaption})}



Convert string to boolean type. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em s} & string identifying type, one of the following\+: \"{}union\"{},\"{}intersect\"{},\"{}minus\"{},\"{}xor\"{},\"{}resolve\"{} \\
\hline
\mbox{\texttt{ out}}  & {\em type} & type of boolean operation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only on success 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a5cb4ded3fe8818156a5f7c540d771835}\label{namespaceigl_1_1copyleft_1_1cgal_a5cb4ded3fe8818156a5f7c540d771835} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!string\_to\_mesh\_boolean\_type@{string\_to\_mesh\_boolean\_type}}
\index{string\_to\_mesh\_boolean\_type@{string\_to\_mesh\_boolean\_type}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{string\_to\_mesh\_boolean\_type()}{string\_to\_mesh\_boolean\_type()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} igl\+::copyleft\+::cgal\+::string\+\_\+to\+\_\+mesh\+\_\+boolean\+\_\+type (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Returns type without error handling \Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a347c87769a3b67d0bee379fb78705679}\label{namespaceigl_1_1copyleft_1_1cgal_a347c87769a3b67d0bee379fb78705679} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!subdivide\_segments@{subdivide\_segments}}
\index{subdivide\_segments@{subdivide\_segments}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{subdivide\_segments()}{subdivide\_segments()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedE , typename Kernel , typename Derived\+VI , typename Derived\+EI , typename DerivedJ , typename Derived\+IM $>$ \\
void igl\+::copyleft\+::cgal\+::subdivide\+\_\+segments (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const std\+::vector$<$ std\+::vector$<$ CGAL\+::\+Point\+\_\+2$<$ Kernel $>$ $>$ $>$ \&}]{steiner,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&}]{VI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EI $>$ \&}]{EI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IM $>$ \&}]{IM }\end{DoxyParamCaption})}



Insert steiner points to subdivide a given set of line segments. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of segment indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em steiner} & \#E list of lists of unsorted steiner points (including endpoints) along the \#E original segments \\
\hline
\mbox{\texttt{ out}}  & {\em VI} & \#\+VI by 2 list of output vertex positions, copies of V are always the first \#V vertices \\
\hline
\mbox{\texttt{ out}}  & {\em EI} & \#\+EI by 2 list of segment indices into V, \#\+EI ≥ \#E \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+EI list of indices into E revealing \"{}parent segments\"{} \\
\hline
\mbox{\texttt{ out}}  & {\em IM} & \#\+VI list of indices into VV of unique vertices. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a3b5cc8bbbcee4ed4567bc754a4e939c0}\label{namespaceigl_1_1copyleft_1_1cgal_a3b5cc8bbbcee4ed4567bc754a4e939c0} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!submesh\_aabb\_tree@{submesh\_aabb\_tree}}
\index{submesh\_aabb\_tree@{submesh\_aabb\_tree}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{submesh\_aabb\_tree()}{submesh\_aabb\_tree()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Kernel $>$ \\
void igl\+::copyleft\+::cgal\+::submesh\+\_\+aabb\+\_\+tree (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{CGAL\+::\+AABB\+\_\+tree$<$ CGAL\+::\+AABB\+\_\+traits$<$ Kernel, CGAL\+::\+AABB\+\_\+triangle\+\_\+primitive$<$ Kernel, typename std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$\+::iterator $>$ $>$ $>$ \&}]{tree,  }\item[{std\+::vector$<$ typename Kernel\+::\+Triangle\+\_\+3 $>$ \&}]{triangles,  }\item[{std\+::vector$<$ bool $>$ \&}]{in\+\_\+I }\end{DoxyParamCaption})}



Build an \doxylink{classigl_1_1AABB}{AABB} tree for a submesh indicated by a face selection list I of a full mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 array of vertices. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 array of faces. \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of triangle indices to consider. \\
\hline
\mbox{\texttt{ out}}  & {\em tree} & aabb containing triangles of (V,F(\+I,\+:)) \\
\hline
\mbox{\texttt{ out}}  & {\em triangles} & \#I list of cgal triangles \\
\hline
\mbox{\texttt{ out}}  & {\em in\+\_\+I} & \#F list of whether in submesh \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a745c9671e98e82bb4f285b028c1aa8c9}\label{namespaceigl_1_1copyleft_1_1cgal_a745c9671e98e82bb4f285b028c1aa8c9} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!triangle\_triangle\_squared\_distance@{triangle\_triangle\_squared\_distance}}
\index{triangle\_triangle\_squared\_distance@{triangle\_triangle\_squared\_distance}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_squared\_distance()}{triangle\_triangle\_squared\_distance()}}
{\footnotesize\ttfamily template$<$typename Kernel $>$ \\
bool igl\+::copyleft\+::cgal\+::triangle\+\_\+triangle\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&}]{T1,  }\item[{const CGAL\+::\+Triangle\+\_\+3$<$ Kernel $>$ \&}]{T2,  }\item[{CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P1,  }\item[{CGAL\+::\+Point\+\_\+3$<$ Kernel $>$ \&}]{P2,  }\item[{typename Kernel\+::\+FT \&}]{d }\end{DoxyParamCaption})}



Given two triangles T1 and T2 find the points on each of closest approach and the squared distance thereof. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T1} & first triangle \\
\hline
\mbox{\texttt{ in}}  & {\em T2} & second triangle \\
\hline
\mbox{\texttt{ out}}  & {\em P1} & point on T1 closest to T2 \\
\hline
\mbox{\texttt{ out}}  & {\em P2} & point on T2 closest to T1 \\
\hline
\mbox{\texttt{ out}}  & {\em d} & distance betwee P1 and T2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the closest approach is unique. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a2c5d9c112aaddddfc00781eb000fddd4}\label{namespaceigl_1_1copyleft_1_1cgal_a2c5d9c112aaddddfc00781eb000fddd4} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!triangulate@{triangulate}}
\index{triangulate@{triangulate}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{triangulate()}{triangulate()}}
{\footnotesize\ttfamily template$<$typename Kernel , typename DerivedV , typename DerivedE , typename DerivedH , typename Derived\+V2 , typename Derived\+F2 $>$ \\
void igl\+::copyleft\+::cgal\+::triangulate (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedH $>$ \&}]{H,  }\item[{const bool}]{retain\+\_\+convex\+\_\+hull,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V2 $>$ \&}]{V2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F2 $>$ \&}]{F2 }\end{DoxyParamCaption})}



Triangulate the interior of a polygon using CGAL. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of 2D vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of vertex ids forming unoriented edges of the boundary of the polygon \\
\hline
\mbox{\texttt{ in}}  & {\em H} & \#H by 2 coordinates of points contained inside holes of the polygon \\
\hline
\mbox{\texttt{ in}}  & {\em retain\+\_\+convex\+\_\+hull} & whether to retain convex hull \{true\} or trim away all faces reachable from infinite by traversing across non-\/constrained edges \{false\}. \{true → \"{}c\"{} flag in {\ttfamily triangle}\} \\
\hline
\mbox{\texttt{ out}}  & {\em V2} & \#\+V2 by 2 coordinates of the vertives of the generated triangulation \\
\hline
\mbox{\texttt{ out}}  & {\em F2} & \#\+F2 by 3 list of indices forming the faces of the generated triangulation\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1triangle_ae4d5a5fa0ad34c41ec9e3361be3f249a}{igl\+::triangle\+::triangulate} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a6dca57f7cfcb9b65b561d5d3ccec99be}\label{namespaceigl_1_1copyleft_1_1cgal_a6dca57f7cfcb9b65b561d5d3ccec99be} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!trim\_with\_solid@{trim\_with\_solid}}
\index{trim\_with\_solid@{trim\_with\_solid}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{trim\_with\_solid()}{trim\_with\_solid()}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename DerivedV , typename DerivedF , typename DerivedD , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::trim\+\_\+with\+\_\+solid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{Vd,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Given an arbitrary mesh (VA,FA) and the boundary mesh (VB,FB) of a solid (as defined in \mbox{[}Zhou et al. 

2016\mbox{]}), Resolve intersections between A and B subdividing faces of A so that intersections with B exists only along edges and vertices (and coplanar faces). Then determine whether each of these faces is inside or outside of B. This can be used to extract the part of A inside or outside of B.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VA} & \#\+VA by 3 list of mesh vertex positions of A \\
\hline
\mbox{\texttt{ in}}  & {\em FA} & \#\+FA by 3 list of mesh triangle indices into VA \\
\hline
\mbox{\texttt{ in}}  & {\em VB} & \#\+VB by 3 list of mesh vertex positions of B \\
\hline
\mbox{\texttt{ in}}  & {\em FB} & \#\+FB by 3 list of mesh triangle indices into VB \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of mesh vertex positions of output \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#F list of bools whether face is inside B \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#F list of indices into FA revealing birth parent \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a1da8adecc2e7b09a987748532fb975d2}\label{namespaceigl_1_1copyleft_1_1cgal_a1da8adecc2e7b09a987748532fb975d2} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!wire\_mesh@{wire\_mesh}}
\index{wire\_mesh@{wire\_mesh}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{wire\_mesh()}{wire\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+WV , typename Derived\+WE , typename Derivedth , typename DerivedV , typename DerivedF , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::wire\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+WV $>$ \&}]{WV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+WE $>$ \&}]{WE,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedth $>$ \&}]{th,  }\item[{const int}]{poly\+\_\+size,  }\item[{const bool}]{solid,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Construct a \"{}wire\"{} or \"{}wireframe\"{} or \"{}strut\"{} surface mesh, given a one-\/dimensional network of straight edges. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em WV} & \#\+WV by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em WE} & \#\+WE by 2 list of edge indices into WV \\
\hline
\mbox{\texttt{ in}}  & {\em th} & \#\+WE diameter thicknesses of wire edges \\
\hline
\mbox{\texttt{ in}}  & {\em poly\+\_\+size} & number of sides on each wire (e.\+g., 4 would produce wires by connecting rectangular prisms). \\
\hline
\mbox{\texttt{ in}}  & {\em solid} & whether to resolve self-\/intersections to create a \"{}solid\"{} output mesh (cf., \mbox{[}Zhou et al. 2016\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of output vertices \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of output triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#F list of indices into \mbox{[}0,\#\+WV+\#\+WE) revealing \"{}birth simplex\"{} of output faces J(j) \texorpdfstring{$<$}{<} \#\+WV means the face corresponds to the J(j)th vertex in WV. J(j) \texorpdfstring{$>$}{>}= \#\+WV means the face corresponds to the (J(j)-\/\#\+WV)th edge in WE. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a7dc5cdc053c1f25a930d46be790a7c74}\label{namespaceigl_1_1copyleft_1_1cgal_a7dc5cdc053c1f25a930d46be790a7c74} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!wire\_mesh@{wire\_mesh}}
\index{wire\_mesh@{wire\_mesh}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{wire\_mesh()}{wire\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+WV , typename Derived\+WE , typename DerivedV , typename DerivedF , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::wire\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+WV $>$ \&}]{WV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+WE $>$ \&}]{WE,  }\item[{const double}]{th,  }\item[{const int}]{poly\+\_\+size,  }\item[{const bool}]{solid,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

uniform th \Hypertarget{namespaceigl_1_1copyleft_1_1cgal_a88a350d009b191ea77e7bb454a2936d7}\label{namespaceigl_1_1copyleft_1_1cgal_a88a350d009b191ea77e7bb454a2936d7} 
\index{igl::copyleft::cgal@{igl::copyleft::cgal}!wire\_mesh@{wire\_mesh}}
\index{wire\_mesh@{wire\_mesh}!igl::copyleft::cgal@{igl::copyleft::cgal}}
\doxysubsubsection{\texorpdfstring{wire\_mesh()}{wire\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+WV , typename Derived\+WE , typename DerivedV , typename DerivedF , typename DerivedJ $>$ \\
void igl\+::copyleft\+::cgal\+::wire\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+WV $>$ \&}]{WV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+WE $>$ \&}]{WE,  }\item[{const double}]{th,  }\item[{const int}]{poly\+\_\+size,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Solid == true 