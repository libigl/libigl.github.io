\doxysection{igl Namespace Reference}
\hypertarget{namespaceigl}{}\label{namespaceigl}\index{igl@{igl}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1copyleft}{copyleft}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1embree}{embree}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1matlab}{matlab}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1mosek}{mosek}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1opengl}{opengl}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1predicates}{predicates}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1serialization}{serialization}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1spectra}{spectra}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1stb}{stb}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1triangle}{triangle}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1xml}{xml}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classigl_1_1AABB}{AABB}}
\begin{DoxyCompactList}\small\item\em Implementation of semi-\/general purpose axis-\/aligned bounding box hierarchy. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1active__set__params}{active\+\_\+set\+\_\+params}}
\begin{DoxyCompactList}\small\item\em Input parameters controling active\+\_\+set. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1ARAPData}{ARAPData}}
\begin{DoxyCompactList}\small\item\em Parameters and precomputed values for arap solver. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}
\begin{DoxyCompactList}\small\item\em Structure that contains fields for all precomputed data or data that needs to be remembered at update. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1AtA__cached__data}{At\+A\+\_\+cached\+\_\+data}}
\begin{DoxyCompactList}\small\item\em Hold precomputed data for At\+A\+\_\+cached. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1BBWData}{BBWData}}
\begin{DoxyCompactList}\small\item\em Container for BBW computation related data and flags. \end{DoxyCompactList}\item 
struct {\bfseries Fast\+Winding\+Number\+BVH}
\begin{DoxyCompactList}\small\item\em Structure for caching precomputation for fast winding number for triangle soups. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1FileMemoryBuffer}{File\+Memory\+Buffer}}
\item 
struct \mbox{\hyperlink{structigl_1_1FileMemoryStream}{File\+Memory\+Stream}}
\begin{DoxyCompactList}\small\item\em Class to convert a FILE \texorpdfstring{$\ast$}{*} to an std\+::istream. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1HalfEdgeIterator}{Half\+Edge\+Iterator}}
\begin{DoxyCompactList}\small\item\em Fake halfedge for fast and easy navigation on triangle meshes with vertex\+\_\+triangle\+\_\+adjacency and triangle\+\_\+triangle adjacency. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}
\begin{DoxyCompactList}\small\item\em Precomputation data for heat\+\_\+geodesics\+\_\+solve. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1Hit}{Hit}}
\begin{DoxyCompactList}\small\item\em Reimplementation of the embree\+::\+Hit struct from embree1.\+0. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1IndexDimLessThan}{Index\+Dim\+Less\+Than}}
\begin{DoxyCompactList}\small\item\em Comparison struct for use with functions like std\+::sort. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1IndexedPointer}{Indexed\+Pointer}}
\item 
struct \mbox{\hyperlink{structigl_1_1IndexedPointerBase}{Indexed\+Pointer\+Base}}
\item 
struct \mbox{\hyperlink{structigl_1_1IndexEquals}{Index\+Equals}}
\begin{DoxyCompactList}\small\item\em Comparison struct used by unique. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1IndexLessThan}{Index\+Less\+Than}}
\begin{DoxyCompactList}\small\item\em Comparison struct used by sort \href{http://bytes.com/topic/c/answers/132045-sort-get-index}{\texttt{ http\+://bytes.\+com/topic/c/answers/132045-\/sort-\/get-\/index}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1IndexRowEquals}{Index\+Row\+Equals}}
\begin{DoxyCompactList}\small\item\em Comparison struct for use with functions like std\+::sort. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1IndexRowLessThan}{Index\+Row\+Less\+Than}}
\begin{DoxyCompactList}\small\item\em Comparison struct For use with functions like std\+::sort. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1IndexVectorLessThan}{Index\+Vector\+Less\+Than}}
\begin{DoxyCompactList}\small\item\em Comparison struct for vectors for use with functions like std\+::sort. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1KelvinletParams}{Kelvinlet\+Params}}
\begin{DoxyCompactList}\small\item\em Parameters for controling kelvinlets. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}
\begin{DoxyCompactList}\small\item\em Parameters and precomputed values for min\+\_\+quad\+\_\+with\+\_\+fixed. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1MshLoader}{Msh\+Loader}}
\begin{DoxyCompactList}\small\item\em Class for loading information from .msh file depends only on c++stl library. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1MshSaver}{Msh\+Saver}}
\begin{DoxyCompactList}\small\item\em Class for dumping information to .msh file depends only on c++stl library current implementation works only with 3D information. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1Serializable}{Serializable}}
\item 
struct \mbox{\hyperlink{structigl_1_1SerializableBase}{Serializable\+Base}}
\item 
struct \mbox{\hyperlink{structigl_1_1ShapeupData}{Shapeup\+Data}}
\begin{DoxyCompactList}\small\item\em Parameters and precomputed data for Shape\+Up. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1SLIMData}{SLIMData}}
\begin{DoxyCompactList}\small\item\em Parameters and precomputed data for computing a SLIM map as derived in "{}\+Scalable Locally Injective Maps"{} \mbox{[}Rabinovich et al. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1SortableRow}{Sortable\+Row}}
\begin{DoxyCompactList}\small\item\em A row of things that can be sorted against other rows. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1Timer}{Timer}}
\begin{DoxyCompactList}\small\item\em Simple timer class. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1WindingNumberAABB}{Winding\+Number\+AABB}}
\begin{DoxyCompactList}\small\item\em Class for building an \doxylink{classigl_1_1AABB}{AABB} tree to implement the divide and conquer algorithm described in \mbox{[}Jacobson et al. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1WindingNumberTree}{Winding\+Number\+Tree}}
\begin{DoxyCompactList}\small\item\em Space partitioning tree for computing winding number hierarchically. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} = std\+::function$<$ void(const int, const Eigen\+::\+Matrix\+Xd \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, double \&, Eigen\+::\+Row\+Vector\+Xd \&)$>$
\begin{DoxyCompactList}\small\item\em Function handle used to control the cost of each edge collapse in \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} = std\+::function$<$ bool(const Eigen\+::\+Matrix\+Xd \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xd \&, const int, const int, const int, const int, const int)$>$
\begin{DoxyCompactList}\small\item\em Function handle used to control whether the queue processing in \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate} should stop. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} = std\+::function$<$ bool(const Eigen\+::\+Matrix\+Xd \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xd \&, const int)$>$
\begin{DoxyCompactList}\small\item\em Function handle called just before {\ttfamily collapse\+\_\+edge} is attempted. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} = std\+::function$<$ void(const Eigen\+::\+Matrix\+Xd \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xd \&, const int, const int, const int, const int, const int, const bool)$>$
\begin{DoxyCompactList}\small\item\em Function handle called just after {\ttfamily collapse\+\_\+edge} is attempted. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespaceigl_a60bbc303acee156af52ab587c4680502}{DEFAULT\+\_\+\+URBG}} = std\+::mt19937
\item 
{\footnotesize template$<$class T $>$ }\\using \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{min\+\_\+heap}} = std\+::priority\+\_\+queue$<$ T, std\+::vector$<$ T $>$, std\+::greater$<$ T $>$ $>$
\begin{DoxyCompactList}\small\item\em Templated min heap (reverses sort order of std\+::priority\+\_\+queue) \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespaceigl_af2b7710824b3b35bfcda5dd2d5c723f5}{shapeup\+\_\+projection\+\_\+function}} = std\+::function$<$ bool(const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&, const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Vector\+Xi $>$ \&, const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xi $>$ \&, Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&)$>$
\begin{DoxyCompactList}\small\item\em Every function here defines a local projection for Shape\+Up, and must have the following structure to qualify\+: \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{ARAPEnergy\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a97e873f2663a9aceb16484fb07de5ff5}{ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+SPOKES}} = 0
, \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a5f5f83bb36e2e299284c9a95ed2ff961}{ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+SPOKES\+\_\+\+AND\+\_\+\+RIMS}} = 1
, \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5af2f155e8dfb975ad92b08f029e49a150}{ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+ELEMENTS}} = 2
, \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a0ab35acc294ac22e4f4d125fce81bb2e}{ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+DEFAULT}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a9a04adfc9ec2f8a964e26ee1e79e192d}{NUM\+\_\+\+ARAP\+\_\+\+ENERGY\+\_\+\+TYPES}} = 4
 \}
\begin{DoxyCompactList}\small\item\em Enum for choosing ARAP energy type. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa6825c15830b7858ad1cae2b2ca8fdf04}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+INFERNO}} = 0
, \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaab42bc8bb5154a66ce55adfc8a55ca23b}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+JET}} = 1
, \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa2f48b6200837d4a9504dc985d9555a43}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+MAGMA}} = 2
, \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa34771169730e68f97bd795796088a1bd}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+PARULA}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa02ba4c2ca7ae86203e286cc7e7681be8}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+PLASMA}} = 4
, \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaac0949b6bec17c57dae985f9945f0ba87}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+VIRIDIS}} = 5
, \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa215964e6083ae591d01d8fc75696b7e4}{COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+TURBO}} = 6
, \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa6fe9ac780033d4a02584149c2079171f}{NUM\+\_\+\+COLOR\+\_\+\+MAP\+\_\+\+TYPES}} = 7
 \}
\item 
enum \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50d}{Eigs\+Type}} \{ \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50da2b8b23d6ed6bab31827ce232b5c4b753}{EIGS\+\_\+\+TYPE\+\_\+\+SM}} = 0
, \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50daea338bf4c5326fb6e1534be0d2d8c3ff}{EIGS\+\_\+\+TYPE\+\_\+\+LM}} = 1
, \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50dad803c6fe03f39ed4ef76376e6ba1d2c2}{NUM\+\_\+\+EIGS\+\_\+\+TYPES}} = 2
 \}
\begin{DoxyCompactList}\small\item\em Type of eigen values to extract. \end{DoxyCompactList}\item 
enum class \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} \{ \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa6ce976e8f061b2b5cfe4d0c50c3405dd}{Binary}}
, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{Ascii}}
 \}
\begin{DoxyCompactList}\small\item\em File encoding types for writing files. \end{DoxyCompactList}\item 
enum class \mbox{\hyperlink{namespaceigl_a69c0d149c7cb41a263f858b695eeb988}{Brush\+Type}} \+: int \{ \mbox{\hyperlink{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a8695c57e30e957161af26fe52d8a5826}{GRAB}}
, \mbox{\hyperlink{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a127ea1d20becc4dba06d9d152db0c2e5}{SCALE}}
, \mbox{\hyperlink{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a7d503f3470adcef7d9b24cdfa82ea1c1}{TWIST}}
, \mbox{\hyperlink{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a1519953796ab374eeab96e42a849ed19}{PINCH}}
 \}
\begin{DoxyCompactList}\small\item\em Kelvinlets brush type. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{Mapping\+Energy\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739ad4c5e62ae2264ce291d4d66fa3603d72}{ARAP}} = 0
, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739ac7e97754f63944f8a1abcd0157df2c24}{LOG\+\_\+\+ARAP}} = 1
, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a4aaaa0e435526b23bf5f26cfbb5c03b9}{SYMMETRIC\+\_\+\+DIRICHLET}} = 2
, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a83bccae0282cd84b5ae8c0d260ae7243}{CONFORMAL}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a26c394b5336e61022324d35b9c070a9b}{EXP\+\_\+\+CONFORMAL}} = 4
, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a265347b4667fbc30a911bb0be708072f}{EXP\+\_\+\+SYMMETRIC\+\_\+\+DIRICHLET}} = 5
, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739abcbff3ae074247ae8998591317528163}{NUM\+\_\+\+SLIM\+\_\+\+ENERGY\+\_\+\+TYPES}} = 6
 \}
\begin{DoxyCompactList}\small\item\em Energy Types used for Parameterization/\+Mapping. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90ad236264764d4f478ccb31c36be553483}{MASSMATRIX\+\_\+\+TYPE\+\_\+\+BARYCENTRIC}} = 0
, \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a8e91d83387a6cdc5e1c58d3249ed8484}{MASSMATRIX\+\_\+\+TYPE\+\_\+\+VORONOI}} = 1
, \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90aa3067b3f2630f50a9806bf46b60e6fb7}{MASSMATRIX\+\_\+\+TYPE\+\_\+\+FULL}} = 2
, \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a69f57abe461a4a62943a5c38cbbf22f0}{MASSMATRIX\+\_\+\+TYPE\+\_\+\+DEFAULT}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a90c5b05e42d20ca21fd5849e64bae2ae}{NUM\+\_\+\+MASSMATRIX\+\_\+\+TYPES}} = 4
 \}
\begin{DoxyCompactList}\small\item\em Type of mass matrix. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{Mesh\+Boolean\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+UNION}} = 0
, \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+INTERSECT}} = 1
, \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+MINUS}} = 2
, \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+XOR}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708}{MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+RESOLVE}} = 4
, \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9fadbaeed658c3fa4c89de4dc951cb9cff9}{NUM\+\_\+\+MESH\+\_\+\+BOOLEAN\+\_\+\+TYPES}} = 5
 \}
\begin{DoxyCompactList}\small\item\em Boolean operation types. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8}{Normal\+Type}} \{ \mbox{\hyperlink{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8af907c6f40997626d2c36a67963c8431d}{PER\+\_\+\+VERTEX\+\_\+\+NORMALS}}
, \mbox{\hyperlink{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8a17cf07533db59fd90e513a7d89d40664}{PER\+\_\+\+FACE\+\_\+\+NORMALS}}
, \mbox{\hyperlink{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8a5c44ccab7f461834b6ecc16928196627}{PER\+\_\+\+CORNER\+\_\+\+NORMALS}}
 \}
\begin{DoxyCompactList}\small\item\em Type of mesh normal computation method. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55}{Per\+Edge\+Normals\+Weighting\+Type}} \{ \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55a832e9d6bd24abeb23b15bc815c888fe9}{PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+UNIFORM}} = 0
, \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55a2822a9a485d6d667e1fc7eb6a9e3788c}{PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+AREA}} = 1
, \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55a545aa62c3fac5887f2a8a939af47395c}{PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+DEFAULT}} = 2
, \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55a163eb96bb83248476c499a06d08c7630}{NUM\+\_\+\+PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE}} = 3
 \}
\begin{DoxyCompactList}\small\item\em Weighting schemes for per edge normals. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}{Per\+Vertex\+Normals\+Weighting\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a221b3f6444f4194512508cce2c89d605}{PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+UNIFORM}} = 0
, \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a6f6afda8e7e65ddb0214f4bf4fe9d714}{PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+AREA}} = 1
, \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a3929a73f6d85de3ab2e7f61c4c569f8d}{PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+ANGLE}} = 2
, \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a8384f77b5ce9bc68e6ed0c9dac5520f8}{PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+DEFAULT}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94ae39893168b9c7f1fb96cbe18aabcaf90}{NUM\+\_\+\+PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE}} = 4
 \}
\begin{DoxyCompactList}\small\item\em Weighting schemes for computing per-\/vertex normals. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}} \{ \newline
\mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02eac0557ab91e577c1b1f918891b6b3a9ce}{SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+PSEUDONORMAL}} = 0
, \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea2d092ad20bad8b2e4d6b015e0f64d5c8}{SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+WINDING\+\_\+\+NUMBER}} = 1
, \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea53947827c1a799002057e5dc4ffe3a6e}{SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+DEFAULT}} = 2
, \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea3455ee3fba0a6898acccb895b94003ae}{SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+UNSIGNED}} = 3
, \newline
\mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea840c3ff04b4ec159043f1c6168ad383d}{SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+FAST\+\_\+\+WINDING\+\_\+\+NUMBER}} = 4
, \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea5ba484850e00fd63057bf36e540ffe57}{NUM\+\_\+\+SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE}} = 5
 \}
\begin{DoxyCompactList}\small\item\em Types of signing a distance field. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2}{Solver\+Status}} \{ \mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aefd03ba8a40ae92dd30b9608543d723a}{SOLVER\+\_\+\+STATUS\+\_\+\+CONVERGED}} = 0
, \mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2a59f8eece563fe4ae6e55c2363f349322}{SOLVER\+\_\+\+STATUS\+\_\+\+MAX\+\_\+\+ITER}} = 1
, \mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aea9aaec839ab7074d95b32649f9a7ccc}{SOLVER\+\_\+\+STATUS\+\_\+\+ERROR}} = 2
, \mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aea329543d3b14ae5d7df63289014df41}{NUM\+\_\+\+SOLVER\+\_\+\+STATUSES}} = 3
 \}
\begin{DoxyCompactList}\small\item\em Solver status type used by min\+\_\+quad\+\_\+with\+\_\+fixed. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}{Tetrahedralized\+Grip\+Type}} \{ \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a6c9f3915cd235c5f5d9ec1f849c4f45a}{TETRAHEDRALIZED\+\_\+\+GRID\+\_\+\+TYPE\+\_\+5}} = 0
, \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a0f009090a25fab927bfc17ed8c95ccf7}{TETRAHEDRALIZED\+\_\+\+GRID\+\_\+\+TYPE\+\_\+6\+\_\+\+ROTATIONAL}} = 1
, \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a4945d263c917ea6178567ad57cedddd6}{NUM\+\_\+\+TETRAHEDRALIZED\+\_\+\+GRID\+\_\+\+TYPE}} = 2
 \}
\begin{DoxyCompactList}\small\item\em Types of tetrahedralizations of a cubical cell. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecf}{Winding\+Number\+Method}} \{ \mbox{\hyperlink{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfaa10945b526da7066079013ebe7efa315}{EXACT\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHOD}} = 0
, \mbox{\hyperlink{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa0d9a88899ed0568e9ea92020c2202c90}{APPROX\+\_\+\+SIMPLE\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHOD}} = 1
, \mbox{\hyperlink{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa8a0f3017839d2e66a55fabbd269bff19}{APPROX\+\_\+\+CACHE\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHOD}} = 2
, \mbox{\hyperlink{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa3d5ef75b451374bbaa7aecc358a66558}{NUM\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHODS}} = 3
 \}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename DerivedS , typename DerivedV , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_a8012b0115ea55d7e1ef308d01a37d65c}{accumarray}} (const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Accumulate values in V using subscripts in S. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_aa6380cf19be5242826791dfb3b26b113}{accumarray}} (const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+A\+::\+Scalar V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Accumulate constant value {\ttfamily V} using subscripts in S. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AT , typename DerivedB , typename Derivedknown , typename DerivedY , typename AeqT , typename Derived\+Beq , typename AieqT , typename Derived\+Bieq , typename Derivedlx , typename Derivedux , typename DerivedZ $>$ }\\\mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2}{igl\+::\+Solver\+Status}} \mbox{\hyperlink{namespaceigl_aebbfd2ea11fa90111a31666f48cc5f00}{active\+\_\+set}} (const Eigen\+::\+Sparse\+Matrix$<$ AT $>$ \&A, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedknown $>$ \&known, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, const Eigen\+::\+Sparse\+Matrix$<$ AeqT $>$ \&Aeq, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Beq $>$ \&Beq, const Eigen\+::\+Sparse\+Matrix$<$ AieqT $>$ \&Aieq, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Bieq $>$ \&Bieq, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedlx $>$ \&lx, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedux $>$ \&ux, const \mbox{\hyperlink{structigl_1_1active__set__params}{igl\+::active\+\_\+set\+\_\+params}} \&params, Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&Z)
\begin{DoxyCompactList}\small\item\em Minimize convex quadratic energy subject to linear inequality constraints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index , typename Index\+Vector $>$ }\\void \mbox{\hyperlink{namespaceigl_a4c905c0e9124bb38a79769497fa9b48b}{adjacency\+\_\+list}} (const Eigen\+::\+Matrix\+Base$<$ Index $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index\+Vector $>$ $>$ \&A, bool sorted=false)
\begin{DoxyCompactList}\small\item\em Constructs the graph adjacency list of a given mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_a3b938bdb46eece91f62ab35a1e152a61}{adjacency\+\_\+list}} (const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&A)
\begin{DoxyCompactList}\small\item\em Constructs the graph adjacency list of a given {\itshape polygon} mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a705a8f51137d1dd807bbe517c0567735}{adjacency\+\_\+matrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A)
\begin{DoxyCompactList}\small\item\em Constructs the graph adjacency matrix of a given mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedI , typename DerivedC , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a9b6ba9089b88d1e5ba18a153462c750c}{adjacency\+\_\+matrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A)
\begin{DoxyCompactList}\small\item\em Constructs an vertex adjacency for a polygon mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}{all}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Check whether all values are logically true along a dimension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mat $>$ }\\void \mbox{\hyperlink{namespaceigl_ad119e257b19a34797c3c9af92d7cc56b}{all\+\_\+pairs\+\_\+distances}} (const Mat \&V, const Mat \&U, const bool squared, Mat \&D)
\begin{DoxyCompactList}\small\item\em Compute distances between each point i in V and point j in U. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedN , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_acc5e79a82d06f353e2cc7364bb63d6ec}{ambient\+\_\+occlusion}} (const std\+::function$<$ bool(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&) $>$ \&shoot\+\_\+ray, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Compute ambient occlusion per given point using ray-\/mesh intersection function handle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a8e5409ff272904057655baa541161f63}{ambient\+\_\+occlusion}} (const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ DerivedV, DIM $>$ \&aabb, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Compute ambient occlusion per given point for mesh (V,F) with precomputed \doxylink{classigl_1_1AABB}{AABB} tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a9892f183be30982954280fde853dd8f3}{ambient\+\_\+occlusion}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Compute ambient occlusion per given point for mesh (V,F) \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespaceigl_a2267549a29a1b490b0b2f56b6ec84ef6}{angular\+\_\+distance}} (const Eigen\+::\+Quaterniond \&A, const Eigen\+::\+Quaterniond \&B)
\begin{DoxyCompactList}\small\item\em The "{}angular distance"{} between two unit quaternions is the angle of the smallest rotation (treated as an Axis and Angle) that takes A to B. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_a8b265abd1563e69c5b980e38f0eff3b9}{any}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Check whether any values are logically true along a dimension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedb $>$ }\\bool \mbox{\hyperlink{namespaceigl_a48e5f486e14127dc6eb9013a7dc312bd}{arap\+\_\+precomputation}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int dim, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, \mbox{\hyperlink{structigl_1_1ARAPData}{ARAPData}} \&data)
\begin{DoxyCompactList}\small\item\em Compute necessary information to start using an ARAP deformation using local-\/global solver as described in "{}\+As-\/rigid-\/as-\/possible surface modeling"{} \mbox{[}Sorkine and Alexa 2007\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedbc , typename DerivedU $>$ }\\bool \mbox{\hyperlink{namespaceigl_a62a45ef9782fe4b54d7487a8b3bb45e9}{arap\+\_\+solve}} (const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, \mbox{\hyperlink{structigl_1_1ARAPData}{ARAPData}} \&data, Eigen\+::\+Matrix\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em Conduct arap solve. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Lbs\+Matrix\+Type , typename SSCALAR $>$ }\\bool \mbox{\hyperlink{namespaceigl_a26233fdaaff7c535c5cf9e54d58f6f80}{arap\+\_\+dof\+\_\+precomputation}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const Lbs\+Matrix\+Type \&M, const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&G, \mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}$<$ Lbs\+Matrix\+Type, SSCALAR $>$ \&data)
\begin{DoxyCompactList}\small\item\em Precomputes the system to optimize for "{}\+Fast Automatic Skinning \+Transformations"{} \mbox{[}Jacobson et al. 2012\mbox{]} skinning degrees of freedom optimization using as-\/rigid-\/as-\/possible energy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Lbs\+Matrix\+Type , typename SSCALAR $>$ }\\bool \mbox{\hyperlink{namespaceigl_acec31e2faca7eecae08c921a0430d0aa}{arap\+\_\+dof\+\_\+recomputation}} (const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&fixed\+\_\+dim, const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&A\+\_\+eq, \mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}$<$ Lbs\+Matrix\+Type, SSCALAR $>$ \&data)
\begin{DoxyCompactList}\small\item\em Should always be called after arap\+\_\+dof\+\_\+precomputation, but may be called in between successive calls to arap\+\_\+dof\+\_\+update, recomputes precomputation given that there are only changes in free and fixed. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Lbs\+Matrix\+Type , typename SSCALAR $>$ }\\bool \mbox{\hyperlink{namespaceigl_a31279c751ae3a7d24bc56dd4c8029d1e}{arap\+\_\+dof\+\_\+update}} (const \mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}$<$ Lbs\+Matrix\+Type, SSCALAR $>$ \&data, const Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, 1 $>$ \&B\+\_\+eq, const Eigen\+::\+Matrix\+Xd \&L0, const int max\+\_\+iters, const double tol, Eigen\+::\+Matrix\+Xd \&L)
\begin{DoxyCompactList}\small\item\em Optimizes the transformations attached to each weight function based on precomputed system. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF , typename MatK $>$ }\\void \mbox{\hyperlink{namespaceigl_ae1324ec871ee5fe0f3d6fa9b461ced93}{arap\+\_\+linear\+\_\+block}} (const MatV \&V, const MatF \&F, const int d, const \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{igl\+::\+ARAPEnergy\+Type}} energy, MatK \&Kd)
\begin{DoxyCompactList}\small\item\em Constructs a block of the matrix which constructs the linear terms of a given arap energy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF , typename MatK $>$ }\\void \mbox{\hyperlink{namespaceigl_ad13e109be700043c1228c300bac31daf}{arap\+\_\+linear\+\_\+block\+\_\+spokes}} (const MatV \&V, const MatF \&F, const int d, MatK \&Kd)
\begin{DoxyCompactList}\small\item\em Constructs a block of the matrix which constructs the linear terms for spokes energy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF , typename MatK $>$ }\\void \mbox{\hyperlink{namespaceigl_a7280d256cac58af8c0dceb1e0ab487ca}{arap\+\_\+linear\+\_\+block\+\_\+spokes\+\_\+and\+\_\+rims}} (const MatV \&V, const MatF \&F, const int d, MatK \&Kd)
\begin{DoxyCompactList}\small\item\em Constructs a block of the matrix which constructs the linear terms for spokes and rims energy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF , typename MatK $>$ }\\void \mbox{\hyperlink{namespaceigl_af81355594a143ab2601ce468536c0112}{arap\+\_\+linear\+\_\+block\+\_\+elements}} (const MatV \&V, const MatF \&F, const int d, MatK \&Kd)
\begin{DoxyCompactList}\small\item\em Constructs a block of the matrix which constructs the linear terms for per element energy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_a02a8f8a4c016647d6f9c823ae3e32eaa}{arap\+\_\+rhs}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int dim, const \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{igl\+::\+ARAPEnergy\+Type}} energy, Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Right-\/hand side constructor of global poisson solve for various Arap energies. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a2fde5a5b34007efccb521fd4f571f153}{At\+A\+\_\+cached\+\_\+precompute}} (const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&A, \mbox{\hyperlink{structigl_1_1AtA__cached__data}{At\+A\+\_\+cached\+\_\+data}} \&data, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&AtA)
\begin{DoxyCompactList}\small\item\em Computes At \texorpdfstring{$\ast$}{*} W \texorpdfstring{$\ast$}{*} A, where A is sparse and W is diagonal. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_ac62e1e593efb31faa3ecb727695f3e53}{At\+A\+\_\+cached}} (const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&A, const \mbox{\hyperlink{structigl_1_1AtA__cached__data}{At\+A\+\_\+cached\+\_\+data}} \&data, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&AtA)
\begin{DoxyCompactList}\small\item\em Computes At \texorpdfstring{$\ast$}{*} W \texorpdfstring{$\ast$}{*} A, where A is sparse and W is diagonal precomputed into data. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DerivedoE , typename DeriveduE , typename DeriveduV $>$ }\\void \mbox{\hyperlink{namespaceigl_a7cb9891e472fd984b8e86dfc5b7a279c}{average\+\_\+from\+\_\+edges\+\_\+onto\+\_\+vertices}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&oE, const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduV $>$ \&uV)
\begin{DoxyCompactList}\small\item\em Move a scalar field defined on edges to vertices by averaging. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedS , typename Derived\+SF $>$ }\\void \mbox{\hyperlink{namespaceigl_ac457ea2c4e31fec1d7a3855fefb0260d}{average\+\_\+onto\+\_\+faces}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF)
\begin{DoxyCompactList}\small\item\em Move a scalar field defined on vertices to faces by averaging. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedS , typename Derived\+SV $>$ }\\void \mbox{\hyperlink{namespaceigl_ac14f50dc6ec911af71c62d6c187fe3c2}{average\+\_\+onto\+\_\+vertices}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV)
\begin{DoxyCompactList}\small\item\em Move a scalar field defined on faces to vertices by averaging. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\double \mbox{\hyperlink{namespaceigl_a2fc598da20b66905a5f3edb6f985cfb1}{avg\+\_\+edge\+\_\+length}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Compute the average edge length for the given triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_af6bab06e3533fb4130d508453175889f}{axis\+\_\+angle\+\_\+to\+\_\+quat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}axis, const Q\+\_\+type angle, Q\+\_\+type \texorpdfstring{$\ast$}{*}out)
\begin{DoxyCompactList}\small\item\em Convert axis angle representation of a rotation to a quaternion. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+BC $>$ }\\void \mbox{\hyperlink{namespaceigl_a952c606ce07c40eb966cd5e55874f92d}{barycenter}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BC $>$ \&BC)
\begin{DoxyCompactList}\small\item\em Computes the barycenter of every simplex. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_ad4b111b83aabbda680af965294681b5b}{barycentric\+\_\+coordinates}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Compute barycentric coordinates of each point in a corresponding tetrahedron. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_a8a603159f2a82b981f00ca10be97d62e}{barycentric\+\_\+coordinates}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Compute barycentric coordinates in a triangle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedD , typename DerivedF , typename DerivedB , typename DerivedI , typename DerivedX $>$ }\\void \mbox{\hyperlink{namespaceigl_ac2d34543d4673ecc638e11d0340f7c38}{barycentric\+\_\+interpolation}} (const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&D, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X)
\begin{DoxyCompactList}\small\item\em Interpolate data on a triangle mesh using barycentric coordinates. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82}{basename}} (const std\+::string \&path)
\begin{DoxyCompactList}\small\item\em Extract basename of file path (like PHP\textquotesingle{}s basename). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+Ele , typename Derivedb , typename Derivedbc , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_a33e3dc749c63b65a87635a309d322e9c}{bbw}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Ele $>$ \&Ele, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedbc $>$ \&bc, \mbox{\hyperlink{classigl_1_1BBWData}{BBWData}} \&data, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Compute Bounded Biharmonic Weights on a given domain (V,Ele) with a given set of boundary conditions. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_ae5227bd6077c6a709c20789e5c0d70cd}{bezier}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const typename Derived\+V\+::\+Scalar t, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Evaluate a polynomial Bezier Curve at single parameter value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_a0860a64b8a1678d63bea76c8b1999c78}{bezier}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Evaluate a polynomial Bezier Curve at many parameter values. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename VMat , typename DerivedT , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_a4be736f827b4ba341d4b2cb40f21f844}{bezier}} (const std\+::vector$<$ VMat $>$ \&spline, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Evaluate a polynomial Bezier spline with a fixed parameter set for each sub-\/curve. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedD , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_a75b1dcc1386b54083fe6a2b70c7b7225}{bfs}} (const AType \&A, const size\+\_\+t s, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Traverse a {\bfseries{directed}} graph represented by an adjacency list using. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DType , typename PType $>$ }\\void \mbox{\hyperlink{namespaceigl_a9ed9474cc5d1478971346be27092d3a2}{bfs}} (const std\+::vector$<$ std\+::vector$<$ AType $>$ $>$ \&A, const size\+\_\+t s, std\+::vector$<$ DType $>$ \&D, std\+::vector$<$ PType $>$ \&P)
\begin{DoxyCompactList}\small\item\em Traverse a {\bfseries{directed}} graph represented by an adjacency list using. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DType , typename PType $>$ }\\void \mbox{\hyperlink{namespaceigl_a3199a27a3e8403ef457e2a7b56f338f3}{bfs}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ AType $>$ \&A, const size\+\_\+t s, std\+::vector$<$ DType $>$ \&D, std\+::vector$<$ PType $>$ \&P)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+FF , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a8b9225d219645e80e01f409b151e7cc1}{bfs\+\_\+orient}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Consistently orient faces in orientable patches using BFS. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename SType , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa0ba6f8afae42bb09f687fe9a518ee94}{biharmonic\+\_\+coordinates}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, const std\+::vector$<$ std\+::vector$<$ SType $>$ $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Compute "{}discrete biharmonic generalized barycentric coordinates"{} as described in "{}\+Linear Subspace Design for Real-\/\+Time Shape Deformation"{} \mbox{[}Wang et al. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename SType , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_abb917f3b67e2fe53d03e8a2c98b6a276}{biharmonic\+\_\+coordinates}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, const std\+::vector$<$ std\+::vector$<$ SType $>$ $>$ \&S, const int k, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6867e7d0b5a7f134059e8205e6e16cc9}{bijective\+\_\+composite\+\_\+harmonic\+\_\+mapping}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em Compute a injective planar mapping of a triangulated polygon (V,F) subjected to boundary conditions (b,bc). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU $>$ }\\bool \mbox{\hyperlink{namespaceigl_a7ef34b7c5ad3903df6e31eb7d57bc6aa}{bijective\+\_\+composite\+\_\+harmonic\+\_\+mapping}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, const int min\+\_\+steps, const int max\+\_\+steps, const int num\+\_\+inner\+\_\+iters, const bool test\+\_\+for\+\_\+flips, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a72b12780a4ac9de89f929034ab464726}{blkdiag}} (const std\+::vector$<$ Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ $>$ \&L, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Given a list of matrices place them along the diagonal as blocks of the output matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a137f77a6ebc0d59e4f7f3f43e862274e}{blkdiag}} (const std\+::vector$<$ DerivedY $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedB , typename Derived\+FI , typename DerivedP , typename URBG  = DEFAULT\+\_\+\+URBG$>$ }\\void \mbox{\hyperlink{namespaceigl_af6fdfaea612ac6f626571df84ba43dd0}{blue\+\_\+noise}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+V\+::\+Scalar r, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&FI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, URBG \&\&urbg=\mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}())
\begin{DoxyCompactList}\small\item\em "{}\+Fast Poisson Disk Sampling in Arbitrary Dimensions"{} \mbox{[}Bridson 2007\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+BE , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_af9bff7fe392542fa173e6665ddaf7a21}{bone\+\_\+parents}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+BE $>$ \&BE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Recover "{}parent"{} bones from directed graph representation. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a366cd5eb6c56116ad697c23065fb8b40}{boundary\+\_\+conditions}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&Ele, const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Vector\+Xi \&P, const Eigen\+::\+Matrix\+Xi \&BE, const Eigen\+::\+Matrix\+Xi \&CE, const Eigen\+::\+Matrix\+Xi \&CF, Eigen\+::\+Vector\+Xi \&b, Eigen\+::\+Matrix\+Xd \&bc)
\begin{DoxyCompactList}\small\item\em Compute boundary conditions for automatic weights computation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedT , typename DerivedF , typename DerivedJ , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_aa7d8c6202cbd9be61850e58d65fd3096}{boundary\+\_\+facets}} (const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Determine boundary faces (edges) of tetrahedra (triangles) stored in T (analogous to qptoolbox\textquotesingle{}s {\ttfamily outline} and {\ttfamily boundary\+\_\+faces}). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedT , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a68133ab0b5aaff2f739a42c49f769512}{boundary\+\_\+facets}} (const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Determine boundary faces (edges) of tetrahedra (triangles) stored in T. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedT , typename Ret $>$ }\\Ret \mbox{\hyperlink{namespaceigl_adfd8cee60db0ccd9448521c2c828430d}{boundary\+\_\+facets}} (const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em Determine boundary faces (edges) of tetrahedra (triangles) stored in T. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename IntegerT , typename IntegerF $>$ }\\void \mbox{\hyperlink{namespaceigl_a782f0e0282464889f69540a72db9e88b}{boundary\+\_\+facets}} (const std\+::vector$<$ std\+::vector$<$ IntegerT $>$ $>$ \&T, std\+::vector$<$ std\+::vector$<$ IntegerF $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em Determine boundary faces (edges) of tetrahedra (triangles) stored in T; inputs and outputs lists. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_adb06d6406b52700028680b4b2c727700}{boundary\+\_\+loop}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&L)
\begin{DoxyCompactList}\small\item\em Compute list of ordered boundary loops for a manifold mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_a21468e50560667302d1637ed6895b29a}{boundary\+\_\+loop}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ Index $>$ \&L)
\begin{DoxyCompactList}\small\item\em Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_a82fec963303eda50e7dec22793b756d8}{boundary\+\_\+loop}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+BV , typename Derived\+BF $>$ }\\void \mbox{\hyperlink{namespaceigl_ad3dc35283c38c7712366f3b0f9dd09a7}{bounding\+\_\+box}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BV $>$ \&BV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&BF)
\begin{DoxyCompactList}\small\item\em Build a triangle mesh of the bounding box of a given list of vertices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+BV , typename Derived\+BF $>$ }\\void \mbox{\hyperlink{namespaceigl_a42a1ef8fd908031e5b30d1aba9614cb7}{bounding\+\_\+box}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const typename Derived\+V\+::\+Scalar pad, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BV $>$ \&BV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&BF)
\item 
double \mbox{\hyperlink{namespaceigl_aac1efbdec1a5c13888e2ec44b70c100a}{bounding\+\_\+box\+\_\+diagonal}} (const Eigen\+::\+Matrix\+Xd \&V)
\begin{DoxyCompactList}\small\item\em Compute the length of the diagonal of a given meshes axis-\/aligned bounding box. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\Q\+\_\+type \mbox{\hyperlink{namespaceigl_ab03aa82f1ac2c783bc64cbc9b869531e}{CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT}} (int i, int j)
\item 
template$<$$>$ float \mbox{\hyperlink{namespaceigl_a9ac4840ccfe1570de9ff6efc2fba06a5}{CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT$<$ float $>$}} (int i, int j)
\item 
template$<$$>$ double \mbox{\hyperlink{namespaceigl_a834139f67af87775d3524a90be997edc}{CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT$<$ double $>$}} (int i, int j)
\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_ad5f624eb7c4015b813215c87880eb54d}{cat}} (const int dim, const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&A, const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&B, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&C)
\begin{DoxyCompactList}\small\item\em Perform concatenation of a two {\itshape sparse} matrices along a single dimension If dim == 1, then C = \mbox{[}A;B\mbox{]}; If dim == 2 then C = \mbox{[}A B\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived , class MatC $>$ }\\void \mbox{\hyperlink{namespaceigl_a0834acd824362d58a9a06710cde2e964}{cat}} (const int dim, const Eigen\+::\+Matrix\+Base$<$ Derived $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ Derived $>$ \&B, MatC \&C)
\begin{DoxyCompactList}\small\item\em Perform concatenation of a two {\itshape dense} matrices along a single dimension If dim == 1, then C = \mbox{[}A;B\mbox{]}; If dim == 2 then C = \mbox{[}A B\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Mat $>$ }\\Mat \mbox{\hyperlink{namespaceigl_a203a47235dd090370a7dccffd385002f}{cat}} (const int dim, const Mat \&A, const Mat \&B)
\begin{DoxyCompactList}\small\item\em Perform concatenation of a two {\itshape dense} matrices along a single dimension If dim == 1, then C = \mbox{[}A;B\mbox{]}; If dim == 2 then C = \mbox{[}A B\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Mat $>$ }\\void \mbox{\hyperlink{namespaceigl_a2b1d04cfbdfdbb8a94fa5712aa9b868e}{cat}} (const std\+::vector$<$ std\+::vector$<$ Mat $>$ $>$ \&A, Mat \&C)
\begin{DoxyCompactList}\small\item\em Concatenate a "{}matrix"{} of sub-\/blocks C = \mbox{[}A0;A1;A2;...;An\mbox{]} where Ai = \mbox{[}A\mbox{[}i\mbox{]}\mbox{[}0\mbox{]} A\mbox{[}i\mbox{]}\mbox{[}1\mbox{]} ... A\mbox{[}i\mbox{]}\mbox{[}m\mbox{]}\mbox{]};. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a13402260035cb13a7110a755ae31c487}{cat}} (const int dim, const std\+::vector$<$ T $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Concatenate a std\+::vector of matrices along the specified dimension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_afacaeba967f62ca7f67bfddf604fd60f}{ceil}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Ceil a given matrix to nearest integers. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedc , typename Derivedvol $>$ }\\void \mbox{\hyperlink{namespaceigl_adaa0102450153380ae5ecdb948352556}{centroid}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, Derivedvol \&vol)
\begin{DoxyCompactList}\small\item\em Computes the centroid and enclosed volume of a closed mesh using a surface integral. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedc $>$ }\\void \mbox{\hyperlink{namespaceigl_a3b05ef9da68218494452d38460a07835}{centroid}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \mbox{\hyperlink{namespaceigl_ad2779ad7549dc5da4bed4c7042e2f780}{circulation}} (const int e, const bool ccw, const Eigen\+::\+Vector\+Xi \&EMAP, const Eigen\+::\+Matrix\+Xi \&EF, const Eigen\+::\+Matrix\+Xi \&EI)
\begin{DoxyCompactList}\small\item\em Return list of faces around the end point of an edge. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a0491f8d6a5d5bd769ab23851f43bb2e0}{circulation}} (const int e, const bool ccw, const Eigen\+::\+Vector\+Xi \&EMAP, const Eigen\+::\+Matrix\+Xi \&EF, const Eigen\+::\+Matrix\+Xi \&EI, Eigen\+::\+Vector\+Xi \&vN)
\begin{DoxyCompactList}\small\item\em Return list of faces around the end point of an edge. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a904a58ea245b35cce0feec144140e368}{circulation}} (const int e, const bool ccw, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Vector\+Xi \&EMAP, const Eigen\+::\+Matrix\+Xi \&EF, const Eigen\+::\+Matrix\+Xi \&EI, std\+::vector$<$ int $>$ \&Nv, std\+::vector$<$ int $>$ \&Nf)
\begin{DoxyCompactList}\small\item\em Return list of faces around the end point of an edge. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_a8d3ed506f1a1d753e1c342b42f008170}{circumradius}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em Compute the circumradius of each triangle in a mesh (V,F) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_aa8e3cfdf30adcadd5172a4f0b862bf59}{collapse\+\_\+edge}} (const int e, const Eigen\+::\+Row\+Vector\+Xd \&p, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI, int \&e1, int \&e2, int \&f1, int \&f2)
\begin{DoxyCompactList}\small\item\em Attempt to collapse a given edge of a mesh. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a2382e1bd40b951c6f6c14da9773f2fea}{collapse\+\_\+edge}} (const int e, const Eigen\+::\+Row\+Vector\+Xd \&p, std\+::vector$<$ int $>$ \&Nsv, const std\+::vector$<$ int $>$ \&Nsf, std\+::vector$<$ int $>$ \&Ndv, const std\+::vector$<$ int $>$ \&Ndf, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI, int \&e1, int \&e2, int \&f1, int \&f2)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a43afe015e0827032a90d6a916c223b2f}{collapse\+\_\+edge}} (const int e, const Eigen\+::\+Row\+Vector\+Xd \&p, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a943c00b18c9d77e42372a02ac5429bd0}{collapse\+\_\+edge}} (const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&pre\+\_\+collapse, const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&post\+\_\+collapse, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI, \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&Q, Eigen\+::\+Vector\+Xi \&EQ, Eigen\+::\+Matrix\+Xd \&C, int \&e, int \&e1, int \&e2, int \&f1, int \&f2)
\begin{DoxyCompactList}\small\item\em Collapse least-\/cost edge from a priority queue and update queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a134e573db7b2488d9118ebcf88419f62}{collapse\+\_\+edge}} (const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI, \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&Q, Eigen\+::\+Vector\+Xi \&EQ, Eigen\+::\+Matrix\+Xd \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a16f5c61d84a3d91b0e701df01c97c26c}{collapse\+\_\+edge}} (const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&pre\+\_\+collapse, const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&post\+\_\+collapse, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI, \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&Q, Eigen\+::\+Vector\+Xi \&EQ, Eigen\+::\+Matrix\+Xd \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a6b31209f04c3bbfb3e3e54836c60d21f}{collapse\+\_\+small\+\_\+triangles}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const double eps, Eigen\+::\+Matrix\+Xi \&FF)
\begin{DoxyCompactList}\small\item\em Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename S , typename H , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a3b87a97bec71e27b622eadb0ba9314ea}{colon}} (const L low, const S step, const H hi, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&I)
\begin{DoxyCompactList}\small\item\em Colon operator like matlab\textquotesingle{}s colon operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename L , typename H , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_af0e3b6d9995f83e6e09df72c562f7dec}{colon}} (const L low, const H hi, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&I)
\begin{DoxyCompactList}\small\item\em Colon operator like matlab\textquotesingle{}s colon operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_afcbc9102801940ac0f884e2749ac1113}{colormap}} (const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}} cm, const T f, T \texorpdfstring{$\ast$}{*}rgb)
\begin{DoxyCompactList}\small\item\em Compute \mbox{[}r,g,b\mbox{]} values of the selected colormap for a given factor f between 0 and 1. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a2b414ed243eb5c329d25492c74f0047a}{colormap}} (const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}} cm, const T f, T \&r, T \&g, T \&b)
\begin{DoxyCompactList}\small\item\em Compute \mbox{[}r,g,b\mbox{]} values of the selected colormap for a given factor f between 0 and 1. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_ab39d4724e45beaa1e1f8562f0e5e54fd}{colormap}} (const double palette\mbox{[}256\mbox{]}\mbox{[}3\mbox{]}, const T x\+\_\+in, T \&r, T \&g, T \&b)
\begin{DoxyCompactList}\small\item\em Compute \mbox{[}r,g,b\mbox{]} values of the colormap palette for a given factor f between 0 and 1. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedZ , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_ab3ae915229f4fed51bf2f7df5850aa5b}{colormap}} (const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}} cm, const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, const bool normalize, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute \mbox{[}r,g,b\mbox{]} values of the colormap palette for a given factors between 0 and 1. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedZ , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a50d9c681c034e001a790a6c31555d429}{colormap}} (const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}} cm, const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, const double min\+\_\+Z, const double max\+\_\+Z, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute \mbox{[}r,g,b\mbox{]} values of the colormap palette for a given factors between {\ttfamily min\+\_\+Z} and {\ttfamily max\+\_\+Z} \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a012bb449a5e1b088fd42ed4eb801391a}{column\+\_\+to\+\_\+quats}} (const Eigen\+::\+Vector\+Xd \&Q, std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&vQ)
\begin{DoxyCompactList}\small\item\em de-\/"{}\+Columnize"{} a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_a2ae4ea0e51288d468b77d2303f7b60e5}{columnize}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, const int k, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em "{}\+Columnize"{} a stack of block matrices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a42d3578aca0da0bea74041ca2b239c1d}{comb\+\_\+cross\+\_\+field}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD1in, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD2in, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&PD1out, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&PD2out)
\begin{DoxyCompactList}\small\item\em Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_a406fa0cb0c3fafe5a7b06e31ba757329}{comb\+\_\+frame\+\_\+field}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&PD1, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&PD2, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&BIS1\+\_\+combed, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&BIS2\+\_\+combed, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&PD1\+\_\+combed, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&PD2\+\_\+combed)
\begin{DoxyCompactList}\small\item\em Computes principal matchings of the vectors of a frame field across face edges, and generates a combed frame field defined on the mesh faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a702a263c5565f41ca8e4585619b746f7}{comb\+\_\+line\+\_\+field}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD1in, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&PD1out)
\begin{DoxyCompactList}\small\item\em Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VV , typename Derived\+FF , typename DerivedV , typename DerivedF , typename Derived\+Vsizes , typename Derived\+Fsizes $>$ }\\void \mbox{\hyperlink{namespaceigl_add396b23f15d16510156bfa839f58661}{combine}} (const std\+::vector$<$ Derived\+VV $>$ \&VV, const std\+::vector$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Vsizes $>$ \&Vsizes, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Fsizes $>$ \&Fsizes)
\begin{DoxyCompactList}\small\item\em Concatenate k meshes into a single \texorpdfstring{$>$}{>}=k connected component mesh with a single vertex list and face list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VV , typename Derived\+FF , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a75f28ec0548f636eb6dc9551eca554bc}{combine}} (const std\+::vector$<$ Derived\+VV $>$ \&VV, const std\+::vector$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_ab190df5efbd072173791f9ae36b0c58c}{compute\+\_\+frame\+\_\+field\+\_\+bisectors}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&B1, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&B2, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD1, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&BIS1, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&BIS2)
\begin{DoxyCompactList}\small\item\em Compute bisectors of a frame field defined on mesh faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a062b8f100ec84d5b9dfc68558f6e3e0b}{compute\+\_\+frame\+\_\+field\+\_\+bisectors}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD1, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&BIS1, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&BIS2)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+FO $>$ }\\void \mbox{\hyperlink{namespaceigl_a6c8cf9368d76d69d41ea95bc5b4fd13b}{connect\+\_\+boundary\+\_\+to\+\_\+infinity}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FO $>$ \&FO)
\begin{DoxyCompactList}\small\item\em Connect all boundary edges to a fictitious point at infinity. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+FO $>$ }\\void \mbox{\hyperlink{namespaceigl_abb409818f72dece08eaa0c0f71d5b2e9}{connect\+\_\+boundary\+\_\+to\+\_\+infinity}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+F\+::\+Scalar inf\+\_\+index, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FO $>$ \&FO)
\begin{DoxyCompactList}\small\item\em Connect all boundary edges to a fictitious point at infinity. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VO , typename Derived\+FO $>$ }\\void \mbox{\hyperlink{namespaceigl_a1d651ddb82e5e25cc25fbab3813190da}{connect\+\_\+boundary\+\_\+to\+\_\+infinity}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VO $>$ \&VO, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FO $>$ \&FO)
\begin{DoxyCompactList}\small\item\em Connect all boundary edges to a fictitious point at infinity. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Atype , typename DerivedC , typename DerivedK $>$ }\\int \mbox{\hyperlink{namespaceigl_ad493c0508f1454ae875031906899d4de}{connected\+\_\+components}} (const Eigen\+::\+Sparse\+Matrix$<$ Atype $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Determine the connected components of a graph described by the input adjacency matrix (similar to MATLAB\textquotesingle{}s graphconncomp or gptoolbox\textquotesingle{}s conncomp, but A is transposed for unsymmetric graphs). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&L)
\begin{DoxyCompactList}\small\item\em Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedI , typename DerivedC , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a42d5463d31cf82b23668e9680975301a}{cotmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&L, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&M, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&P)
\begin{DoxyCompactList}\small\item\em Cotangent Laplacian (and mass matrix) for polygon meshes according to "{}\+Polygon Laplacian Made Simple"{} \mbox{[}Bunge et al. 2020\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a4c5e7ebbe20f12078dc576d644935f83}{cotmatrix\+\_\+entries}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute the cotmatrix contributions (cotangents) of each angle in mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a01189493d30a0e8a2cbd6e053641545f}{cotmatrix\+\_\+entries}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute the cotmatrix contributions (cotangents) of each angle in mesh with edge lengths (l) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_ae47d4dd3239dba392f54b8dc3f62e8dd}{cotmatrix\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&L)
\begin{DoxyCompactList}\small\item\em Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh with faces F and edge lengths l. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename XType , typename SType $>$ }\\void \mbox{\hyperlink{namespaceigl_a83819bb842f4bc4c8af21a98e1db44b3}{count}} (const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&X, const int dim, Eigen\+::\+Sparse\+Vector$<$ SType $>$ \&S)
\begin{DoxyCompactList}\small\item\em Count the number of non-\/zeros in the columns or rows of a sparse matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename XType , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a91399ecb01f4828dbe0b5d3e9c51a73b}{count}} (const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&X, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a566bead6b8810ca47f10d8e0b184c2ab}{covariance\+\_\+scatter\+\_\+matrix}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{ARAPEnergy\+Type}} energy, Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&CSM)
\begin{DoxyCompactList}\small\item\em Construct the covariance scatter matrix for a given arap energy. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ }\\void \mbox{\hyperlink{namespaceigl_a9a8762cbd164779fc2b875dd73ab70d0}{cr\+\_\+vector\+\_\+curvature\+\_\+correction}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Computes the vector Crouzeix-\/\+Raviart curvature correction term of Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ }\\void \mbox{\hyperlink{namespaceigl_aeca2a3d390d85a9432843e481cc1b2ca}{cr\+\_\+vector\+\_\+curvature\+\_\+correction}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&K)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename Derivedtheta , typename Derivedkappa , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ }\\void \mbox{\hyperlink{namespaceigl_a8e4ef6fb71a86a0dc23499f0d2859578}{cr\+\_\+vector\+\_\+curvature\+\_\+correction\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ Derivedtheta $>$ \&theta, const Eigen\+::\+Matrix\+Base$<$ Derivedkappa $>$ \&kappa, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&K)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ }\\void \mbox{\hyperlink{namespaceigl_a9522053349c7920e8399af8da638720d}{cr\+\_\+vector\+\_\+curvature\+\_\+correction\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&K)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{cr__vector__curvature__correction_8h}{include/igl/cr\+\_\+vector\+\_\+curvature\+\_\+correction.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename Derivedtheta , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ }\\void \mbox{\hyperlink{namespaceigl_a27d76cb9c1bfa1cc13c9bc19f4bcbdc8}{cr\+\_\+vector\+\_\+curvature\+\_\+correction\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ Derivedtheta $>$ \&theta, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&K)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{cr__vector__curvature__correction_8h}{include/igl/cr\+\_\+vector\+\_\+curvature\+\_\+correction.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ }\\void \mbox{\hyperlink{namespaceigl_ad3b4cd87c1b79a3e8220217907e2f92d}{cr\+\_\+vector\+\_\+laplacian}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Computes the CR vector Laplacian matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ }\\void \mbox{\hyperlink{namespaceigl_a6cc88ca84e384cf6d28d2fc8a0f9bebf}{cr\+\_\+vector\+\_\+laplacian}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&L)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DeriveddA , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ }\\void \mbox{\hyperlink{namespaceigl_a7a2c2b7f03004fbcca3d3fa8f4fef60f}{cr\+\_\+vector\+\_\+laplacian\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&dA, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&L)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ }\\void \mbox{\hyperlink{namespaceigl_a74c1a4348f8eeba501dac71ffe89a71c}{cr\+\_\+vector\+\_\+laplacian\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&L)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{cr__vector__laplacian_8h}{include/igl/cr\+\_\+vector\+\_\+laplacian.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM $>$ }\\void \mbox{\hyperlink{namespaceigl_adb956da2f2c2355242b2c267b86d8fea}{cr\+\_\+vector\+\_\+mass}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Sparse\+Matrix$<$ ScalarM $>$ \&M)
\begin{DoxyCompactList}\small\item\em Computes the CR vector mass matrix, using an arrangement of all parallel degrees of freedom first, and all perpendicular degrees of freedom next. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM $>$ }\\void \mbox{\hyperlink{namespaceigl_ab2dabc69504695d2ad3ea01676bf9353}{cr\+\_\+vector\+\_\+mass}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Sparse\+Matrix$<$ ScalarM $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DeriveddA , typename DerivedE , typename ScalarM $>$ }\\void \mbox{\hyperlink{namespaceigl_a10ed1159cd7e63e2d4993c501085be42}{cr\+\_\+vector\+\_\+mass\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&dA, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Sparse\+Matrix$<$ ScalarM $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a8eb65039a597811fba7c59d41d039b4c}{cross}} (const double \texorpdfstring{$\ast$}{*}a, const double \texorpdfstring{$\ast$}{*}b, double \texorpdfstring{$\ast$}{*}out)
\begin{DoxyCompactList}\small\item\em Cross product; out = cross(a,b) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a4887506ff673ad3a57ca0697dda4d029}{cross}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Computes rowwise cross product C = cross(\+A,\+B,2);. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedM $>$ }\\void \mbox{\hyperlink{namespaceigl_a916e1792b25fb32f0554288f22dcaa21}{cross\+\_\+field\+\_\+mismatch}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD1, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD2, const bool is\+Combed, Eigen\+::\+Plain\+Object\+Base$<$ DerivedM $>$ \&mismatch)
\begin{DoxyCompactList}\small\item\em Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename LT , typename DerivedE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_a528d6ff188e05af669e3369a40562268}{crouzeix\+\_\+raviart\+\_\+cotmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ LT $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em Compute the Crouzeix-\/\+Raviart cotangent stiffness matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+EMAP , typename LT $>$ }\\void \mbox{\hyperlink{namespaceigl_a0cba460e00e27a7947e2d7d7d569ec04}{crouzeix\+\_\+raviart\+\_\+cotmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, Eigen\+::\+Sparse\+Matrix$<$ LT $>$ \&L)
\begin{DoxyCompactList}\small\item\em Compute the Crouzeix-\/\+Raviart cotangent stiffness matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_a1e1d2b58df45ae7555c3719963bb39d6}{crouzeix\+\_\+raviart\+\_\+massmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ MT $>$ \&M, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em CROUZEIX\+\_\+\+RAVIART\+\_\+\+MASSMATRIX Compute the Crouzeix-\/\+Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_a4fbcad6ddce4e7c8f209f87f5deb5f81}{crouzeix\+\_\+raviart\+\_\+massmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, Eigen\+::\+Sparse\+Matrix$<$ MT $>$ \&M)
\begin{DoxyCompactList}\small\item\em CROUZEIX\+\_\+\+RAVIART\+\_\+\+MASSMATRIX Compute the Crouzeix-\/\+Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a8115269b075eef2f1c35db347806319d}{cumprod}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Computes a cumulative product of the columns of X, like matlab\textquotesingle{}s {\ttfamily cumprod}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a6ad6bf440539af2b6aa5b38ce6d8f4ec}{cumsum}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Computes a cumulative sum of the columns of X, like matlab\textquotesingle{}s {\ttfamily cumsum}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a717f5ffd3d4bc3771bdd7e2e2786bb95}{cumsum}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const int dim, const bool zero\+\_\+prefix, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Computes a cumulative sum of the columns of \mbox{[}0;X\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename ScalarQ $>$ }\\void \mbox{\hyperlink{namespaceigl_adf8191d83bb2517d430b625c5416988b}{curved\+\_\+hessian\+\_\+energy}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ }\\void \mbox{\hyperlink{namespaceigl_a805b9c22927ea42f1756d0094e373f9f}{curved\+\_\+hessian\+\_\+energy}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ }\\void \mbox{\hyperlink{namespaceigl_a22ef8866a2a9dee7c48ba52640e2d1f0}{curved\+\_\+hessian\+\_\+energy}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ }\\void \mbox{\hyperlink{namespaceigl_adf2f70635c7e74512f3a00c9fbf0175f}{curved\+\_\+hessian\+\_\+energy\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DeriveddA , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ }\\void \mbox{\hyperlink{namespaceigl_a6ee4e11b54bb3477734d8f83e33c01c7}{curved\+\_\+hessian\+\_\+energy\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&dA, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a3221b56ac51e76ede2f88111bd099e2c}{cut\+\_\+mesh}} (Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&cuts, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FF , typename Derived\+FFi , typename DerivedC , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a9a4e732845de9d7f23536e1e6afe4a12}{cut\+\_\+mesh}} (Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Matrix\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Matrix\+Base$<$ Derived\+FFi $>$ \&FFi, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_ab4c53d1e5c547015ed9a3a31941c9e80}{cut\+\_\+mesh}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&cuts, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&Vn, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&Fn)
\begin{DoxyCompactList}\small\item\em Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a073f4b026cc266fb9d229b0063139681}{cut\+\_\+mesh}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&cuts, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&Vn, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&Fn, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO $>$ }\\void \mbox{\hyperlink{namespaceigl_a719fb78367f00bac1b9ef47dacead128}{cut\+\_\+mesh\+\_\+from\+\_\+singularities}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&MMatch, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&seams)
\begin{DoxyCompactList}\small\item\em Given a mesh (V,F) and the integer mismatch of a cross field per edge (mismatch), finds the cut\+\_\+graph connecting the singularities (seams) and the degree of the singularities singularity\+\_\+index. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_ace2b58d7048e2871ef70de6761fe10f2}{cut\+\_\+to\+\_\+disk}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&cuts)
\begin{DoxyCompactList}\small\item\em Given a triangle mesh, computes a set of edge cuts sufficient to carve the mesh into a topological disk, without disconnecting any connected components. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_ab77a363af4a0fcf59e15409bd8a09fc4}{cylinder}} (const int axis\+\_\+devisions, const int height\+\_\+devisions, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Construct a triangle mesh of a cylinder (without caps) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a73748b03f3e779d764d30d920653aba6}{dated\+\_\+copy}} (const std\+::string \&src\+\_\+path, const std\+::string \&dir)
\begin{DoxyCompactList}\small\item\em Copy the given file to a new file with the same basename in {\ttfamily dir} directory with the current date and time as a suffix. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_ad50bddf10510ab0ef1bda0bb11641fef}{dated\+\_\+copy}} (const std\+::string \&src\+\_\+path)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{decimate}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const size\+\_\+t max\+\_\+m, Eigen\+::\+Matrix\+Xd \&U, Eigen\+::\+Matrix\+Xi \&G, Eigen\+::\+Vector\+Xi \&J, Eigen\+::\+Vector\+Xi \&I)
\begin{DoxyCompactList}\small\item\em Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of faces is achieved. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a012dde4236352501b14abc42b746906e}{decimate}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const size\+\_\+t max\+\_\+m, Eigen\+::\+Matrix\+Xd \&U, Eigen\+::\+Matrix\+Xi \&G, Eigen\+::\+Vector\+Xi \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a61885a8ab4cc1e4ed8ed1fba6e42ecb6}{decimate}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, const \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&stopping\+\_\+condition, const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&pre\+\_\+collapse, const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&post\+\_\+collapse, const Eigen\+::\+Matrix\+Xi \&E, const Eigen\+::\+Vector\+Xi \&EMAP, const Eigen\+::\+Matrix\+Xi \&EF, const Eigen\+::\+Matrix\+Xi \&EI, Eigen\+::\+Matrix\+Xd \&U, Eigen\+::\+Matrix\+Xi \&G, Eigen\+::\+Vector\+Xi \&J, Eigen\+::\+Vector\+Xi \&I)
\begin{DoxyCompactList}\small\item\em Collapses edges of a {\bfseries{closed manifold mesh}} (V,F) using user defined callbacks in a priority queue. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a8e383abbd367d0ed68c602a7ae7ea2f7}{decimate}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, const \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&stopping\+\_\+condition, const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&pre\+\_\+collapse, const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&post\+\_\+collapse, Eigen\+::\+Matrix\+Xd \&U, Eigen\+::\+Matrix\+Xi \&G, Eigen\+::\+Vector\+Xi \&J, Eigen\+::\+Vector\+Xi \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_aa716c4de65ed56fd9f9968f9d79ee657}{decimate}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, const \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&stopping\+\_\+condition, Eigen\+::\+Matrix\+Xd \&U, Eigen\+::\+Matrix\+Xi \&G, Eigen\+::\+Vector\+Xi \&J, Eigen\+::\+Vector\+Xi \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a199e2a88dcf8d16e8b0244d20e4743c1}{decimate\+\_\+trivial\+\_\+callbacks}} (\mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&always\+\_\+try, \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&never\+\_\+care)
\begin{DoxyCompactList}\small\item\em Function to build trivial pre and post collapse actions. \end{DoxyCompactList}\item 
unsigned int \mbox{\hyperlink{namespaceigl_aa03c54b4a3c8a07853528d49455f4fcc}{default\+\_\+num\+\_\+threads}} (unsigned int force\+\_\+num\+\_\+threads=0)
\begin{DoxyCompactList}\small\item\em Returns the default number of threads used in libigl. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a5819845b8bcf251d5e25bc93bf425e35}{deform\+\_\+skeleton}} (const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&BE, const std\+::vector$<$ Eigen\+::\+Affine3d, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Affine3d $>$ $>$ \&vA, Eigen\+::\+Matrix\+Xd \&CT, Eigen\+::\+Matrix\+Xi \&BET)
\begin{DoxyCompactList}\small\item\em Deform a skeleton. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a473e4f58cfd34838b53114e315604728}{deform\+\_\+skeleton}} (const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&BE, const Eigen\+::\+Matrix\+Xd \&T, Eigen\+::\+Matrix\+Xd \&CT, Eigen\+::\+Matrix\+Xi \&BET)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Orient2D , typename In\+Circle , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_ad85b334c412de101ce6003dabbd6ad70}{delaunay\+\_\+triangulation}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Orient2D orient2D, In\+Circle incircle, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Given a set of points in 2D, return a Delaunay triangulation of these points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedD , typename DerivedP , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a9bed0a54e4a3d573a8ca709f613d2b8c}{dfs}} (const std\+::vector$<$ std\+::vector$<$ AType $>$ $>$ \&A, const size\+\_\+t s, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Traverse a {\bfseries{directed}} graph represented by an adjacency list using depth first search. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DType , typename PType , typename CType $>$ }\\void \mbox{\hyperlink{namespaceigl_a95618dab6ef7c11351e352297c2d77fc}{dfs}} (const std\+::vector$<$ std\+::vector$<$ AType $>$ $>$ \&A, const size\+\_\+t s, std\+::vector$<$ DType $>$ \&D, std\+::vector$<$ PType $>$ \&P, std\+::vector$<$ CType $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename Derivedtheta , typename Derivedcos\+\_\+theta $>$ }\\void \mbox{\hyperlink{namespaceigl_ae1d2eff20a5c7b15bbe61a1d53eadc9b}{dihedral\+\_\+angles}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ Derivedtheta $>$ \&theta, Eigen\+::\+Plain\+Object\+Base$<$ Derivedcos\+\_\+theta $>$ \&cos\+\_\+theta)
\begin{DoxyCompactList}\small\item\em Compute dihedral angles for all tets of a given tet mesh (V,T). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename DerivedA , typename Derivedtheta , typename Derivedcos\+\_\+theta $>$ }\\void \mbox{\hyperlink{namespaceigl_af8fd16e614bedafbd69fa739a29a7622}{dihedral\+\_\+angles\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&L, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ Derivedtheta $>$ \&theta, Eigen\+::\+Plain\+Object\+Base$<$ Derivedcos\+\_\+theta $>$ \&cos\+\_\+theta)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index\+Type , typename DerivedD , typename DerivedP $>$ }\\int \mbox{\hyperlink{namespaceigl_a16b06e5e2a37a01b6648acb209437f78}{dijkstra}} (const Index\+Type \&source, const std\+::set$<$ Index\+Type $>$ \&targets, const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&VV, const std\+::vector$<$ double $>$ \&weights, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&min\+\_\+distance, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&previous)
\begin{DoxyCompactList}\small\item\em Dijkstra\textquotesingle{}s algorithm for vertex-\/weighted shortest paths, with multiple targets. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index\+Type , typename DerivedV , typename DerivedD , typename DerivedP $>$ }\\int \mbox{\hyperlink{namespaceigl_a5a2bd7c3c9affbdcd476b68cfe36a41d}{dijkstra}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&VV, const Index\+Type \&source, const std\+::set$<$ Index\+Type $>$ \&targets, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&min\+\_\+distance, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&previous)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index\+Type , typename DerivedD , typename DerivedP $>$ }\\int \mbox{\hyperlink{namespaceigl_ad95f2745c0d523d9b1b8d7b7ef2707b9}{dijkstra}} (const Index\+Type \&source, const std\+::set$<$ Index\+Type $>$ \&targets, const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&VV, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&min\+\_\+distance, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&previous)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index\+Type , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_a574a508288788ba1c5a7c8c2adbd0c33}{dijkstra}} (const Index\+Type \&vertex, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&previous, std\+::vector$<$ Index\+Type $>$ \&path)
\begin{DoxyCompactList}\small\item\em Backtracking after Dijkstra\textquotesingle{}s algorithm, to find shortest path. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+Omega , typename DerivedU $>$ }\\void \mbox{\hyperlink{namespaceigl_a24aaa9b2bd870165bee8f9c18c826496}{direct\+\_\+delta\+\_\+mush}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const std\+::vector$<$ Eigen\+::\+Affine3d, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Affine3d $>$ $>$ \&T, const Eigen\+::\+Matrix\+Base$<$ Derived\+Omega $>$ \&Omega, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em Computes Direct Delta Mush Skinning (Variant 0) from "{}\+Direct Delta Mush \+Skinning and Variants"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedW , typename Derived\+Omega $>$ }\\void \mbox{\hyperlink{namespaceigl_a48dbae56ef5784518387be01caf9bb5c}{direct\+\_\+delta\+\_\+mush\+\_\+precomputation}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&W, const int p, const typename Derived\+V\+::\+Scalar lambda, const typename Derived\+V\+::\+Scalar kappa, const typename Derived\+V\+::\+Scalar alpha, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Omega $>$ \&Omega)
\begin{DoxyCompactList}\small\item\em Precomputation for Direct Delta Mush Skinning. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedC , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a72a57e1816cf4b6448d72f2f98b5e071}{directed\+\_\+edge\+\_\+orientations}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Determine rotations that take each edge from the x-\/axis to its given rest orientation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedE , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_af8de9b7859fbf82291598bae63e47550}{directed\+\_\+edge\+\_\+parents}} (const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Recover "{}parents"{} (preceding edges) in a tree given just directed edges. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_aef1ff1d390be65861384b6ff764ebe09}{dirname}} (const std\+::string \&path)
\begin{DoxyCompactList}\small\item\em Function like PHP\textquotesingle{}s dirname\+: /etc/passwd -\/-\/\texorpdfstring{$>$}{>} /etc,. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespaceigl_a3bdaab27eb4626ff5685a3a4f9347b6a}{dot}} (const double \texorpdfstring{$\ast$}{*}a, const double \texorpdfstring{$\ast$}{*}b)
\begin{DoxyCompactList}\small\item\em Computes out = dot(a,b) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV $>$ }\\DerivedV \mbox{\hyperlink{namespaceigl_a23322b4cdcba5a31a7e95dc0a29b83f1}{dot\+\_\+row}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&A, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&B)
\begin{DoxyCompactList}\small\item\em Compute the dot product between each row of A and B. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DeriveddblA $>$ }\\void \mbox{\hyperlink{namespaceigl_a7bae61a0f8a1bbe72e7832381c9beca5}{doublearea}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&dblA)
\begin{DoxyCompactList}\small\item\em Computes twice the area for each input triangle or quad. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_adb2512ac1588eb6929dee61b2fb70955}{doublearea}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em Compute the twice the signed area of a each triangle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC $>$ }\\Derived\+A\+::\+Scalar \mbox{\hyperlink{namespaceigl_aace08ffa72a43a1758a45fe097625aef}{doublearea\+\_\+single}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute the twice the signed area of a single triangle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DeriveddblA $>$ }\\void \mbox{\hyperlink{namespaceigl_aa4f3fcc3d502d79e4617250e0ea85ef6}{doublearea}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const typename Derivedl\+::\+Scalar nan\+\_\+replacement, Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&dblA)
\begin{DoxyCompactList}\small\item\em Compute twice the area of each intrinsic triangle in a mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DeriveddblA $>$ }\\void \mbox{\hyperlink{namespaceigl_a0fcad7016d7021778f7ec4ff91cec557}{doublearea}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&dblA)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DeriveddblA $>$ }\\void \mbox{\hyperlink{namespaceigl_a516b190062ec90a40ecce7a721951303}{doublearea\+\_\+quad}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&dblA)
\begin{DoxyCompactList}\small\item\em Computes twice the area for each input quadrilateral. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedW , typename Q , typename QAlloc , typename T , typename DerivedU $>$ }\\void \mbox{\hyperlink{namespaceigl_ae135ef705d377be39be52549ba816de4}{dqs}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&W, const std\+::vector$<$ Q, QAlloc $>$ \&vQ, const std\+::vector$<$ T $>$ \&vT, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em Dual quaternion skinning. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedQ $>$ }\\void \mbox{\hyperlink{namespaceigl_ac43379fb55c1019ff88c726aacb64b91}{dual\+\_\+contouring}} (const std\+::function$<$ typename Derived\+V\+::\+Scalar(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&f, const std\+::function$<$ Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&f\+\_\+grad, const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&min\+\_\+corner, const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&max\+\_\+corner, const int nx, const int ny, const int nz, const bool constrained, const bool triangles, const bool root\+\_\+finding, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Dual contouring to extract a pure quad mesh from differentiable implicit function using a dense grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+Gf , typename Derived\+GV , typename DerivedV , typename DerivedQ $>$ }\\void \mbox{\hyperlink{namespaceigl_ab912fd8e785a570ce48146acf3c84597}{dual\+\_\+contouring}} (const std\+::function$<$ typename Derived\+V\+::\+Scalar(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&f, const std\+::function$<$ Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&f\+\_\+grad, const Eigen\+::\+Matrix\+Base$<$ Derived\+Gf $>$ \&Gf, const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&GV, const int nx, const int ny, const int nz, const bool constrained, const bool triangles, const bool root\+\_\+finding, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+Gf , typename Derived\+GV , typename Derived\+GI , typename DerivedV , typename DerivedQ $>$ }\\void \mbox{\hyperlink{namespaceigl_aab25bc6339ed9e928df2fcb7bd20ef7e}{dual\+\_\+contouring}} (const std\+::function$<$ typename Derived\+V\+::\+Scalar(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&f, const std\+::function$<$ Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&f\+\_\+grad, const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&step, const Eigen\+::\+Matrix\+Base$<$ Derived\+Gf $>$ \&Gf, const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&GV, const Eigen\+::\+Matrix\+Base$<$ Derived\+GI $>$ \&GI, const bool constrained, const bool triangles, const bool root\+\_\+finding, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derivedear , typename Derivedear\+\_\+opp $>$ }\\void \mbox{\hyperlink{namespaceigl_a484fcecc222d6c50ff16fe61ff820a80}{ears}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derivedear $>$ \&ear, Eigen\+::\+Plain\+Object\+Base$<$ Derivedear\+\_\+opp $>$ \&ear\+\_\+opp)
\begin{DoxyCompactList}\small\item\em Find all ears (faces with two boundary edges) in a given mesh. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_aa77cd5878fb81e389480d12080f8679c}{edge\+\_\+collapse\+\_\+is\+\_\+valid}} (const int e, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xi \&E, const Eigen\+::\+Vector\+Xi \&EMAP, const Eigen\+::\+Matrix\+Xi \&EF, const Eigen\+::\+Matrix\+Xi \&EI)
\begin{DoxyCompactList}\small\item\em Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a4449e689db8a9360f41451ad4980b354}{edge\+\_\+collapse\+\_\+is\+\_\+valid}} (std\+::vector$<$ int $>$ \&Nsv, std\+::vector$<$ int $>$ \&Ndv)
\begin{DoxyCompactList}\small\item\em Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DeriveduE , typename DerivedS , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a0cf37d2a8f8c08387438a60ba3bcb2ca}{edge\+\_\+crossings}} (const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar val, std\+::unordered\+\_\+map$<$ int, int $>$ \&u\+E2I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em Compute the each point that a scalar field crosses a specified value along an edge of a mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6c1b6d5e7d874099d4260df5291e63e7}{edge\+\_\+exists\+\_\+near}} (const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, const Index \&a, const Index \&b, const Index \&uei)
\begin{DoxyCompactList}\small\item\em Does edge (a,b) exist in the edges of all faces incident on existing unique edge uei. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a984c604c49a10f557933850d8c8e2a76}{edge\+\_\+flaps}} (const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xi \&uE, const Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI)
\begin{DoxyCompactList}\small\item\em Determine "{}edge flaps"{}\+: two faces on either side of a unique edge (assumes edge-\/manifold mesh) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a00745ad61704fb8a6dc941ebf003f628}{edge\+\_\+flaps}} (const Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&uE, Eigen\+::\+Vector\+Xi \&EMAP, Eigen\+::\+Matrix\+Xi \&EF, Eigen\+::\+Matrix\+Xi \&EI)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_a9b2b3d2e2b569256e7704f81859b4d2a}{edge\+\_\+lengths}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Constructs a list of lengths of edges opposite each index in a face (triangle/tet) list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedmps $>$ }\\void \mbox{\hyperlink{namespaceigl_a98288ab94dfbdf3104687419fe33b704}{edge\+\_\+midpoints}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&oE, Eigen\+::\+Plain\+Object\+Base$<$ Derivedmps $>$ \&mps)
\begin{DoxyCompactList}\small\item\em Computes the midpoints of edges in a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a182268447e88dbae647fd2971598226a}{edge\+\_\+topology}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&EV, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&FE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&EF)
\begin{DoxyCompactList}\small\item\em Initialize Edges and their topological relations (assumes an edge-\/manifold mesh). \end{DoxyCompactList}\item 
{\footnotesize template$<$bool compute\+Perpendicular = true, typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedvec\+Parallel , typename Derivedvec\+Perpendicular $>$ }\\void \mbox{\hyperlink{namespaceigl_aeb415384505882dfd1de98f678d214a2}{edge\+\_\+vectors}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&oE, Eigen\+::\+Plain\+Object\+Base$<$ Derivedvec\+Parallel $>$ \&vec\+Parallel, Eigen\+::\+Plain\+Object\+Base$<$ Derivedvec\+Perpendicular $>$ \&vec\+Perpendicular)
\begin{DoxyCompactList}\small\item\em Computes the normalized edge vectors for edges in a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedvec $>$ }\\void \mbox{\hyperlink{namespaceigl_a7c252b86d3deff637414b045dce9d271}{edge\+\_\+vectors}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&oE, Eigen\+::\+Plain\+Object\+Base$<$ Derivedvec $>$ \&vec)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\begin{DoxyCompactList}\small\item\em Constructs a list of unique edges represented in a given mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedI , typename DerivedC , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_aa0ad8afcbeffbd52acd213150ef184cc}{edges}} (const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\begin{DoxyCompactList}\small\item\em Constructs a list of unique edges represented in a given polygon mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a93abf38f4293f5e3010211137c9a6ea4}{edges}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\begin{DoxyCompactList}\small\item\em Constructs a list of unique edges represented in a given adjacency matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedE , typename DerivedI , typename DerivedJ , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_acfa1bf0ca6473ee9234b38b59c90e800}{edges\+\_\+to\+\_\+path}} (const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Given a set of undirected, unique edges such that all form a single connected compoent with exactly 0 or 2 nodes with valence =1, determine the/a path visiting all nodes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Atype , typename Btype , typename DerivedU , typename DerivedS $>$ }\\bool \mbox{\hyperlink{namespaceigl_a77bf75e3dc429d5ca9d830c137ac1b1f}{eigs}} (const Eigen\+::\+Sparse\+Matrix$<$ Atype $>$ \&A, const Eigen\+::\+Sparse\+Matrix$<$ Btype $>$ \&B, const size\+\_\+t k, const \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50d}{Eigs\+Type}} type, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&sU, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&sS)
\begin{DoxyCompactList}\small\item\em Compute the first/last k eigen pairs of the generalized eigen value problem\+: \end{DoxyCompactList}\item 
{\footnotesize template$<$typename S\+\_\+type $>$ }\\S\+\_\+type \mbox{\hyperlink{namespaceigl_ad059c2eefaa87bb31a2b03a1787f133d}{EPS}} ()
\begin{DoxyCompactList}\small\item\em Function returning EPS for corresponding type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename S\+\_\+type $>$ }\\S\+\_\+type \mbox{\hyperlink{namespaceigl_aba458ce3c4cbdd9d0cbb3c83b3a255c7}{EPS\+\_\+\+SQ}} ()
\begin{DoxyCompactList}\small\item\em Function returning EPS\+\_\+\+SQ for corresponding type. \end{DoxyCompactList}\item 
template$<$$>$ float \mbox{\hyperlink{namespaceigl_abfc53046d44a2c9f6c3c6e32cb3ae024}{EPS$<$ float $>$}} ()
\item 
template$<$$>$ double \mbox{\hyperlink{namespaceigl_a8d0aed7321fc747f72cd8f680826ed8e}{EPS$<$ double $>$}} ()
\item 
template$<$$>$ float \mbox{\hyperlink{namespaceigl_aa724bd6d64eb6b639407db5b87f1ac64}{EPS\+\_\+\+SQ$<$ float $>$}} ()
\item 
template$<$$>$ double \mbox{\hyperlink{namespaceigl_a5e39a8d172ad95e01e3171a06a3a0bac}{EPS\+\_\+\+SQ$<$ double $>$}} ()
\item 
{\footnotesize template$<$typename DerivedF $>$ }\\int \mbox{\hyperlink{namespaceigl_a4bda900bb61246ae8c8ec80881cf14c1}{euler\+\_\+characteristic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Computes the Euler characteristic of a given mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VS , typename Derived\+FS , typename Derived\+VT , typename Derived\+FT , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_addb59555ec8b85d9c5d492f449a24b4b}{exact\+\_\+geodesic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+VS $>$ \&VS, const Eigen\+::\+Matrix\+Base$<$ Derived\+FS $>$ \&FS, const Eigen\+::\+Matrix\+Base$<$ Derived\+VT $>$ \&VT, const Eigen\+::\+Matrix\+Base$<$ Derived\+FT $>$ \&FT, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em Exact geodesic algorithm for triangular mesh with the implementation from \href{https://code.google.com/archive/p/geodesic/}{\texttt{ https\+://code.\+google.\+com/archive/p/geodesic/}}, and the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Printable $>$ }\\bool \mbox{\hyperlink{namespaceigl_adb99ccd45b42797c3490bf4dfefe9d02}{example\+\_\+fun}} (const Printable \&input)
\begin{DoxyCompactList}\small\item\em This is an example of a function, it takes a templated parameter and shovels it into cout. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename Derived\+EV , typename Derived\+EF , typename DerivedI , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_ad617638bca753edfeed7b8cdb65794ad}{exploded\+\_\+view}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, const typename Derived\+V\+::\+Scalar s, const typename Derived\+V\+::\+Scalar t, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EV $>$ \&EV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EF $>$ \&EF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Given a tet-\/mesh, create a trivial surface mesh (4 triangles per tet) with each tet scaled individually and translated outward from the mesh\textquotesingle{}s centroid, creating an exploded-\/view visualization. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_af53e1e0ea4e1632ee9d5b5a6411093e2}{extension}} (const std\+::string \&path)
\begin{DoxyCompactList}\small\item\em Extract file extension from path. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a269a81c6ea4fcbc58882d48720e1a4f5}{exterior\+\_\+edges}} (const Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xi \&E)
\begin{DoxyCompactList}\small\item\em Determines boundary "{}edges"{} and also edges with an odd number of occurrences where seeing edge (i,j) counts as +1 and seeing the opposite edge (j,i) counts as -\/1. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xi \mbox{\hyperlink{namespaceigl_a47866518a950145c0151a245889b502f}{exterior\+\_\+edges}} (const Eigen\+::\+Matrix\+Xi \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedP $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_a9b637953696bc3821b0a15ebbd4b5105}{extract\+\_\+manifold\+\_\+patches}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&u\+EE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Extract a set of maximal patches from a given mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+EMAP , typename u\+E2\+EType , typename DerivedP $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_ac86020caa06983927879da2393cf5095}{extract\+\_\+manifold\+\_\+patches}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedP $>$ }\\size\+\_\+t \mbox{\hyperlink{namespaceigl_a644f27405a7cb3bf6b00a451381e8210}{extract\+\_\+manifold\+\_\+patches}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+EMAP , typename u\+E2\+EType $>$ }\\void \mbox{\hyperlink{namespaceigl_a4f66eca661e45dd9827bf7cae56c61ce}{extract\+\_\+non\+\_\+manifold\+\_\+edge\+\_\+curves}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&curves)
\begin{DoxyCompactList}\small\item\em Extract non-\/manifold curves from a given mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_ad7de3a366fede697c4cc178a8f36e30e}{face\+\_\+areas}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Constructs a list of face areas of faces opposite each index in a tet list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_a7448c2f83363e1920d02fe6bcb12c5eb}{face\+\_\+areas}} (const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_a41c2271033be3dc067310683ec802e22}{face\+\_\+areas}} (const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&L, const typename Derived\+L\+::\+Scalar doublearea\+\_\+nan\+\_\+replacement, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename IntegerF , typename IntegerC $>$ }\\void \mbox{\hyperlink{namespaceigl_aa4885ed7913bafcb653dade6c257a29e}{face\+\_\+occurrences}} (const std\+::vector$<$ std\+::vector$<$ IntegerF $>$ $>$ \&F, std\+::vector$<$ IntegerC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Count the occurances of each face (row) in a list of face indices (irrespecitive of order) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a02c8ab57f00492797e93f9da9cf3c63e}{face\+\_\+occurrences}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF , typename VecI $>$ }\\void \mbox{\hyperlink{namespaceigl_af7aa77ffc481c82074bcdd0ae765c090}{faces\+\_\+first}} (const MatV \&V, const MatF \&F, MatV \&RV, MatF \&RF, VecI \&IM)
\begin{DoxyCompactList}\small\item\em Reorder vertices so that vertices in face list come before vertices that don\textquotesingle{}t appear in the face list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF , typename VecI $>$ }\\void \mbox{\hyperlink{namespaceigl_a9e44af09a10d6457aa439a6afbb3a6b2}{faces\+\_\+first}} (MatV \&V, MatF \&F, VecI \&IM)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Atype $>$ }\\void \mbox{\hyperlink{namespaceigl_ab3c84999e29d9e168fe33b0ca7f2b199}{facet\+\_\+adjacency\+\_\+matrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Atype $>$ \&A)
\begin{DoxyCompactList}\small\item\em Construct a \#\+F\#F adjacency matrix with A(i,j)\texorpdfstring{$>$}{>}0 indicating that faces i and j share an edge. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedC $>$ }\\int \mbox{\hyperlink{namespaceigl_a7823f08d518cb237ee3cb47bb03cdb6d}{facet\+\_\+components}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute connected components of facets based on edge-\/edge adjacency. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TTIndex , typename DerivedC , typename Derivedcounts $>$ }\\void \mbox{\hyperlink{namespaceigl_a0320b3e4f5075ce62360f96080b57a92}{facet\+\_\+components}} (const std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&TT, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derivedcounts $>$ \&counts)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_a772265419ff3f9f3c3716644191fa4ff}{false\+\_\+barycentric\+\_\+subdivision}} (const Eigen\+::\+Plain\+Object\+Base$<$ Scalar $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ Index $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Scalar $>$ \&VD, Eigen\+::\+Plain\+Object\+Base$<$ Index $>$ \&FD)
\begin{DoxyCompactList}\small\item\em Refine the mesh by adding the barycenter of each face. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+V1 , typename Derived\+F1 , typename Derived\+V2 , typename Derived\+F2 , typename DerivedI , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a30b7f81580d0eb77cfa387adaa4e9c67}{fast\+\_\+find\+\_\+intersections}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+V1 $>$ \&V1, const Eigen\+::\+Matrix\+Base$<$ Derived\+F1 $>$ \&F1, const Eigen\+::\+Matrix\+Base$<$ Derived\+V2 $>$ \&V2, const Eigen\+::\+Matrix\+Base$<$ Derived\+F2 $>$ \&F2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&intersect\+\_\+pairs, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&\mbox{\hyperlink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}})
\begin{DoxyCompactList}\small\item\em Identify triangles where two meshes interesect using AABBTree and tri\+\_\+tri\+\_\+intersection\+\_\+test\+\_\+3d. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+V1 , typename Derived\+F1 , typename Derived\+V2 , typename Derived\+F2 , typename DerivedI , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a768af49174bc1daafe45f9eedda6eb8f}{fast\+\_\+find\+\_\+intersections}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ Derived\+V1, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ Derived\+V1 $>$ \&V1, const Eigen\+::\+Matrix\+Base$<$ Derived\+F1 $>$ \&F1, const Eigen\+::\+Matrix\+Base$<$ Derived\+V2 $>$ \&V2, const Eigen\+::\+Matrix\+Base$<$ Derived\+F2 $>$ \&F2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&intersect\+\_\+pairs, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&\mbox{\hyperlink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a2f1a7f1d5201633025a2ac99846b1b78}{fast\+\_\+find\+\_\+self\+\_\+intersections}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&\mbox{\hyperlink{namespaceigl_a4f72acbb659a5c1d291a4cff36910a87}{intersect}}, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&\mbox{\hyperlink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}})
\begin{DoxyCompactList}\small\item\em Identify triangles where mesh intersects itself using AABBTree and tri\+\_\+tri\+\_\+intersection\+\_\+test\+\_\+3d. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa607a0b8a29847a27f3e92685a652d51}{fast\+\_\+find\+\_\+self\+\_\+intersections}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&\mbox{\hyperlink{namespaceigl_a4f72acbb659a5c1d291a4cff36910a87}{intersect}})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename Derived\+CH , typename Derived\+CM , typename DerivedR , typename Derived\+EC $>$ }\\void \mbox{\hyperlink{namespaceigl_af9a50987fefc0df065fb3e2cde90c92e}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&point\+\_\+indices, const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&CH, const int expansion\+\_\+order, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CM $>$ \&CM, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EC $>$ \&EC)
\begin{DoxyCompactList}\small\item\em Generate the precomputation for the fast winding number for point data \mbox{[}Barill et. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename Derived\+CH , typename Derived\+CM , typename DerivedR , typename Derived\+EC , typename DerivedQ , typename Beta\+Type , typename Derived\+WN $>$ }\\void \mbox{\hyperlink{namespaceigl_a9f25aa098c2a53832cc8d86022bf0691}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&point\+\_\+indices, const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&CH, const Eigen\+::\+Matrix\+Base$<$ Derived\+CM $>$ \&CM, const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Matrix\+Base$<$ Derived\+EC $>$ \&EC, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, const Beta\+Type beta, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&WN)
\begin{DoxyCompactList}\small\item\em Evaluate the fast winding number for point data, having already done the the precomputation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename Beta\+Type , typename Derived\+WN $>$ }\\void \mbox{\hyperlink{namespaceigl_a397e83be466a676e5e932eb176222024}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, const int expansion\+\_\+order, const Beta\+Type beta, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&WN)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename Derived\+WN $>$ }\\void \mbox{\hyperlink{namespaceigl_ad8da00864c2893af6726906818520d94}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&WN)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedQ , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_ab8c8f607d6379a200ca2b06d48a177c7}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Compute approximate winding number of a triangle soup mesh according to "{}\+Fast Winding Numbers for Soups and Clouds"{} \mbox{[}Barill et al. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a903c781c6e83ef8f7cf2f8791a603cff}{fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int order, Fast\+Winding\+Number\+BVH \&fwn\+\_\+bvh)
\begin{DoxyCompactList}\small\item\em Precomputation for computing approximate winding numbers of a triangle soup. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedQ , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_a82cd97bb9dcfdb31036cb2d61a8feec7}{fast\+\_\+winding\+\_\+number}} (const Fast\+Winding\+Number\+BVH \&fwn\+\_\+bvh, const float accuracy\+\_\+scale, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em After precomputation, compute winding number at a each of many points in a list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedp $>$ }\\Derivedp\+::\+Scalar \mbox{\hyperlink{namespaceigl_a3142103ed9b3cdf64d5a81fbaa34dc4c}{fast\+\_\+winding\+\_\+number}} (const Fast\+Winding\+Number\+BVH \&fwn\+\_\+bvh, const float accuracy\+\_\+scale, const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&p)
\begin{DoxyCompactList}\small\item\em After precomputation, compute winding number at a single point. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a740022c998c2a894e28fb49bb7ed4d24}{file\+\_\+contents\+\_\+as\+\_\+string}} (const std\+::string file\+\_\+name, std\+::string \&content)
\begin{DoxyCompactList}\small\item\em Read a files contents as plain text into a given string. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_a555b9d7f83d39b3fc2dee6eabb79c0ec}{file\+\_\+contents\+\_\+as\+\_\+string}} (const std\+::string file\+\_\+name)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_a784c417892e831c40ced7805b23be275}{file\+\_\+dialog\+\_\+open}} ()
\begin{DoxyCompactList}\small\item\em Open a file dialog to select a file. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_a85f585cff929022ed45d00faee99eea3}{file\+\_\+dialog\+\_\+save}} ()
\begin{DoxyCompactList}\small\item\em Open a file dialog to select a file. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a63e14036599fdc6d4f6706d26a542e92}{file\+\_\+exists}} (const std\+::string filename)
\begin{DoxyCompactList}\small\item\em Check if a file or directory exists like PHP\textquotesingle{}s file\+\_\+exists function\+: \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename DerivedI , typename DerivedJ , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_ad0ba264f987871035fb7d12de96fccab}{find}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X, Eigen\+::\+Dense\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Dense\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Dense\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em Find the non-\/zero entries and there respective indices in a sparse matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ Eigen\+::\+Triplet$<$ T $>$ $>$ \mbox{\hyperlink{namespaceigl_a7ed5d2d6c493023192c2b2f1c5ed0bf0}{find}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedI , typename DerivedJ , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_a2f6c699f94449b23813f0d80df36db8e}{find}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a1c874cf1ad179744026898ded3da4ea7}{find}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_ab6758ca13380f9bd099c860aba705d45}{find}} (const Eigen\+::\+Sparse\+Vector$<$ T $>$ \&X, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&I, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&V)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Rows\+At\+Compile\+Time, int Max\+Rows\+At\+Compile\+Time$>$ }\\std\+::vector$<$ int $>$ \mbox{\hyperlink{namespaceigl_a35cd54b6c6bf02c39e4caf02782fcfbc}{find}} (const Eigen\+::\+Array$<$ bool, Rows\+At\+Compile\+Time, 1, 0, Max\+Rows\+At\+Compile\+Time, 1 $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO $>$ }\\void \mbox{\hyperlink{namespaceigl_abb0edb6d4f1aed375b757bdc5c273246}{find\+\_\+cross\+\_\+field\+\_\+singularities}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&mismatch, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&is\+Singularity, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&singularity\+Index)
\begin{DoxyCompactList}\small\item\em Computes singularities of a cross field, assumed combed. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedO $>$ }\\void \mbox{\hyperlink{namespaceigl_a6081a94201c4aee0d64d44fb108b82b3}{find\+\_\+cross\+\_\+field\+\_\+singularities}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD1, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&PD2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&is\+Singularity, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&singularity\+Index, bool is\+Combed=false)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a805390aaedf0c7993e52697b46e85be8}{find\+\_\+zero}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Find the first zero (whether implicit or explicitly stored) in the rows/columns of a matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a7e61e6506e142c21944010806e350df3}{fit\+\_\+cubic\+\_\+bezier}} (const Eigen\+::\+Matrix\+Xd \&d, const double error, std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&cubics)
\begin{DoxyCompactList}\small\item\em Fit a cubic bezier spline (G1 continuous) to an ordered list of input points in any dimension, according to "{}\+An algorithm for automatically fitting digitized curves"{} \mbox{[}Schneider 1990\mbox{]}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a30fbe8999a386dbd7193683db1ed7ea7}{fit\+\_\+cubic\+\_\+bezier\+\_\+substring}} (const Eigen\+::\+Matrix\+Xd \&d, const int first, const int last, const Eigen\+::\+Row\+Vector\+Xd \&t\+Hat1, const Eigen\+::\+Row\+Vector\+Xd \&t\+Hat2, const double error, const bool force\+\_\+split, std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&cubics)
\begin{DoxyCompactList}\small\item\em Recursive helper function for fit\+\_\+cubic\+\_\+bezier. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_ade7e5fc6b5fac0540a715a429d1196da}{fit\+\_\+plane}} (const Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Row\+Vector3d \&N, Eigen\+::\+Row\+Vector3d \&C)
\begin{DoxyCompactList}\small\item\em Fit a plane to a point cloud. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_aab9cbb962b540c16acdca0c7d168345d}{fit\+\_\+rotations}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, const bool single\+\_\+precision, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&R)
\begin{DoxyCompactList}\small\item\em Given an input mesh and new positions find rotations for every covariance matrix in a stack of covariance matrices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_ac84591b34ac42f8f958c015edabec2d6}{fit\+\_\+rotations\+\_\+planar}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&R)
\begin{DoxyCompactList}\small\item\em Given an input mesh and new positions find 2D rotations for every vertex that best maps its one ring to the new one ring. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespaceigl_ae63ab7ae87908c83fc544443d41b87e5}{flip\+\_\+avoiding\+\_\+line\+\_\+search}} (const Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Matrix\+Xd \&cur\+\_\+v, const Eigen\+::\+Matrix\+Xd \&dst\+\_\+v, std\+::function$<$ double(Eigen\+::\+Matrix\+Xd \&)$>$ \&energy, double cur\+\_\+energy=-\/1)
\begin{DoxyCompactList}\small\item\em A bisection line search for a mesh based energy that avoids triangle flips as suggested in "{}\+Bijective Parameterization with Free Boundaries"{} (Smith J. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType $>$ }\\void \mbox{\hyperlink{namespaceigl_ac891db77f570329431e6c333c3d08b26}{flip\+\_\+edge}} (Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, const size\+\_\+t uei)
\begin{DoxyCompactList}\small\item\em Flip an edge in a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedX $>$ }\\void \mbox{\hyperlink{namespaceigl_a6f82175bae9b6801c8c9012785317f2a}{flipped\+\_\+triangles}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X)
\begin{DoxyCompactList}\small\item\em Finds the ids of the flipped triangles of the mesh V,F in the UV mapping uv. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\Eigen\+::\+Vector\+Xi \mbox{\hyperlink{namespaceigl_a20a1df627820c7b21a02a7ec429af4e7}{flipped\+\_\+triangles}} (const Eigen\+::\+Matrix\+Base$<$ Scalar $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ Index $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedres , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_ac512b1b084fa118f737ffc49db7a5ba6}{flood\+\_\+fill}} (const Eigen\+::\+Matrix\+Base$<$ Derivedres $>$ \&res, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Given a 3D array with sparse non-\/nan (number?) data fill in the Na\+Ns via flood fill. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a52b113177cc099be08ae55cad66b4dcb}{floor}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Floor a given matrix to nearest integers. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename Func $>$ }\\void \mbox{\hyperlink{namespaceigl_a09311547ed4f12bee75c2631d2d19bfd}{for\+\_\+each}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const Func \&func)
\begin{DoxyCompactList}\small\item\em FOR\+\_\+\+EACH Call a given function for each non-\/zero (i.\+e., explicit value might actually be ==0) in a Sparse Matrix A {\itshape in order (of storage)}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename Func $>$ }\\void \mbox{\hyperlink{namespaceigl_a99ebd81ebaff178e507beedf87766722}{for\+\_\+each}} (const Eigen\+::\+Dense\+Base$<$ DerivedA $>$ \&A, const Func \&func)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a583ee685a22b43577be16d088b6d3f29}{forward\+\_\+kinematics}} (const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&BE, const Eigen\+::\+Vector\+Xi \&P, const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&dQ, const std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&dT, std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&vQ, std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&vT)
\begin{DoxyCompactList}\small\item\em Given a skeleton and a set of relative bone rotations compute absolute rigid transformations for each bone. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a4346a6b4e9b7d07955fe6ab59399e82e}{forward\+\_\+kinematics}} (const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&BE, const Eigen\+::\+Vector\+Xi \&P, const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&dQ, std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&vQ, std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&vT)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a9be847e42a2d294cdb9014c5b04d5649}{forward\+\_\+kinematics}} (const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&BE, const Eigen\+::\+Vector\+Xi \&P, const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&dQ, const std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&dT, Eigen\+::\+Matrix\+Xd \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_adedacc380a9c0e97fcb830413a407aee}{forward\+\_\+kinematics}} (const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&BE, const Eigen\+::\+Vector\+Xi \&P, const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&dQ, Eigen\+::\+Matrix\+Xd \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a2da75428de04db095ad2b8c01861d9e7}{frame\+\_\+field\+\_\+deformer}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xd \&FF1, const Eigen\+::\+Matrix\+Xd \&FF2, Eigen\+::\+Matrix\+Xd \&V\+\_\+d, Eigen\+::\+Matrix\+Xd \&FF1\+\_\+d, Eigen\+::\+Matrix\+Xd \&FF2\+\_\+d, const int iterations=50, const double lambda=0.\+1, const bool perturb\+\_\+initial\+\_\+guess=true)
\begin{DoxyCompactList}\small\item\em Deform a mesh to transform the given per-\/face frame field to be as close as possible to a cross field, in the least square sense. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a9b1822be03089dbefc97ae0274f7f744}{frame\+\_\+to\+\_\+cross\+\_\+field}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xd \&FF1, const Eigen\+::\+Matrix\+Xd \&FF2, Eigen\+::\+Matrix\+Xd \&X)
\begin{DoxyCompactList}\small\item\em Convert a frame field into its closest cross field. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_acd2f248b52f9534c49484e76be8aa0bc}{frustum}} (const typename Derived\+P\+::\+Scalar left, const typename Derived\+P\+::\+Scalar right, const typename Derived\+P\+::\+Scalar bottom, const typename Derived\+P\+::\+Scalar top, const typename Derived\+P\+::\+Scalar near\+Val, const typename Derived\+P\+::\+Scalar far\+Val, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Implementation of the deprecated gl\+Frustum function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_ad31a0406b0fb32f5345361442c0e85c9}{gaussian\+\_\+curvature}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Compute the 2 minus the sum of interior angles at each vertex. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceigl_a60bbc303acee156af52ab587c4680502}{DEFAULT\+\_\+\+URBG}} \mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{generate\+\_\+default\+\_\+urbg}} ()
\item 
double \mbox{\hyperlink{namespaceigl_a14a7a848b8b1eb296b5c8b80efc05efc}{get\+\_\+seconds}} ()
\begin{DoxyCompactList}\small\item\em Current time in seconds. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_afc61afb5c46c76e8be9fcca2e4783d53}{grad}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ typename Derived\+V\+::\+Scalar $>$ \&G, bool uniform=false)
\begin{DoxyCompactList}\small\item\em Gradient operator on a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedF , typename Gtype $>$ }\\void \mbox{\hyperlink{namespaceigl_ae277a1d4cf02f1612ad3c7bb47fc93f7}{grad\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Gtype $>$ \&G)
\begin{DoxyCompactList}\small\item\em Construct an intrinsic gradient operator. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedres , typename Derived\+GV $>$ }\\void \mbox{\hyperlink{namespaceigl_adfb4bab2b437369dce2059e85836bd9a}{grid}} (const Eigen\+::\+Matrix\+Base$<$ Derivedres $>$ \&res, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&GV)
\begin{DoxyCompactList}\small\item\em Construct vertices of a regular grid, suitable for input to {\ttfamily \doxylink{namespaceigl_a3e677970b7188cac95bc9f93181f2ed7}{igl\+::marching\+\_\+cubes}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB , typename DerivedI $>$ }\\Scalar \mbox{\hyperlink{namespaceigl_a9a189dbba012d12c812bb7b0970b4ab9}{grid\+\_\+search}} (const std\+::function$<$ Scalar(DerivedX \&) $>$ f, const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&LB, const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&UB, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, DerivedX \&X)
\begin{DoxyCompactList}\small\item\em Global optimization via grid search. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_af3d530c8efa1612e1bb3aa180064451d}{group\+\_\+sum\+\_\+matrix}} (const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&G, const int k, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A)
\begin{DoxyCompactList}\small\item\em Builds a matrix A such that A\texorpdfstring{$\ast$}{*}V computes the sum of vertices in each group specified by G. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a3ef361caeca0b62001b9d59df11b5c06}{group\+\_\+sum\+\_\+matrix}} (const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&G, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a229749fb9c004cc9a77f83a4c1881adb}{guess\+\_\+extension}} (FILE \texorpdfstring{$\ast$}{*}fp, std\+::string \&guess)
\begin{DoxyCompactList}\small\item\em Given a file pointer at the beginning of a "{}mesh"{} file, try to guess the extension of the file format it comes from. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_ab79410fbbb723767aecc21edcc5941cb}{guess\+\_\+extension}} (FILE \texorpdfstring{$\ast$}{*}fp)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_a5ade90c5c56252e2c88f4452996c50a0}{harmonic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, const int k, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Compute k-\/harmonic weight functions "{}coordinates"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_ac3baf24e87966423e7c6dac58f40c406}{harmonic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, const int k, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename DerivedM , typename Derivedb , typename Derivedbc , typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_a720d55d920ca7659102fd8dd267e7936}{harmonic}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedL $>$ \&L, const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedM $>$ \&M, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, const int k, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Compute a harmonic map using a given Laplacian and mass matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename DerivedM , typename DerivedQ $>$ }\\void \mbox{\hyperlink{namespaceigl_aba39f8e29962d636cfae080188ec1da7}{harmonic}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedL $>$ \&L, const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedM $>$ \&M, const int k, DerivedQ \&Q)
\begin{DoxyCompactList}\small\item\em Build the discrete k-\/harmonic operator (computing integrated quantities). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedQ $>$ }\\void \mbox{\hyperlink{namespaceigl_accdfdc1795f3cd0fbf66aeb3ca316604}{harmonic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int k, DerivedQ \&Q)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_a073322f93d4fd2e161868d738abdfc09}{harwell\+\_\+boeing}} (const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&A, int \&num\+\_\+rows, std\+::vector$<$ Scalar $>$ \&V, std\+::vector$<$ Index $>$ \&R, std\+::vector$<$ Index $>$ \&C)
\begin{DoxyCompactList}\small\item\em Convert the matrix to Compressed sparse column (CSC or CCS) format, also known as Harwell Boeing format. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a64901d7f496bd1cccbccceddbc091603}{hausdorff}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&VA, const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&FA, const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&VB, const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&FB, Scalar \&d)
\begin{DoxyCompactList}\small\item\em Compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a3de06347c75f90acb8cc0114c7249e58}{hausdorff}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const std\+::function$<$ Scalar(const Scalar \&, const Scalar \&, const Scalar \&)$>$ \&dist\+\_\+to\+\_\+B, Scalar \&l, Scalar \&u)
\begin{DoxyCompactList}\small\item\em Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.\+g., mesh, triangle soup) given by a distance function handle (dist\+\_\+to\+\_\+B). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_affbddd3e363a529044cd4bd848b278f4}{heat\+\_\+geodesics\+\_\+precompute}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, \mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}$<$ Scalar $>$ \&data)
\begin{DoxyCompactList}\small\item\em Precompute factorized solvers for computing a fast approximation of geodesic distances on a mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_a12efa6b8fc863b52dd131d478a456802}{heat\+\_\+geodesics\+\_\+precompute}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Scalar t, \mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}$<$ Scalar $>$ \&data)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Derivedgamma , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_ae558cd690e05ad2e41caa655251e23c4}{heat\+\_\+geodesics\+\_\+solve}} (const \mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}$<$ Scalar $>$ \&data, const Eigen\+::\+Matrix\+Base$<$ Derivedgamma $>$ \&gamma, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em Compute fast approximate geodesic distances using precomputed data from a set of selected source vertices (gamma). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a8e6dbdaae94657379ac8491942082d20}{hessian}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&H)
\begin{DoxyCompactList}\small\item\em Constructs the finite element Hessian matrix as described in \href{https://arxiv.org/abs/1707.04348}{\texttt{ https\+://arxiv.\+org/abs/1707.\+04348}}, Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) The interior vertices are NOT set to zero yet. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a5d3d292215a6020d9e70cd7cfdd29ec1}{hessian\+\_\+energy}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Constructs the Hessian energy matrix using mixed FEM as described in \href{https://arxiv.org/abs/1707.04348}{\texttt{ https\+://arxiv.\+org/abs/1707.\+04348}} Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedE , typename DerivedN , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_a7e66c7ad3404c4e5a43a2ecaf1c21819}{histc}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Count occurrences of values in X between consecutive entries in E. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedE , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_af74c4ce0e45c4fc1ab9e958c93ef4437}{histc}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a946a214630848d43ddc7df74e00f4d57}{histc}} (const typename Derived\+E\+::\+Scalar \&x, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, typename Derived\+E\+::\+Index \&b)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a840674ca4222700909ca8197e27800a5}{hsv\+\_\+to\+\_\+rgb}} (const T \texorpdfstring{$\ast$}{*}hsv, T \texorpdfstring{$\ast$}{*}rgb)
\begin{DoxyCompactList}\small\item\em Convert RGB to HSV. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a67a8efe9fd3b48830cd07fd2fb45ece6}{hsv\+\_\+to\+\_\+rgb}} (const T \&h, const T \&s, const T \&v, T \&r, T \&g, T \&b)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedH , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_a3e2573040155e553e83f6b2098417ed2}{hsv\+\_\+to\+\_\+rgb}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedH $>$ \&H, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a91986768165db4e2fe4f6541db3a100e}{icosahedron}} (Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\item 
{\footnotesize template$<$typename DerivedV , typename DerivedQ , int DIM$>$ }\\void \mbox{\hyperlink{namespaceigl_ae6a48ea815ed7c6fce66c5fb16643592}{in\+\_\+element}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Xi \&Ele, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, DIM $>$ \&aabb, Eigen\+::\+Vector\+Xi \&I)
\begin{DoxyCompactList}\small\item\em Determine whether each point in a list of points is in the elements of a mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedQ , int DIM, typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a1cc28747ccc281b8790d1ec2a07daf42}{in\+\_\+element}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Xi \&Ele, const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, DIM $>$ \&aabb, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived $>$ }\\void \mbox{\hyperlink{namespaceigl_ac35f10d1dc8993c19f76b5c2ba6c48e7}{increment\+\_\+ulp}} (Eigen\+::\+Matrix\+Base$<$ Derived $>$ \&inout, int it)
\begin{DoxyCompactList}\small\item\em Increment Unit in Last Place of a matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a0cba56449805461c9713bc29b8ebcc79}{infinite\+\_\+cost\+\_\+stopping\+\_\+condition}} (const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement, \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&stopping\+\_\+condition)
\begin{DoxyCompactList}\small\item\em Stopping condition function compatible with \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \mbox{\hyperlink{namespaceigl_a6f95773129e4cd1a29171858e1f313b5}{infinite\+\_\+cost\+\_\+stopping\+\_\+condition}} (const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&cost\+\_\+and\+\_\+placement)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_a461e3490769bd9ac20f48a0179f58b0f}{inradius}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em Compute the inradius of each triangle in a mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_a748a89868e9e150c9d02736c6f304318}{internal\+\_\+angles}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Compute internal angles for a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_a42cf87a6db6ebff753475465b9e0a6f3}{internal\+\_\+angles\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&L\+\_\+sq, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Compute internal angles for a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$class M $>$ }\\void \mbox{\hyperlink{namespaceigl_a4f72acbb659a5c1d291a4cff36910a87}{intersect}} (const M \&A, const M \&B, M \&C)
\begin{DoxyCompactList}\small\item\em Determine the intersect between two sets of coefficients using ==. \end{DoxyCompactList}\item 
{\footnotesize template$<$class M $>$ }\\M \mbox{\hyperlink{namespaceigl_a41a6a9d793818a4836de7c3faa524e26}{intersect}} (const M \&A, const M \&B)
\begin{DoxyCompactList}\small\item\em overload \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar , typename Derivedl\+\_\+intrinsic , typename Derived\+F\+\_\+intrinsic $>$ }\\void \mbox{\hyperlink{namespaceigl_a6173f608f5bae73866cc21f0159562dc}{intrinsic\+\_\+delaunay\+\_\+cotmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ Derivedl\+\_\+intrinsic $>$ \&l\+\_\+intrinsic, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F\+\_\+intrinsic $>$ \&F\+\_\+intrinsic)
\begin{DoxyCompactList}\small\item\em Computes the discrete cotangent Laplacian of a mesh after converting it into its intrinsic Delaunay triangulation (see, e.\+g., \mbox{[}Fisher et al. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_ab774229e4511d5f186a394c39f813d2f}{intrinsic\+\_\+delaunay\+\_\+cotmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&L)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl\+\_\+in , typename Derived\+F\+\_\+in , typename Derivedl , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_abf4975f69822136269d681f02b2c3279}{intrinsic\+\_\+delaunay\+\_\+triangulation}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl\+\_\+in $>$ \&l\+\_\+in, const Eigen\+::\+Matrix\+Base$<$ Derived\+F\+\_\+in $>$ \&F\+\_\+in, Eigen\+::\+Plain\+Object\+Base$<$ Derivedl $>$ \&l, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em INTRINSIC\+\_\+\+DELAUNAY\+\_\+\+TRIANGULATION Flip edges {\itshape intrinsically} until all are "{}intrinsic Delaunay"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl\+\_\+in , typename Derived\+F\+\_\+in , typename Derivedl , typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType $>$ }\\void \mbox{\hyperlink{namespaceigl_a6c0bd085d3b95f40fe92ef1c75f6ad32}{intrinsic\+\_\+delaunay\+\_\+triangulation}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl\+\_\+in $>$ \&l\+\_\+in, const Eigen\+::\+Matrix\+Base$<$ Derived\+F\+\_\+in $>$ \&F\+\_\+in, Eigen\+::\+Plain\+Object\+Base$<$ Derivedl $>$ \&l, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename MatY $>$ }\\void \mbox{\hyperlink{namespaceigl_ad6fc59b895f5ad4472ca15758fd947b5}{invert\+\_\+diag}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedX $>$ \&X, MatY \&Y)
\begin{DoxyCompactList}\small\item\em Invert the diagonal entries of a matrix (if the matrix is a diagonal matrix then this amounts to inverting the matrix) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF $>$ }\\std\+::vector$<$ bool $>$ \mbox{\hyperlink{namespaceigl_addf49f5f7e92069382f5607639d92555}{is\+\_\+border\+\_\+vertex}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Determine vertices on open boundary of a (manifold) mesh with triangle faces F. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_a39d02bea0e57dce707ada6bc3228d22a}{is\+\_\+boundary\+\_\+edge}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Determine for each edge E if it is a "{}boundary edge"{} in F. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DerivedB , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_a2687ea500d0a998cf01ab3ff7456ba25}{is\+\_\+boundary\+\_\+edge}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_a8670d8afa68524c4d0e4745faa89efc7}{is\+\_\+delaunay}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em IDetermine if each edge in the mesh (V,F) is Delaunay. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename u\+E2\+EType , typename In\+Circle , typename uei\+Type $>$ }\\bool \mbox{\hyperlink{namespaceigl_ae3e60388b9f45015b2d555acf24b9b4e}{is\+\_\+delaunay}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, const In\+Circle incircle, const uei\+Type uei)
\begin{DoxyCompactList}\small\item\em Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_acc2105d7b15672349f4662a1c77ea4d5}{is\+\_\+dir}} (const char \texorpdfstring{$\ast$}{*}filename)
\begin{DoxyCompactList}\small\item\em Tells whether the given filename is a directory. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_ab086008065bab7abde580f8bdea5d156}{is\+\_\+edge\+\_\+manifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Check if the mesh is edge-\/manifold (every edge is incident one one face (boundary) or two oppositely oriented faces). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+BF , typename DerivedE , typename Derived\+EMAP , typename Derived\+BE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a7d04d883ce83ec8376b7eb4f22db6f03}{is\+\_\+edge\+\_\+manifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&BF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BE $>$ \&BE)
\begin{DoxyCompactList}\small\item\em Checks if mesh is edge-\/manifold and outputs per-\/edge info. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+EMAP , typename Derived\+BF , typename Derived\+BE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a1bd5dfc80e3180cb9f8cfbeb0049c2b5}{is\+\_\+edge\+\_\+manifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+F\+::\+Index ne, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&BF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BE $>$ \&BE)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a5d660daa58e9ec65ac1756adc4b61454}{is\+\_\+file}} (const char \texorpdfstring{$\ast$}{*}filename)
\begin{DoxyCompactList}\small\item\em Tells whether the given filename is a regular file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedF , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_a95a946e409259bd08727637f7fd15b74}{is\+\_\+intrinsic\+\_\+delaunay}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em Determine if each edge in the mesh (V,F) is Delaunay. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedF , typename u\+E2\+EType , typename DerivedD $>$ }\\void \mbox{\hyperlink{namespaceigl_ada6b3f9347053522b1fc5da210be1968}{is\+\_\+intrinsic\+\_\+delaunay}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename u\+E2\+EType , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_ae63e0780a4c5344cbafb31919f77bd0a}{is\+\_\+intrinsic\+\_\+delaunay}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, const Index num\+\_\+faces, const Index uei)
\begin{DoxyCompactList}\small\item\em Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF $>$ }\\std\+::vector$<$ bool $>$ \mbox{\hyperlink{namespaceigl_a05f076e50c33c9998c7f9c9559ed36e0}{is\+\_\+irregular\+\_\+vertex}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Determine if a vertex is irregular, i.\+e. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_aedd09a46e564a0d19ae4f97891b95de9}{is\+\_\+planar}} (const Eigen\+::\+Matrix\+Xd \&V)
\begin{DoxyCompactList}\small\item\em Determine if a set of points lies on the XY plane. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a036d4412fb94156420eff091457a73b3}{is\+\_\+readable}} (const char \texorpdfstring{$\ast$}{*}filename)
\begin{DoxyCompactList}\small\item\em Check if a file is reabable like PHP\textquotesingle{}s is\+\_\+readable function\+: \href{http://www.php.net/manual/en/function.is-readable.php}{\texttt{ http\+://www.\+php.\+net/manual/en/function.\+is-\/readable.\+php}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad7968d06fbb2bcb8b64f707ec4b29f87}{is\+\_\+sparse}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A)
\begin{DoxyCompactList}\small\item\em Determine if a matrix A is sparse. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA $>$ }\\bool \mbox{\hyperlink{namespaceigl_a910c84c58fdea4379d5e0ff34588ffe6}{is\+\_\+sparse}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a1f40e6e779275ad817df4c8d1ac22aa6}{is\+\_\+stl}} (FILE \texorpdfstring{$\ast$}{*}stl\+\_\+file, bool \&is\+\_\+ascii)
\begin{DoxyCompactList}\small\item\em Given a file pointer, determine if it contains an .stl file and then rewind it. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a623b66ea2a39ba8c09f3c72599272562}{is\+\_\+stl}} (FILE \texorpdfstring{$\ast$}{*}stl\+\_\+file)
\item 
{\footnotesize template$<$typename AT $>$ }\\bool \mbox{\hyperlink{namespaceigl_a4f840791a21ca650ec1d68910c3ec900}{is\+\_\+symmetric}} (const Eigen\+::\+Sparse\+Matrix$<$ AT $>$ \&A)
\begin{DoxyCompactList}\small\item\em Returns true if the given matrix is symmetric. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AT , typename epsilonT $>$ }\\bool \mbox{\hyperlink{namespaceigl_a819c37589176cb7dde8fb52796314fc3}{is\+\_\+symmetric}} (const Eigen\+::\+Sparse\+Matrix$<$ AT $>$ \&A, const epsilonT epsilon)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA $>$ }\\bool \mbox{\hyperlink{namespaceigl_a00ac1f26b40979584dfa370cee528d71}{is\+\_\+symmetric}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedB $>$ }\\bool \mbox{\hyperlink{namespaceigl_abd0dbef9a4a2738b2c33de0cb6938bfb}{is\+\_\+vertex\+\_\+manifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Check if a mesh is vertex-\/manifold. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a081c3e366717287e1be24e695b5b034e}{is\+\_\+vertex\+\_\+manifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a6584dca7db2b1e9f2601973c2609e6c1}{is\+\_\+writable}} (const char \texorpdfstring{$\ast$}{*}filename)
\begin{DoxyCompactList}\small\item\em Check if a file exists {\itshape and} is writable like PHP\textquotesingle{}s is\+\_\+writable function\+: \href{http://www.php.net/manual/en/function.is-writable.php}{\texttt{ http\+://www.\+php.\+net/manual/en/function.\+is-\/writable.\+php}}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived $>$ }\\bool \mbox{\hyperlink{namespaceigl_a28fb666256b9e2c9aa5bd79cbfb5397b}{isdiag}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ Derived $>$ \&A)
\begin{DoxyCompactList}\small\item\em Determine if a given matrix is diagonal\+: all non-\/zeros lie on the main diagonal. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename Derived\+IA , typename Derived\+LOCB $>$ }\\void \mbox{\hyperlink{namespaceigl_a3b1dfc725b9f364c46cc835853c4d154}{ismember}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+LOCB $>$ \&LOCB)
\begin{DoxyCompactList}\small\item\em Determine if elements of A exist in elements of B. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename Derived\+IA , typename Derived\+LOCB $>$ }\\void \mbox{\hyperlink{namespaceigl_a22eecc8e676dfea634eedb0f1121ed88}{ismember\+\_\+rows}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+LOCB $>$ \&LOCB)
\begin{DoxyCompactList}\small\item\em Determine if row of A exist in rows of B. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediV , typename DerivediE , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a24e807a90c41e3a89ee0171b1518c27d}{isolines}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ Derivedvals $>$ \&vals, Eigen\+::\+Plain\+Object\+Base$<$ DerivediV $>$ \&iV, Eigen\+::\+Plain\+Object\+Base$<$ DerivediE $>$ \&iE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Compute isolines of a scalar field on a triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediB , typename Derivedi\+FI , typename DerivediE , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a616f5985cbb36acb190f207f9dff82df}{isolines\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ Derivedvals $>$ \&vals, Eigen\+::\+Plain\+Object\+Base$<$ DerivediB $>$ \&iB, Eigen\+::\+Plain\+Object\+Base$<$ Derivedi\+FI $>$ \&i\+FI, Eigen\+::\+Plain\+Object\+Base$<$ DerivediE $>$ \&iE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Compute isolines of a scalar field on a triangle mesh intrinsically. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedS , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivediB , typename Derivedi\+FI , typename DerivediE $>$ }\\void \mbox{\hyperlink{namespaceigl_a276bde6ae2e23fb1811ec18a353b15be}{isolines\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&u\+EE, const typename Derived\+S\+::\+Scalar val, Eigen\+::\+Plain\+Object\+Base$<$ DerivediB $>$ \&iB, Eigen\+::\+Plain\+Object\+Base$<$ Derivedi\+FI $>$ \&i\+FI, Eigen\+::\+Plain\+Object\+Base$<$ DerivediE $>$ \&iE)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+CM , typename Derivediso\+\_\+color , typename Derived\+ICM $>$ }\\void \mbox{\hyperlink{namespaceigl_ac262ba447b16b5edccade00d31f39722}{isolines\+\_\+map}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+CM $>$ \&CM, const Eigen\+::\+Matrix\+Base$<$ Derivediso\+\_\+color $>$ \&iso\+\_\+color, const int interval\+\_\+thickness, const int iso\+\_\+thickness, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ICM $>$ \&ICM)
\begin{DoxyCompactList}\small\item\em Inject a given colormap with evenly spaced isolines. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+CM , typename Derived\+ICM $>$ }\\void \mbox{\hyperlink{namespaceigl_a807d847189eeb2aa93fb387f81452494}{isolines\+\_\+map}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+CM $>$ \&CM, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ICM $>$ \&ICM)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VX , typename Derived\+FX , typename Derived\+VY , typename Derived\+FY , typename DerivedR , typename Derivedt $>$ }\\void \mbox{\hyperlink{namespaceigl_aa7b2dbd6e4ee3d5ca15dd5dce9928453}{iterative\+\_\+closest\+\_\+point}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VX $>$ \&VX, const Eigen\+::\+Matrix\+Base$<$ Derived\+FX $>$ \&FX, const Eigen\+::\+Matrix\+Base$<$ Derived\+VY $>$ \&VY, const Eigen\+::\+Matrix\+Base$<$ Derived\+FY $>$ \&FY, const int num\+\_\+samples, const int max\+\_\+iters, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&t)
\begin{DoxyCompactList}\small\item\em Solve for the rigid transformation that places mesh X onto mesh Y using the iterative closest point method. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+VX , typename Derived\+FX , typename Derived\+VY , typename Derived\+FY , typename Derived\+NY , typename DerivedR , typename Derivedt $>$ }\\void \mbox{\hyperlink{namespaceigl_a1cd54b56f1bb183ab3898eb0e78949da}{iterative\+\_\+closest\+\_\+point}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+VX $>$ \&VX, const Eigen\+::\+Matrix\+Base$<$ Derived\+FX $>$ \&FX, const Eigen\+::\+Matrix\+Base$<$ Derived\+VY $>$ \&VY, const Eigen\+::\+Matrix\+Base$<$ Derived\+FY $>$ \&FY, const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ Derived\+VY, 3 $>$ \&Ytree, const Eigen\+::\+Matrix\+Base$<$ Derived\+NY $>$ \&NY, const int num\+\_\+samples, const int max\+\_\+iters, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&t)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a86feeac6e40d21e10cc147d82782000a}{jet}} (const T f, T \texorpdfstring{$\ast$}{*}rgb)
\begin{DoxyCompactList}\small\item\em Jet colormap like MATLAB\textquotesingle{}s jet. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a7b40235bb5881e629930f522e5f3ee1a}{jet}} (const T f, T \&r, T \&g, T \&b)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedZ , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a495fc46dda1dad8354b6aa9f9f146c89}{jet}} (const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, const bool normalize, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedZ , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a5ecfd839e37628b61641d0e766eaf12b}{jet}} (const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, const double min\+\_\+Z, const double max\+\_\+Z, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derivedx0 , typename Derivedf , typename DerivedF , typename DerivedU $>$ }\\void \mbox{\hyperlink{namespaceigl_a0a85e70cd58bcb5ebb5b36ef4a010fde}{kelvinlets}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ Derivedx0 $>$ \&x0, const Eigen\+::\+Matrix\+Base$<$ Derivedf $>$ \&f, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{structigl_1_1KelvinletParams}{Kelvinlet\+Params}}$<$ typename Derived\+V\+::\+Scalar $>$ \&params, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em Implements Pixar\textquotesingle{}s Regularized Kelvinlets (Pixar Technical Memo \#17-\/03)\+: Sculpting Brushes based on Fundamental Solutions of Elasticity, a technique for real-\/time physically based volume sculpting of virtual elastic materials. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a2c092ead172c396770ffeda0fcb56089}{kkt\+\_\+inverse}} (const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&A, const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&Aeq, const bool use\+\_\+lu\+\_\+decomposition, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&S)
\begin{DoxyCompactList}\small\item\em Constructs the inverse of the KKT matrix of a convex, linear equality constrained quadratic minimization problem. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename Index\+Type , typename Derived\+CH , typename Derived\+CN , typename DerivedW , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a6f2969bd735df2588ce37026375ddefe}{knn}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, size\+\_\+t k, const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&point\+\_\+indices, const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&CH, const Eigen\+::\+Matrix\+Base$<$ Derived\+CN $>$ \&CN, const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neighbors for each point in P. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedV , typename Index\+Type , typename Derived\+CH , typename Derived\+CN , typename DerivedW , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a8937a7fe108b5aa0669d3731c34e281d}{knn}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, size\+\_\+t k, const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&point\+\_\+indices, const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&CH, const Eigen\+::\+Matrix\+Base$<$ Derived\+CN $>$ \&CN, const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename DerivedF $>$ }\\int \mbox{\hyperlink{namespaceigl_af44b520d132c6b6d1941fe5819f45ae1}{launch\+\_\+medit}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const bool wait)
\begin{DoxyCompactList}\small\item\em Writes the tetmesh in (V,T,F) to a temporary file, opens it with medit (forking with a system call) and returns. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a7e6a7f8c0fb33cae88074977a12e12fc}{lbs\+\_\+matrix}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xd \&W, Eigen\+::\+Matrix\+Xd \&M)
\begin{DoxyCompactList}\small\item\em Linear blend skinning can be expressed by V\textquotesingle{} = M \texorpdfstring{$\ast$}{*} T where V\textquotesingle{} is a \#V by dim matrix of deformed vertex positions (one vertex per row), M is a \#V by (dim+1)\texorpdfstring{$\ast$}{*}\#T (composed of weights and rest positions) and T is a \#T\texorpdfstring{$\ast$}{*}(dim+1) by dim matrix of \#T stacked transposed transformation matrices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_abf08b3e278ea284934baa0d3f6dc4975}{lbs\+\_\+matrix\+\_\+column}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xd \&W, Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&M)
\begin{DoxyCompactList}\small\item\em Construct a matrix that when multiplied against a column of affine transformation entries computes new coordinates of the vertices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_aaafa8162de573ea1c1c90b3f4ffad4a7}{lbs\+\_\+matrix\+\_\+column}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xd \&W, Eigen\+::\+Matrix\+Xd \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a5f0754d811bd0e0c95fac0317917c255}{lbs\+\_\+matrix\+\_\+column}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xd \&W, const Eigen\+::\+Matrix\+Xi \&WI, Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a24aaeb1753decc0b7602a6cb0432458e}{lbs\+\_\+matrix\+\_\+column}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xd \&W, const Eigen\+::\+Matrix\+Xi \&WI, Eigen\+::\+Matrix\+Xd \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename Orient2D , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a7afcff53e324c859c08eaa01e48f4581}{lexicographic\+\_\+triangulation}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, Orient2D orient2D, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Given a set of points in 2D, return a lexicographic triangulation of these points. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatF , typename VecL $>$ }\\void \mbox{\hyperlink{namespaceigl_a2365ceb20a3b51fb10c3050cc456e343}{limit\+\_\+faces}} (const MatF \&F, const VecL \&L, const bool exclusive, MatF \&LF)
\begin{DoxyCompactList}\small\item\em Limit given faces F to those which contain (only) indices found in L. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedO $>$ }\\void \mbox{\hyperlink{namespaceigl_a4deb0e936a117ec6c8c973f3d0670770}{line\+\_\+field\+\_\+mismatch}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&PD1, const bool is\+Combed, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&mismatch)
\begin{DoxyCompactList}\small\item\em Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespaceigl_a9145bd261a2cf691294d8104c99a4ab9}{line\+\_\+search}} (Eigen\+::\+Matrix\+Xd \&x, const Eigen\+::\+Matrix\+Xd \&d, double i\+\_\+step\+\_\+size, std\+::function$<$ double(Eigen\+::\+Matrix\+Xd \&)$>$ energy, double cur\+\_\+energy=-\/1)
\begin{DoxyCompactList}\small\item\em Implement a bisection linesearch to minimize a mesh-\/based energy on vertices given at \textquotesingle{}x\textquotesingle{} at a search direction \textquotesingle{}d\textquotesingle{}, with initial step size. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a2b5853a837850f17eadaff857ad1e463}{line\+\_\+segment\+\_\+in\+\_\+rectangle}} (const Eigen\+::\+Vector2d \&s, const Eigen\+::\+Vector2d \&d, const Eigen\+::\+Vector2d \&A, const Eigen\+::\+Vector2d \&B)
\begin{DoxyCompactList}\small\item\em Determine whether a line segment overlaps with a rectangle. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_afa9c39cf6f0bef4857b1dc66360e4f52}{linprog}} (const Eigen\+::\+Vector\+Xd \&c, const Eigen\+::\+Matrix\+Xd \&A, const Eigen\+::\+Vector\+Xd \&b, const int k, Eigen\+::\+Vector\+Xd \&x)
\begin{DoxyCompactList}\small\item\em Solve a linear program given in "{}standard form"{}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a9455a41cb54a91242fe498354445bd28}{linprog}} (const Eigen\+::\+Vector\+Xd \&f, const Eigen\+::\+Matrix\+Xd \&A, const Eigen\+::\+Vector\+Xd \&b, const Eigen\+::\+Matrix\+Xd \&B, const Eigen\+::\+Vector\+Xd \&c, Eigen\+::\+Vector\+Xd \&x)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived $>$ }\\Derived \mbox{\hyperlink{namespaceigl_ae8a4579279c09a298a5988c18f215d33}{Lin\+Spaced}} (typename Derived\+::\+Index size, const typename Derived\+::\+Scalar \&low, const typename Derived\+::\+Scalar \&high)
\begin{DoxyCompactList}\small\item\em Replacement for Eigen\+::\+Dense\+Base\+::\+Lin\+Spaced. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Derived $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6df6ee5a6c7852f628cefbb8dbb025af}{list\+\_\+to\+\_\+matrix}} (const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&M)
\begin{DoxyCompactList}\small\item\em Convert a list (std\+::vector) of row vectors of the same length to a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , size\+\_\+t N, typename Derived $>$ }\\bool \mbox{\hyperlink{namespaceigl_ae5fd001a788d43f744d257d305ddb1b3}{list\+\_\+to\+\_\+matrix}} (const std\+::vector$<$ std\+::array$<$ T, N $>$ $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Derived $>$ }\\bool \mbox{\hyperlink{namespaceigl_a47b768c6f9bfb5e3e0342cbe32f91110}{list\+\_\+to\+\_\+matrix}} (const std\+::vector$<$ T $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Derived $>$ }\\bool \mbox{\hyperlink{namespaceigl_a25bb0b08ed4407588cdc107ce3f99b3d}{list\+\_\+to\+\_\+matrix}} (const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&V, const int n, const T \&padding, Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&M)
\begin{DoxyCompactList}\small\item\em Convert a list of row vectors of {\ttfamily n} or less to a matrix and pad on the right with {\ttfamily padding}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a108a662cae580e5c3459d81435f32e24}{local\+\_\+basis}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&B1, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&B2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&B3)
\begin{DoxyCompactList}\small\item\em Compute a local orthogonal reference system for each triangle in the given mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedeye , typename Derivedcenter , typename Derivedup , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_ae46bcc8364a310c7a3bc0ee718b91fb1}{look\+\_\+at}} (const Eigen\+::\+Plain\+Object\+Base$<$ Derivedeye $>$ \&eye, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedcenter $>$ \&center, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedup $>$ \&up, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em Implementation of the deprecated glu\+Look\+At function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename SType , typename Derived\+NF $>$ }\\void \mbox{\hyperlink{namespaceigl_aea9965bc615b0a851fabf90d37a73320}{loop}} (const int n\+\_\+verts, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ SType $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&NF)
\begin{DoxyCompactList}\small\item\em Given the triangle mesh \mbox{[}V, F\mbox{]}, where n\+\_\+verts = V.\+rows(), computes newV and a sparse matrix S s.\+t. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF $>$ }\\void \mbox{\hyperlink{namespaceigl_aee95891ee4e9418b27c3fbfa92542784}{loop}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&NV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&NF, const int number\+\_\+of\+\_\+subdivs=1)
\begin{DoxyCompactList}\small\item\em Given the triangle mesh \mbox{[}V, F\mbox{]}, computes number\+\_\+of\+\_\+subdivs steps of loop subdivision and outputs the new mesh \mbox{[}newV, newF\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename Derived\+V\+\_\+uv , typename QScalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_a31de2a4d188ef681f7057d0d948edbf1}{lscm}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V\+\_\+uv $>$ \&V\+\_\+uv, Eigen\+::\+Sparse\+Matrix$<$ QScalar $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Compute a Least-\/squares conformal map parametrization (equivalently derived in "{}\+Intrinsic Parameterizations of Surface Meshes"{} \mbox{[}Desbrun et al. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename Derived\+V\+\_\+uv $>$ }\\bool \mbox{\hyperlink{namespaceigl_a1c37dc9607d1629ed72cba5af4e64554}{lscm}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&b, const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&bc, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V\+\_\+uv $>$ \&V\+\_\+uv)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+V\+\_\+uv $>$ }\\bool \mbox{\hyperlink{namespaceigl_a378192fe12df93afb032da2706ff5c0a}{lscm}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V\+\_\+uv $>$ \&V\+\_\+uv)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename QScalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a1cf5daa1660b341b111456aabafc1f9b}{lscm\+\_\+hessian}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ QScalar $>$ \&Q)
\begin{DoxyCompactList}\small\item\em Compute a Least-\/squares conformal map parametrization (equivalently derived in "{}\+Intrinsic Parameterizations of Surface Meshes"{} \mbox{[}Desbrun et al. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a8b077eb9a7d351e5b313ff150dc3eabb}{map\+\_\+vertices\+\_\+to\+\_\+circle}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Vector\+Xi \&bnd, Eigen\+::\+Matrix\+Xd \&UV)
\begin{DoxyCompactList}\small\item\em Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespaceigl_a0a118619cf44f20a0956f9e856707aa2}{mapping\+\_\+energy\+\_\+with\+\_\+jacobians}} (const Eigen\+::\+Matrix\+Xd \&Ji, const Eigen\+::\+Vector\+Xd \&areas, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type}} slim\+\_\+energy, double exp\+\_\+factor)
\begin{DoxyCompactList}\small\item\em Compute the rotation-\/invariant energy of a mapping (represented in Jacobians and areas) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+GV , typename Scalar , typename Index , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a75c4985a12f6c71116d36492d2f6154d}{march\+\_\+cube}} (const Derived\+GV \&GV, const Eigen\+::\+Matrix$<$ Scalar, 8, 1 $>$ \&cS, const Eigen\+::\+Matrix$<$ Index, 8, 1 $>$ \&cI, const Scalar \&isovalue, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Index \&n, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Index \&m, std\+::unordered\+\_\+map$<$ int64\+\_\+t, int $>$ \&E2V)
\begin{DoxyCompactList}\small\item\em Process a single cube of a marching cubes grid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename Derived\+GV , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a3e677970b7188cac95bc9f93181f2ed7}{marching\+\_\+cubes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&GV, const unsigned nx, const unsigned ny, const unsigned nz, const typename Derived\+S\+::\+Scalar isovalue, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh defined by vertices and faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename Derived\+GV , typename Derived\+GI , typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_af60d3b30634f77428770f2ae32f34059}{marching\+\_\+cubes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&GV, const Eigen\+::\+Matrix\+Base$<$ Derived\+GI $>$ \&GI, const typename Derived\+S\+::\+Scalar isovalue, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename DerivedJ , typename BCType $>$ }\\void \mbox{\hyperlink{namespaceigl_a5512306a29939c7ac8d4ebcef2cd032a}{marching\+\_\+tets}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&TV, const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&TT, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar isovalue, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Sparse\+Matrix$<$ BCType $>$ \&BC)
\begin{DoxyCompactList}\small\item\em Performs the marching tetrahedra algorithm on a tet mesh defined by TV and TT with scalar values defined at each vertex in TV. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename DerivedJ , typename BCType $>$ }\\void \mbox{\hyperlink{namespaceigl_aa49f489ae12ec4a901418253fcd3f3ed}{marching\+\_\+tets}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&TV, const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&TT, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Sparse\+Matrix$<$ BCType $>$ \&BC)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a77b74374c21bab647512f658e050cc27}{marching\+\_\+tets}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&TV, const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&TT, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar isovalue, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename BCType $>$ }\\void \mbox{\hyperlink{namespaceigl_ac630f9be345647d2008378e9489ea50e}{marching\+\_\+tets}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&TV, const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&TT, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar isovalue, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Sparse\+Matrix$<$ BCType $>$ \&BC)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF $>$ }\\void \mbox{\hyperlink{namespaceigl_a4416636f9a80fb95a7656732a32dbf0f}{marching\+\_\+tets}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&TV, const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&TT, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar isovalue, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a72cf047d8b4df743c47bbbf0ba9dc6e1}{massmatrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}} type, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&M)
\begin{DoxyCompactList}\small\item\em Constructs the mass (area) matrix for a given mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a4ab669b8ca4aea8ed68a0ba8c58a39bb}{massmatrix\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}} type, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&M)
\begin{DoxyCompactList}\small\item\em Constructs the mass (area) matrix for a given mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedl , typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_af2f410b7b17ce4aca5873af755825d76}{massmatrix\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&l, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}} type, const int n, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_ae45c197a9b5b63af57d2791909442e41}{mat4\+\_\+to\+\_\+quat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}m, Q\+\_\+type \texorpdfstring{$\ast$}{*}q)
\begin{DoxyCompactList}\small\item\em Convert a Open\+GL (rotation) matrix to a quaternion. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_aa21c6c4b638d223560312607397b5ba8}{mat3\+\_\+to\+\_\+quat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}m, Q\+\_\+type \texorpdfstring{$\ast$}{*}q)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_afa21880837017adbf621456039ee7682}{MAYA\+\_\+\+GREEN}} (128./255., 242./255., 0./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_a4babb52f3f1868081e0cefa0e4f56e07}{MAYA\+\_\+\+YELLOW}} (255./255., 247./255., 50./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_a10e550e4712ab9495265314ad14c3372}{MAYA\+\_\+\+RED}} (234./255., 63./255., 52./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_a669df861bcae5e90ab84e929012a1007}{MAYA\+\_\+\+BLUE}} (0./255., 73./255., 252./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_af3d3a9a0275b56ed0378893b3e80f0b4}{MAYA\+\_\+\+PURPLE}} (180./255., 73./255., 200./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_a2348169281b988537537308cba384db3}{MAYA\+\_\+\+VIOLET}} (31./255., 15./255., 66./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_acf86c730ad8ddf83e5c89d8589047364}{MAYA\+\_\+\+GREY}} (0.\+5, 0.\+5, 0.\+5, 1.\+0)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_a362ead03e0717a9a1e39f52996e6f6db}{MAYA\+\_\+\+CYAN}} (131./255., 219./255., 252./255., 1.)
\item 
const Eigen\+::\+Vector4f \mbox{\hyperlink{namespaceigl_a576798d977c56f9ebd4699e1d9693dd3}{MAYA\+\_\+\+SEA\+\_\+\+GREEN}} (70./255., 252./255., 167./255., 1.)
\item 
{\footnotesize template$<$typename DerivedM $>$ }\\const Eigen\+::\+With\+Format$<$ DerivedM $>$ \mbox{\hyperlink{namespaceigl_a64d87355c9c3b734e7658eed10bdd764}{matlab\+\_\+format}} (const Eigen\+::\+Dense\+Base$<$ DerivedM $>$ \&M, const std\+::string name="{}"{})
\begin{DoxyCompactList}\small\item\em This is a routine to print a matrix using format suitable for pasting into the matlab IDE. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedM $>$ }\\std\+::string \mbox{\hyperlink{namespaceigl_acc0f1184f42624896cf510cd82ccb6ca}{matlab\+\_\+format\+\_\+index}} (const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, const std\+::string name="{}"{})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS $>$ }\\const std\+::string \mbox{\hyperlink{namespaceigl_a92ca4e0bd6d85899d88544c29389b048}{matlab\+\_\+format}} (const Eigen\+::\+Sparse\+Matrix$<$ DerivedS $>$ \&S, const std\+::string name="{}"{})
\begin{DoxyCompactList}\small\item\em Same but for sparse matrices. \end{DoxyCompactList}\item 
const std\+::string \mbox{\hyperlink{namespaceigl_a9641504c7ccb6996da7abc34c5ebe6a1}{matlab\+\_\+format}} (const double v, const std\+::string name="{}"{})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
const std\+::string \mbox{\hyperlink{namespaceigl_a367414630ebe7f7fe7a243502d57b1ad}{matlab\+\_\+format}} (const float v, const std\+::string name="{}"{})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
Eigen\+::\+IOFormat \mbox{\hyperlink{namespaceigl_a6b539a21fb577617710f5fce2046e65b}{matlab\+\_\+format}} ()
\begin{DoxyCompactList}\small\item\em Just build and return the format. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedM $>$ }\\void \mbox{\hyperlink{namespaceigl_ac9d68f355e17a7ba95194bfd46f3ce49}{matrix\+\_\+to\+\_\+list}} (const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, std\+::vector$<$ std\+::vector$<$ typename Derived\+M\+::\+Scalar $>$ $>$ \&V)
\begin{DoxyCompactList}\small\item\em Convert a matrix to a list (std\+::vector) of row vectors of the same size. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedM $>$ }\\void \mbox{\hyperlink{namespaceigl_adc8c8289cdddc4408bc1e12579de244c}{matrix\+\_\+to\+\_\+list}} (const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, std\+::vector$<$ typename Derived\+M\+::\+Scalar $>$ \&V)
\begin{DoxyCompactList}\small\item\em Convert a matrix to a list (std\+::vector) of elements in column-\/major ordering. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedM $>$ }\\std\+::vector$<$ typename Derived\+M\+::\+Scalar $>$ \mbox{\hyperlink{namespaceigl_aec3a51cfa07853b2b45e1226672e16da}{matrix\+\_\+to\+\_\+list}} (const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedB , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a406b1c228d9a40c7c25062de5c6e20c9}{max}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Compute the maximum along dimension dim of a matrix X. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a5e2e2d77d83c68427be201b4e3a877a6}{max}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a74b5b6981f78cc7519e2ac080f4ec561}{max\+\_\+faces\+\_\+stopping\+\_\+condition}} (int \&m, const int orig\+\_\+m, const int max\+\_\+m, \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&stopping\+\_\+condition)
\begin{DoxyCompactList}\small\item\em Stopping condition function compatible with \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \mbox{\hyperlink{namespaceigl_afb31e9c7165119e57a70705383c7275d}{max\+\_\+faces\+\_\+stopping\+\_\+condition}} (int \&m, const int orign\+\_\+m, const int max\+\_\+m)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\int \mbox{\hyperlink{namespaceigl_ad4303b454ca438ac3e09fdc506d431df}{max\+\_\+size}} (const std\+::vector$<$ T $>$ \&V)
\begin{DoxyCompactList}\small\item\em Determine max size of lists in a vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename m\+Type $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad73289b6fbba95eacda8174e185dcf9f}{median}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, m\+Type \&m)
\begin{DoxyCompactList}\small\item\em Compute the median of an eigen vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedB , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_aea356ce5149b60ed9d36e9f7a94db372}{min}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Compute the minimum along dimension dim of a matrix X. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a9b9c8ab934e0d7755a6c90c0fa6486c4}{min}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Derivedknown $>$ }\\bool \mbox{\hyperlink{namespaceigl_adc0382628e374a5b92a226ad75ce6b8b}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+precompute}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ Derivedknown $>$ \&known, const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&Aeq, const bool pd, \mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}$<$ T $>$ \&data)
\begin{DoxyCompactList}\small\item\em Minimize a convex quadratic energy subject to fixed value and linear equality constraints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename DerivedB , typename DerivedY , typename Derived\+Beq , typename DerivedZ , typename Derivedsol $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad6d436a09a132f780d5e503b39499fbb}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+solve}} (const \mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}$<$ T $>$ \&data, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, const Eigen\+::\+Matrix\+Base$<$ Derived\+Beq $>$ \&Beq, Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&Z, Eigen\+::\+Plain\+Object\+Base$<$ Derivedsol $>$ \&sol)
\begin{DoxyCompactList}\small\item\em Solves a system previously factored using min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+precompute. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename DerivedB , typename DerivedY , typename Derived\+Beq , typename DerivedZ $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad5720740af2df4180f61b1731bd5499f}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+solve}} (const \mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}$<$ T $>$ \&data, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, const Eigen\+::\+Matrix\+Base$<$ Derived\+Beq $>$ \&Beq, Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&Z)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename Derivedknown , typename DerivedB , typename DerivedY , typename Derived\+Beq , typename DerivedZ $>$ }\\bool \mbox{\hyperlink{namespaceigl_abcdcf5c62d46412f4b5de5889e51c0d4}{min\+\_\+quad\+\_\+with\+\_\+fixed}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ Derivedknown $>$ \&known, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&Aeq, const Eigen\+::\+Matrix\+Base$<$ Derived\+Beq $>$ \&Beq, const bool pd, Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&Z)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , int n, int m, bool Hpd = true$>$ }\\Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \mbox{\hyperlink{namespaceigl_a897bf8d157d9e2b51b81603c5fd6e099}{min\+\_\+quad\+\_\+with\+\_\+fixed}} (const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&H, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&f, const Eigen\+::\+Array$<$ bool, n, 1 $>$ \&k, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&bc, const Eigen\+::\+Matrix$<$ Scalar, m, n $>$ \&A, const Eigen\+::\+Matrix$<$ Scalar, m, 1 $>$ \&b)
\begin{DoxyCompactList}\small\item\em Dense version optimized for very small, known at compile time sizes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , int n, bool Hpd = true$>$ }\\Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \mbox{\hyperlink{namespaceigl_a4f2961e370b73126b4896c0f53cc8af4}{min\+\_\+quad\+\_\+with\+\_\+fixed}} (const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&H, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&f, const Eigen\+::\+Array$<$ bool, n, 1 $>$ \&k, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&bc)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , int n, int kcount, bool Hpd$>$ }\\Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \mbox{\hyperlink{namespaceigl_a810f069896eadc075940d13f7cc22a4f}{min\+\_\+quad\+\_\+with\+\_\+fixed}} (const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&H, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&f, const Eigen\+::\+Array$<$ bool, n, 1 $>$ \&k, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&bc)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\int \mbox{\hyperlink{namespaceigl_aea4adc0413c180d649f00d8759cf63b3}{min\+\_\+size}} (const std\+::vector$<$ T $>$ \&V)
\begin{DoxyCompactList}\small\item\em Determine min size of lists in a vector. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_ae574038db202105a0eccec2ef233be57}{mod}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, const int base, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Compute elementwise mod\+: B = A \% base. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA $>$ }\\DerivedA \mbox{\hyperlink{namespaceigl_a0394947bf9e27382711c730186ec631c}{mod}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, const int base)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a037858abb04a677ebd5cdf660de0b0ae}{mode}} (const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&X, const int d, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&M)
\begin{DoxyCompactList}\small\item\em Takes mode of coefficients in a matrix along a given dimension. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedm0 , typename Derivedm1 , typename Derivedm2 $>$ }\\void \mbox{\hyperlink{namespaceigl_ae9c8d358cf9fdbac0bd749920e072b84}{moments}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Derivedm0 \&m0, Eigen\+::\+Plain\+Object\+Base$<$ Derivedm1 $>$ \&m1, Eigen\+::\+Plain\+Object\+Base$<$ Derivedm2 $>$ \&m2)
\begin{DoxyCompactList}\small\item\em Computes the moments of mass for a solid object bound by a triangle mesh. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a2b6d36d1a68f0978c2b20b1586ccc18f}{mvc}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xd \&C, Eigen\+::\+Matrix\+Xd \&W)
\begin{DoxyCompactList}\small\item\em Mean value coordinates for a polygon. \end{DoxyCompactList}\item 
double \mbox{\hyperlink{namespaceigl_a330d1e74582084d2c5d7002ecab40baf}{nchoosek}} (const int n, const int k)
\begin{DoxyCompactList}\small\item\em Binomial coefficient. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedU $>$ }\\void \mbox{\hyperlink{namespaceigl_a5aa3a7446d17387b412677075b546ebb}{nchoosek}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const int k, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U)
\begin{DoxyCompactList}\small\item\em All combinations . \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a368a81066e3790575847edac849c6aa9}{next\+\_\+filename}} (const std\+::string \&prefix, const int zeros, const std\+::string \&suffix, std\+::string \&next)
\begin{DoxyCompactList}\small\item\em Find the file with the first filename of the form "{}prefix\%0\mbox{[}zeros\mbox{]}dsuffix"{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+Ele , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_af63be3993b067600b578e85bf0fa186a}{normal\+\_\+derivative}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&Ele, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&DD)
\begin{DoxyCompactList}\small\item\em Computes the directional derivative {\bfseries{normal}} to {\bfseries{all}} (half-\/)edges of a triangle mesh (not just boundary edges). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\bool \mbox{\hyperlink{namespaceigl_a01a8628fb6a1bef5682ad416cfcd0a5e}{normalize\+\_\+quat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}q, Q\+\_\+type \texorpdfstring{$\ast$}{*}out)
\begin{DoxyCompactList}\small\item\em Normalize a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a8799fd07216a41e98f6ccaa39aec488f}{null}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em Compute a basis for the null space for the given matrix A\+: the columns of the output N form a basis for the space orthogonal to that spanned by the rows of A. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename Index\+Type , typename Derived\+CH , typename Derived\+CN , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_a3ff69240d0614e6f4ab20ff15b2f21a4}{octree}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&point\+\_\+indices, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CH $>$ \&CH, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&CN, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Given a set of 3D points P, generate data structures for a pointerless octree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename isolevel\+Type , typename Derived\+SV , typename Derived\+SF , typename Derived\+GV , typename Derivedside , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_afff5efd1454c4544da0680e4c410b7cf}{offset\+\_\+surface}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const isolevel\+Type isolevel, const typename Derivedside\+::\+Scalar s, const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}} \&signed\+\_\+distance\+\_\+type, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&GV, Eigen\+::\+Plain\+Object\+Base$<$ Derivedside $>$ \&side, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Compute a triangulated offset surface using matching cubes on a grid of signed distance values from the input triangle mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename IntegerT $>$ }\\void \mbox{\hyperlink{namespaceigl_a9f19762456ef8396dfc4096f34c841e6}{on\+\_\+boundary}} (const std\+::vector$<$ std\+::vector$<$ IntegerT $>$ $>$ \&T, std\+::vector$<$ bool $>$ \&I, std\+::vector$<$ std\+::vector$<$ bool $>$ $>$ \&C)
\begin{DoxyCompactList}\small\item\em Determine boundary facets of mesh elements stored in T. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedT , typename DerivedI , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_acc0e9a973c6c86bc98645ef61f4d4b43}{on\+\_\+boundary}} (const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename Derived\+OE $>$ }\\void \mbox{\hyperlink{namespaceigl_ae76f879f4715d4a8596d28f12bc7161d}{orient\+\_\+halfedges}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&oE)
\begin{DoxyCompactList}\small\item\em Orients halfedges for a triangle mesh, assigning them to a unique edge. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC , typename Derived\+FF , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a13811b519cd4b97b94f6ef8f3fe90f30}{orient\+\_\+outward}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Orient each component (identified by C) of a mesh (V,F) so the normals on average point away from the patch\textquotesingle{}s centroid. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedC , typename AScalar $>$ }\\void \mbox{\hyperlink{namespaceigl_aa7ea97ba9a25206eb1ba9d7469b371d1}{orientable\+\_\+patches}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ AScalar $>$ \&A)
\begin{DoxyCompactList}\small\item\em Compute connected components of facets connected by manifold edges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_ad5c31bf9a8576f1775affb93a5722e85}{orientable\+\_\+patches}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_a3f9293ec84689fd8949325ccb22d55fb}{oriented\+\_\+facets}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\begin{DoxyCompactList}\small\item\em Determines all "{}directed \mbox{[}facets\mbox{]}(https\+://en.\+wikipedia.\+org/wiki/\+Simplex\#\+Elements)"{} of a given set of simplicial elements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a8010396f68fc2ad676aa1a713b6a7bc4}{orth}} (const Eigen\+::\+Matrix\+Xd \&A, Eigen\+::\+Matrix\+Xd \&Q)
\begin{DoxyCompactList}\small\item\em Orthogonalization of a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_a4aa53ae1b1d678353d4056c724b7df7c}{ortho}} (const typename Derived\+P\+::\+Scalar left, const typename Derived\+P\+::\+Scalar right, const typename Derived\+P\+::\+Scalar bottom, const typename Derived\+P\+::\+Scalar top, const typename Derived\+P\+::\+Scalar near\+Val, const typename Derived\+P\+::\+Scalar far\+Val, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Implementation of the deprecated gl\+Ortho function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_abf646b1d4c8ad6dd0d2660d0a5cae584}{outer\+\_\+vertex}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, Index\+Type \&v\+\_\+index, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Find a vertex that is reachable from infinite without crossing any faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ }\\void \mbox{\hyperlink{namespaceigl_a8a1dbaf3fab3346a4956ef93313e488b}{outer\+\_\+edge}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, Index\+Type \&v1, Index\+Type \&v2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A)
\begin{DoxyCompactList}\small\item\em Find an edge that is reachable from infinity without crossing any faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename Index\+Type $>$ }\\void \mbox{\hyperlink{namespaceigl_ab8ea262d61548f3946263a5c00ed0192}{outer\+\_\+facet}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, Index\+Type \&f, bool \&flipped)
\begin{DoxyCompactList}\small\item\em Find a facet that is reachable from infinity without crossing any faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index , typename Function\+Type $>$ }\\bool \mbox{\hyperlink{namespaceigl_a48ba3dac8f2da11935cd7e566f27e69d}{parallel\+\_\+for}} (const Index loop\+\_\+size, const Function\+Type \&func, const size\+\_\+t min\+\_\+parallel=0)
\begin{DoxyCompactList}\small\item\em Functional implementation of a basic, open-\/mp style, parallel for loop. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index , typename Prep\+Function\+Type , typename Function\+Type , typename Accum\+Function\+Type $>$ }\\bool \mbox{\hyperlink{namespaceigl_a8e1804e24a4fefa3bbe3e6241bd00f75}{parallel\+\_\+for}} (const Index loop\+\_\+size, const Prep\+Function\+Type \&prep\+\_\+func, const Function\+Type \&func, const Accum\+Function\+Type \&accum\+\_\+func, const size\+\_\+t min\+\_\+parallel=0)
\begin{DoxyCompactList}\small\item\em Functional implementation of an open-\/mp style, parallel for loop with accumulation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ }\\void \mbox{\hyperlink{namespaceigl_a842fd7e11ac0c43a81d15fa137337adb}{parallel\+\_\+transport\+\_\+angles}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&FN, const Eigen\+::\+Matrix\+Xi \&E2F, const Eigen\+::\+Matrix\+Xi \&F2E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&K)
\begin{DoxyCompactList}\small\item\em Given the per-\/face local bases computed via \doxylink{namespaceigl_a108a662cae580e5c3459d81435f32e24}{igl\+::local\+\_\+basis}, this function computes the angle between the two reference frames across each edge. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_af85fb6c92debf67385c27c8a06c2a1f9}{partition}} (const Eigen\+::\+Matrix\+Xd \&W, const int k, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&G, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&S, Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, 1 $>$ \&D)
\begin{DoxyCompactList}\small\item\em Partition vertices into groups based on each vertex\textquotesingle{}s vector\+: vertices with similar coordinates (close in space) will be put in the same group. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_aa9dfa8a07d0d391278ff5023da5ba1bf}{parula}} (const T f, T \texorpdfstring{$\ast$}{*}rgb)
\begin{DoxyCompactList}\small\item\em Parula colormap like MATLAB\textquotesingle{}s parula. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a79a5375852c84e549987ad3aedd7e80e}{parula}} (const T f, T \&r, T \&g, T \&b)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedZ , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a36caf45296cda61ad8a61ee3772378e7}{parula}} (const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, const bool normalize, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedZ , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a70ff59da460d9fa5095c2cd9447fe9a4}{parula}} (const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, const double min\+\_\+Z, const double max\+\_\+Z, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedI , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_ad9dedb9d3d8f684abb92cef75cacdb69}{path\+\_\+to\+\_\+edges}} (const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, bool make\+\_\+loop=false)
\begin{DoxyCompactList}\small\item\em Given a path as an ordered list of N\texorpdfstring{$>$}{>}=2 vertex indices I\mbox{[}0\mbox{]}, I\mbox{[}1\mbox{]}, ..., I\mbox{[}N-\/1\mbox{]} construct a list of edges \mbox{[}\mbox{[}I\mbox{[}0\mbox{]},I\mbox{[}1\mbox{]}\mbox{]}, \mbox{[}I\mbox{[}1\mbox{]},I\mbox{[}2\mbox{]}\mbox{]}, ..., \mbox{[}I\mbox{[}N-\/2\mbox{]}, I\mbox{[}N-\/1\mbox{]}\mbox{]}\mbox{]} connecting each sequential pair of vertices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Index , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_abc2ac47ac2adbe917283d5dd317dab36}{path\+\_\+to\+\_\+edges}} (const std\+::vector$<$ Index $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, bool make\+\_\+loop=false)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_a35cb149bbe78233befd8a3fcbf0bf0f9}{path\+\_\+to\+\_\+executable}} ()
\begin{DoxyCompactList}\small\item\em Path to current executable. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a541dccb34e02684e3d43966fca86bdaf}{pathinfo}} (const std\+::string \&path, std\+::string \&\mbox{\hyperlink{namespaceigl_aef1ff1d390be65861384b6ff764ebe09}{dirname}}, std\+::string \&\mbox{\hyperlink{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82}{basename}}, std\+::string \&\mbox{\hyperlink{namespaceigl_af53e1e0ea4e1632ee9d5b5a6411093e2}{extension}}, std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em Function like PHP\textquotesingle{}s pathinfo to return information about path. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+CN $>$ }\\void \mbox{\hyperlink{namespaceigl_a3a09c2edf78994c6f25f23a9212a3666}{per\+\_\+corner\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+V\+::\+Scalar corner\+\_\+threshold\+\_\+degrees, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&CN)
\begin{DoxyCompactList}\small\item\em Compute per corner normals for a triangle mesh by computing the area-\/weighted average of normals at incident faces whose normals deviate less than the provided threshold. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VF , typename Derived\+NI , typename Derived\+CN $>$ }\\void \mbox{\hyperlink{namespaceigl_a1038de65b964583d4ea533a631e6c1b8}{per\+\_\+corner\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+V\+::\+Scalar corner\+\_\+threshold\+\_\+degrees, const Eigen\+::\+Matrix\+Base$<$ Derived\+VF $>$ \&VF, const Eigen\+::\+Matrix\+Base$<$ Derived\+NI $>$ \&NI, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&CN)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+CI , typename Derived\+CC , typename Derived\+CN $>$ }\\void \mbox{\hyperlink{namespaceigl_a01b4e893d7a38a99124fb826f0f337c1}{per\+\_\+corner\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+CI $>$ \&CI, const Eigen\+::\+Matrix\+Base$<$ Derived\+CC $>$ \&CC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&CN)
\item 
{\footnotesize template$<$typename Derived\+NV , typename Derived\+NF , typename Derived\+CN $>$ }\\void \mbox{\hyperlink{namespaceigl_aac0d1344faa3702f4c79dcdf54888c68}{per\+\_\+corner\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+NV $>$ \&NV, const Eigen\+::\+Matrix\+Base$<$ Derived\+NF $>$ \&NF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&CN)
\begin{DoxyCompactList}\small\item\em Given indexed normals (e.\+g., read from a .obj file), explode into per-\/corner normals (e.\+g., as expected by \doxylink{classigl_1_1opengl_1_1ViewerData}{igl\+::opengl\+::\+Viewer\+Data}) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename Derived\+VV , typename Derived\+FF , typename DerivedJ , typename Derived\+NN $>$ }\\void \mbox{\hyperlink{namespaceigl_a4353bfd8d4ca70d1ea3bdf98dbfb50f4}{per\+\_\+corner\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const typename Derived\+V\+::\+Scalar corner\+\_\+threshold\+\_\+degrees, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&VV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NN $>$ \&NN)
\begin{DoxyCompactList}\small\item\em Per-\/corner normals for a polygon mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename DerivedN , typename DerivedE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_ae0359520eb722b81b3460a2dc23178e2}{per\+\_\+edge\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55}{Per\+Edge\+Normals\+Weighting\+Type}} weight, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em Compute face normals via vertex position list, face list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_accd393d9be7212b4986f0e14328e4acc}{per\+\_\+edge\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55}{Per\+Edge\+Normals\+Weighting\+Type}} weight, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_abe5c6976aa15d2689a00df1cbb695776}{per\+\_\+edge\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedZ , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a3d793baadcefcf122deae556812b2406}{per\+\_\+face\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&Z, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em Compute face normals via vertex position list, face list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_aa5e240d2506aa22bb2a07edd7636d6cb}{per\+\_\+face\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a49d8e3459f18186d9cbfd36ba4c053bc}{per\+\_\+face\+\_\+normals\+\_\+stable}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename Derived\+VV , typename Derived\+FF , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a95670a831d56f91f1afdd042cc8ae97b}{per\+\_\+face\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&VV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Per face normals for a general polygon mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a55694e78e07c4a2640cbfa122fa3deed}{per\+\_\+vertex\+\_\+attribute\+\_\+smoothing}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&Ain, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&Aout)
\begin{DoxyCompactList}\small\item\em Smooth vertex attributes using uniform Laplacian. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a7d913043c5590b413bc2ea64adae0c17}{per\+\_\+vertex\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}{igl\+::\+Per\+Vertex\+Normals\+Weighting\+Type}} weighting, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em Compute vertex normals via vertex position list, face list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a3b0ea8f0fee8d96f0acbda506d40fe2d}{per\+\_\+vertex\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_aa29a9edc300d4684a03a6d656d2d715c}{per\+\_\+vertex\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}{Per\+Vertex\+Normals\+Weighting\+Type}} weighting, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_addca97c5fd3aeb0c2ed9fb260b020092}{per\+\_\+vertex\+\_\+normals}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a3ac6a5f35466ea9216e1de32fecaf032}{per\+\_\+vertex\+\_\+point\+\_\+to\+\_\+plane\+\_\+quadrics}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xi \&EMAP, const Eigen\+::\+Matrix\+Xi \&EF, const Eigen\+::\+Matrix\+Xi \&EI, std\+::vector$<$ std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ $>$ \&quadrics)
\begin{DoxyCompactList}\small\item\em Compute quadrics per vertex of a "{}closed"{} triangle mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DeriveduE , typename Derivedu\+EC , typename Derivedu\+EE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a9edfc37639a2817ac5ffde534ec7391a}{piecewise\+\_\+constant\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&uE, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&u\+EE)
\begin{DoxyCompactList}\small\item\em Determine if a given mesh induces a piecewise constant winding number field\+: Is this mesh valid input to solid set operations. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a4321fc08252fa849e3fa6f47f3047fd9}{piecewise\+\_\+constant\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedX $>$ }\\void \mbox{\hyperlink{namespaceigl_ad226f56507bf0f6f88843734531e04cb}{pinv}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, typename Derived\+A\+::\+Scalar tol, Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X)
\begin{DoxyCompactList}\small\item\em Compute the Moore-\/\+Penrose pseudoinverse. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedX $>$ }\\void \mbox{\hyperlink{namespaceigl_a11e789f2ff1ea85406f3c41468c7f1b5}{pinv}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_a4a6123b286eebf1eb6e5ca4957ae2b89}{planarize\+\_\+quad\+\_\+mesh}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&Vin, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int max\+Iter, const double \&threshold, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&Vout)
\begin{DoxyCompactList}\small\item\em Planarizes a given quad mesh using the algorithm described in the paper "{}\+Shape-\/\+Up\+: Shaping Discrete Geometry with Projections"{} by S. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a0dad55e28df3f93b606cddb108b85e9d}{point\+\_\+in\+\_\+circle}} (const double qx, const double qy, const double cx, const double cy, const double r)
\begin{DoxyCompactList}\small\item\em Determine if 2d point is in a circle. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedV , typename Derived\+Ele , typename DerivedsqrD , typename DerivedI , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_ae9616bb9fd33e6c00dcb4e8f91952091}{point\+\_\+mesh\+\_\+squared\+\_\+distance}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&Ele, Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&sqrD, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute distances from a set of points P to a triangle mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$int DIM, typename Derivedp , typename DerivedV , typename Derived\+Ele , typename Derivedsqr\+\_\+d , typename Derivedc $>$ }\\void \mbox{\hyperlink{namespaceigl_a8c64da392edc068d98cf9c78ec8a6ee3}{point\+\_\+simplex\+\_\+squared\+\_\+distance}} (const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&p, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&Ele, const typename Derived\+Ele\+::\+Index i, Derivedsqr\+\_\+d \&sqr\+\_\+d, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c)
\begin{DoxyCompactList}\small\item\em Determine squared distance from a point to linear simplex. \end{DoxyCompactList}\item 
{\footnotesize template$<$int DIM, typename Derivedp , typename DerivedV , typename Derived\+Ele , typename Derivedsqr\+\_\+d , typename Derivedc , typename Derivedb $>$ }\\void \mbox{\hyperlink{namespaceigl_a937e7f60501c5fa10d8ddf3aba6e3d2e}{point\+\_\+simplex\+\_\+squared\+\_\+distance}} (const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&p, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&Ele, const typename Derived\+Ele\+::\+Index i, Derivedsqr\+\_\+d \&sqr\+\_\+d, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, Eigen\+::\+Plain\+Object\+Base$<$ Derivedb $>$ \&b)
\begin{DoxyCompactList}\small\item\em Determine squared distance from a point to linear simplex. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_adef4fd6ebad61768a405ac601011aa83}{polar\+\_\+dec}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, bool include\+Reflections, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em Computes the polar decomposition (R,T) of a matrix A. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a4542a1ce3e5fc92a58929332bf0d5afe}{polar\+\_\+dec}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, const bool include\+Reflections, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_af5cc516e97872405063d0bcf3005f99e}{polar\+\_\+dec}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a32e10aea297c30b7daf1616d1eba2a4f}{polar\+\_\+dec}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_aaa0b3fd9e1e8dbf5c6ddb9750f575b77}{polar\+\_\+svd}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, bool include\+Reflections, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em Computes the polar decomposition (R,T) of a matrix A using SVD singular value decomposition. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a9357cd43402973e99dcba962cdc1c8f9}{polar\+\_\+svd}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const bool include\+Reflections, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ }\\void \mbox{\hyperlink{namespaceigl_a5bf5509fee9fb84f1bce5173d27cb3e4}{polar\+\_\+svd}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a299b725f8b4d5586c64c2c5e22a242db}{polar\+\_\+svd}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mat $>$ }\\void \mbox{\hyperlink{namespaceigl_a78fc94343abfa102d5a9b95e8faca581}{polar\+\_\+svd3x3}} (const Mat \&A, Mat \&R)
\begin{DoxyCompactList}\small\item\em Computes the closest rotation to input matrix A using specialized 3x3 SVD singular value decomposition (Wunder\+SVD3x3) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename PType , typename DerivedI , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_ae45e0eb6f9263af4777dc45bc136e1fd}{polygon\+\_\+corners}} (const std\+::vector$<$ std\+::vector$<$ PType $>$ $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Convert a list-\/of-\/lists polygon mesh faces representation to list of polygon corners and sizes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedQ , typename DerivedI , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a5393c55c226b5d9d116837047c016f14}{polygon\+\_\+corners}} (const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedI , typename DerivedC , typename DerivedF , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a5c951f3fc9bfbbd0c78c007fd43c8337}{polygons\+\_\+to\+\_\+triangles}} (const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Given a polygon mesh, trivially triangulate each polygon with a fan. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+PD1 , typename Derived\+PD2 , typename Derived\+PV1 , typename Derived\+PV2 $>$ }\\void \mbox{\hyperlink{namespaceigl_a381027e74d14b6e7adb31c0565a26027}{principal\+\_\+curvature}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD1 $>$ \&PD1, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD2 $>$ \&PD2, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV1 $>$ \&PV1, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV2 $>$ \&PV2, unsigned radius=5, bool use\+Kring=true)
\begin{DoxyCompactList}\small\item\em Compute the principal curvature directions and magnitude of the given triangle mesh DerivedV derived from vertex positions matrix type\+: i.\+e. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+PD1 , typename Derived\+PD2 , typename Derived\+PV1 , typename Derived\+PV2 , typename Index $>$ }\\void \mbox{\hyperlink{namespaceigl_a1521eb853db32a29fdb6eacbf3ad9fc2}{principal\+\_\+curvature}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD1 $>$ \&PD1, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD2 $>$ \&PD2, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV1 $>$ \&PV1, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV2 $>$ \&PV2, std\+::vector$<$ Index $>$ \&bad\+\_\+vertices, unsigned radius=5, bool use\+Kring=true)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a0f935d00d75dd71d9b65d2f6a7fe4a19}{print\+\_\+ijv}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X, const int offset=0)
\begin{DoxyCompactList}\small\item\em Prints a 3 column matrix representing \mbox{[}I,J,V\mbox{]} = find(\+X). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a5d05e9d7e5d74e1a763370ff141d3628}{print\+\_\+vector}} (std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&v)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a59761c584c133e800d3e0f34dfa717cc}{print\+\_\+vector}} (std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ T $>$ $>$ $>$ \&v)
\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Scalar , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a6f43ea8a5c6f5622b8340b9d9d5d3936}{procrustes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, const bool include\+Scaling, const bool include\+Reflections, Scalar \&scale, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&t)
\begin{DoxyCompactList}\small\item\em Solve Procrustes problem in d dimensions. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Scalar , int DIM, int TType$>$ }\\void \mbox{\hyperlink{namespaceigl_a71995610b0f5d6e170ea2748950c0138}{procrustes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, const bool include\+Scaling, const bool include\+Reflections, Eigen\+::\+Transform$<$ Scalar, DIM, TType $>$ \&T)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_a2f02fa686c9416188ccb0b47bbb41985}{procrustes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, const bool include\+Scaling, const bool include\+Reflections, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&t)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_aa5807bccc7e6795e024af55047f473e6}{procrustes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&t)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Scalar , typename DerivedT $>$ }\\void \mbox{\hyperlink{namespaceigl_ab2b1805a74d6529030a2eb932a6f2fa0}{procrustes}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Rotation2D$<$ Scalar $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&t)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ \mbox{\hyperlink{namespaceigl_aea21608bab1115f54a773ade037824bd}{project}} (const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ \&obj, const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&model, const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&proj, const Eigen\+::\+Matrix$<$ Scalar, 4, 1 $>$ \&viewport)
\begin{DoxyCompactList}\small\item\em Eigen reimplementation of glu\+Project. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_af7eb3109db11f7024416cd77670e4bb6}{project}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&model, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&proj, const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&viewport, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedU , typename Derived\+UF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a33f14c3d07d3f875efa80645432c32b8}{project\+\_\+isometrically\+\_\+to\+\_\+plane}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UF $>$ \&UF, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&I)
\begin{DoxyCompactList}\small\item\em Project each triangle to the plane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD $>$ }\\void \mbox{\hyperlink{namespaceigl_a51a1c901184c35afeb294420a2cfe4f5}{project\+\_\+to\+\_\+line}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&t, Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&sqrD)
\begin{DoxyCompactList}\small\item\em Project points onto vectors, that is find the parameter t for a point p such that proj\+\_\+p = (y-\/x). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_aa6f357976c09a2f618f23fa9710bbf5c}{project\+\_\+to\+\_\+line}} (const Scalar px, const Scalar py, const Scalar pz, const Scalar sx, const Scalar sy, const Scalar sz, const Scalar dx, const Scalar dy, const Scalar dz, Scalar \&projpx, Scalar \&projpy, Scalar \&projpz, Scalar \&t, Scalar \&sqrd)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a3608b109e5112e5f70ff99cbdd56af0a}{project\+\_\+to\+\_\+line}} (const Scalar px, const Scalar py, const Scalar pz, const Scalar sx, const Scalar sy, const Scalar sz, const Scalar dx, const Scalar dy, const Scalar dz, Scalar \&t, Scalar \&sqrd)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD $>$ }\\void \mbox{\hyperlink{namespaceigl_a1dc57864ef37d9b1d37f52bb65fccc07}{project\+\_\+to\+\_\+line\+\_\+segment}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&t, Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&sqrD)
\begin{DoxyCompactList}\small\item\em Project points onto vectors, that is find the parameter t for a point p such that proj\+\_\+p = (y-\/x). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename DerivedA , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_a6cc2bb56a9aea43d8fc3108544294915}{projection\+\_\+constraint}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&VP, Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Construct two constraint equations for projecting a point to the screen. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn $>$ }\\void \mbox{\hyperlink{namespaceigl_a55630c2a7977e397d8b8fbc562a05bc5}{pseudonormal\+\_\+test}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&VN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&EN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, const int f, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, Scalar \&s, Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&n)
\begin{DoxyCompactList}\small\item\em Given a mesh (V,F), a query point q, and a point on (V,F) c, determine whether q is inside (V,F) -\/-\/\texorpdfstring{$>$}{>} s=-\/1 or outside (V,F) s=1, based on the sign of the dot product between (q-\/c) and n, where n is the normal {\itshape at c}, carefully chosen according to \mbox{[}Brentzen \& Aans 2005\mbox{]}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+EN , typename Derived\+VN , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn $>$ }\\void \mbox{\hyperlink{namespaceigl_a56d059b63286144db10a9dc08d5083d2}{pseudonormal\+\_\+test}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&EN, const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&VN, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, const int e, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, Scalar \&s, Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&n)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB $>$ }\\Scalar \mbox{\hyperlink{namespaceigl_a011d3a109b2f48a5285cb49b1cf1f288}{pso}} (const std\+::function$<$ Scalar(DerivedX \&) $>$ f, const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&LB, const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&UB, const int max\+\_\+iters, const int population, DerivedX \&X)
\begin{DoxyCompactList}\small\item\em Global optimization with the particle swarm algorithm. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB , typename DerivedP $>$ }\\Scalar \mbox{\hyperlink{namespaceigl_a1b1cad08724f66e0be85d15317bb5f11}{pso}} (const std\+::function$<$ Scalar(DerivedX \&) $>$ f, const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&LB, const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&UB, const Eigen\+::\+Dense\+Base$<$ DerivedP $>$ \&P, const int max\+\_\+iters, const int population, DerivedX \&X)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_ad5a2ee54dd545ede9b79ee62905dfc4d}{qslim}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const size\+\_\+t max\+\_\+m, Eigen\+::\+Matrix\+Xd \&U, Eigen\+::\+Matrix\+Xi \&G, Eigen\+::\+Vector\+Xi \&J, Eigen\+::\+Vector\+Xi \&I)
\begin{DoxyCompactList}\small\item\em Decimate (simplify) a triangle mesh in nD according to the paper "{}\+Simplifying Surfaces with Color and Texture using Quadric Error Metrics"{} by \mbox{[}Garland and Heckbert, 1987\mbox{]} (technically a followup to qslim). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedQ , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_acb165fc9bf550b7a4248ef3e4750c7b5}{quad\+\_\+grid}} (const int nx, const int ny, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\item 
{\footnotesize template$<$typename DerivedQ , typename DerivedE $>$ }\\void \mbox{\hyperlink{namespaceigl_aa374c6a411a695fa5fec90e301b42daf}{quad\+\_\+grid}} (const int nx, const int ny, Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP $>$ }\\void \mbox{\hyperlink{namespaceigl_addf84125e942c49f765c4d652f607cd2}{quad\+\_\+planarity}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Compute planarity of the faces of a quad mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , int n, int ni$>$ }\\Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \mbox{\hyperlink{namespaceigl_af95394212815de2e493636449c262bfc}{quadprog}} (const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&H, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&f, const Eigen\+::\+Matrix$<$ Scalar, ni, n $>$ \&Ai, const Eigen\+::\+Matrix$<$ Scalar, ni, 1 $>$ \&lbi, const Eigen\+::\+Matrix$<$ Scalar, ni, 1 $>$ \&ubi, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&lb, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&ub)
\begin{DoxyCompactList}\small\item\em Solve a convex quadratic program. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , int n, int m$>$ }\\Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \mbox{\hyperlink{namespaceigl_a552c079165c8e8dac0d633ddc36ad8f7}{quadprog}} (const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&H, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&f, const Eigen\+::\+Matrix$<$ Scalar, m, n $>$ \&A, const Eigen\+::\+Matrix$<$ Scalar, m, 1 $>$ \&b, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&lb, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&ub)
\begin{DoxyCompactList}\small\item\em Solve a convex quadratic program. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , int n$>$ }\\Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \mbox{\hyperlink{namespaceigl_a4086d9d0f9c0d8f922776a698cbe2055}{quadprog}} (const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&H, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&f, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&lb, const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&ub)
\begin{DoxyCompactList}\small\item\em Solve a convex quadratic program. \end{DoxyCompactList}\item 
std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ \mbox{\hyperlink{namespaceigl_a0c609e4b0050f7ab7371dcde020c5566}{operator+}} (const std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ \&a, const std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ \&b)
\begin{DoxyCompactList}\small\item\em A binary addition operator for Quadric tuples compatible with qslim, computing c = a+b. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_ada511054bec3939ade8f2a9494ada31b}{quat\+\_\+conjugate}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}q1, Q\+\_\+type \texorpdfstring{$\ast$}{*}out)
\begin{DoxyCompactList}\small\item\em Compute conjugate of given quaternion \href{http://en.wikipedia.org/wiki/Quaternion\#Conjugation.2C_the_norm.2C_and_reciprocal}{\texttt{ http\+://en.\+wikipedia.\+org/wiki/\+Quaternion\#\+Conjugation.\+2\+C\+\_\+the\+\_\+norm.\+2\+C\+\_\+and\+\_\+reciprocal}} A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_ac19bfa1b6952d8ab0687e3b33f445444}{quat\+\_\+mult}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}q1, const Q\+\_\+type \texorpdfstring{$\ast$}{*}q2, Q\+\_\+type \texorpdfstring{$\ast$}{*}out)
\begin{DoxyCompactList}\small\item\em Computes out = q1 \texorpdfstring{$\ast$}{*} q2 with quaternion multiplication A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_a0300d689abe2fb73dcf6b2c51821dada}{quat\+\_\+to\+\_\+axis\+\_\+angle}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}q, Q\+\_\+type \texorpdfstring{$\ast$}{*}axis, Q\+\_\+type \&angle)
\begin{DoxyCompactList}\small\item\em Convert quat representation of a rotation to axis angle A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_a279531123a14c37bbfeddb71253c50d9}{quat\+\_\+to\+\_\+axis\+\_\+angle\+\_\+deg}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}q, Q\+\_\+type \texorpdfstring{$\ast$}{*}axis, Q\+\_\+type \&angle)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{quat__to__axis__angle_8h}{include/igl/quat\+\_\+to\+\_\+axis\+\_\+angle.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_aeb3f708cef51eb10e942ea1274a4fdc1}{quat\+\_\+to\+\_\+mat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}quat, Q\+\_\+type \texorpdfstring{$\ast$}{*}mat)
\begin{DoxyCompactList}\small\item\em Convert a quaternion to a 4x4 matrix A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_af1bd78c3679effe1e85e5049ddeba5f4}{quats\+\_\+to\+\_\+column}} (const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ vQ, Eigen\+::\+Vector\+Xd \&Q)
\begin{DoxyCompactList}\small\item\em "{}\+Columnize"{} a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...) \end{DoxyCompactList}\item 
Eigen\+::\+Vector\+Xd \mbox{\hyperlink{namespaceigl_a586f0e07552e1ed4293b6e627b2d21a9}{quats\+\_\+to\+\_\+column}} (const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ vQ)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedS , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a0fe9e431751b9d9370672f22da915cea}{ramer\+\_\+douglas\+\_\+peucker}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const typename Derived\+P\+::\+Scalar tol, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Ramer-\/\+Douglas-\/\+Peucker piecewise-\/linear curve simplification. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedS , typename DerivedJ , typename DerivedQ $>$ }\\void \mbox{\hyperlink{namespaceigl_aef4dc2b120bfd3e28f7e1731a3afe7d1}{ramer\+\_\+douglas\+\_\+peucker}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const typename Derived\+P\+::\+Scalar tol, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&Q)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
Eigen\+::\+Vector3d \mbox{\hyperlink{namespaceigl_ae0064a7187fded546bbaf927301a9c7c}{random\+\_\+dir}} ()
\begin{DoxyCompactList}\small\item\em Generate a uniformly random unit direction in 3D, return as vector. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{namespaceigl_a4782a4291e5724eb403de4686b8c786d}{random\+\_\+dir\+\_\+stratified}} (const int n)
\begin{DoxyCompactList}\small\item\em Generate n stratified uniformly random unit directions in 3d, return as rows of an n by 3 matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedB , typename Derived\+FI , typename DerivedX , typename URBG  = DEFAULT\+\_\+\+URBG$>$ }\\void \mbox{\hyperlink{namespaceigl_a1fc88d96c492e3bf962501af8bea413e}{random\+\_\+points\+\_\+on\+\_\+mesh}} (const int n, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&FI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X, URBG \&\&urbg=\mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}())
\begin{DoxyCompactList}\small\item\em Randomly sample a mesh (V,F) n times. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DeriveddblA , typename DerivedB , typename Derived\+FI , typename URBG  = DEFAULT\+\_\+\+URBG$>$ }\\void \mbox{\hyperlink{namespaceigl_a17abb32491125229903977390f4149b6}{random\+\_\+points\+\_\+on\+\_\+mesh\+\_\+intrinsic}} (const int n, const Eigen\+::\+Matrix\+Base$<$ DeriveddblA $>$ \&dblA, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&FI, URBG \&\&urbg=\mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}())
\begin{DoxyCompactList}\small\item\em Randomly sample a mesh (V,F) n times. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DeriveddblA , typename DerivedF , typename ScalarB , typename Derived\+FI , typename URBG $>$ }\\void \mbox{\hyperlink{namespaceigl_a96aa82c3339685c664b22f768a8a6e0e}{random\+\_\+points\+\_\+on\+\_\+mesh\+\_\+intrinsic}} (const int n, const Eigen\+::\+Matrix\+Base$<$ DeriveddblA $>$ \&dblA, const int num\+\_\+vertices, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ ScalarB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&FI, URBG \&\&urbg)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\Eigen\+::\+Quaternion$<$ Scalar $>$ \mbox{\hyperlink{namespaceigl_afce1200f20db3dc284cca380285517cf}{random\+\_\+quaternion}} ()
\begin{DoxyCompactList}\small\item\em Generate a random quaternion via uniform sampling of the 4-\/sphere. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB $>$ }\\Scalar \mbox{\hyperlink{namespaceigl_ad39042be3d7a469bc3519bc2a6ce7932}{random\+\_\+search}} (const std\+::function$<$ Scalar(DerivedX \&) $>$ f, const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&LB, const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&UB, const int iters, DerivedX \&X)
\begin{DoxyCompactList}\small\item\em Global optimization via random search. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedI , typename URBG  = DEFAULT\+\_\+\+URBG$>$ }\\void \mbox{\hyperlink{namespaceigl_a7279a059983ae9a728c94ccc1983343d}{randperm}} (const int n, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, URBG \&\&urbg=\mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}())
\begin{DoxyCompactList}\small\item\em Like matlab\textquotesingle{}s randperm(n) but minus 1. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedsource , typename Deriveddir , typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_af41f8552f81764bc8793cb5f76a87553}{ray\+\_\+box\+\_\+intersect}} (const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&source, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&dir, const Eigen\+::\+Aligned\+Box$<$ Scalar, 3 $>$ \&box, const Scalar \&t0, const Scalar \&t1, Scalar \&tmin, Scalar \&tmax)
\begin{DoxyCompactList}\small\item\em Determine whether a ray origin+t\texorpdfstring{$\ast$}{*}dir and box intersect within the ray\textquotesingle{}s parameterized range (t0,t1) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedsource , typename Deriveddir , typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_a18af1e6cc596af264e3a02e02b823a01}{ray\+\_\+box\+\_\+intersect}} (const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&source, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&inv\+\_\+dir, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&inv\+\_\+dir\+\_\+pad, const Eigen\+::\+Aligned\+Box$<$ Scalar, 3 $>$ \&box, const Scalar \&t0, const Scalar \&t1, Scalar \&tmin, Scalar \&tmax)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_adcb07bb96941cdba2a28b4239f88a246}{ray\+\_\+mesh\+\_\+intersect}} (const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&source, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&dir, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&hits)
\begin{DoxyCompactList}\small\item\em Shoot a ray against a mesh (V,F) and collect all hits. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6a827e72cc935817ec986e83ce56cc73}{ray\+\_\+mesh\+\_\+intersect}} (const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&source, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&dir, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} \&hit)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_afab2426f066fcd19c79646bcca3501b8}{ray\+\_\+triangle\+\_\+intersect}} (const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&source, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&dir, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int f, \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} \&hit)
\item 
{\footnotesize template$<$typename Derivedo , typename Derivedd , typename Derivedc , typename r\+\_\+type , typename t\+\_\+type $>$ }\\int \mbox{\hyperlink{namespaceigl_a11b3c855b74e0beac5385f073686761e}{ray\+\_\+sphere\+\_\+intersect}} (const Eigen\+::\+Plain\+Object\+Base$<$ Derivedo $>$ \&o, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedd $>$ \&d, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, r\+\_\+type r, t\+\_\+type \&t0, t\+\_\+type \&t1)
\begin{DoxyCompactList}\small\item\em Compute the intersection between a ray from O in direction D and a sphere centered at C with radius r. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a28bb8198773c2124500fd5bc9a5f810b}{read\+\_\+file\+\_\+binary}} (FILE \texorpdfstring{$\ast$}{*}fp, std\+::vector$<$ uint8\+\_\+t $>$ \&file\+Buffer\+Bytes)
\begin{DoxyCompactList}\small\item\em Read contents of file into a buffer of uint8\+\_\+t bytes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6bd18b073b51beb1500c10c4f2825aba}{read\+\_\+triangle\+\_\+mesh}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Read mesh from an ascii file with automatic detection of file format among\+: mesh, msh obj, off, ply, stl, wrl. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad787fca3bc0010177aa587a1ad0d8bc8}{read\+\_\+triangle\+\_\+mesh}} (const std\+::string str, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_ae6cf40d2ba95e3819ecc7d733a73d321}{read\+\_\+triangle\+\_\+mesh}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, std\+::string \&dir, std\+::string \&base, std\+::string \&ext, std\+::string \&name)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a8cfd07940eb9445554a8f64c84ea385c}{read\+\_\+triangle\+\_\+mesh}} (const std\+::string \&ext, FILE \texorpdfstring{$\ast$}{*}fp, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+WI , typename DerivedP , typename DerivedO $>$ }\\bool \mbox{\hyperlink{namespaceigl_a4efbc110f683b253ef703142d1406f28}{read\+BF}} (const std\+::string \&filename, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WI $>$ \&WI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&O)
\begin{DoxyCompactList}\small\item\em Read a bones forest from a file, returns a list of bone roots. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+WI , typename DerivedbfP , typename DerivedO , typename DerivedC , typename Derived\+BE , typename DerivedP $>$ }\\bool \mbox{\hyperlink{namespaceigl_a0ad78f74b0306e9a2775575579314170}{read\+BF}} (const std\+::string \&filename, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WI $>$ \&WI, Eigen\+::\+Plain\+Object\+Base$<$ DerivedbfP $>$ \&bfP, Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&O, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BE $>$ \&BE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Read bone forest into pure bone-\/skeleton format, expects only bones (no point handles), and that a root in the .bf \texorpdfstring{$<$}{<}---\texorpdfstring{$>$}{>} no weight attachment. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_a5b133398a6e09068c97655f27de173a0}{read\+CSV}} (const std\+::string str, Eigen\+::\+Matrix$<$ Scalar, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&M)
\begin{DoxyCompactList}\small\item\em read a matrix from a csv file into a Eigen matrix \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_a44a50547ab59bcb0705475875bb39a7d}{read\+DMAT}} (const std\+::string file\+\_\+name, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Read a matrix from an .dmat file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_a866564d1ac5b6f69fcee878f2ac2429d}{read\+DMAT}} (const std\+::string file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&W)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedT $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa40ef4e0517c71c597272824497377b2}{read\+MESH}} (const std\+::string mesh\+\_\+file\+\_\+name, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Load a tetrahedral volume mesh from a .mesh file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a078957e6e3c6a1f4cff7de4d0a28956d}{read\+MESH}} (const std\+::string mesh\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&T, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedT $>$ }\\bool \mbox{\hyperlink{namespaceigl_a1471e99a81d4975918c69176594f4621}{read\+MESH}} (FILE \texorpdfstring{$\ast$}{*}mesh\+\_\+file, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a2bcad51e218e111ff185566bea366cb3}{read\+MESH}} (FILE \texorpdfstring{$\ast$}{*}mesh\+\_\+file, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&T, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Eigen\+Matrix\+Options$>$ }\\bool \mbox{\hyperlink{namespaceigl_a9364f18a5e9db3da7b923ab9ee054481}{read\+MSH}} (const std\+::string \&msh, Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&X, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&Tri, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&Tet, Eigen\+::\+Vector\+Xi \&Tri\+Tag, Eigen\+::\+Vector\+Xi \&Tet\+Tag, std\+::vector$<$ std\+::string $>$ \&XFields, std\+::vector$<$ Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ $>$ \&XF, std\+::vector$<$ std\+::string $>$ \&EFields, std\+::vector$<$ Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ $>$ \&TriF, std\+::vector$<$ Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ $>$ \&TetF)
\begin{DoxyCompactList}\small\item\em read triangle surface mesh and tetrahedral volume mesh from .msh file \end{DoxyCompactList}\item 
{\footnotesize template$<$int Eigen\+Matrix\+Options$>$ }\\bool \mbox{\hyperlink{namespaceigl_aadcaf1cbdf935ab8ae06264bc17a80b1}{read\+MSH}} (const std\+::string \&msh, Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&X, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&Tri, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&Tet, Eigen\+::\+Vector\+Xi \&Tri\+Tag, Eigen\+::\+Vector\+Xi \&Tet\+Tag)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Eigen\+Matrix\+Options$>$ }\\bool \mbox{\hyperlink{namespaceigl_ad3928fbb4033580f092da0afb953cc7c}{read\+MSH}} (const std\+::string \&msh, Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&X, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&Tri, Eigen\+::\+Vector\+Xi \&Tri\+Tag)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$int Eigen\+Matrix\+Options$>$ }\\bool \mbox{\hyperlink{namespaceigl_af2a21df0040f4d7799d33535261164ac}{read\+MSH}} (const std\+::string \&msh, Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&X, Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&Tri)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedI $>$ }\\bool \mbox{\hyperlink{namespaceigl_a0a5218e3a581f3ae7d3937db7cb6bafe}{read\+NODE}} (const std\+::string node\+\_\+file\+\_\+name, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em load a list of points from a .node file \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a9897d432300521fe95987a223d3c834c}{read\+NODE}} (const std\+::string node\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad3d68499324615abfb462bf80130431b}{read\+OBJ}} (const std\+::string obj\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&TC, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&N, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&FTC, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&FN, std\+::vector$<$ std\+::tuple$<$ std\+::string, Index, Index $>$ $>$ \&FM)
\begin{DoxyCompactList}\small\item\em Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8}{read\+OBJ}} (const std\+::string obj\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&TC, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&N, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&FTC, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&FN)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a86d39ea33fc7a17fb16a3e02a5065757}{read\+OBJ}} (FILE \texorpdfstring{$\ast$}{*}obj\+\_\+file, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&TC, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&N, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&FTC, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&FN, std\+::vector$<$ std\+::tuple$<$ std\+::string, Index, Index $>$ $>$ \&FM)
\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6485914541d342f476f70e9ba97a00ff}{read\+OBJ}} (const std\+::string obj\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+TC , typename Derived\+CN , typename DerivedF , typename Derived\+FTC , typename Derived\+FN $>$ }\\bool \mbox{\hyperlink{namespaceigl_a2d8c28b2557217c00bb8e146d828cd35}{read\+OBJ}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TC $>$ \&TC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&CN, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FTC $>$ \&FTC, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FN $>$ \&FN)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a3034889b938bdf0fa96f79ad62f47641}{read\+OBJ}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedI , typename DerivedC $>$ }\\bool \mbox{\hyperlink{namespaceigl_a4c4849d6cdcfeffd1ed7b48c15d493ad}{read\+OBJ}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_ae0b3fbb305991ff009d5ef2bf7c2bb99}{read\+OFF}} (const std\+::string off\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&N, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&C)
\begin{DoxyCompactList}\small\item\em Read a mesh from an ascii OFF file, filling in vertex positions, normals and texture coordinates. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a80e987bbb9c21c44facf425147ce0c0e}{read\+OFF}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a53bb9e4bd7e6acfc8838f372351d7fd5}{read\+OFF}} (const std\+::string str, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a805a632075fa2b99892f172b2063e8de}{read\+OFF}} (FILE \texorpdfstring{$\ast$}{*}off\+\_\+file, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&N, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ }\\bool \mbox{\hyperlink{namespaceigl_a19dbe47791345f0dff905ae3515ffd21}{read\+PLY}} (std\+::istream \&ply\+\_\+stream, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&UV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VD $>$ \&VD, std\+::vector$<$ std\+::string $>$ \&Vheader, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FD $>$ \&FD, std\+::vector$<$ std\+::string $>$ \&Fheader, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ED $>$ \&ED, std\+::vector$<$ std\+::string $>$ \&Eheader, std\+::vector$<$ std\+::string $>$ \&comments)
\begin{DoxyCompactList}\small\item\em Read triangular mesh from ply file, filling in vertex positions, normals and texture coordinates, if available also read additional properties associated with vertex,faces and edges and file comments. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ }\\bool \mbox{\hyperlink{namespaceigl_a2d9d95305b4c4ad23b0ae936bf8ebe28}{read\+PLY}} (const std\+::string \&ply\+\_\+file, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&UV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VD $>$ \&VD, std\+::vector$<$ std\+::string $>$ \&VDheader, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FD $>$ \&FD, std\+::vector$<$ std\+::string $>$ \&FDheader, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ED $>$ \&ED, std\+::vector$<$ std\+::string $>$ \&EDheader, std\+::vector$<$ std\+::string $>$ \&comments)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename Derived\+UV , typename Derived\+VD $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa82ecbf00ab1917446d26d4aaed0c79f}{read\+PLY}} (const std\+::string \&filename, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&UV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VD $>$ \&VD, std\+::vector$<$ std\+::string $>$ \&Vheader)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV $>$ }\\bool \mbox{\hyperlink{namespaceigl_a500ef30b39ed4e46a12342238fddd1ea}{read\+PLY}} (const std\+::string \&filename, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&UV)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_aab45ac576aa1e4ed7721b0a00e5d12c1}{read\+PLY}} (const std\+::string \&filename, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a18adc6f5870ec2806992a65719834abd}{read\+PLY}} (const std\+::string \&filename, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a0c0ed58390b96d5981b908b62103c250}{read\+PLY}} (FILE \texorpdfstring{$\ast$}{*}fp, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa1e874916eb50201727b290cc48fbaac}{read\+STL}} (std\+::istream \&input, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em Read a mesh from an ascii/binary stl file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TypeV , typename TypeF , typename TypeN $>$ }\\bool \mbox{\hyperlink{namespaceigl_a1b3c654bf8fde8ab6f7b55c515b11bea}{read\+STL}} (std\+::istream \&input, std\+::vector$<$ std\+::array$<$ TypeV, 3 $>$ $>$ \&V, std\+::vector$<$ std\+::array$<$ TypeF, 3 $>$ $>$ \&F, std\+::vector$<$ std\+::array$<$ TypeN, 3 $>$ $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa7d360f2f2694afebd1e62cee1551de4}{read\+STL}} (FILE \texorpdfstring{$\ast$}{*}fp, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a0e2ff313a45b1882bc42711ef59518ea}{read\+TGF}} (const std\+::string tgf\+\_\+filename, std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&C, std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&E, std\+::vector$<$ int $>$ \&P, std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&BE, std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&CE, std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&PE)
\begin{DoxyCompactList}\small\item\em Read a graph from a .tgf file. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a86a753ab8f368313c20aa9d6aa98841c}{read\+TGF}} (const std\+::string tgf\+\_\+filename, Eigen\+::\+Matrix\+Xd \&C, Eigen\+::\+Matrix\+Xi \&E, Eigen\+::\+Vector\+Xi \&P, Eigen\+::\+Matrix\+Xi \&BE, Eigen\+::\+Matrix\+Xi \&CE, Eigen\+::\+Matrix\+Xi \&PE)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a2cfc64e83ab4d2cd4fb8a6e31d4403d6}{read\+TGF}} (const std\+::string tgf\+\_\+filename, Eigen\+::\+Matrix\+Xd \&C, Eigen\+::\+Matrix\+Xi \&E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a480b2999b4d8ec50dcfa86d790f7b9d0}{read\+WRL}} (const std\+::string wrl\+\_\+file\+\_\+name, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em Read a mesh from an ascii wrl file, filling in vertex positions and face indices of the first model. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a90ea20362e20a0f75e389904a2957ed2}{read\+WRL}} (FILE \texorpdfstring{$\ast$}{*}wrl\+\_\+file, std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename Func , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_af757c8be2caaeaf804de6240cc6ffa7f}{redux}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, const Func \&func, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Perform reductions on the rows or columns of a Sparse\+Matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedU , typename DerivedG , typename DerivedJ , typename BCtype , typename Derived\+SU , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_a492e4e2a6bc227fe67a79b0110d4c8de}{remesh\+\_\+along\+\_\+isoline}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar val, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SU $>$ \&SU, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Sparse\+Matrix$<$ BCtype $>$ \&BC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Given a triangle mesh and a scalar field, remesh so that a given isovalue of the scalar field follows (new) edges of the output mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedS , typename DerivedG , typename DerivedJ , typename BCtype , typename Derived\+SU , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_a7057971dd3f4cb240c6598b5ee52eaff}{remesh\+\_\+along\+\_\+isoline}} (const int n, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, const typename Derived\+S\+::\+Scalar val, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SU $>$ \&SU, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J, Eigen\+::\+Sparse\+Matrix$<$ BCtype $>$ \&BC, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+SV , typename Derived\+SVI , typename Derived\+SVJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a4684c8d485a5cd367751c6bb92e8b415}{remove\+\_\+duplicate\+\_\+vertices}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const double epsilon, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&SVI, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVJ $>$ \&SVJ)
\begin{DoxyCompactList}\small\item\em Remove duplicate vertices upto a uniqueness tolerance (epsilon) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+SV , typename Derived\+SVI , typename Derived\+SVJ , typename Derived\+SF $>$ }\\void \mbox{\hyperlink{namespaceigl_ae2865c2682b8f7cda67db377ca026619}{remove\+\_\+duplicate\+\_\+vertices}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const double epsilon, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&SVI, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVJ $>$ \&SVJ, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF , typename DerivedI , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a8d51bedab2b1bb46c40334e6d59035bc}{remove\+\_\+unreferenced}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&NV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&NF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Remove unreferenced vertices from V, updating F accordingly. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a84fd84522be8f2e70fa6ef154849f3c1}{remove\+\_\+unreferenced}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&NV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&NF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedI , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a6afd2f60ecc2994c7f37deecac94dc80}{remove\+\_\+unreferenced}} (const size\+\_\+t n, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_ad35357b4f4e8dbf29c3fad77850fb957}{repdiag}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&A, const int d, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&B)
\begin{DoxyCompactList}\small\item\em Repeat a matrix along the diagonal a certain number of times, so that if A is a m by n matrix and we want to repeat along the diagonal d times, we get a m\texorpdfstring{$\ast$}{*}d by n\texorpdfstring{$\ast$}{*}d matrix B such that\+: B( (k\texorpdfstring{$\ast$}{*}m+1)\+:(k\texorpdfstring{$\ast$}{*}m+1+m-\/1), (k\texorpdfstring{$\ast$}{*}n+1)\+:(k\texorpdfstring{$\ast$}{*}n+1+n-\/1)) = A for k from 0 to d-\/1. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a4425112c9b09eccba5935d7390228b8f}{repdiag}} (const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&A, const int d, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&B)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Mat $>$ }\\Mat \mbox{\hyperlink{namespaceigl_a8da20ed25cb6630b40cb666c4f0153fb}{repdiag}} (const Mat \&A, const int d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38}{repmat}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const int r, const int c, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em Replicate and tile a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , int major\+Type$>$ }\\void \mbox{\hyperlink{namespaceigl_ab60f3cce9962403250a40b72d322e7c3}{repmat}} (const Eigen\+::\+Sparse\+Matrix$<$ T, major\+Type $>$ \&A, const int r, const int c, Eigen\+::\+Sparse\+Matrix$<$ T, major\+Type $>$ \&B)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+F1 , typename Derived\+F2 , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_aaadc5b485c5ab4b8719143b79e9458b2}{resolve\+\_\+duplicated\+\_\+faces}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+F1 $>$ \&F1, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F2 $>$ \&F2, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Resolve duplicated faces according to the following rules per unique face\+: \end{DoxyCompactList}\item 
{\footnotesize template$<$typename R , typename H $>$ }\\void \mbox{\hyperlink{namespaceigl_ad9c02b0853de3739e4fcfe1a39591826}{rgb\+\_\+to\+\_\+hsv}} (const R \texorpdfstring{$\ast$}{*}rgb, H \texorpdfstring{$\ast$}{*}hsv)
\begin{DoxyCompactList}\small\item\em Convert RGB to HSV. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedR , typename DerivedH $>$ }\\void \mbox{\hyperlink{namespaceigl_a2ffa1e3139c0b53002dfc44fa70bb3de}{rgb\+\_\+to\+\_\+hsv}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedH $>$ \&H)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedP , typename DerivedN , typename DerivedR , typename Derivedt $>$ }\\void \mbox{\hyperlink{namespaceigl_ad9b76e4f79b4040f8b327696d8120ac6}{rigid\+\_\+alignment}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&t)
\begin{DoxyCompactList}\small\item\em Find the rigid transformation that best aligns the 3D points X to their corresponding points P with associated normals N. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_ad3a4c70fcd75b8cb889db416e1412838}{rotate\+\_\+by\+\_\+quat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}v, const Q\+\_\+type \texorpdfstring{$\ast$}{*}q, Q\+\_\+type \texorpdfstring{$\ast$}{*}out)
\begin{DoxyCompactList}\small\item\em Compute rotation of a given vector/point by a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{namespaceigl_ac6346e87eb125dbf3922a86b2430cd66}{rotate\+\_\+vectors}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Vector\+Xd \&A, const Eigen\+::\+Matrix\+Xd \&B1, const Eigen\+::\+Matrix\+Xd \&B2)
\begin{DoxyCompactList}\small\item\em Rotate the vectors V by A radians on the tangent plane spanned by B1 and B2. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\Eigen\+::\+Matrix$<$ Scalar, 3, 3 $>$ \mbox{\hyperlink{namespaceigl_a9d8d4e651144f2c59335a8050526d3a2}{rotation\+\_\+matrix\+\_\+from\+\_\+directions}} (const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ v0, const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ v1)
\begin{DoxyCompactList}\small\item\em Given 2 vectors centered on origin calculate the rotation matrix from first to the second. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_ae02094b6dc03417864b855a494010674}{round}} (const DerivedX r)
\begin{DoxyCompactList}\small\item\em Round a scalar value. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a97b570d716cfd4d32ff22a5ec6b1d14b}{round}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&X, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Round a given matrix to nearest integers. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Row , class Mat $>$ }\\bool \mbox{\hyperlink{namespaceigl_a7fa793427dc212ca586bf37babf9459e}{rows\+\_\+to\+\_\+matrix}} (const std\+::vector$<$ Row $>$ \&V, Mat \&M)
\begin{DoxyCompactList}\small\item\em Convert a list (std\+::vector) of row vectors of the same length to a matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a32d8c4634efb1346c13c78dc765a3550}{sample\+\_\+edges}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&E, const int k, Eigen\+::\+Matrix\+Xd \&S)
\begin{DoxyCompactList}\small\item\em Compute k extra points along each edge in E defined over vertices of V. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ }\\void \mbox{\hyperlink{namespaceigl_a037463f70cf735b53d1205d9f24f8bd3}{scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&G)
\begin{DoxyCompactList}\small\item\em Computes the gradient matrix with hat functions on the right, and vector CR functions on the left. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ }\\void \mbox{\hyperlink{namespaceigl_adb08e6f491b4715eb69439e76a9d6829}{scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&G)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DeriveddA , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ }\\void \mbox{\hyperlink{namespaceigl_a27653ad9aae1bdd251eeb2b990cb69be}{scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&dA, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&G)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ }\\void \mbox{\hyperlink{namespaceigl_a9e243eeab5d04120f9aa5670610e5961}{scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient\+\_\+intrinsic}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&l\+\_\+sq, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&oE, Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&G)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{scalar__to__cr__vector__gradient_8h}{include/igl/scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW , typename Deriveda $>$ }\\void \mbox{\hyperlink{namespaceigl_a0aea89901f87476263f8973c9ea065e4}{screen\+\_\+space\+\_\+selection}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ DerivedV, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&model, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&proj, const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&viewport, const std\+::vector$<$ Eigen\+::\+Matrix$<$ Ltype, 1, 2 $>$ $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W, Eigen\+::\+Plain\+Object\+Base$<$ Deriveda $>$ \&and\+\_\+visible)
\begin{DoxyCompactList}\small\item\em Given a mesh, a camera determine which points are inside of a given 2D screen space polygon {\bfseries{culling points based on self-\/occlusion. }}\end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_aa76ba56f1ce1b064b681b9c9d1a258bf}{screen\+\_\+space\+\_\+selection}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&model, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&proj, const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&viewport, const std\+::vector$<$ Eigen\+::\+Matrix$<$ Ltype, 1, 2 $>$ $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Given a mesh, a camera determine which points are inside of a given 2D screen space polygon. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP , typename DerivedE , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_ad310e7bb193a3ef3e6b0de1b5598799b}{screen\+\_\+space\+\_\+selection}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&model, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&proj, const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&viewport, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Given a mesh, a camera determine which points are inside of a given 2D screen space polygon. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+TC , typename DerivedF , typename Derived\+FTC , typename Derivedseams , typename Derivedboundaries , typename Derivedfoldovers $>$ }\\void \mbox{\hyperlink{namespaceigl_ac159f8e26c3ca48a403dd1f27d3fd645}{seam\+\_\+edges}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TC $>$ \&TC, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FTC $>$ \&FTC, Eigen\+::\+Plain\+Object\+Base$<$ Derivedseams $>$ \&seams, Eigen\+::\+Plain\+Object\+Base$<$ Derivedboundaries $>$ \&boundaries, Eigen\+::\+Plain\+Object\+Base$<$ Derivedfoldovers $>$ \&foldovers)
\begin{DoxyCompactList}\small\item\em Finds all UV-\/space boundaries of a mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+Source , typename Derived\+Dir $>$ }\\bool \mbox{\hyperlink{namespaceigl_ab4c9b0f32a7605d9de8575ba478e0817}{segment\+\_\+segment\+\_\+intersect}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+Source $>$ \&p, const Eigen\+::\+Matrix\+Base$<$ Derived\+Dir $>$ \&r, const Eigen\+::\+Matrix\+Base$<$ Derived\+Source $>$ \&q, const Eigen\+::\+Matrix\+Base$<$ Derived\+Dir $>$ \&s, double \&t, double \&u, double eps=1e-\/6)
\begin{DoxyCompactList}\small\item\em Determine whether two line segments A,B intersect. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_a212b29890b63152674a53444a2003677}{serialize}} (const T \&obj, const std\+::string \&filename)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_ab2bd82ed66c652d0930f6b460886010b}{serialize}} (const T \&obj, const std\+::string \&object\+Name, const std\+::string \&filename, bool overwrite=false)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_af1e1aa7b19e544f9f8d0e5d2872c1b21}{serialize}} (const T \&obj, const std\+::string \&object\+Name, std\+::vector$<$ char $>$ \&buffer)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_a61617b81f6b89d6692a31f8d34c6d294}{deserialize}} (T \&obj, const std\+::string \&filename)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa8dfda78a1c420b40f80b07d1c3f8b2e}{deserialize}} (T \&obj, const std\+::string \&object\+Name, const std\+::string \&filename)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_a5dd8043bf43851bafaa6e264162eefce}{deserialize}} (T \&obj, const std\+::string \&object\+Name, const std\+::vector$<$ char $>$ \&buffer)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad1b7a7a566f0d4a5553987d4d25aedec}{serializer}} (bool \mbox{\hyperlink{namespaceigl_a212b29890b63152674a53444a2003677}{serialize}}, T \&obj, const std\+::string \&filename)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_a8dba28198b48a2a0432d5c4e640484e4}{serializer}} (bool \mbox{\hyperlink{namespaceigl_a212b29890b63152674a53444a2003677}{serialize}}, T \&obj, const std\+::string \&object\+Name, const std\+::string \&filename, bool overwrite=false)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_af28b32c6f34213f61257beff8a2927ca}{serializer}} (bool \mbox{\hyperlink{namespaceigl_a212b29890b63152674a53444a2003677}{serialize}}, T \&obj, const std\+::string \&object\+Name, std\+::vector$<$ char $>$ \&buffer)
\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename Derived\+IA $>$ }\\void \mbox{\hyperlink{namespaceigl_ad9fa51487804e5c3f67e72d4ff8fceb1}{setdiff}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA)
\begin{DoxyCompactList}\small\item\em Set difference of elements of matrices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename Derived\+IA , typename Derived\+IB $>$ }\\void \mbox{\hyperlink{namespaceigl_a925a8ea3a2337a70f7cadc603e7e741e}{setunion}} (const Eigen\+::\+Dense\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Dense\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IB $>$ \&IB)
\begin{DoxyCompactList}\small\item\em Union of elements of matrices (like matlab\textquotesingle{}s {\ttfamily union}) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename Derived\+IA , typename Derived\+IB $>$ }\\void \mbox{\hyperlink{namespaceigl_a9bbf23ea4d8a5f3ef6ce4117496fb037}{setxor}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IB $>$ \&IB)
\begin{DoxyCompactList}\small\item\em Set xor of elements of matrices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedN , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a3df5a621d40fe169f2138e39b8b81fec}{shape\+\_\+diameter\+\_\+function}} (const std\+::function$<$ double(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&) $>$ \&shoot\+\_\+ray, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Compute shape diamater function per given point. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a982784dfbf6aae442c5e9b0bc3fdcb53}{shape\+\_\+diameter\+\_\+function}} (const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ DerivedV, DIM $>$ \&aabb, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a46e0193f9523e75a450e14e3cf8179fd}{shape\+\_\+diameter\+\_\+function}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a725c756cdeba9b4dbc64ab4a50c50cfa}{shape\+\_\+diameter\+\_\+function}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const bool per\+\_\+face, const int num\+\_\+samples, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\item 
bool \mbox{\hyperlink{namespaceigl_a5df9db393a5b6b3865e7a10d9d02a31b}{shapeup\+\_\+identity\+\_\+projection}} (const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Vector\+Xi $>$ \&SC, const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xi $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&projP)
\begin{DoxyCompactList}\small\item\em This projection does nothing but render points into projP. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_aaced06a2a1f184dc5bfe8ff1b87d6d0d}{shapeup\+\_\+regular\+\_\+face\+\_\+projection}} (const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Vector\+Xi $>$ \&SC, const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xi $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&projP)
\begin{DoxyCompactList}\small\item\em the projection assumes that the sets are vertices of polygons in cyclic order \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename Derived\+SC , typename DerivedS , typename Derivedw $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad94a2c7d2cbbaf046ff244daa6620895}{shapeup\+\_\+precomputation}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SC $>$ \&SC, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&E, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SC $>$ \&b, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedw $>$ \&w\+Shape, const Eigen\+::\+Plain\+Object\+Base$<$ Derivedw $>$ \&w\+Smooth, \mbox{\hyperlink{structigl_1_1ShapeupData}{Shapeup\+Data}} \&sudata)
\begin{DoxyCompactList}\small\item\em This function precomputation the necessary matrices for the Shape\+Up process, and prefactorizes them. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename Derived\+SC , typename DerivedS $>$ }\\bool \mbox{\hyperlink{namespaceigl_a9b6baf02654fad9293e1560d71475185}{shapeup\+\_\+solve}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&bc, const std\+::function$<$ bool(const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SC $>$ \&, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&)$>$ \&local\+\_\+projection, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P0, const \mbox{\hyperlink{structigl_1_1ShapeupData}{Shapeup\+Data}} \&sudata, const bool quiet\+Iterations, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em This function solve the shapeup project optimization. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+SE , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+Etype , typename sharptype $>$ }\\void \mbox{\hyperlink{namespaceigl_a0b1cfc3d745b201faa8129b75d5a3b79}{sharp\+\_\+edges}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+V\+::\+Scalar angle, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SE $>$ \&SE, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, std\+::vector$<$ std\+::vector$<$ u\+E2\+Etype $>$ $>$ \&u\+E2E, std\+::vector$<$ sharptype $>$ \&sharp)
\begin{DoxyCompactList}\small\item\em Given a mesh, compute sharp edges. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+SE $>$ }\\void \mbox{\hyperlink{namespaceigl_a7002429ac13c0e1d678e1e9d9aea99d8}{sharp\+\_\+edges}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const typename Derived\+V\+::\+Scalar angle, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SE $>$ \&SE)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a571aed34e627db21360984824ccc7838}{shortest\+\_\+edge\+\_\+and\+\_\+midpoint}} (const int e, const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&E, const Eigen\+::\+Vector\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, const Eigen\+::\+Matrix\+Xi \&, double \&cost, Eigen\+::\+Row\+Vector\+Xd \&p)
\begin{DoxyCompactList}\small\item\em Cost and placement function compatible with \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedP $>$ }\\Derived\+A\+::\+Scalar \mbox{\hyperlink{namespaceigl_a78da3ad1832aa83542b3dc3a28e1a8e1}{signed\+\_\+angle}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Compute the signed angle subtended by the oriented 3d triangle (A,B,C) at some point P. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a094f93a7b569504f70587f81f75fd879}{signed\+\_\+distance}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}} sign\+\_\+type, const typename Derived\+V\+::\+Scalar lower\+\_\+bound, const typename Derived\+V\+::\+Scalar upper\+\_\+bound, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em Computes signed distance to a mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_a9379f935afc42d6fbad6340c07639c54}{signed\+\_\+distance}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}} sign\+\_\+type, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename Derivedq $>$ }\\Derived\+V\+::\+Scalar \mbox{\hyperlink{namespaceigl_a102279423d1d1b649cdf6a74558883dc}{signed\+\_\+distance\+\_\+pseudonormal}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&VN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&EN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q)
\begin{DoxyCompactList}\small\item\em Computes signed distance to mesh using pseudonormal with precomputed \doxylink{classigl_1_1AABB}{AABB} tree and edge/vertice normals. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN $>$ }\\void \mbox{\hyperlink{namespaceigl_aead78bb0215bc26bdb1dafabc8366acd}{signed\+\_\+distance\+\_\+pseudonormal}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&VN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&EN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&N)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn $>$ }\\void \mbox{\hyperlink{namespaceigl_a391b1e9f4f4bc678fac2b8c522ce4331}{signed\+\_\+distance\+\_\+pseudonormal}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&VN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&EN, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, Scalar \&s, Scalar \&sqrd, int \&i, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&n)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedE , typename Derived\+EN , typename Derived\+VN , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn $>$ }\\void \mbox{\hyperlink{namespaceigl_a5011d0263ec9b3347530d3d807596671}{signed\+\_\+distance\+\_\+pseudonormal}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 2 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&EN, const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&VN, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, Scalar \&s, Scalar \&sqrd, int \&i, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c, Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&n)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedq $>$ }\\Derived\+V\+::\+Scalar \mbox{\hyperlink{namespaceigl_a75576a9807c547b55f797639412650d6}{signed\+\_\+distance\+\_\+winding\+\_\+number}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{classigl_1_1WindingNumberAABB}{igl\+::\+Winding\+Number\+AABB}}$<$ Derivedq, DerivedV, DerivedF $>$ \&hier, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q)
\begin{DoxyCompactList}\small\item\em Computes signed distance to mesh using winding number with precomputed \doxylink{classigl_1_1AABB}{AABB}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc $>$ }\\void \mbox{\hyperlink{namespaceigl_ad184a41c6d66cebef9a4714a2d59326f}{signed\+\_\+distance\+\_\+winding\+\_\+number}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{classigl_1_1WindingNumberAABB}{igl\+::\+Winding\+Number\+AABB}}$<$ Derivedq, DerivedV, DerivedF $>$ \&hier, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, Scalar \&s, Scalar \&sqrd, int \&i, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc $>$ }\\void \mbox{\hyperlink{namespaceigl_af25f0719d3f6108b4917e1511a4941f5}{signed\+\_\+distance\+\_\+winding\+\_\+number}} (const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 2 $>$ \&tree, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, Scalar \&s, Scalar \&sqrd, int \&i, Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&c)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS $>$ }\\void \mbox{\hyperlink{namespaceigl_a88918723d512e80456d10a043fa25177}{signed\+\_\+distance\+\_\+fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const igl\+::\+Fast\+Winding\+Number\+BVH \&fwn\+\_\+bvh, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&S)
\begin{DoxyCompactList}\small\item\em Calculates signed distance at query points P, using fast winding number for sign. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedq , typename DerivedV , typename DerivedF $>$ }\\Derived\+V\+::\+Scalar \mbox{\hyperlink{namespaceigl_a0dabf308e8466b0ec192b798fc538eb4}{signed\+\_\+distance\+\_\+fast\+\_\+winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&q, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&tree, const igl\+::\+Fast\+Winding\+Number\+BVH \&fwn\+\_\+bvh)
\begin{DoxyCompactList}\small\item\em Calculates signed distance at query point q, using fast winding number for sign. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a4d3b37a4f86172d30f35d330aed1e7fe}{simplify\+\_\+polyhedron}} (const Eigen\+::\+Matrix\+Xd \&OV, const Eigen\+::\+Matrix\+Xi \&OF, Eigen\+::\+Matrix\+Xd \&V, Eigen\+::\+Matrix\+Xi \&F, Eigen\+::\+Vector\+Xi \&J)
\begin{DoxyCompactList}\small\item\em Simplify a polyhedron represented as a triangle mesh (OV,OF) by collapsing any edge that doesn\textquotesingle{}t contribute to defining surface\textquotesingle{}s pointset. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TX , typename TY , typename DerivedR , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{slice}} (const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatX , typename DerivedR , typename MatY $>$ }\\void \mbox{\hyperlink{namespaceigl_ae747d042c40e074264e161b49906216d}{slice}} (const MatX \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const int dim, MatY \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespaceigl_aa05264f934b9cecbac042ef69735b74b}{slice}} (const std\+::vector$<$ T $>$ \&X, std\+::vector$<$ size\+\_\+t $>$ const \&R, std\+::vector$<$ T $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_aae8c4cf15b6f5f8cc16da9405b96be59}{slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR , typename DerivedC , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a90268d9fb8c64692427036793191a8b7}{slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_a86abeffa3ef136e9e35057e526618dc8}{slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_aa5271870d0385781c2236145ee9c3897}{slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const int dim)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TX , typename TY , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a473da3d5636834fa6b0510d7a2f97628}{slice\+\_\+cached\+\_\+precompute}} (const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&X, const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&R, const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&C, Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&data, Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TX , typename TY , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a192c36479a5f74cfc02aaddd3afa4fea}{slice\+\_\+cached}} (const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&data, Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Slice X by cached C,R indices into Y. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T , typename DerivedR , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_ab893d0a94d4eb6a1c5422e7cfe368daf}{slice\+\_\+into}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Act like the matlab Y(row\+\_\+indices,col\+\_\+indices) = X. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatX , typename MatY , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_a185ee703c7cf8760af368bcb0861d37f}{slice\+\_\+into}} (const MatX \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&R, const int dim, MatY \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_afce428bb768059c8d6f9563873f8e730}{slice\+\_\+into}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_aa29b762b3094e33fd5167ca196de49ce}{slice\+\_\+into}} (const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename XType , typename YType $>$ }\\void \mbox{\hyperlink{namespaceigl_acb30d6061d773254628256682b88b427}{slice\+\_\+mask}} (const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&X, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&R, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ YType $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Act like the matlab X(row\+\_\+mask,col\+\_\+mask) operator, where row\+\_\+mask, col\+\_\+mask are non-\/negative integer indices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename XType , typename YType $>$ }\\void \mbox{\hyperlink{namespaceigl_a6770877236349590d6b4bbc2a6f616ad}{slice\+\_\+mask}} (const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&X, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&R, const int dim, Eigen\+::\+Sparse\+Matrix$<$ YType $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_aef569f1ee0e9cd71c2cfabd1e27e2f40}{slice\+\_\+mask}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&R, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_ab448e84d310f37a2cffd09d50faad326}{slice\+\_\+mask}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&R, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\item 
{\footnotesize template$<$typename DerivedX $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_afe884ab3e3a80bcea135959a5b9aa831}{slice\+\_\+mask}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&R, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_ae4dd189219e52c3496a80f36b82cbbce}{slice\+\_\+mask}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&R, const int dim)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename TX , typename TY , typename DerivedR , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_af8a1c0b05598d819b78e57f2525f5497}{slice\+\_\+sorted}} (const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a4b29382a965c510055a154aac6ecde4e}{slim\+\_\+precompute}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xd \&V\+\_\+init, \mbox{\hyperlink{structigl_1_1SLIMData}{SLIMData}} \&data, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{Mapping\+Energy\+Type}} slim\+\_\+energy, const Eigen\+::\+Vector\+Xi \&b, const Eigen\+::\+Matrix\+Xd \&bc, double soft\+\_\+p)
\begin{DoxyCompactList}\small\item\em Compute necessary information to start using SLIM. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xd \mbox{\hyperlink{namespaceigl_a5651f5d9a88f7dc131b6dd3b99f31fdf}{slim\+\_\+solve}} (\mbox{\hyperlink{structigl_1_1SLIMData}{SLIMData}} \&data, int iter\+\_\+num)
\begin{DoxyCompactList}\small\item\em Run iter\+\_\+num iterations of SLIM. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a02c86d444aaf4ab498a1466a59775059}{slim\+\_\+update\+\_\+weights\+\_\+and\+\_\+closest\+\_\+rotations\+\_\+with\+\_\+jacobians}} (const Eigen\+::\+Matrix\+Xd \&Ji, \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type}} slim\+\_\+energy, double exp\+\_\+factor, Eigen\+::\+Matrix\+Xd \&W, Eigen\+::\+Matrix\+Xd \&Ri)
\begin{DoxyCompactList}\small\item\em Internal Routine. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_ac1a2368c134ab7daeb5cfb40b5a0e639}{slim\+\_\+buildA}} (const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&Dx, const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&Dy, const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&Dz, const Eigen\+::\+Matrix\+Xd \&W, std\+::vector$<$ Eigen\+::\+Triplet$<$ double $>$ $>$ \&IJV)
\begin{DoxyCompactList}\small\item\em Undocumented function related to SLIM optimization. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_aef5e220e449787733ece4abbc94f419a}{smooth\+\_\+corner\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const double corner\+\_\+threshold\+\_\+radians, Eigen\+::\+Vector\+Xi \&CI, Eigen\+::\+Vector\+Xi \&CC)
\begin{DoxyCompactList}\small\item\em Determine the corner-\/to-\/face adjacency relationship that can be used for computing crease-\/aware per-\/corner normals. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a6eedd51ba703a9667e0bc21d6de863d8}{smooth\+\_\+corner\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Xi \&FV, const Eigen\+::\+Matrix\+Xi \&FN, Eigen\+::\+Vector\+Xi \&CI, Eigen\+::\+Vector\+Xi \&CC)
\begin{DoxyCompactList}\small\item\em Determine the effective corner-\/to-\/face adjacency relationship implied by a set of indexed vertex positions (FV) and normals (FV) (e.\+g., those read in from a .obj file). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD , typename Derived\+VI $>$ }\\void \mbox{\hyperlink{namespaceigl_a3c65a87d0656aad1a67568ce7fe62505}{snap\+\_\+points}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedminD $>$ \&minD, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&VI)
\begin{DoxyCompactList}\small\item\em Snap list of points C to closest of another list of points V. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD $>$ }\\void \mbox{\hyperlink{namespaceigl_a0456e1ef831df9943ee2f062e8119655}{snap\+\_\+points}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I, Eigen\+::\+Plain\+Object\+Base$<$ DerivedminD $>$ \&minD)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedC , typename DerivedV , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_aa76c38e927f8da17319f7809593f78b0}{snap\+\_\+points}} (const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalarq , typename Scalars $>$ }\\bool \mbox{\hyperlink{namespaceigl_a2773ac49873440379d546be16bf756e8}{snap\+\_\+to\+\_\+canonical\+\_\+view\+\_\+quat}} (const Eigen\+::\+Quaternion$<$ Scalarq $>$ \&q, const double threshold, Eigen\+::\+Quaternion$<$ Scalars $>$ \&s)
\begin{DoxyCompactList}\small\item\em Snap the quaternion q to the nearest canonical view quaternion. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\bool \mbox{\hyperlink{namespaceigl_a972274b2ed4c85251899428421619ad5}{snap\+\_\+to\+\_\+canonical\+\_\+view\+\_\+quat}} (const Q\+\_\+type \texorpdfstring{$\ast$}{*}q, const Q\+\_\+type threshold, Q\+\_\+type \texorpdfstring{$\ast$}{*}s)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Qtype $>$ }\\void \mbox{\hyperlink{namespaceigl_af6de4ebdb7f531d96fb57a566e0d121c}{snap\+\_\+to\+\_\+fixed\+\_\+up}} (const Eigen\+::\+Quaternion$<$ Qtype $>$ \&q, Eigen\+::\+Quaternion$<$ Qtype $>$ \&s)
\begin{DoxyCompactList}\small\item\em Snap an arbitrary rotation to a rotation resulting from a rotation about the y-\/axis then the x-\/axis (maintaining fixed up like two\+\_\+axis\+\_\+valuator\+\_\+fixed\+\_\+up.) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedP $>$ }\\Derived\+A\+::\+Scalar \mbox{\hyperlink{namespaceigl_ac42833fb0899d755feb35dbf0db24410}{solid\+\_\+angle}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P)
\begin{DoxyCompactList}\small\item\em Compute the signed solid angle subtended by the oriented 3d triangle (A,B,C) at some point P. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ }\\void \mbox{\hyperlink{namespaceigl_aea54a5804527aa194785e403870ba7db}{sort}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&IX)
\begin{DoxyCompactList}\small\item\em Sort the elements of a matrix X along a given dimension like matlabs sort function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a1b8c55dff1cae23221b5570ad7f9c194}{sort}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ }\\void \mbox{\hyperlink{namespaceigl_a4dd6daca2b874edaf27301a111ed2401}{sort\+\_\+new}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&IX)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ }\\void \mbox{\hyperlink{namespaceigl_a61ad3bd047a94be9c5ad7bf8890dd798}{sort2}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&IX)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ }\\void \mbox{\hyperlink{namespaceigl_a6bfeee50844cf4deac8ad3b473407428}{sort3}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const int dim, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&IX)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespaceigl_a5ee021e4c406d792e624a3ddbdc5145d}{sort}} (const std\+::vector$<$ T $>$ \&unsorted, const bool ascending, std\+::vector$<$ T $>$ \&sorted, std\+::vector$<$ size\+\_\+t $>$ \&index\+\_\+map)
\begin{DoxyCompactList}\small\item\em Act like matlab\textquotesingle{}s \mbox{[}Y,I\mbox{]} = SORT(\+X) for std library vectors. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedM , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_af203a35e46d72618e788c9c02e5f2e0c}{sort\+\_\+angles}} (const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em Sort angles in ascending order in a numerically robust way. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+MV , typename DerivedP , typename Derived\+FF , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a1c0a98c41282a4c612da5ad971a4a676}{sort\+\_\+triangles}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+MV $>$ \&MV, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Sort triangles by depth (from back to front) using a painter\textquotesingle{}s algorithm. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_ab6d31a3df6fc3ab3d769b240cc8ca2f5}{sort\+\_\+vectors\+\_\+ccw}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&order, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&sorted, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&inv\+\_\+order)
\begin{DoxyCompactList}\small\item\em Sorts a set of N coplanar vectors in a ccw order, and returns their order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_ad12fb37ec629691009ae42d926adcb02}{sort\+\_\+vectors\+\_\+ccw}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&order, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&sorted)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a9b4fdcbef0f11737a037711a7ebf833c}{sort\+\_\+vectors\+\_\+ccw}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&order, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&inv\+\_\+order)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_a08c139732fd7bcd7379c91befbb35775}{sort\+\_\+vectors\+\_\+ccw}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&N, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&order)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_af8ac99e9c2a051fdbc1b1c132e8102f8}{sortrows}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&I)
\begin{DoxyCompactList}\small\item\em Act like matlab\textquotesingle{}s \mbox{[}Y,I\mbox{]} = sortrows(\+X) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a4f276cc65a7f7d0a0929e983028a3169}{sortrows}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const bool ascending, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Index\+VectorI , class Index\+VectorJ , class Value\+Vector , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_aa0031015feb34d6398264ceac841bc0c}{sparse}} (const Index\+VectorI \&I, const Index\+VectorJ \&J, const Value\+Vector \&V, const size\+\_\+t m, const size\+\_\+t n, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X)
\begin{DoxyCompactList}\small\item\em Build a sparse matrix from list of indices and values (I,J,V), functions like the sparse function in matlab. \end{DoxyCompactList}\item 
{\footnotesize template$<$class Index\+Vector , class Value\+Vector , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a55e6cc04971d8a30de15d18272221aa9}{sparse}} (const Index\+Vector \&I, const Index\+Vector \&J, const Value\+Vector \&V, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedD , typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a1af79e7e819b442592de8d5db2e5829c}{sparse}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X)
\begin{DoxyCompactList}\small\item\em Convert a full, dense matrix to a sparse one. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedD $>$ }\\Eigen\+::\+Sparse\+Matrix$<$ typename Derived\+D\+::\+Scalar $>$ \mbox{\hyperlink{namespaceigl_aee96f9beefd8dd12066e82a32b314855}{sparse}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&D)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedI , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_ac623ce43ac510a2b3374c791984d819c}{sparse\+\_\+cached\+\_\+precompute}} (const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&I, const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&J, Eigen\+::\+Vector\+Xi \&data, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&X)
\begin{DoxyCompactList}\small\item\em Build a sparse matrix from list of indices and values (I,J,V), similarly to the sparse function in matlab. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a652603bae4d621913f8679441ac6d771}{sparse\+\_\+cached\+\_\+precompute}} (const std\+::vector$<$ Eigen\+::\+Triplet$<$ Scalar $>$ $>$ \&triplets, Eigen\+::\+Vector\+Xi \&data, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&X)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_abff00fedf6ea99985f251a964eb2fe21}{sparse\+\_\+cached}} (const std\+::vector$<$ Eigen\+::\+Triplet$<$ Scalar $>$ $>$ \&triplets, const Eigen\+::\+Vector\+Xi \&data, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&X)
\begin{DoxyCompactList}\small\item\em Build a sparse matrix from cached list of data and values. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_adb2f3d6b20dcda22b4415935b0b4a250}{sparse\+\_\+cached}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Vector\+Xi \&data, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&X)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+P0 , typename Func , typename DerivedS , typename DerivedV , typename DerivedI $>$ }\\void \mbox{\hyperlink{namespaceigl_ae4c369ebc42c4e76553730c636d7967d}{sparse\+\_\+voxel\+\_\+grid}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+P0 $>$ \&p0, const Func \&scalar\+Func, const double eps, const int expected\+\_\+number\+\_\+of\+\_\+cubes, Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&CS, Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&CV, Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&CI)
\begin{DoxyCompactList}\small\item\em Given a point, p0, on an isosurface, construct a shell of epsilon sized cubes surrounding the surface. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_ab7bca403061433327f7ae13005e190a6}{speye}} (const int n, const int m, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&I)
\begin{DoxyCompactList}\small\item\em Builds an m by n sparse identity matrix like matlab\textquotesingle{}s speye function. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a99a506e0e604f1618c56560c1c3238a7}{speye}} (const int n, Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&I)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+SF , typename Derived\+SVI $>$ }\\void \mbox{\hyperlink{namespaceigl_ad087e73516c7afa1370f7b24c1132a36}{split\+\_\+nonmanifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&SVI)
\begin{DoxyCompactList}\small\item\em Split a non-\/manifold (or non-\/orientable) mesh into a orientable manifold mesh possibly with more connected components and geometrically duplicate vertices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+SV , typename Derived\+SF , typename Derived\+SVI $>$ }\\void \mbox{\hyperlink{namespaceigl_af6330810b20e78a8af65cb151d537d6d}{split\+\_\+nonmanifold}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&SV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&SF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&SVI)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedL $>$ }\\void \mbox{\hyperlink{namespaceigl_a45669ed07ec4ce3c9d9af3c976246bda}{squared\+\_\+edge\+\_\+lengths}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&L)
\begin{DoxyCompactList}\small\item\em Constructs a list of squared lengths of edges opposite each index in a face (triangle/tet) list. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a8f4750b8f143bb05a426374c4c65b92a}{stdin\+\_\+to\+\_\+temp}} (FILE \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}temp\+\_\+file)
\begin{DoxyCompactList}\small\item\em Write stdin/piped input to a temporary file which can than be preprocessed as it is (a normal file). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+VT , typename Derived\+FT , typename Scalar , typename Derived\+UE , typename Derived\+UT , typename Derived\+OT $>$ }\\void \mbox{\hyperlink{namespaceigl_a43464482f2fd9b2c4b7e2beac12fc522}{straighten\+\_\+seams}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+VT $>$ \&VT, const Eigen\+::\+Matrix\+Base$<$ Derived\+FT $>$ \&FT, const Scalar tol, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UE $>$ \&UE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UT $>$ \&UT, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OT $>$ \&OT)
\begin{DoxyCompactList}\small\item\em Given a obj-\/style mesh with (V,F) defining the geometric surface of the mesh and (VT,FT) defining the parameterization/texture-\/mapping of the mesh in the uv-\/domain, find all seams and boundaries in the texture-\/mapping and "{}straighten"{} them, remapping vertices along the boundary and in the interior. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_ac4a359f88733a83493b68b6f605a5161}{starts\+\_\+with}} (const std\+::string \&str, const std\+::string \&prefix)
\begin{DoxyCompactList}\small\item\em Check if a string starts with a given prefix. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_ad5e02163e30570e181965fba3609c8b4}{starts\+\_\+with}} (const char \texorpdfstring{$\ast$}{*}str, const char \texorpdfstring{$\ast$}{*}prefix)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{string__utils_8h}{include/igl/string\+\_\+utils.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}{sum}} (const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&X, const int dim, Eigen\+::\+Sparse\+Vector$<$ T $>$ \&S)
\begin{DoxyCompactList}\small\item\em Sum the columns or rows of a sparse matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename AType , typename DerivedB $>$ }\\void \mbox{\hyperlink{namespaceigl_a5bcbac428755ce31717db4079956840b}{sum}} (const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&A, const int dim, Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&B)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a3b7376c37ca3ec7bb7dc4cf7fdecfe36}{svd3x3}} (const Eigen\+::\+Matrix$<$ T, 3, 3 $>$ \&A, Eigen\+::\+Matrix$<$ T, 3, 3 $>$ \&U, Eigen\+::\+Matrix$<$ T, 3, 1 $>$ \&S, Eigen\+::\+Matrix$<$ T, 3, 3 $>$ \&V)
\begin{DoxyCompactList}\small\item\em Super fast 3x3 SVD according to \href{http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/\texorpdfstring{$\sim$}{\string~}sifakis/project\+\_\+pages/svd.\+html}} The resulting decomposition is A = U \texorpdfstring{$\ast$}{*} diag(\+S\mbox{[}0\mbox{]}, S\mbox{[}1\mbox{]}, S\mbox{[}2\mbox{]}) \texorpdfstring{$\ast$}{*} V\textquotesingle{}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a4153817f124410a202847cbf878d271b}{svd3x3\+\_\+avx}} (const Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 3 $>$ \&A, Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 3 $>$ \&U, Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 1 $>$ \&S, Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 3 $>$ \&V)
\begin{DoxyCompactList}\small\item\em Super fast 3x3 SVD according to \href{http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/\texorpdfstring{$\sim$}{\string~}sifakis/project\+\_\+pages/svd.\+html}} This is AVX version of svd3x3 (see \doxylink{svd3x3_8h}{svd3x3.\+h}) which works on 8 matrices at a time These eight matrices are simply stacked in columns, the rest is the same as for svd3x3. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_ae67ee73993135205bd97cfc9c8453d68}{svd3x3\+\_\+sse}} (const Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 3 $>$ \&A, Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 3 $>$ \&U, Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 1 $>$ \&S, Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 3 $>$ \&V)
\item 
void \mbox{\hyperlink{namespaceigl_a525f425d4315f9547a6e82782d7d672b}{swept\+\_\+volume}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const std\+::function$<$ Eigen\+::\+Affine3d(const double t)$>$ \&transform, const size\+\_\+t steps, const size\+\_\+t grid\+\_\+res, const size\+\_\+t isolevel, Eigen\+::\+Matrix\+Xd \&SV, Eigen\+::\+Matrix\+Xi \&SF)
\begin{DoxyCompactList}\small\item\em Compute the surface of the swept volume of a solid object with surface (V,F) mesh under going rigid motion. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a0739e2c6e91f7aa950aca9580a90e612}{swept\+\_\+volume\+\_\+bounding\+\_\+box}} (const size\+\_\+t \&n, const std\+::function$<$ Eigen\+::\+Row\+Vector3d(const size\+\_\+t vi, const double t)$>$ \&V, const size\+\_\+t \&steps, Eigen\+::\+Aligned\+Box3d \&box)
\begin{DoxyCompactList}\small\item\em Construct an axis-\/aligned bounding box containing a shape undergoing a motion sampled at {\ttfamily steps} discrete momements. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a2df37d639d7915a6623d3dd0deecaf8a}{swept\+\_\+volume\+\_\+signed\+\_\+distance}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const std\+::function$<$ Eigen\+::\+Affine3d(const double t)$>$ \&transform, const size\+\_\+t \&steps, const Eigen\+::\+Matrix\+Xd \&GV, const Eigen\+::\+Row\+Vector3i \&res, const double h, const double isolevel, const Eigen\+::\+Vector\+Xd \&S0, Eigen\+::\+Vector\+Xd \&S)
\begin{DoxyCompactList}\small\item\em Compute the signed distance to a sweep surface of a mesh under-\/going an arbitrary motion V(t) discretely sampled at {\ttfamily steps}-\/many moments in time at a grid. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a030deb66b915a2f498701588640ee3a4}{swept\+\_\+volume\+\_\+signed\+\_\+distance}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const std\+::function$<$ Eigen\+::\+Affine3d(const double t)$>$ \&transform, const size\+\_\+t \&steps, const Eigen\+::\+Matrix\+Xd \&GV, const Eigen\+::\+Row\+Vector3i \&res, const double h, const double isolevel, Eigen\+::\+Vector\+Xd \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\Scalar \mbox{\hyperlink{namespaceigl_aca626f9c0a1f205b884fc1c6787c6a59}{tan\+\_\+half\+\_\+angle}} (const Scalar \&a, const Scalar \&b, const Scalar \&c)
\begin{DoxyCompactList}\small\item\em Compute the tangent of half of the angle opposite the side with length a, in a triangle with side lengths (a,b,c). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedT , typename Derived\+TT , typename Derived\+TTi $>$ }\\void \mbox{\hyperlink{namespaceigl_ab9fcd72a6173a2c6d4e4651a706b2911}{tet\+\_\+tet\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&TT, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TTi $>$ \&TTi)
\begin{DoxyCompactList}\small\item\em Constructs the tet\+\_\+tet adjacency matrix for a given tet mesh with tets T. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedT , typename Derived\+TT $>$ }\\void \mbox{\hyperlink{namespaceigl_ada72de8eeac466f8cb2a52016a1bd1cf}{tet\+\_\+tet\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&TT)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+GV , typename Derived\+GT $>$ }\\void \mbox{\hyperlink{namespaceigl_a09d82782b314ba8729b05712387f7ec4}{tetrahedralized\+\_\+grid}} (const int nx, const int ny, const int nz, const \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}{Tetrahedralized\+Grip\+Type}} type, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&GV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GT $>$ \&GT)
\begin{DoxyCompactList}\small\item\em Construct vertices of a regular grid, suitable for input to {\ttfamily \doxylink{namespaceigl_a5512306a29939c7ac8d4ebcef2cd032a}{igl\+::marching\+\_\+tets}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedside , typename Derived\+GT $>$ }\\void \mbox{\hyperlink{namespaceigl_ae86a7e69f97c1ca839467731e3944441}{tetrahedralized\+\_\+grid}} (const Eigen\+::\+Matrix\+Base$<$ Derivedside $>$ \&side, const \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}{Tetrahedralized\+Grip\+Type}} type, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GT $>$ \&GT)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Vector\+Index , typename Derived\+F\+\_\+filled $>$ }\\void \mbox{\hyperlink{namespaceigl_a6f1fa0516e3b6395846621d6a79507e8}{topological\+\_\+hole\+\_\+fill}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const std\+::vector$<$ Vector\+Index $>$ \&holes, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F\+\_\+filled $>$ \&F\+\_\+filled)
\begin{DoxyCompactList}\small\item\em Topological fill hole on a mesh, with one additional vertex each hole Index of new abstract vertices will be F.\+max\+Coeff() + (index of hole) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_a4c72a7f89ae16b8e5196c4cd37fb2689}{trackball}} (const double w, const double h, const Q\+\_\+type speed\+\_\+factor, const double down\+\_\+mouse\+\_\+x, const double down\+\_\+mouse\+\_\+y, const double mouse\+\_\+x, const double mouse\+\_\+y, Q\+\_\+type \texorpdfstring{$\ast$}{*}quat)
\begin{DoxyCompactList}\small\item\em Applies a trackball drag to identity. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Q\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_a46c31d9f94cfdba0d5da1b69f4f4d968}{trackball}} (const double w, const double h, const Q\+\_\+type speed\+\_\+factor, const Q\+\_\+type \texorpdfstring{$\ast$}{*}down\+\_\+quat, const double down\+\_\+mouse\+\_\+x, const double down\+\_\+mouse\+\_\+y, const double mouse\+\_\+x, const double mouse\+\_\+y, Q\+\_\+type \texorpdfstring{$\ast$}{*}quat)
\begin{DoxyCompactList}\small\item\em Applies a trackball drag to a given rotation. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalardown\+\_\+quat , typename Scalarquat $>$ }\\void \mbox{\hyperlink{namespaceigl_aaf9d8f7f6bbca5f24365f3ce5f401f9a}{trackball}} (const double w, const double h, const double speed\+\_\+factor, const Eigen\+::\+Quaternion$<$ Scalardown\+\_\+quat $>$ \&down\+\_\+quat, const double down\+\_\+mouse\+\_\+x, const double down\+\_\+mouse\+\_\+y, const double mouse\+\_\+x, const double mouse\+\_\+y, Eigen\+::\+Quaternion$<$ Scalarquat $>$ \&quat)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a5fa327db1af41a1e29e474981b963409}{transpose\+\_\+blocks}} (const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&A, const size\+\_\+t k, const size\+\_\+t dim, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&B)
\begin{DoxyCompactList}\small\item\em Transpose blocks of a matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+P1 , typename Derived\+Q1 , typename Derived\+R1 , typename Derived\+P2 , typename Derived\+Q2 , typename Derived\+R2 $>$ }\\bool \mbox{\hyperlink{namespaceigl_a62161fdfef57c22542b38d735550b635}{tri\+\_\+tri\+\_\+overlap\+\_\+test\+\_\+3d}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+P1 $>$ \&p1, const Eigen\+::\+Matrix\+Base$<$ Derived\+Q1 $>$ \&q1, const Eigen\+::\+Matrix\+Base$<$ Derived\+R1 $>$ \&r1, const Eigen\+::\+Matrix\+Base$<$ Derived\+P2 $>$ \&p2, const Eigen\+::\+Matrix\+Base$<$ Derived\+Q2 $>$ \&q2, const Eigen\+::\+Matrix\+Base$<$ Derived\+R2 $>$ \&r2)
\item 
{\footnotesize template$<$typename Derived\+P1 , typename Derived\+Q1 , typename Derived\+R1 , typename Derived\+P2 , typename Derived\+Q2 , typename Derived\+R2 , typename DerivedS , typename DerivedT $>$ }\\bool \mbox{\hyperlink{namespaceigl_a56ff893a73c2642eeec2692d37aad4d0}{tri\+\_\+tri\+\_\+intersection\+\_\+test\+\_\+3d}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+P1 $>$ \&p1, const Eigen\+::\+Matrix\+Base$<$ Derived\+Q1 $>$ \&q1, const Eigen\+::\+Matrix\+Base$<$ Derived\+R1 $>$ \&r1, const Eigen\+::\+Matrix\+Base$<$ Derived\+P2 $>$ \&p2, const Eigen\+::\+Matrix\+Base$<$ Derived\+Q2 $>$ \&q2, const Eigen\+::\+Matrix\+Base$<$ Derived\+R2 $>$ \&r2, bool \&coplanar, Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&source, Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&target)
\item 
{\footnotesize template$<$typename Derived\+P1 , typename Derived\+Q1 , typename Derived\+R1 , typename Derived\+P2 , typename Derived\+Q2 , typename Derived\+R2 $>$ }\\bool \mbox{\hyperlink{namespaceigl_ac4e80369c0a74cc009ec973dd70fd752}{tri\+\_\+tri\+\_\+overlap\+\_\+test\+\_\+2d}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+P1 $>$ \&p1, const Eigen\+::\+Matrix\+Base$<$ Derived\+Q1 $>$ \&q1, const Eigen\+::\+Matrix\+Base$<$ Derived\+R1 $>$ \&r1, const Eigen\+::\+Matrix\+Base$<$ Derived\+P2 $>$ \&p2, const Eigen\+::\+Matrix\+Base$<$ Derived\+Q2 $>$ \&q2, const Eigen\+::\+Matrix\+Base$<$ Derived\+R2 $>$ \&r2)
\item 
{\footnotesize template$<$typename DerivedE , typename Derivedcap $>$ }\\void \mbox{\hyperlink{namespaceigl_a9ce1a2b984f20466ffc7732ab29501ba}{triangle\+\_\+fan}} (const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ Derivedcap $>$ \&cap)
\begin{DoxyCompactList}\small\item\em Given a list of faces tessellate all of the "{}exterior"{} edges forming another list of. \end{DoxyCompactList}\item 
Eigen\+::\+Matrix\+Xi \mbox{\hyperlink{namespaceigl_a6b17a92c69587c651fe1b4d549235a9d}{triangle\+\_\+fan}} (const Eigen\+::\+Matrix\+Xi \&E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+TT , typename Derived\+TTi $>$ }\\void \mbox{\hyperlink{namespaceigl_ae07b1e4d35569138ffa0d8a874f0e24f}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&TT, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TTi $>$ \&TTi)
\begin{DoxyCompactList}\small\item\em Constructs the triangle-\/triangle adjacency matrix for a given mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+TT $>$ }\\void \mbox{\hyperlink{namespaceigl_a7210f2492117b1c482907e6a47dbed75}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&TT)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename TTT\+\_\+type $>$ }\\void \mbox{\hyperlink{namespaceigl_add74393b2dabd37b8efd0a7c2145372a}{triangle\+\_\+triangle\+\_\+adjacency\+\_\+preprocess}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ TTT\+\_\+type $>$ $>$ \&TTT)
\begin{DoxyCompactList}\small\item\em Preprocessing for triangle\+\_\+triangle\+\_\+adjacency. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename TTT\+\_\+type , typename Derived\+TT $>$ }\\void \mbox{\hyperlink{namespaceigl_a45cd01351200f4312c4fa5abef9c63a1}{triangle\+\_\+triangle\+\_\+adjacency\+\_\+extract\+TT}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ TTT\+\_\+type $>$ $>$ \&TTT, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&TT)
\begin{DoxyCompactList}\small\item\em Extract the face adjacencies for triangle\+\_\+triangle\+\_\+adjacency. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename TTT\+\_\+type , typename Derived\+TTi $>$ }\\void \mbox{\hyperlink{namespaceigl_a81887c23c0079fb92f46a517cd42f752}{triangle\+\_\+triangle\+\_\+adjacency\+\_\+extract\+TTi}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ TTT\+\_\+type $>$ $>$ \&TTT, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TTi $>$ \&TTi)
\begin{DoxyCompactList}\small\item\em Extract the face adjacencies indices for triangle\+\_\+triangle\+\_\+adjacency. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename TTIndex , typename TTi\+Index $>$ }\\void \mbox{\hyperlink{namespaceigl_a99e6fd086c1507cb6b02df0b458566cd}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&TT, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&TTi)
\begin{DoxyCompactList}\small\item\em Adjacency list version, which works with non-\/manifold meshes. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename TTIndex $>$ }\\void \mbox{\hyperlink{namespaceigl_a5ea1a1ba3c8bee980c00db518fb9f443}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&TT)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename TTIndex , typename TTi\+Index $>$ }\\void \mbox{\hyperlink{namespaceigl_ad091a40b270aa5030a3dd0909e6402e6}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const bool construct\+\_\+\+TTi, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&TT, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&TTi)
\item 
{\footnotesize template$<$typename DerivedE , typename Derived\+EMAP , typename u\+E2\+EType , typename TTIndex , typename TTi\+Index $>$ }\\void \mbox{\hyperlink{namespaceigl_ab979438c0daba73490363a56fc67f54a}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E, const bool construct\+\_\+\+TTi, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&TT, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&TTi)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename TTIndex , typename TTi\+Index $>$ }\\void \mbox{\hyperlink{namespaceigl_afc80c379b811624a97c1ed29ba4df0fb}{triangle\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&EMAP, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&u\+EC, const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&u\+EE, const bool construct\+\_\+\+TTi, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&TT, std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&TTi)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedS , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_ae67465786e131443ebdb6bdae0aa701f}{triangles\+\_\+from\+\_\+strip}} (const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Create a list of triangles from a stream of indices along a strip. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename XType , typename YType , typename Derived\+GV , typename Derived\+GF $>$ }\\void \mbox{\hyperlink{namespaceigl_a3be3b842294c1e29d654ace1e4f735ca}{triangulated\+\_\+grid}} (const XType \&nx, const YType \&ny, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&GV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GF $>$ \&GF)
\begin{DoxyCompactList}\small\item\em Create a regular grid of elements (only 2D supported, currently) Vertex position order is compatible with {\ttfamily \doxylink{namespaceigl_adfb4bab2b437369dce2059e85836bd9a}{igl\+::grid}} \end{DoxyCompactList}\item 
{\footnotesize template$<$typename XType , typename YType , typename Derived\+GF $>$ }\\void \mbox{\hyperlink{namespaceigl_a82c16be739961936bc5159688a4c7683}{triangulated\+\_\+grid}} (const XType \&nx, const YType \&ny, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GF $>$ \&GF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV $>$ }\\Derived\+V\+::\+Scalar \mbox{\hyperlink{namespaceigl_a38fd083e49162fe9dfe2e1de54948c89}{turning\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V)
\begin{DoxyCompactList}\small\item\em Compute the turning number of a closed curve in the plane. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalardown\+\_\+quat , typename Scalarquat $>$ }\\void \mbox{\hyperlink{namespaceigl_aaef42c6f3251414c7485b4d1433a54e4}{two\+\_\+axis\+\_\+valuator\+\_\+fixed\+\_\+up}} (const int w, const int h, const double speed, const Eigen\+::\+Quaternion$<$ Scalardown\+\_\+quat $>$ \&down\+\_\+quat, const int down\+\_\+x, const int down\+\_\+y, const int mouse\+\_\+x, const int mouse\+\_\+y, Eigen\+::\+Quaternion$<$ Scalarquat $>$ \&quat)
\begin{DoxyCompactList}\small\item\em Applies a two-\/axis valuator drag rotation (as seen in Maya/\+Studio max) to a given rotation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_a653da1c359295934ee69235ad8d43db4}{uniformly\+\_\+sample\+\_\+two\+\_\+manifold}} (const Eigen\+::\+Matrix\+Xd \&W, const Eigen\+::\+Matrix\+Xi \&F, const int k, const double push, Eigen\+::\+Matrix\+Xd \&WS)
\begin{DoxyCompactList}\small\item\em Attempt to sample a mesh uniformly with k-\/points by furthest point relaxation as described in "{}\+Fast Automatic Skinning Transformations"{} \mbox{[}Jacobson et al. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_ad17a2faf487e7a4ee375842967d6b285}{uniformly\+\_\+sample\+\_\+two\+\_\+manifold\+\_\+at\+\_\+vertices}} (const Eigen\+::\+Matrix\+Xd \&W, const int k, const double push, Eigen\+::\+Vector\+Xi \&S)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{uniformly__sample__two__manifold_8h}{include/igl/uniformly\+\_\+sample\+\_\+two\+\_\+manifold.\+h}. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_a45aa8c440aeb5e9aab5fb79156197153}{unique}} (const std\+::vector$<$ T $>$ \&A, std\+::vector$<$ T $>$ \&C, std\+::vector$<$ size\+\_\+t $>$ \&IA, std\+::vector$<$ size\+\_\+t $>$ \&IC)
\begin{DoxyCompactList}\small\item\em Act like matlab\textquotesingle{}s \mbox{[}C,IA,IC\mbox{]} = unique(\+X) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_ae97cc0b7a30e7285c6375d63fca2946c}{unique}} (const std\+::vector$<$ T $>$ \&A, std\+::vector$<$ T $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedC , typename Derived\+IA , typename Derived\+IC $>$ }\\void \mbox{\hyperlink{namespaceigl_a715dcc29e1a1beb8b358ebd275765fbb}{unique}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IC $>$ \&IC)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a03a554daf5ff87c8e4661b250e0078ce}{unique}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType $>$ }\\void \mbox{\hyperlink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{unique\+\_\+edge\+\_\+map}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&u\+E2E)
\begin{DoxyCompactList}\small\item\em Construct relationships between facet "{}half"{}-\/(or rather "{}viewed"{})-\/edges E to unique edges of the mesh seen as a graph. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP $>$ }\\void \mbox{\hyperlink{namespaceigl_a386a94bc8aaf45b2eb84b355d2bff311}{unique\+\_\+edge\+\_\+map}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE $>$ }\\void \mbox{\hyperlink{namespaceigl_a50a5bc29088ffa37e630cf9fd0d92c66}{unique\+\_\+edge\+\_\+map}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&E, Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&uE, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&EMAP, Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&u\+EC, Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&u\+EE)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedC , typename Derived\+IA , typename Derived\+IC $>$ }\\void \mbox{\hyperlink{namespaceigl_adc1388186f7f12be43df64d7ad45a136}{unique\+\_\+rows}} (const Eigen\+::\+Dense\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IC $>$ \&IC)
\begin{DoxyCompactList}\small\item\em Act like matlab\textquotesingle{}s \mbox{[}C,IA,IC\mbox{]} = unique(X,\textquotesingle{}rows\textquotesingle{}) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+FF , typename Derived\+IA , typename Derived\+IC $>$ }\\void \mbox{\hyperlink{namespaceigl_a23358af3f14021f32e9d30758f80a9a7}{unique\+\_\+simplices}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&IA, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IC $>$ \&IC)
\begin{DoxyCompactList}\small\item\em Find {\itshape combinatorially} unique simplices in F. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+FF $>$ }\\void \mbox{\hyperlink{namespaceigl_a20ecb806162f1bbe1260c630e8bb941d}{unique\+\_\+simplices}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&FF)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedwin , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Derivedscene $>$ }\\void \mbox{\hyperlink{namespaceigl_a04b29a2138c5fa4268400e42b8df04a9}{unproject}} (const Eigen\+::\+Matrix\+Base$<$ Derivedwin $>$ \&win, const Eigen\+::\+Matrix\+Base$<$ Derivedmodel $>$ \&model, const Eigen\+::\+Matrix\+Base$<$ Derivedproj $>$ \&proj, const Eigen\+::\+Matrix\+Base$<$ Derivedviewport $>$ \&viewport, Eigen\+::\+Plain\+Object\+Base$<$ Derivedscene $>$ \&scene)
\begin{DoxyCompactList}\small\item\em Eigen reimplementation of glu\+Unproject. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ \mbox{\hyperlink{namespaceigl_ac545f7c2b0b725169a3785ba8e5bdbc2}{unproject}} (const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ \&win, const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&model, const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&proj, const Eigen\+::\+Matrix$<$ Scalar, 4, 1 $>$ \&viewport)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedobj $>$ }\\int \mbox{\hyperlink{namespaceigl_adec5b69e885a84437436bde2e86bb09a}{unproject\+\_\+in\+\_\+mesh}} (const Eigen\+::\+Vector2f \&pos, const Eigen\+::\+Matrix4f \&model, const Eigen\+::\+Matrix4f \&proj, const Eigen\+::\+Vector4f \&viewport, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derivedobj $>$ \&obj, std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&hits)
\begin{DoxyCompactList}\small\item\em Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position {\itshape inside} a given mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedobj $>$ }\\int \mbox{\hyperlink{namespaceigl_a25fc2d8b2c9e58a5006fe7f8ea6308ec}{unproject\+\_\+in\+\_\+mesh}} (const Eigen\+::\+Vector2f \&pos, const Eigen\+::\+Matrix4f \&model, const Eigen\+::\+Matrix4f \&proj, const Eigen\+::\+Vector4f \&viewport, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derivedobj $>$ \&obj)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedobj $>$ }\\int \mbox{\hyperlink{namespaceigl_a86f5bf3b46d4f04f8189b0a5b489e4bb}{unproject\+\_\+in\+\_\+mesh}} (const Eigen\+::\+Vector2f \&pos, const Eigen\+::\+Matrix4f \&model, const Eigen\+::\+Matrix4f \&proj, const Eigen\+::\+Vector4f \&viewport, const std\+::function$<$ void(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&, std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&) $>$ \&shoot\+\_\+ray, Eigen\+::\+Plain\+Object\+Base$<$ Derivedobj $>$ \&obj, std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&hits)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename Derivedorigin , typename Deriveddir $>$ }\\void \mbox{\hyperlink{namespaceigl_a28d4df676266aad88e2fad4b43a0777c}{unproject\+\_\+on\+\_\+line}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&VP, const Eigen\+::\+Matrix\+Base$<$ Derivedorigin $>$ \&origin, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&dir, typename Derived\+UV\+::\+Scalar \&t)
\begin{DoxyCompactList}\small\item\em Given a screen space point (u,v) and the current projection matrix (e.\+g. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename Derivedorigin , typename Deriveddir , typename DerivedZ $>$ }\\void \mbox{\hyperlink{namespaceigl_addb8ea814628c47819f95f70ed6ff5d8}{unproject\+\_\+on\+\_\+line}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&VP, const Eigen\+::\+Matrix\+Base$<$ Derivedorigin $>$ \&origin, const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&dir, Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&Z)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename DerivedP , typename DerivedZ $>$ }\\void \mbox{\hyperlink{namespaceigl_a0cf2e9896877756fbe8f09c0b051e76d}{unproject\+\_\+on\+\_\+plane}} (const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&M, const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&VP, const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&P, Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&Z)
\begin{DoxyCompactList}\small\item\em Given a screen space point (u,v) and the current projection matrix (e.\+g. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedbc $>$ }\\bool \mbox{\hyperlink{namespaceigl_abbefb4e32e184a299b36f663b23b7b9c}{unproject\+\_\+onto\+\_\+mesh}} (const Eigen\+::\+Vector2f \&pos, const Eigen\+::\+Matrix4f \&model, const Eigen\+::\+Matrix4f \&proj, const Eigen\+::\+Vector4f \&viewport, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, int \&fid, Eigen\+::\+Plain\+Object\+Base$<$ Derivedbc $>$ \&bc)
\begin{DoxyCompactList}\small\item\em Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position {\itshape onto} a given mesh, if the ray through the given screen location (x,y) {\itshape hits} the mesh. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedbc $>$ }\\bool \mbox{\hyperlink{namespaceigl_af4d029fbc6f770b7dec469f743858d8f}{unproject\+\_\+onto\+\_\+mesh}} (const Eigen\+::\+Vector2f \&pos, const Eigen\+::\+Matrix4f \&model, const Eigen\+::\+Matrix4f \&proj, const Eigen\+::\+Vector4f \&viewport, const std\+::function$<$ bool(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&, \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} \&) $>$ \&shoot\+\_\+ray, int \&fid, Eigen\+::\+Plain\+Object\+Base$<$ Derivedbc $>$ \&bc)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derivedpos , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Deriveds , typename Deriveddir $>$ }\\void \mbox{\hyperlink{namespaceigl_a171d8ab81ed0ba003408f162c80a5505}{unproject\+\_\+ray}} (const Eigen\+::\+Matrix\+Base$<$ Derivedpos $>$ \&pos, const Eigen\+::\+Matrix\+Base$<$ Derivedmodel $>$ \&model, const Eigen\+::\+Matrix\+Base$<$ Derivedproj $>$ \&proj, const Eigen\+::\+Matrix\+Base$<$ Derivedviewport $>$ \&viewport, Eigen\+::\+Plain\+Object\+Base$<$ Deriveds $>$ \&s, Eigen\+::\+Plain\+Object\+Base$<$ Deriveddir $>$ \&dir)
\begin{DoxyCompactList}\small\item\em Construct a ray (source point + direction vector) given a screen space positions (e.\+g. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedU , typename DerivedG , typename DerivedJ $>$ }\\void \mbox{\hyperlink{namespaceigl_a681d80aaa80e594a1983b10aaf6006fd}{unzip\+\_\+corners}} (const std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ DerivedA $>$ $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&U, Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&G, Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&J)
\begin{DoxyCompactList}\small\item\em Given a triangle mesh where corners of each triangle index different matrices of attributes (e.\+g. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename SType , typename Derived\+NF $>$ }\\void \mbox{\hyperlink{namespaceigl_a7897e133babd19415648e5aaef9cc63a}{upsample}} (const int n\+\_\+verts, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ SType $>$ \&S, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&NF)
\begin{DoxyCompactList}\small\item\em Subdivide without moving vertices\+: Given the triangle mesh \mbox{[}V, F\mbox{]}, where n\+\_\+verts = V.\+rows(), computes newV and a sparse matrix S s.\+t. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF $>$ }\\void \mbox{\hyperlink{namespaceigl_a22564028c3ea860f1dcfb72d48872602}{upsample}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&NV, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&NF, const int number\+\_\+of\+\_\+subdivs=1)
\begin{DoxyCompactList}\small\item\em Subdivide a mesh without moving vertices\+: loop subdivision but odd vertices stay put and even vertices are just edge midpoints. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatV , typename MatF $>$ }\\void \mbox{\hyperlink{namespaceigl_a9347f30f3803c2aa656a3b73ed9c02f5}{upsample}} (MatV \&V, MatF \&F, const int number\+\_\+of\+\_\+subdivs=1)
\item 
{\footnotesize template$<$typename DerivedF , typename Scalar $>$ }\\void \mbox{\hyperlink{namespaceigl_a4a3e7408bbfe1e7f478d79af1ab05dc0}{vector\+\_\+area\+\_\+matrix}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&A)
\begin{DoxyCompactList}\small\item\em Constructs the symmetric area matrix A, s.\+t. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespaceigl_a1052b6f357eb1bcc4258d45490d866ad}{verbose}} (const char \texorpdfstring{$\ast$}{*}msg,...)
\begin{DoxyCompactList}\small\item\em Provide a wrapper for printf, called verbose that functions exactly like printf if VERBOSE is defined and does exactly nothing if VERBOSE is undefined. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedC , typename Derivedcounts $>$ }\\void \mbox{\hyperlink{namespaceigl_ab8159118b103ccc116d788259917acdb}{vertex\+\_\+components}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ Derivedcounts $>$ \&counts)
\begin{DoxyCompactList}\small\item\em Compute connected components of a graph represented by an adjacency matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a669ae9814690f3c0f466cfae73890263}{vertex\+\_\+components}} (const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedA $>$ \&A, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a1cfebfe524e61fecdadf7d789ddb9ec9}{vertex\+\_\+components}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Compute the connected components for a mesh given its faces. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename VFType , typename VFi\+Type $>$ }\\void \mbox{\hyperlink{namespaceigl_acabdf409439e0498066a620d30db6899}{vertex\+\_\+triangle\+\_\+adjacency}} (const typename Derived\+F\+::\+Scalar n, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ VFType $>$ $>$ \&VF, std\+::vector$<$ std\+::vector$<$ VFi\+Type $>$ $>$ \&VFi)
\begin{DoxyCompactList}\small\item\em vertex\+\_\+face\+\_\+adjacency constructs the vertex-\/face topology of a given mesh (V,F) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Index\+Type $>$ }\\void \mbox{\hyperlink{namespaceigl_a44c886a9ced7765ce3e2f03332bbcf91}{vertex\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&VF, std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&VFi)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedF , typename Derived\+VF , typename Derived\+NI $>$ }\\void \mbox{\hyperlink{namespaceigl_a6e4082714e403404167543bddf89ba53}{vertex\+\_\+triangle\+\_\+adjacency}} (const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const int n, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VF $>$ \&VF, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NI $>$ \&NI)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename Derivedvol $>$ }\\void \mbox{\hyperlink{namespaceigl_a289cc75429d0c045af9eca70642b8f8a}{volume}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, Eigen\+::\+Plain\+Object\+Base$<$ Derivedvol $>$ \&vol)
\begin{DoxyCompactList}\small\item\em Compute volume for all tets of a given tet mesh (V,T) \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename Derivedvol $>$ }\\void \mbox{\hyperlink{namespaceigl_ab25567c5af213643fd332e32003e63b4}{volume}} (const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&A, const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&B, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C, const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&D, Eigen\+::\+Plain\+Object\+Base$<$ Derivedvol $>$ \&vol)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename VecA , typename VecB , typename VecC , typename VecD $>$ }\\Vec\+A\+::\+Scalar \mbox{\hyperlink{namespaceigl_a89ebffa70b6797c8fd0404da673aaf3c}{volume\+\_\+single}} (const VecA \&a, const VecB \&b, const VecC \&c, const VecD \&d)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedL , typename Derivedvol $>$ }\\void \mbox{\hyperlink{namespaceigl_a0da5bd53ebc802822b96aebabbfddfa1}{volume}} (const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&L, Eigen\+::\+Plain\+Object\+Base$<$ Derivedvol $>$ \&vol)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Derived\+GV , typename Derivedside $>$ }\\void \mbox{\hyperlink{namespaceigl_adbd087fd838f29b3d9e50ef45403f2ce}{voxel\+\_\+grid}} (const Eigen\+::\+Aligned\+Box$<$ Scalar, 3 $>$ \&box, const int s, const int pad\+\_\+count, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&GV, Eigen\+::\+Plain\+Object\+Base$<$ Derivedside $>$ \&side)
\begin{DoxyCompactList}\small\item\em Construct the cell center positions of a regular voxel grid (lattice) made of perfectly square voxels. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename Derived\+GV , typename Derivedside $>$ }\\void \mbox{\hyperlink{namespaceigl_a467c3ec21d8d152e2e6aaf04ef8ab1da}{voxel\+\_\+grid}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const typename Derived\+V\+::\+Scalar offset, const int s, const int pad\+\_\+count, Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&GV, Eigen\+::\+Plain\+Object\+Base$<$ Derivedside $>$ \&side)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedO , typename DerivedW $>$ }\\void \mbox{\hyperlink{namespaceigl_a468f01ca961ac9ea78d02b3ecac25bee}{winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&O, Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&W)
\begin{DoxyCompactList}\small\item\em Computes the generalized winding number at each dim-\/dimensional query point in O with respect to the oriented one-\/codimensional mesh (V,F). \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derivedp $>$ }\\Derived\+V\+::\+Scalar \mbox{\hyperlink{namespaceigl_a6aab3f308b50dd0cafa361fed13ee213}{winding\+\_\+number}} (const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&p)
\begin{DoxyCompactList}\small\item\em Compute winding number of a single point. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_aa10e48891b5b843708fd73f095a5f96c}{write\+\_\+triangle\+\_\+mesh}} (const std\+::string str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding=\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{File\+Encoding\+::\+Ascii}})
\begin{DoxyCompactList}\small\item\em write mesh to a file with automatic detection of file format. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Derived\+WI , typename DerivedP , typename DerivedO $>$ }\\bool \mbox{\hyperlink{namespaceigl_a95b5e18062898bc13278debb80127424}{write\+BF}} (const std\+::string \&filename, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WI $>$ \&WI, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&P, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&O)
\begin{DoxyCompactList}\small\item\em Write a bones forest to a file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedW $>$ }\\bool \mbox{\hyperlink{namespaceigl_a8159d2953cb18953457a90976885ff57}{write\+DMAT}} (const std\+::string file\+\_\+name, const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&W, const bool ascii=true)
\begin{DoxyCompactList}\small\item\em Write a matrix using ascii dmat file type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_a24f57ac9b3108c7e4e62890786a69337}{write\+DMAT}} (const std\+::string file\+\_\+name, const std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&W, const bool ascii=true)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar $>$ }\\bool \mbox{\hyperlink{namespaceigl_ace5cabc9f902b654e3a9169855250e7c}{write\+DMAT}} (const std\+::string file\+\_\+name, const std\+::vector$<$ Scalar $>$ \&W, const bool ascii=true)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Scalar , typename Index $>$ }\\bool \mbox{\hyperlink{namespaceigl_a6a6b14a1061d9ce7d0ef20880e604186}{write\+MESH}} (const std\+::string mesh\+\_\+file\+\_\+name, const std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&V, const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&T, const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em save a tetrahedral volume mesh to a .mesh file \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedT , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_ac173c671f0c9f633abe3daa005455507}{write\+MESH}} (const std\+::string str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&T, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em save a tetrahedral volume mesh to a .mesh file \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a2df694c52f937d065a10d20c184ddfc4}{write\+MSH}} (const std\+::string \&msh, const Eigen\+::\+Matrix\+Xd \&X, const Eigen\+::\+Matrix\+Xi \&Tri, const Eigen\+::\+Matrix\+Xi \&Tet, const Eigen\+::\+Matrix\+Xi \&Tri\+Tag, const Eigen\+::\+Matrix\+Xi \&Tet\+Tag, const std\+::vector$<$ std\+::string $>$ \&XFields, const std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&XF, const std\+::vector$<$ std\+::string $>$ \&EFields, const std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&TriF, const std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&TetF)
\begin{DoxyCompactList}\small\item\em write triangle surface mesh and tetrahedral volume mesh to .msh file \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename Derived\+CN , typename Derived\+FN , typename Derived\+TC , typename Derived\+FTC $>$ }\\bool \mbox{\hyperlink{namespaceigl_a1a1761a85ec5cdef44ce8104d0ccdc3f}{write\+OBJ}} (const std\+::string str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ Derived\+CN $>$ \&CN, const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&FN, const Eigen\+::\+Matrix\+Base$<$ Derived\+TC $>$ \&TC, const Eigen\+::\+Matrix\+Base$<$ Derived\+FTC $>$ \&FTC)
\begin{DoxyCompactList}\small\item\em Write a mesh in an ascii obj file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad361555ef88be9751c1940298028a4a3}{write\+OBJ}} (const std\+::string str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename T $>$ }\\bool \mbox{\hyperlink{namespaceigl_a5acdf796fe0c739fd37989deb859f564}{write\+OBJ}} (const std\+::string \&str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&F)
\begin{DoxyCompactList}\small\item\em Write a mesh of mixed tris and quads to an ascii obj file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ }\\bool \mbox{\hyperlink{namespaceigl_a3c26424f96cf3b86305b18dd91dd0c83}{write\+OFF}} (const std\+::string str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em Export geometry and colors-\/by-\/vertex to an ascii OFF file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_ab9d5937707edc99d534ccab39d14429c}{write\+OFF}} (const std\+::string str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ }\\bool \mbox{\hyperlink{namespaceigl_ad75b8abd010b0cc4ce47469b3f855e42}{write\+PLY}} (std\+::ostream \&ply\+\_\+stream, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&VD, const std\+::vector$<$ std\+::string $>$ \&VDheader, const Eigen\+::\+Matrix\+Base$<$ Derived\+FD $>$ \&FD, const std\+::vector$<$ std\+::string $>$ \&FDheader, const Eigen\+::\+Matrix\+Base$<$ Derived\+ED $>$ \&ED, const std\+::vector$<$ std\+::string $>$ \&EDheader, const std\+::vector$<$ std\+::string $>$ \&comments, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding)
\begin{DoxyCompactList}\small\item\em write triangular mesh to ply file \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ }\\bool \mbox{\hyperlink{namespaceigl_ab97df6737c8ab9d4d1c9093491d41c2a}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&VD, const std\+::vector$<$ std\+::string $>$ \&VDheader, const Eigen\+::\+Matrix\+Base$<$ Derived\+FD $>$ \&FD, const std\+::vector$<$ std\+::string $>$ \&FDheader, const Eigen\+::\+Matrix\+Base$<$ Derived\+ED $>$ \&ED, const std\+::vector$<$ std\+::string $>$ \&EDheader, const std\+::vector$<$ std\+::string $>$ \&comments, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a089a8c3e1a12d0ad0be24eb7b9b35f47}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a0f47de9a532d3a6d2ccc94267d3806f2}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename Derived\+UV $>$ }\\bool \mbox{\hyperlink{namespaceigl_a21c501124b7b44b6adf81a2a11a1fea2}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV $>$ }\\bool \mbox{\hyperlink{namespaceigl_a263e6503e126ed829c6a3e3e9c188110}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_abe192d7895221e908003d65ab544d24f}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ }\\bool \mbox{\hyperlink{namespaceigl_a689ca1568cfbecb2d29a1c37d6f38e7b}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename Derived\+UV , typename Derived\+VD $>$ }\\bool \mbox{\hyperlink{namespaceigl_a0c7f6c3884f0355670c8fcdb36923671}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&VD=Eigen\+::\+Matrix\+Xd(0, 0), const std\+::vector$<$ std\+::string $>$ \&VDheader=\{\}, const std\+::vector$<$ std\+::string $>$ \&comments=\{\})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD $>$ }\\bool \mbox{\hyperlink{namespaceigl_aedef9e44fe11f235719d619185e404b7}{write\+PLY}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&E, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&UV, const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&VD=Eigen\+::\+Matrix\+Xd(0, 0), const std\+::vector$<$ std\+::string $>$ \&VDheader=\{\}, const std\+::vector$<$ std\+::string $>$ \&comments=\{\})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ }\\bool \mbox{\hyperlink{namespaceigl_a07adddd7239a8b049f1383c09d78d245}{write\+STL}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&N, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding=\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{File\+Encoding\+::\+Ascii}})
\begin{DoxyCompactList}\small\item\em Write a mesh to an stl file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a13c6477f242f1c28b713fc41205f21db}{write\+STL}} (const std\+::string \&filename, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}} encoding=\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{File\+Encoding\+::\+Ascii}})
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_ae98f5c58b4e2db831a37794d14e68190}{write\+TGF}} (const std\+::string tgf\+\_\+filename, const std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&C, const std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&E)
\begin{DoxyCompactList}\small\item\em Write a graph to a .tgf file. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_a217cf16c6a0be84701d89c49b3337ff4}{write\+TGF}} (const std\+::string tgf\+\_\+filename, const Eigen\+::\+Matrix\+Xd \&C, const Eigen\+::\+Matrix\+Xi \&E)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\bool \mbox{\hyperlink{namespaceigl_a0cfecc2999b584fe90aa57e9e6538ddd}{write\+WRL}} (const std\+::string \&str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F)
\begin{DoxyCompactList}\small\item\em Write mesh to a .wrl file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ }\\bool \mbox{\hyperlink{namespaceigl_a315f62cc42f483bf2651f05eb1fd6d71}{write\+WRL}} (const std\+::string \&str, const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&F, const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&C)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const float \mbox{\hyperlink{namespaceigl_a4132693fc82720d3e947c09aad236d96}{IDENTITY\+\_\+\+QUAT\+\_\+F}} \mbox{[}4\mbox{]} = \{0,0,0,1\}
\item 
const float \mbox{\hyperlink{namespaceigl_afc1c639c804d4e91dc1ffb424c5caf37}{XY\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+F}} \mbox{[}4\mbox{]} = \{0,0,0,1\}
\item 
const float \mbox{\hyperlink{namespaceigl_adf4ae9044c47ccad908df3775523d731}{XZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+F}} \mbox{[}4\mbox{]} = \{-\/\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}},0,0,\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}}\}
\item 
const float \mbox{\hyperlink{namespaceigl_abd154ccb32e580426fe71c29fccf45e8}{YZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+F}} \mbox{[}4\mbox{]} = \{-\/0.\+5,-\/0.\+5,-\/0.\+5,0.\+5\}
\item 
const float \mbox{\hyperlink{namespaceigl_ab16914177d382aa61d647d2bdac2f61a}{CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT\+\_\+F}} \mbox{[}$\,$\mbox{]}\mbox{[}4\mbox{]}
\item 
const double \mbox{\hyperlink{namespaceigl_a4d25a0a671a74bdb8bea35d6dc482d66}{IDENTITY\+\_\+\+QUAT\+\_\+D}} \mbox{[}4\mbox{]} = \{0,0,0,1\}
\item 
const double \mbox{\hyperlink{namespaceigl_a1e0bd2386fb8512b5fccf9abaab47952}{XY\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+D}} \mbox{[}4\mbox{]} = \{0,0,0,1\}
\item 
const double \mbox{\hyperlink{namespaceigl_a83519a14c0cfc4eb50105894232e10a4}{XZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+D}} \mbox{[}4\mbox{]} = \{-\/\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}},0,0,\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}}\}
\item 
const double \mbox{\hyperlink{namespaceigl_aec963f40812a8ab05b4b6b370fce4cfd}{YZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+D}} \mbox{[}4\mbox{]} = \{-\/0.\+5,-\/0.\+5,-\/0.\+5,0.\+5\}
\item 
const double \mbox{\hyperlink{namespaceigl_abbe2a3410b25f28096dcde690d7df743}{CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT\+\_\+D}} \mbox{[}$\,$\mbox{]}\mbox{[}4\mbox{]}
\item 
const double \mbox{\hyperlink{namespaceigl_a959bd85cf0ed1b59e3a9ad857c953604}{DOUBLE\+\_\+\+EPS}} = 1.\+0e-\/14
\begin{DoxyCompactList}\small\item\em Standard value for double epsilon. \end{DoxyCompactList}\item 
const double \mbox{\hyperlink{namespaceigl_ab4c4eb25dcc0beddf9732c13704a07b7}{DOUBLE\+\_\+\+EPS\+\_\+\+SQ}} = 1.\+0e-\/28
\begin{DoxyCompactList}\small\item\em Standard value for double epsilon \end{DoxyCompactList}\item 
const float \mbox{\hyperlink{namespaceigl_a7184cb6e2f319e3c31a0e1f5bc90354d}{FLOAT\+\_\+\+EPS}} = 1.\+0e-\/7f
\begin{DoxyCompactList}\small\item\em Standard value for single epsilon. \end{DoxyCompactList}\item 
const float \mbox{\hyperlink{namespaceigl_a529be4dc6f96c94adc21d8480d9d9bbf}{FLOAT\+\_\+\+EPS\+\_\+\+SQ}} = 1.\+0e-\/14f
\begin{DoxyCompactList}\small\item\em Standard value for single epsilon \end{DoxyCompactList}\item 
const float \mbox{\hyperlink{namespaceigl_a2719a5fd20a68136038b7132136e74bf}{GOLD\+\_\+\+AMBIENT}} \mbox{[}4\mbox{]} = \{ 51.\+0/255.\+0, 43.\+0/255.\+0,33.\+3/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a8589d6f0c07c7387258e004cfade2567}{GOLD\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,228.\+0/255.\+0,58.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a63110eff6fbd6ded60fc3c4a004c1ac3}{GOLD\+\_\+\+SPECULAR}} \mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,235.\+0/255.\+0,80.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a2cea9492c40178a4255d810a81b27abb}{SILVER\+\_\+\+AMBIENT}} \mbox{[}4\mbox{]} = \{ 0.\+2f, 0.\+2f, 0.\+2f, 1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a285eccdcab39b99b34da071d0e811328}{SILVER\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 1.\+0f, 1.\+0f, 1.\+0f, 1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_adde55f12f19663cc168932e3cbaa1033}{SILVER\+\_\+\+SPECULAR}} \mbox{[}4\mbox{]} = \{ 1.\+0f, 1.\+0f, 1.\+0f, 1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a41f327ea1271a24126e5b54b58137207}{CYAN\+\_\+\+AMBIENT}} \mbox{[}4\mbox{]} = \{ 59.\+0/255.\+0, 68.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_aa91b40d8001ba8a6732b57ea544e3cff}{CYAN\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 94.\+0/255.\+0,185.\+0/255.\+0,238.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a2aa44781d95faf982b844c0aa39b3138}{CYAN\+\_\+\+SPECULAR}} \mbox{[}4\mbox{]} = \{ 163.\+0/255.\+0,221.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a35121926b4786e30ae17f9f96c2657c6}{DENIS\+\_\+\+PURPLE\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 80.\+0/255.\+0,64.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a31d9148951bd2c269433253e37bdb5fa}{LADISLAV\+\_\+\+ORANGE\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{1.\+0f, 125.\+0f / 255.\+0f, 19.\+0f / 255.\+0f, 0.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_a3ef7cc70cc21ec016debd929ca40cb25}{FAST\+\_\+\+GREEN\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 113.\+0f/255.\+0f, 239.\+0f/255.\+0f, 46.\+0f/255.\+0f, 1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_af6d07e97190e3d6eb57c438d929fd9f7}{FAST\+\_\+\+RED\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 255.\+0f/255.\+0f, 65.\+0f/255.\+0f, 46.\+0f/255.\+0f, 1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_a81c3adfdf58bb4b9041258ed528419d8}{FAST\+\_\+\+BLUE\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 106.\+0f/255.\+0f, 106.\+0f/255.\+0f, 255.\+0f/255.\+0f, 1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_a1a8c0ec0db4f21074319658ec9cda122}{FAST\+\_\+\+GRAY\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 150.\+0f/255.\+0f, 150.\+0f/255.\+0f, 150.\+0f/255.\+0f, 1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_a42bdfa6acbe2c64f29cbd31426c86bfb}{WHITE}} \mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_aba9827caee2da38a16d2578ad87c18b8}{BLACK}} \mbox{[}4\mbox{]} = \{ 0.\+0/255.\+0,0.\+0/255.\+0,0.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a4ace1077f98e7c25d1b590afc21001d4}{WHITE\+\_\+\+AMBIENT}} \mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_af258223de150eac4510266bce6c15adc}{WHITE\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_aa83f669c0c7352ed86d6991e28616eed}{WHITE\+\_\+\+SPECULAR}} \mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}
\item 
const float \mbox{\hyperlink{namespaceigl_a8d653f310491c5eeea8199df41a8506b}{BBW\+\_\+\+POINT\+\_\+\+COLOR}} \mbox{[}4\mbox{]} = \{239./255.,213./255.,46./255.,255.\+0/255.\+0\}
\item 
const float \mbox{\hyperlink{namespaceigl_a2a441cf01da7bb4f7455fa87831cc862}{BBW\+\_\+\+LINE\+\_\+\+COLOR}} \mbox{[}4\mbox{]} = \{106./255.,106./255.,255./255.,255./255.\}
\item 
const float \mbox{\hyperlink{namespaceigl_a3443568d1ef02dea80982a3df4bbfec1}{MIDNIGHT\+\_\+\+BLUE\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{ 21.\+0f/255.\+0f, 27.\+0f/255.\+0f, 84.\+0f/255.\+0f, 1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_aa9c277b6c43132159685619ae7e56d38}{EASTER\+\_\+\+RED\+\_\+\+DIFFUSE}} \mbox{[}4\mbox{]} = \{0.\+603922,0.\+494118f,0.\+603922f,1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_af16c584a27f3dcfaa597e5864861931f}{WN\+\_\+\+OPEN\+\_\+\+BOUNDARY\+\_\+\+COLOR}} \mbox{[}4\mbox{]} = \{154./255.,0./255.,0./255.,1.\+0f\}
\item 
const float \mbox{\hyperlink{namespaceigl_a147760067e19822d9de2d3386c607b6e}{WN\+\_\+\+NON\+\_\+\+MANIFOLD\+\_\+\+EDGE\+\_\+\+COLOR}} \mbox{[}4\mbox{]} = \{201./255., 51./255.,255./255.,1.\+0f\}
\item 
const char \mbox{\hyperlink{namespaceigl_a417e9fcd5135f9dfc60524331328b9d8}{CHAR\+\_\+\+ONE}} = 1
\begin{DoxyCompactList}\small\item\em Often one needs a reference to a dummy variable containing one as its value, for example when using Ant\+Tweak\+Bar\textquotesingle{}s Tw\+Set\+Param( "{}3\+D View"{}, "{}opened"{}, TW\+\_\+\+PARAM\+\_\+\+INT32, 1, \&INT\+\_\+\+ONE);. \end{DoxyCompactList}\item 
const int \mbox{\hyperlink{namespaceigl_a13bf1ec6ed30256c1043772e67394b33}{INT\+\_\+\+ONE}} = 1
\item 
const unsigned int \mbox{\hyperlink{namespaceigl_a57884543ce9ab8f3b3b1f9ffbef9a977}{UNSIGNED\+\_\+\+INT\+\_\+\+ONE}} = 1
\item 
const double \mbox{\hyperlink{namespaceigl_ad63b4ffb0ea045dc3cd8a516ba072090}{DOUBLE\+\_\+\+ONE}} = 1
\item 
const float \mbox{\hyperlink{namespaceigl_af7ed44be1be4ade1ba7a4e7b382085db}{FLOAT\+\_\+\+ONE}} = 1
\item 
constexpr double \mbox{\hyperlink{namespaceigl_af3c65fcb2a063b19e572a9d982b5dcdc}{PI}} = 3.\+1415926535897932384626433832795
\begin{DoxyCompactList}\small\item\em  \end{DoxyCompactList}\item 
const char \mbox{\hyperlink{namespaceigl_a89d712ab3a824b8712b6f228dc8242cf}{CHAR\+\_\+\+ZERO}} = 0
\item 
const int \mbox{\hyperlink{namespaceigl_ad26002c6ec8c14b1b4a7acc5db59b1e4}{INT\+\_\+\+ZERO}} = 0
\item 
const unsigned int \mbox{\hyperlink{namespaceigl_a3d956292d4f64a8ce6b1e1d92a9f9d24}{UNSIGNED\+\_\+\+INT\+\_\+\+ZERO}} = 0
\item 
const double \mbox{\hyperlink{namespaceigl_af1cef568dc365b5b596341a5b7f06867}{DOUBLE\+\_\+\+ZERO}} = 0
\item 
const float \mbox{\hyperlink{namespaceigl_aec3a0ea947dabbe9fc09e7e8da909613}{FLOAT\+\_\+\+ZERO}} = 0
\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\Hypertarget{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}\label{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f} 
\index{igl@{igl}!decimate\_cost\_and\_placement\_callback@{decimate\_cost\_and\_placement\_callback}}
\index{decimate\_cost\_and\_placement\_callback@{decimate\_cost\_and\_placement\_callback}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate\_cost\_and\_placement\_callback}{decimate\_cost\_and\_placement\_callback}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{igl\+::decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} = typedef std\+::function$<$void( const int , const Eigen\+::\+Matrix\+Xd \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , double \& , Eigen\+::\+Row\+Vector\+Xd \& )$>$}



Function handle used to control the cost of each edge collapse in \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. 

See \doxylink{decimate_8h}{decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e} & index into E of edge to be collapsed \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions, lesser index of E(e,\+:) will be set to midpoint of edge. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\mbox{\texttt{ out}}  & {\em cost} & cost of collapsing edge e \\
\hline
\mbox{\texttt{ out}}  & {\em p} & placement of merged vertex resulting from collapse \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}\label{namespaceigl_a64c8b006ed52af02a20d1664722a94b3} 
\index{igl@{igl}!decimate\_stopping\_condition\_callback@{decimate\_stopping\_condition\_callback}}
\index{decimate\_stopping\_condition\_callback@{decimate\_stopping\_condition\_callback}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate\_stopping\_condition\_callback}{decimate\_stopping\_condition\_callback}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{igl\+::decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} = typedef std\+::function$<$bool( const Eigen\+::\+Matrix\+Xd \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$double,int,int$>$ $>$ \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xd \& , const int , const int , const int , const int , const int )$>$}



Function handle used to control whether the queue processing in \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate} should stop. 

See \doxylink{decimate_8h}{decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions, lesser index of E(e,\+:) will be set to midpoint of edge. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{}     e=(j-\/$>$i) @param \mbox{[}in\mbox{]} EI  \#\+E by 2 list of edge flap corners (see above). @param \mbox{[}in\mbox{]} Q  queue containing pairs of costs and edge indices and insertion "{}time"{} @param \mbox{[}in\mbox{]} EQ  \#\+E list of "{}time"{} of last time pushed into Q \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#E by dim list of stored placements \\
\hline
\mbox{\texttt{ in}}  & {\em e} & index into E of attempted collapsed edge. Set to -\/1 if Q is empty or contains only infinite cost edges. \\
\hline
\mbox{\texttt{ in}}  & {\em e1} & index into E of edge collpased on left. \\
\hline
\mbox{\texttt{ in}}  & {\em e2} & index into E of edge collpased on right. \\
\hline
\mbox{\texttt{ in}}  & {\em f1} & index into F of face collpased on left. \\
\hline
\mbox{\texttt{ in}}  & {\em f2} & index into F of face collpased on right. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether to stop 
\end{DoxyReturn}
\Hypertarget{namespaceigl_af695d0b4a424387592b06f466a86088e}\label{namespaceigl_af695d0b4a424387592b06f466a86088e} 
\index{igl@{igl}!decimate\_pre\_collapse\_callback@{decimate\_pre\_collapse\_callback}}
\index{decimate\_pre\_collapse\_callback@{decimate\_pre\_collapse\_callback}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate\_pre\_collapse\_callback}{decimate\_pre\_collapse\_callback}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{igl\+::decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} = typedef std\+::function$<$bool( const Eigen\+::\+Matrix\+Xd \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$double,int,int$>$ $>$ \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xd \& , const int )$>$}



Function handle called just before {\ttfamily collapse\+\_\+edge} is attempted. 

If this function returns false then the collapse is aborted.

See \doxylink{decimate_8h}{decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions, lesser index of E(e,\+:) will be set to midpoint of edge. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & queue containing pairs of costs and edge indices and insertion "{}time"{} \\
\hline
\mbox{\texttt{ in}}  & {\em EQ} & \#E list of "{}time"{} of last time pushed into Q \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#E by dim list of stored placements \\
\hline
\mbox{\texttt{ in}}  & {\em e} & index into E of attempted collapsed edge. Set to -\/1 if Q is empty or contains only infinite cost edges. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if collapse should be carried out 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}\label{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426} 
\index{igl@{igl}!decimate\_post\_collapse\_callback@{decimate\_post\_collapse\_callback}}
\index{decimate\_post\_collapse\_callback@{decimate\_post\_collapse\_callback}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate\_post\_collapse\_callback}{decimate\_post\_collapse\_callback}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{igl\+::decimate\+\_\+post\+\_\+collapse\+\_\+callback}} = typedef std\+::function$<$void( const Eigen\+::\+Matrix\+Xd \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const Eigen\+::\+Matrix\+Xi \& , const \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$double,int,int$>$ $>$ \& , const Eigen\+::\+Vector\+Xi \& , const Eigen\+::\+Matrix\+Xd \& , const int , const int , const int , const int , const int , const bool )$>$}



Function handle called just after {\ttfamily collapse\+\_\+edge} is attempted. 

See \doxylink{decimate_8h}{decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions, lesser index of E(e,\+:) will be set to midpoint of edge. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & queue containing pairs of costs and edge indices and insertion "{}time"{} \\
\hline
\mbox{\texttt{ in}}  & {\em EQ} & \#E list of "{}time"{} of last time pushed into Q \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#E by dim list of stored placements \\
\hline
\mbox{\texttt{ in}}  & {\em e} & index into E of attempted collapsed edge. Set to -\/1 if Q is empty or contains only infinite cost edges. \\
\hline
\mbox{\texttt{ in}}  & {\em e1} & index into E of edge collpased on left. \\
\hline
\mbox{\texttt{ in}}  & {\em e2} & index into E of edge collpased on right. \\
\hline
\mbox{\texttt{ in}}  & {\em f1} & index into F of face collpased on left. \\
\hline
\mbox{\texttt{ in}}  & {\em f2} & index into F of face collpased on right. \\
\hline
\mbox{\texttt{ in}}  & {\em collapsed} & whether collapse actual took place \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a60bbc303acee156af52ab587c4680502}\label{namespaceigl_a60bbc303acee156af52ab587c4680502} 
\index{igl@{igl}!DEFAULT\_URBG@{DEFAULT\_URBG}}
\index{DEFAULT\_URBG@{DEFAULT\_URBG}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{DEFAULT\_URBG}{DEFAULT\_URBG}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_a60bbc303acee156af52ab587c4680502}{igl\+::\+DEFAULT\+\_\+\+URBG}} = typedef std\+::mt19937}

\Hypertarget{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}\label{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf} 
\index{igl@{igl}!min\_heap@{min\_heap}}
\index{min\_heap@{min\_heap}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_heap}{min\_heap}}
{\footnotesize\ttfamily template$<$class T $>$ \\
using \mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}} = typedef std\+::priority\+\_\+queue$<$ T, std\+::vector$<$T $>$, std\+::greater$<$T $>$ $>$}



Templated min heap (reverses sort order of std\+::priority\+\_\+queue) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of elements in heap \\
\hline
\end{DoxyTemplParams}
\Hypertarget{namespaceigl_af2b7710824b3b35bfcda5dd2d5c723f5}\label{namespaceigl_af2b7710824b3b35bfcda5dd2d5c723f5} 
\index{igl@{igl}!shapeup\_projection\_function@{shapeup\_projection\_function}}
\index{shapeup\_projection\_function@{shapeup\_projection\_function}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shapeup\_projection\_function}{shapeup\_projection\_function}}
{\footnotesize\ttfamily using \mbox{\hyperlink{namespaceigl_af2b7710824b3b35bfcda5dd2d5c723f5}{igl\+::shapeup\+\_\+projection\+\_\+function}} = typedef std\+::function$<$ bool( const Eigen\+::\+Plain\+Object\+Base$<$Eigen\+::\+Matrix\+Xd$>$\&, const Eigen\+::\+Plain\+Object\+Base$<$Eigen\+::\+Vector\+Xi$>$\&, const Eigen\+::\+Plain\+Object\+Base$<$Eigen\+::\+Matrix\+Xi$>$\&, Eigen\+::\+Plain\+Object\+Base$<$Eigen\+::\+Matrix\+Xd$>$\&)$>$}



Every function here defines a local projection for Shape\+Up, and must have the following structure to qualify\+: 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 set of points, either the initial solution, or from previous iteration. \\
\hline
\mbox{\texttt{ in}}  & {\em SC} & \#\+Set by 1 cardinalities of sets in S \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#\+Sets by max(\+SC) independent sets where the local projection applies. Values beyond column SC(i)-\/1 in row S(i,\+:) are "{}don\textquotesingle{}t care"{} \\
\hline
\mbox{\texttt{ out}}  & {\em projP} & \#S by 3\texorpdfstring{$\ast$}{*}max(SC) in format xyzxyzxyz, where the projected points correspond to each set in S in the same order. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return value appears to be ignored
\end{DoxyReturn}
\doxylink{shapeup_8h}{include/igl/shapeup.\+h} 

\doxysubsection{Enumeration Type Documentation}
\Hypertarget{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}\label{namespaceigl_afcbc9001656cf2d4cc135602618c97e5} 
\index{igl@{igl}!ARAPEnergyType@{ARAPEnergyType}}
\index{ARAPEnergyType@{ARAPEnergyType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ARAPEnergyType}{ARAPEnergyType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{igl\+::\+ARAPEnergy\+Type}}}



Enum for choosing ARAP energy type. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{ARAP\_ENERGY\_TYPE\_SPOKES@{ARAP\_ENERGY\_TYPE\_SPOKES}!igl@{igl}}\index{igl@{igl}!ARAP\_ENERGY\_TYPE\_SPOKES@{ARAP\_ENERGY\_TYPE\_SPOKES}}}\Hypertarget{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a97e873f2663a9aceb16484fb07de5ff5}\label{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a97e873f2663a9aceb16484fb07de5ff5} 
ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+SPOKES&"{}\+As-\/rigid-\/as-\/possible Surface Modeling"{} by \mbox{[}Sorkine and Alexa 2007\mbox{]}, rotations defined at vertices affecting incident edges, default \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ARAP\_ENERGY\_TYPE\_SPOKES\_AND\_RIMS@{ARAP\_ENERGY\_TYPE\_SPOKES\_AND\_RIMS}!igl@{igl}}\index{igl@{igl}!ARAP\_ENERGY\_TYPE\_SPOKES\_AND\_RIMS@{ARAP\_ENERGY\_TYPE\_SPOKES\_AND\_RIMS}}}\Hypertarget{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a5f5f83bb36e2e299284c9a95ed2ff961}\label{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a5f5f83bb36e2e299284c9a95ed2ff961} 
ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+SPOKES\+\_\+\+AND\+\_\+\+RIMS&Adapted version of "{}\+As-\/rigid-\/as-\/possible Surface Modeling"{} by \mbox{[}Sorkine and Alexa 2007\mbox{]} presented in section 4.\+2 of or "{}\+A simple geometric model     for elastic deformation"{} by \mbox{[}Chao et al. 2010\mbox{]}, rotations defined at vertices affecting incident edges and opposite edges. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ARAP\_ENERGY\_TYPE\_ELEMENTS@{ARAP\_ENERGY\_TYPE\_ELEMENTS}!igl@{igl}}\index{igl@{igl}!ARAP\_ENERGY\_TYPE\_ELEMENTS@{ARAP\_ENERGY\_TYPE\_ELEMENTS}}}\Hypertarget{namespaceigl_afcbc9001656cf2d4cc135602618c97e5af2f155e8dfb975ad92b08f029e49a150}\label{namespaceigl_afcbc9001656cf2d4cc135602618c97e5af2f155e8dfb975ad92b08f029e49a150} 
ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+ELEMENTS&"{}\+A local-\/global approach to mesh parameterization"{} by \mbox{[}Liu et al. 2010\mbox{]} or "{}\+A simple geometric model for elastic deformation"{} by \mbox{[}Chao et al. 2010\mbox{]}, rotations defined at elements (triangles or tets) ~\newline
 \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{ARAP\_ENERGY\_TYPE\_DEFAULT@{ARAP\_ENERGY\_TYPE\_DEFAULT}!igl@{igl}}\index{igl@{igl}!ARAP\_ENERGY\_TYPE\_DEFAULT@{ARAP\_ENERGY\_TYPE\_DEFAULT}}}\Hypertarget{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a0ab35acc294ac22e4f4d125fce81bb2e}\label{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a0ab35acc294ac22e4f4d125fce81bb2e} 
ARAP\+\_\+\+ENERGY\+\_\+\+TYPE\+\_\+\+DEFAULT&Choose one automatically\+: spokes and rims for surfaces, elements for planar meshes and tets (not fully supported) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_ARAP\_ENERGY\_TYPES@{NUM\_ARAP\_ENERGY\_TYPES}!igl@{igl}}\index{igl@{igl}!NUM\_ARAP\_ENERGY\_TYPES@{NUM\_ARAP\_ENERGY\_TYPES}}}\Hypertarget{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a9a04adfc9ec2f8a964e26ee1e79e192d}\label{namespaceigl_afcbc9001656cf2d4cc135602618c97e5a9a04adfc9ec2f8a964e26ee1e79e192d} 
NUM\+\_\+\+ARAP\+\_\+\+ENERGY\+\_\+\+TYPES&Total number of types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea} 
\index{igl@{igl}!ColorMapType@{ColorMapType}}
\index{ColorMapType@{ColorMapType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ColorMapType}{ColorMapType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{igl\+::\+Color\+Map\+Type}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_INFERNO@{COLOR\_MAP\_TYPE\_INFERNO}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_INFERNO@{COLOR\_MAP\_TYPE\_INFERNO}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa6825c15830b7858ad1cae2b2ca8fdf04}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa6825c15830b7858ad1cae2b2ca8fdf04} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+INFERNO&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_JET@{COLOR\_MAP\_TYPE\_JET}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_JET@{COLOR\_MAP\_TYPE\_JET}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaab42bc8bb5154a66ce55adfc8a55ca23b}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaab42bc8bb5154a66ce55adfc8a55ca23b} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+JET&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_MAGMA@{COLOR\_MAP\_TYPE\_MAGMA}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_MAGMA@{COLOR\_MAP\_TYPE\_MAGMA}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa2f48b6200837d4a9504dc985d9555a43}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa2f48b6200837d4a9504dc985d9555a43} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+MAGMA&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_PARULA@{COLOR\_MAP\_TYPE\_PARULA}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_PARULA@{COLOR\_MAP\_TYPE\_PARULA}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa34771169730e68f97bd795796088a1bd}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa34771169730e68f97bd795796088a1bd} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+PARULA&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_PLASMA@{COLOR\_MAP\_TYPE\_PLASMA}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_PLASMA@{COLOR\_MAP\_TYPE\_PLASMA}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa02ba4c2ca7ae86203e286cc7e7681be8}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa02ba4c2ca7ae86203e286cc7e7681be8} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+PLASMA&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_VIRIDIS@{COLOR\_MAP\_TYPE\_VIRIDIS}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_VIRIDIS@{COLOR\_MAP\_TYPE\_VIRIDIS}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaac0949b6bec17c57dae985f9945f0ba87}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaac0949b6bec17c57dae985f9945f0ba87} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+VIRIDIS&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{COLOR\_MAP\_TYPE\_TURBO@{COLOR\_MAP\_TYPE\_TURBO}!igl@{igl}}\index{igl@{igl}!COLOR\_MAP\_TYPE\_TURBO@{COLOR\_MAP\_TYPE\_TURBO}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa215964e6083ae591d01d8fc75696b7e4}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa215964e6083ae591d01d8fc75696b7e4} 
COLOR\+\_\+\+MAP\+\_\+\+TYPE\+\_\+\+TURBO&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_COLOR\_MAP\_TYPES@{NUM\_COLOR\_MAP\_TYPES}!igl@{igl}}\index{igl@{igl}!NUM\_COLOR\_MAP\_TYPES@{NUM\_COLOR\_MAP\_TYPES}}}\Hypertarget{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa6fe9ac780033d4a02584149c2079171f}\label{namespaceigl_a1b823cd12b22dd7d7c16b36223e68deaa6fe9ac780033d4a02584149c2079171f} 
NUM\+\_\+\+COLOR\+\_\+\+MAP\+\_\+\+TYPES&\\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a39bb96a0597986315dc20d78ba46a50d}\label{namespaceigl_a39bb96a0597986315dc20d78ba46a50d} 
\index{igl@{igl}!EigsType@{EigsType}}
\index{EigsType@{EigsType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EigsType}{EigsType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50d}{igl\+::\+Eigs\+Type}}}



Type of eigen values to extract. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{EIGS\_TYPE\_SM@{EIGS\_TYPE\_SM}!igl@{igl}}\index{igl@{igl}!EIGS\_TYPE\_SM@{EIGS\_TYPE\_SM}}}\Hypertarget{namespaceigl_a39bb96a0597986315dc20d78ba46a50da2b8b23d6ed6bab31827ce232b5c4b753}\label{namespaceigl_a39bb96a0597986315dc20d78ba46a50da2b8b23d6ed6bab31827ce232b5c4b753} 
EIGS\+\_\+\+TYPE\+\_\+\+SM&Smallest magnitude eigen values. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{EIGS\_TYPE\_LM@{EIGS\_TYPE\_LM}!igl@{igl}}\index{igl@{igl}!EIGS\_TYPE\_LM@{EIGS\_TYPE\_LM}}}\Hypertarget{namespaceigl_a39bb96a0597986315dc20d78ba46a50daea338bf4c5326fb6e1534be0d2d8c3ff}\label{namespaceigl_a39bb96a0597986315dc20d78ba46a50daea338bf4c5326fb6e1534be0d2d8c3ff} 
EIGS\+\_\+\+TYPE\+\_\+\+LM&Largest magnitude eigen values. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_EIGS\_TYPES@{NUM\_EIGS\_TYPES}!igl@{igl}}\index{igl@{igl}!NUM\_EIGS\_TYPES@{NUM\_EIGS\_TYPES}}}\Hypertarget{namespaceigl_a39bb96a0597986315dc20d78ba46a50dad803c6fe03f39ed4ef76376e6ba1d2c2}\label{namespaceigl_a39bb96a0597986315dc20d78ba46a50dad803c6fe03f39ed4ef76376e6ba1d2c2} 
NUM\+\_\+\+EIGS\+\_\+\+TYPES&Total number of types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}\label{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf} 
\index{igl@{igl}!FileEncoding@{FileEncoding}}
\index{FileEncoding@{FileEncoding}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FileEncoding}{FileEncoding}}
{\footnotesize\ttfamily enum class \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{igl\+::\+File\+Encoding}}\hspace{0.3cm}{\ttfamily [strong]}}



File encoding types for writing files. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Binary@{Binary}!igl@{igl}}\index{igl@{igl}!Binary@{Binary}}}\Hypertarget{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa6ce976e8f061b2b5cfe4d0c50c3405dd}\label{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa6ce976e8f061b2b5cfe4d0c50c3405dd} 
Binary&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Ascii@{Ascii}!igl@{igl}}\index{igl@{igl}!Ascii@{Ascii}}}\Hypertarget{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}\label{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31} 
Ascii&\\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a69c0d149c7cb41a263f858b695eeb988}\label{namespaceigl_a69c0d149c7cb41a263f858b695eeb988} 
\index{igl@{igl}!BrushType@{BrushType}}
\index{BrushType@{BrushType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{BrushType}{BrushType}}
{\footnotesize\ttfamily enum class \mbox{\hyperlink{namespaceigl_a69c0d149c7cb41a263f858b695eeb988}{igl\+::\+Brush\+Type}} \+: int\hspace{0.3cm}{\ttfamily [strong]}}



Kelvinlets brush type. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{GRAB@{GRAB}!igl@{igl}}\index{igl@{igl}!GRAB@{GRAB}}}\Hypertarget{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a8695c57e30e957161af26fe52d8a5826}\label{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a8695c57e30e957161af26fe52d8a5826} 
GRAB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SCALE@{SCALE}!igl@{igl}}\index{igl@{igl}!SCALE@{SCALE}}}\Hypertarget{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a127ea1d20becc4dba06d9d152db0c2e5}\label{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a127ea1d20becc4dba06d9d152db0c2e5} 
SCALE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{TWIST@{TWIST}!igl@{igl}}\index{igl@{igl}!TWIST@{TWIST}}}\Hypertarget{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a7d503f3470adcef7d9b24cdfa82ea1c1}\label{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a7d503f3470adcef7d9b24cdfa82ea1c1} 
TWIST&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PINCH@{PINCH}!igl@{igl}}\index{igl@{igl}!PINCH@{PINCH}}}\Hypertarget{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a1519953796ab374eeab96e42a849ed19}\label{namespaceigl_a69c0d149c7cb41a263f858b695eeb988a1519953796ab374eeab96e42a849ed19} 
PINCH&\\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739} 
\index{igl@{igl}!MappingEnergyType@{MappingEnergyType}}
\index{MappingEnergyType@{MappingEnergyType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MappingEnergyType}{MappingEnergyType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type}}}



Energy Types used for Parameterization/\+Mapping. 

Refer to SLIM \mbox{[}Rabinovich et al. 2017\mbox{]} for more details \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{ARAP@{ARAP}!igl@{igl}}\index{igl@{igl}!ARAP@{ARAP}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739ad4c5e62ae2264ce291d4d66fa3603d72}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739ad4c5e62ae2264ce291d4d66fa3603d72} 
ARAP&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{LOG\_ARAP@{LOG\_ARAP}!igl@{igl}}\index{igl@{igl}!LOG\_ARAP@{LOG\_ARAP}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739ac7e97754f63944f8a1abcd0157df2c24}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739ac7e97754f63944f8a1abcd0157df2c24} 
LOG\+\_\+\+ARAP&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SYMMETRIC\_DIRICHLET@{SYMMETRIC\_DIRICHLET}!igl@{igl}}\index{igl@{igl}!SYMMETRIC\_DIRICHLET@{SYMMETRIC\_DIRICHLET}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a4aaaa0e435526b23bf5f26cfbb5c03b9}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a4aaaa0e435526b23bf5f26cfbb5c03b9} 
SYMMETRIC\+\_\+\+DIRICHLET&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{CONFORMAL@{CONFORMAL}!igl@{igl}}\index{igl@{igl}!CONFORMAL@{CONFORMAL}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a83bccae0282cd84b5ae8c0d260ae7243}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a83bccae0282cd84b5ae8c0d260ae7243} 
CONFORMAL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{EXP\_CONFORMAL@{EXP\_CONFORMAL}!igl@{igl}}\index{igl@{igl}!EXP\_CONFORMAL@{EXP\_CONFORMAL}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a26c394b5336e61022324d35b9c070a9b}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a26c394b5336e61022324d35b9c070a9b} 
EXP\+\_\+\+CONFORMAL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{EXP\_SYMMETRIC\_DIRICHLET@{EXP\_SYMMETRIC\_DIRICHLET}!igl@{igl}}\index{igl@{igl}!EXP\_SYMMETRIC\_DIRICHLET@{EXP\_SYMMETRIC\_DIRICHLET}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a265347b4667fbc30a911bb0be708072f}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739a265347b4667fbc30a911bb0be708072f} 
EXP\+\_\+\+SYMMETRIC\+\_\+\+DIRICHLET&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_SLIM\_ENERGY\_TYPES@{NUM\_SLIM\_ENERGY\_TYPES}!igl@{igl}}\index{igl@{igl}!NUM\_SLIM\_ENERGY\_TYPES@{NUM\_SLIM\_ENERGY\_TYPES}}}\Hypertarget{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739abcbff3ae074247ae8998591317528163}\label{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739abcbff3ae074247ae8998591317528163} 
NUM\+\_\+\+SLIM\+\_\+\+ENERGY\+\_\+\+TYPES&\\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}\label{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90} 
\index{igl@{igl}!MassMatrixType@{MassMatrixType}}
\index{MassMatrixType@{MassMatrixType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MassMatrixType}{MassMatrixType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{igl\+::\+Mass\+Matrix\+Type}}}



Type of mass matrix. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{MASSMATRIX\_TYPE\_BARYCENTRIC@{MASSMATRIX\_TYPE\_BARYCENTRIC}!igl@{igl}}\index{igl@{igl}!MASSMATRIX\_TYPE\_BARYCENTRIC@{MASSMATRIX\_TYPE\_BARYCENTRIC}}}\Hypertarget{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90ad236264764d4f478ccb31c36be553483}\label{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90ad236264764d4f478ccb31c36be553483} 
MASSMATRIX\+\_\+\+TYPE\+\_\+\+BARYCENTRIC&Lumping area of each element to corner vertices in equal parts. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MASSMATRIX\_TYPE\_VORONOI@{MASSMATRIX\_TYPE\_VORONOI}!igl@{igl}}\index{igl@{igl}!MASSMATRIX\_TYPE\_VORONOI@{MASSMATRIX\_TYPE\_VORONOI}}}\Hypertarget{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a8e91d83387a6cdc5e1c58d3249ed8484}\label{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a8e91d83387a6cdc5e1c58d3249ed8484} 
MASSMATRIX\+\_\+\+TYPE\+\_\+\+VORONOI&Lumping area by Voronoi dual area (clamped to be positive according to Meyer et al. 2003) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MASSMATRIX\_TYPE\_FULL@{MASSMATRIX\_TYPE\_FULL}!igl@{igl}}\index{igl@{igl}!MASSMATRIX\_TYPE\_FULL@{MASSMATRIX\_TYPE\_FULL}}}\Hypertarget{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90aa3067b3f2630f50a9806bf46b60e6fb7}\label{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90aa3067b3f2630f50a9806bf46b60e6fb7} 
MASSMATRIX\+\_\+\+TYPE\+\_\+\+FULL&Full (non-\/diagonal mass matrix) for piecewise linear functions. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MASSMATRIX\_TYPE\_DEFAULT@{MASSMATRIX\_TYPE\_DEFAULT}!igl@{igl}}\index{igl@{igl}!MASSMATRIX\_TYPE\_DEFAULT@{MASSMATRIX\_TYPE\_DEFAULT}}}\Hypertarget{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a69f57abe461a4a62943a5c38cbbf22f0}\label{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a69f57abe461a4a62943a5c38cbbf22f0} 
MASSMATRIX\+\_\+\+TYPE\+\_\+\+DEFAULT&Use MASSMATRIX\+\_\+\+TYPE\+\_\+\+VORONOI for triangles and MASSMATRIX\+\_\+\+TYPE\+\_\+\+BARYCENTRIC for tetrahedra. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_MASSMATRIX\_TYPES@{NUM\_MASSMATRIX\_TYPES}!igl@{igl}}\index{igl@{igl}!NUM\_MASSMATRIX\_TYPES@{NUM\_MASSMATRIX\_TYPES}}}\Hypertarget{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a90c5b05e42d20ca21fd5849e64bae2ae}\label{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90a90c5b05e42d20ca21fd5849e64bae2ae} 
NUM\+\_\+\+MASSMATRIX\+\_\+\+TYPES&Total number of mass matrix types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9f} 
\index{igl@{igl}!MeshBooleanType@{MeshBooleanType}}
\index{MeshBooleanType@{MeshBooleanType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MeshBooleanType}{MeshBooleanType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a16cc7fd8778cd880be528227e0318b9f}{igl\+::\+Mesh\+Boolean\+Type}}}



Boolean operation types. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{MESH\_BOOLEAN\_TYPE\_UNION@{MESH\_BOOLEAN\_TYPE\_UNION}!igl@{igl}}\index{igl@{igl}!MESH\_BOOLEAN\_TYPE\_UNION@{MESH\_BOOLEAN\_TYPE\_UNION}}}\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056} 
MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+UNION&A  B. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MESH\_BOOLEAN\_TYPE\_INTERSECT@{MESH\_BOOLEAN\_TYPE\_INTERSECT}!igl@{igl}}\index{igl@{igl}!MESH\_BOOLEAN\_TYPE\_INTERSECT@{MESH\_BOOLEAN\_TYPE\_INTERSECT}}}\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34} 
MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+INTERSECT&A  B. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MESH\_BOOLEAN\_TYPE\_MINUS@{MESH\_BOOLEAN\_TYPE\_MINUS}!igl@{igl}}\index{igl@{igl}!MESH\_BOOLEAN\_TYPE\_MINUS@{MESH\_BOOLEAN\_TYPE\_MINUS}}}\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80} 
MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+MINUS&A \textbackslash{} B. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MESH\_BOOLEAN\_TYPE\_XOR@{MESH\_BOOLEAN\_TYPE\_XOR}!igl@{igl}}\index{igl@{igl}!MESH\_BOOLEAN\_TYPE\_XOR@{MESH\_BOOLEAN\_TYPE\_XOR}}}\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b} 
MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+XOR&A  B. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{MESH\_BOOLEAN\_TYPE\_RESOLVE@{MESH\_BOOLEAN\_TYPE\_RESOLVE}!igl@{igl}}\index{igl@{igl}!MESH\_BOOLEAN\_TYPE\_RESOLVE@{MESH\_BOOLEAN\_TYPE\_RESOLVE}}}\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708} 
MESH\+\_\+\+BOOLEAN\+\_\+\+TYPE\+\_\+\+RESOLVE&Resolve intersections without removing any non-\/coplanar faces. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_MESH\_BOOLEAN\_TYPES@{NUM\_MESH\_BOOLEAN\_TYPES}!igl@{igl}}\index{igl@{igl}!NUM\_MESH\_BOOLEAN\_TYPES@{NUM\_MESH\_BOOLEAN\_TYPES}}}\Hypertarget{namespaceigl_a16cc7fd8778cd880be528227e0318b9fadbaeed658c3fa4c89de4dc951cb9cff9}\label{namespaceigl_a16cc7fd8778cd880be528227e0318b9fadbaeed658c3fa4c89de4dc951cb9cff9} 
NUM\+\_\+\+MESH\+\_\+\+BOOLEAN\+\_\+\+TYPES&Total number of Boolean options. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8}\label{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8} 
\index{igl@{igl}!NormalType@{NormalType}}
\index{NormalType@{NormalType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{NormalType}{NormalType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8}{igl\+::\+Normal\+Type}}}



Type of mesh normal computation method. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_VERTEX\_NORMALS@{PER\_VERTEX\_NORMALS}!igl@{igl}}\index{igl@{igl}!PER\_VERTEX\_NORMALS@{PER\_VERTEX\_NORMALS}}}\Hypertarget{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8af907c6f40997626d2c36a67963c8431d}\label{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8af907c6f40997626d2c36a67963c8431d} 
PER\+\_\+\+VERTEX\+\_\+\+NORMALS&Normals computed per vertex based on incident faces. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_FACE\_NORMALS@{PER\_FACE\_NORMALS}!igl@{igl}}\index{igl@{igl}!PER\_FACE\_NORMALS@{PER\_FACE\_NORMALS}}}\Hypertarget{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8a17cf07533db59fd90e513a7d89d40664}\label{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8a17cf07533db59fd90e513a7d89d40664} 
PER\+\_\+\+FACE\+\_\+\+NORMALS&Normals computed per face. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_CORNER\_NORMALS@{PER\_CORNER\_NORMALS}!igl@{igl}}\index{igl@{igl}!PER\_CORNER\_NORMALS@{PER\_CORNER\_NORMALS}}}\Hypertarget{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8a5c44ccab7f461834b6ecc16928196627}\label{namespaceigl_a6483aa681000a106ae0973fc53b2d2e8a5c44ccab7f461834b6ecc16928196627} 
PER\+\_\+\+CORNER\+\_\+\+NORMALS&Normals computed per corner (aka wedge) based on incident faces without sharp edge. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a347183daf701cad3537c990f8ce0cf55}\label{namespaceigl_a347183daf701cad3537c990f8ce0cf55} 
\index{igl@{igl}!PerEdgeNormalsWeightingType@{PerEdgeNormalsWeightingType}}
\index{PerEdgeNormalsWeightingType@{PerEdgeNormalsWeightingType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{PerEdgeNormalsWeightingType}{PerEdgeNormalsWeightingType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55}{igl\+::\+Per\+Edge\+Normals\+Weighting\+Type}}}



Weighting schemes for per edge normals. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM@{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM}!igl@{igl}}\index{igl@{igl}!PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM@{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM}}}\Hypertarget{namespaceigl_a347183daf701cad3537c990f8ce0cf55a832e9d6bd24abeb23b15bc815c888fe9}\label{namespaceigl_a347183daf701cad3537c990f8ce0cf55a832e9d6bd24abeb23b15bc815c888fe9} 
PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+UNIFORM&Incident face normals have uniform influence on edge normal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_AREA@{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_AREA}!igl@{igl}}\index{igl@{igl}!PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_AREA@{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_AREA}}}\Hypertarget{namespaceigl_a347183daf701cad3537c990f8ce0cf55a2822a9a485d6d667e1fc7eb6a9e3788c}\label{namespaceigl_a347183daf701cad3537c990f8ce0cf55a2822a9a485d6d667e1fc7eb6a9e3788c} 
PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+AREA&Incident face normals are averaged weighted by area. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT@{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT}!igl@{igl}}\index{igl@{igl}!PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT@{PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT}}}\Hypertarget{namespaceigl_a347183daf701cad3537c990f8ce0cf55a545aa62c3fac5887f2a8a939af47395c}\label{namespaceigl_a347183daf701cad3537c990f8ce0cf55a545aa62c3fac5887f2a8a939af47395c} 
PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+DEFAULT&Area weights. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE@{NUM\_PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE}!igl@{igl}}\index{igl@{igl}!NUM\_PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE@{NUM\_PER\_EDGE\_NORMALS\_WEIGHTING\_TYPE}}}\Hypertarget{namespaceigl_a347183daf701cad3537c990f8ce0cf55a163eb96bb83248476c499a06d08c7630}\label{namespaceigl_a347183daf701cad3537c990f8ce0cf55a163eb96bb83248476c499a06d08c7630} 
NUM\+\_\+\+PER\+\_\+\+EDGE\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE&Total number of weighting types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}\label{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94} 
\index{igl@{igl}!PerVertexNormalsWeightingType@{PerVertexNormalsWeightingType}}
\index{PerVertexNormalsWeightingType@{PerVertexNormalsWeightingType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{PerVertexNormalsWeightingType}{PerVertexNormalsWeightingType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}{igl\+::\+Per\+Vertex\+Normals\+Weighting\+Type}}}



Weighting schemes for computing per-\/vertex normals. 

\begin{DoxyNote}{Note}
It would be nice to support more or all of the methods here\+: "{}\+A comparison of algorithms for vertex normal computation"{} 
\end{DoxyNote}
\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM}!igl@{igl}}\index{igl@{igl}!PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_UNIFORM}}}\Hypertarget{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a221b3f6444f4194512508cce2c89d605}\label{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a221b3f6444f4194512508cce2c89d605} 
PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+UNIFORM&Incident face normals have uniform influence on vertex normal. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_AREA@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_AREA}!igl@{igl}}\index{igl@{igl}!PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_AREA@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_AREA}}}\Hypertarget{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a6f6afda8e7e65ddb0214f4bf4fe9d714}\label{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a6f6afda8e7e65ddb0214f4bf4fe9d714} 
PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+AREA&Incident face normals are averaged weighted by area. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_ANGLE@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_ANGLE}!igl@{igl}}\index{igl@{igl}!PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_ANGLE@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_ANGLE}}}\Hypertarget{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a3929a73f6d85de3ab2e7f61c4c569f8d}\label{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a3929a73f6d85de3ab2e7f61c4c569f8d} 
PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+ANGLE&Incident face normals are averaged weighted by incident angle of vertex. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT}!igl@{igl}}\index{igl@{igl}!PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT@{PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE\_DEFAULT}}}\Hypertarget{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a8384f77b5ce9bc68e6ed0c9dac5520f8}\label{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94a8384f77b5ce9bc68e6ed0c9dac5520f8} 
PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE\+\_\+\+DEFAULT&Area weights. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE@{NUM\_PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE}!igl@{igl}}\index{igl@{igl}!NUM\_PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE@{NUM\_PER\_VERTEX\_NORMALS\_WEIGHTING\_TYPE}}}\Hypertarget{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94ae39893168b9c7f1fb96cbe18aabcaf90}\label{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94ae39893168b9c7f1fb96cbe18aabcaf90} 
NUM\+\_\+\+PER\+\_\+\+VERTEX\+\_\+\+NORMALS\+\_\+\+WEIGHTING\+\_\+\+TYPE&Total number of weighting types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e} 
\index{igl@{igl}!SignedDistanceType@{SignedDistanceType}}
\index{SignedDistanceType@{SignedDistanceType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{SignedDistanceType}{SignedDistanceType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{igl\+::\+Signed\+Distance\+Type}}}



Types of signing a distance field. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{SIGNED\_DISTANCE\_TYPE\_PSEUDONORMAL@{SIGNED\_DISTANCE\_TYPE\_PSEUDONORMAL}!igl@{igl}}\index{igl@{igl}!SIGNED\_DISTANCE\_TYPE\_PSEUDONORMAL@{SIGNED\_DISTANCE\_TYPE\_PSEUDONORMAL}}}\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02eac0557ab91e577c1b1f918891b6b3a9ce}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02eac0557ab91e577c1b1f918891b6b3a9ce} 
SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+PSEUDONORMAL&Use fast pseudo-\/normal test \mbox{[}Brentzen \& Aans 2005\mbox{]}. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SIGNED\_DISTANCE\_TYPE\_WINDING\_NUMBER@{SIGNED\_DISTANCE\_TYPE\_WINDING\_NUMBER}!igl@{igl}}\index{igl@{igl}!SIGNED\_DISTANCE\_TYPE\_WINDING\_NUMBER@{SIGNED\_DISTANCE\_TYPE\_WINDING\_NUMBER}}}\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea2d092ad20bad8b2e4d6b015e0f64d5c8}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea2d092ad20bad8b2e4d6b015e0f64d5c8} 
SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+WINDING\+\_\+\+NUMBER&Use winding number \mbox{[}Jacobson, Kavan Sorking-\/\+Hornug 2013\mbox{]}. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SIGNED\_DISTANCE\_TYPE\_DEFAULT@{SIGNED\_DISTANCE\_TYPE\_DEFAULT}!igl@{igl}}\index{igl@{igl}!SIGNED\_DISTANCE\_TYPE\_DEFAULT@{SIGNED\_DISTANCE\_TYPE\_DEFAULT}}}\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea53947827c1a799002057e5dc4ffe3a6e}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea53947827c1a799002057e5dc4ffe3a6e} 
SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+DEFAULT&Default. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SIGNED\_DISTANCE\_TYPE\_UNSIGNED@{SIGNED\_DISTANCE\_TYPE\_UNSIGNED}!igl@{igl}}\index{igl@{igl}!SIGNED\_DISTANCE\_TYPE\_UNSIGNED@{SIGNED\_DISTANCE\_TYPE\_UNSIGNED}}}\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea3455ee3fba0a6898acccb895b94003ae}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea3455ee3fba0a6898acccb895b94003ae} 
SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+UNSIGNED&Unsigned (absolute value) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SIGNED\_DISTANCE\_TYPE\_FAST\_WINDING\_NUMBER@{SIGNED\_DISTANCE\_TYPE\_FAST\_WINDING\_NUMBER}!igl@{igl}}\index{igl@{igl}!SIGNED\_DISTANCE\_TYPE\_FAST\_WINDING\_NUMBER@{SIGNED\_DISTANCE\_TYPE\_FAST\_WINDING\_NUMBER}}}\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea840c3ff04b4ec159043f1c6168ad383d}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea840c3ff04b4ec159043f1c6168ad383d} 
SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+FAST\+\_\+\+WINDING\+\_\+\+NUMBER&Use Fast winding number \mbox{[}Barill, Dickson, Schmidt, Levin, Jacobson 2018\mbox{]}. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_SIGNED\_DISTANCE\_TYPE@{NUM\_SIGNED\_DISTANCE\_TYPE}!igl@{igl}}\index{igl@{igl}!NUM\_SIGNED\_DISTANCE\_TYPE@{NUM\_SIGNED\_DISTANCE\_TYPE}}}\Hypertarget{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea5ba484850e00fd63057bf36e540ffe57}\label{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02ea5ba484850e00fd63057bf36e540ffe57} 
NUM\+\_\+\+SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE&Total number of signed distance types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2}\label{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2} 
\index{igl@{igl}!SolverStatus@{SolverStatus}}
\index{SolverStatus@{SolverStatus}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{SolverStatus}{SolverStatus}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2}{igl\+::\+Solver\+Status}}}



Solver status type used by min\+\_\+quad\+\_\+with\+\_\+fixed. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{SOLVER\_STATUS\_CONVERGED@{SOLVER\_STATUS\_CONVERGED}!igl@{igl}}\index{igl@{igl}!SOLVER\_STATUS\_CONVERGED@{SOLVER\_STATUS\_CONVERGED}}}\Hypertarget{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aefd03ba8a40ae92dd30b9608543d723a}\label{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aefd03ba8a40ae92dd30b9608543d723a} 
SOLVER\+\_\+\+STATUS\+\_\+\+CONVERGED&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SOLVER\_STATUS\_MAX\_ITER@{SOLVER\_STATUS\_MAX\_ITER}!igl@{igl}}\index{igl@{igl}!SOLVER\_STATUS\_MAX\_ITER@{SOLVER\_STATUS\_MAX\_ITER}}}\Hypertarget{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2a59f8eece563fe4ae6e55c2363f349322}\label{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2a59f8eece563fe4ae6e55c2363f349322} 
SOLVER\+\_\+\+STATUS\+\_\+\+MAX\+\_\+\+ITER&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SOLVER\_STATUS\_ERROR@{SOLVER\_STATUS\_ERROR}!igl@{igl}}\index{igl@{igl}!SOLVER\_STATUS\_ERROR@{SOLVER\_STATUS\_ERROR}}}\Hypertarget{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aea9aaec839ab7074d95b32649f9a7ccc}\label{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aea9aaec839ab7074d95b32649f9a7ccc} 
SOLVER\+\_\+\+STATUS\+\_\+\+ERROR&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_SOLVER\_STATUSES@{NUM\_SOLVER\_STATUSES}!igl@{igl}}\index{igl@{igl}!NUM\_SOLVER\_STATUSES@{NUM\_SOLVER\_STATUSES}}}\Hypertarget{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aea329543d3b14ae5d7df63289014df41}\label{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2aea329543d3b14ae5d7df63289014df41} 
NUM\+\_\+\+SOLVER\+\_\+\+STATUSES&\\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}\label{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2} 
\index{igl@{igl}!TetrahedralizedGripType@{TetrahedralizedGripType}}
\index{TetrahedralizedGripType@{TetrahedralizedGripType}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{TetrahedralizedGripType}{TetrahedralizedGripType}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}{igl\+::\+Tetrahedralized\+Grip\+Type}}}



Types of tetrahedralizations of a cubical cell. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{TETRAHEDRALIZED\_GRID\_TYPE\_5@{TETRAHEDRALIZED\_GRID\_TYPE\_5}!igl@{igl}}\index{igl@{igl}!TETRAHEDRALIZED\_GRID\_TYPE\_5@{TETRAHEDRALIZED\_GRID\_TYPE\_5}}}\Hypertarget{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a6c9f3915cd235c5f5d9ec1f849c4f45a}\label{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a6c9f3915cd235c5f5d9ec1f849c4f45a} 
TETRAHEDRALIZED\+\_\+\+GRID\+\_\+\+TYPE\+\_\+5&1 cube  5 tets \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{TETRAHEDRALIZED\_GRID\_TYPE\_6\_ROTATIONAL@{TETRAHEDRALIZED\_GRID\_TYPE\_6\_ROTATIONAL}!igl@{igl}}\index{igl@{igl}!TETRAHEDRALIZED\_GRID\_TYPE\_6\_ROTATIONAL@{TETRAHEDRALIZED\_GRID\_TYPE\_6\_ROTATIONAL}}}\Hypertarget{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a0f009090a25fab927bfc17ed8c95ccf7}\label{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a0f009090a25fab927bfc17ed8c95ccf7} 
TETRAHEDRALIZED\+\_\+\+GRID\+\_\+\+TYPE\+\_\+6\+\_\+\+ROTATIONAL&1 cube  6 tets with rotatonal symmetry \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_TETRAHEDRALIZED\_GRID\_TYPE@{NUM\_TETRAHEDRALIZED\_GRID\_TYPE}!igl@{igl}}\index{igl@{igl}!NUM\_TETRAHEDRALIZED\_GRID\_TYPE@{NUM\_TETRAHEDRALIZED\_GRID\_TYPE}}}\Hypertarget{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a4945d263c917ea6178567ad57cedddd6}\label{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2a4945d263c917ea6178567ad57cedddd6} 
NUM\+\_\+\+TETRAHEDRALIZED\+\_\+\+GRID\+\_\+\+TYPE&Total number of tetrahedralization types. \\
\hline

\end{DoxyEnumFields}
\Hypertarget{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecf}\label{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecf} 
\index{igl@{igl}!WindingNumberMethod@{WindingNumberMethod}}
\index{WindingNumberMethod@{WindingNumberMethod}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WindingNumberMethod}{WindingNumberMethod}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecf}{igl\+::\+Winding\+Number\+Method}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{EXACT\_WINDING\_NUMBER\_METHOD@{EXACT\_WINDING\_NUMBER\_METHOD}!igl@{igl}}\index{igl@{igl}!EXACT\_WINDING\_NUMBER\_METHOD@{EXACT\_WINDING\_NUMBER\_METHOD}}}\Hypertarget{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfaa10945b526da7066079013ebe7efa315}\label{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfaa10945b526da7066079013ebe7efa315} 
EXACT\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHOD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{APPROX\_SIMPLE\_WINDING\_NUMBER\_METHOD@{APPROX\_SIMPLE\_WINDING\_NUMBER\_METHOD}!igl@{igl}}\index{igl@{igl}!APPROX\_SIMPLE\_WINDING\_NUMBER\_METHOD@{APPROX\_SIMPLE\_WINDING\_NUMBER\_METHOD}}}\Hypertarget{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa0d9a88899ed0568e9ea92020c2202c90}\label{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa0d9a88899ed0568e9ea92020c2202c90} 
APPROX\+\_\+\+SIMPLE\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHOD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{APPROX\_CACHE\_WINDING\_NUMBER\_METHOD@{APPROX\_CACHE\_WINDING\_NUMBER\_METHOD}!igl@{igl}}\index{igl@{igl}!APPROX\_CACHE\_WINDING\_NUMBER\_METHOD@{APPROX\_CACHE\_WINDING\_NUMBER\_METHOD}}}\Hypertarget{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa8a0f3017839d2e66a55fabbd269bff19}\label{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa8a0f3017839d2e66a55fabbd269bff19} 
APPROX\+\_\+\+CACHE\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHOD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{NUM\_WINDING\_NUMBER\_METHODS@{NUM\_WINDING\_NUMBER\_METHODS}!igl@{igl}}\index{igl@{igl}!NUM\_WINDING\_NUMBER\_METHODS@{NUM\_WINDING\_NUMBER\_METHODS}}}\Hypertarget{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa3d5ef75b451374bbaa7aecc358a66558}\label{namespaceigl_a509f63ef3c5ff8b238920eb0fe3ceecfa3d5ef75b451374bbaa7aecc358a66558} 
NUM\+\_\+\+WINDING\+\_\+\+NUMBER\+\_\+\+METHODS&Number of winding number methods. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Function Documentation}
\Hypertarget{namespaceigl_a8012b0115ea55d7e1ef308d01a37d65c}\label{namespaceigl_a8012b0115ea55d7e1ef308d01a37d65c} 
\index{igl@{igl}!accumarray@{accumarray}}
\index{accumarray@{accumarray}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{accumarray()}{accumarray()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedV , typename DerivedA $>$ \\
void igl\+::accumarray (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Accumulate values in V using subscripts in S. 

Like Matlab\textquotesingle{}s accumarray.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & \#S list of subscripts \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V list of values \\
\hline
\mbox{\texttt{ out}}  & {\em A} & max(subs)+1 list of accumulated values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa6380cf19be5242826791dfb3b26b113}\label{namespaceigl_aa6380cf19be5242826791dfb3b26b113} 
\index{igl@{igl}!accumarray@{accumarray}}
\index{accumarray@{accumarray}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{accumarray()}{accumarray()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedA $>$ \\
void igl\+::accumarray (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+A\+::\+Scalar}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Accumulate constant value {\ttfamily V} using subscripts in S. 

Like Matlab\textquotesingle{}s accumarray.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & \#S list of subscripts \\
\hline
\mbox{\texttt{ in}}  & {\em V} & single value used for all \\
\hline
\mbox{\texttt{ out}}  & {\em A} & max(subs)+1 list of accumulated values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aebbfd2ea11fa90111a31666f48cc5f00}\label{namespaceigl_aebbfd2ea11fa90111a31666f48cc5f00} 
\index{igl@{igl}!active\_set@{active\_set}}
\index{active\_set@{active\_set}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{active\_set()}{active\_set()}}
{\footnotesize\ttfamily template$<$typename AT , typename DerivedB , typename Derivedknown , typename DerivedY , typename AeqT , typename Derived\+Beq , typename AieqT , typename Derived\+Bieq , typename Derivedlx , typename Derivedux , typename DerivedZ $>$ \\
\mbox{\hyperlink{namespaceigl_a9b754bfef0dda338efc49cbf1fb6cfc2}{igl\+::\+Solver\+Status}} igl\+::active\+\_\+set (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AT $>$ \&}]{A,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedknown $>$ \&}]{known,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ AeqT $>$ \&}]{Aeq,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Beq $>$ \&}]{Beq,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ AieqT $>$ \&}]{Aieq,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Bieq $>$ \&}]{Bieq,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedlx $>$ \&}]{lx,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedux $>$ \&}]{ux,  }\item[{const \mbox{\hyperlink{structigl_1_1active__set__params}{igl\+::active\+\_\+set\+\_\+params}} \&}]{params,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&}]{Z }\end{DoxyParamCaption})}



Minimize convex quadratic energy subject to linear inequality constraints. 

\begin{DoxyVerb}min  Z A Z + Z B + constant
 Z
subject to
       Aeq Z = Beq
       Aieq Z <= Bieq
       lx <= Z <= ux
       Z(known) = Y
\end{DoxyVerb}
 that Z(known) = Y, optionally also subject to the constraints Aeq\texorpdfstring{$\ast$}{*}Z = Beq, and further optionally subject to the linear inequality constraints that Aieq\texorpdfstring{$\ast$}{*}Z \texorpdfstring{$<$}{<}= Bieq and constant inequality constraints lx \texorpdfstring{$<$}{<}= x \texorpdfstring{$<$}{<}= ux


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & n by n matrix of quadratic coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em B} & n by 1 column of linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em known} & list of indices to known rows in Z \\
\hline
\mbox{\texttt{ in}}  & {\em Y} & list of fixed values corresponding to known rows in Z \\
\hline
\mbox{\texttt{ in}}  & {\em Aeq} & meq by n list of linear equality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em Beq} & meq by 1 list of linear equality constraint constant values \\
\hline
\mbox{\texttt{ in}}  & {\em Aieq} & mieq by n list of linear inequality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em Bieq} & mieq by 1 list of linear inequality constraint constant values \\
\hline
\mbox{\texttt{ in}}  & {\em lx} & n by 1 list of lower bounds \mbox{[}\mbox{]} implies -\/Inf \\
\hline
\mbox{\texttt{ in}}  & {\em ux} & n by 1 list of upper bounds \mbox{[}\mbox{]} implies Inf \\
\hline
\mbox{\texttt{ in}}  & {\em params} & struct of additional parameters (see below) \\
\hline
\mbox{\texttt{ in,out}}  & {\em Z} & if not empty, is taken to be an n by 1 list of initial guess values. Set to solution on output. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Benchmark\+: For a harmonic solve on a mesh with 325K facets, matlab 2.\+2 secs, \doxylink{min__quad__with__fixed_8h}{igl/min\+\_\+quad\+\_\+with\+\_\+fixed.\+h} 7.\+1 secs
\end{DoxyNote}
\begin{DoxyPrecond}{Precondition}
rows of \mbox{[}Aeq;Aieq\mbox{]} {\bfseries{must}} be linearly independent. Should be using QR decomposition otherwise\+: \href{https://v8doc.sas.com/sashtml/ormp/chap5/sect32.htm}{\texttt{ https\+://v8doc.\+sas.\+com/sashtml/ormp/chap5/sect32.\+htm}}
\end{DoxyPrecond}
\begin{DoxyWarning}{Warning}
This solver is fairly experimental. It works reasonably well for bbw problems but doesn\textquotesingle{}t generalize well to other problems. NASOQ and OSQP are better general purpose solvers. 
\end{DoxyWarning}
\Hypertarget{namespaceigl_a4c905c0e9124bb38a79769497fa9b48b}\label{namespaceigl_a4c905c0e9124bb38a79769497fa9b48b} 
\index{igl@{igl}!adjacency\_list@{adjacency\_list}}
\index{adjacency\_list@{adjacency\_list}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{adjacency\_list()}{adjacency\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Index , typename Index\+Vector $>$ \\
void igl\+::adjacency\+\_\+list (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Index $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index\+Vector $>$ $>$ \&}]{A,  }\item[{bool}]{sorted = {\ttfamily false} }\end{DoxyParamCaption})}



Constructs the graph adjacency list of a given mesh (V,F) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em A} & vector\texorpdfstring{$<$}{<}vector$<$\+T$>$ \texorpdfstring{$>$}{>} containing at row i the adjacent vertices of vertex i \\
\hline
\mbox{\texttt{ in}}  & {\em sorted} & flag that indicates if the list should be sorted counter-\/clockwise. Input assumed to be manifold.\\
\hline
\end{DoxyParams}
Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Mesh\ in\ (V,F)}}
\DoxyCodeLine{vector<vector<double>\ >\ A;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a4c905c0e9124bb38a79769497fa9b48b}{adjacency\_list}}(F,A);}

\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a705a8f51137d1dd807bbe517c0567735}{adjacency\+\_\+matrix} \doxylink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}, \doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix}, diag 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a3b938bdb46eece91f62ab35a1e152a61}\label{namespaceigl_a3b938bdb46eece91f62ab35a1e152a61} 
\index{igl@{igl}!adjacency\_list@{adjacency\_list}}
\index{adjacency\_list@{adjacency\_list}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{adjacency\_list()}{adjacency\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Index $>$ \\
void igl\+::adjacency\+\_\+list (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{A }\end{DoxyParamCaption})}



Constructs the graph adjacency list of a given {\itshape polygon} mesh (V,F) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F list of polygon face index lists \\
\hline
\mbox{\texttt{ out}}  & {\em A} & vector\texorpdfstring{$<$}{<}vector$<$\+T$>$ \texorpdfstring{$>$}{>} containing at row i the adjacent vertices of vertex i \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a705a8f51137d1dd807bbe517c0567735}\label{namespaceigl_a705a8f51137d1dd807bbe517c0567735} 
\index{igl@{igl}!adjacency\_matrix@{adjacency\_matrix}}
\index{adjacency\_matrix@{adjacency\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{adjacency\_matrix()}{adjacency\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename T $>$ \\
void igl\+::adjacency\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A }\end{DoxyParamCaption})}



Constructs the graph adjacency matrix of a given mesh (V,F) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like {\ttfamily int} or {\ttfamily double} \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh simplices \\
\hline
\mbox{\texttt{ out}}  & {\em A} & max(\+F)+1 by max(\+F)+1 adjacency matrix, each row i corresponding to V(i,\+:)\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md1}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md1}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Mesh\ in\ (V,F)}}
\DoxyCodeLine{Eigen::SparseMatrix<double>\ A;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a705a8f51137d1dd807bbe517c0567735}{adjacency\_matrix}}(F,A);}
\DoxyCodeLine{\textcolor{comment}{//\ sum\ each\ row\ }}
\DoxyCodeLine{SparseVector<double>\ Asum;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}{sum}}(A,1,Asum);}
\DoxyCodeLine{\textcolor{comment}{//\ Convert\ row\ sums\ into\ diagonal\ of\ sparse\ matrix}}
\DoxyCodeLine{SparseMatrix<double>\ Adiag;}
\DoxyCodeLine{diag(Asum,Adiag);}
\DoxyCodeLine{\textcolor{comment}{//\ Build\ uniform\ laplacian}}
\DoxyCodeLine{SparseMatrix<double>\ U;}
\DoxyCodeLine{U\ =\ A-\/Adiag;}

\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}, \doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix}, diag 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a9b6ba9089b88d1e5ba18a153462c750c}\label{namespaceigl_a9b6ba9089b88d1e5ba18a153462c750c} 
\index{igl@{igl}!adjacency\_matrix@{adjacency\_matrix}}
\index{adjacency\_matrix@{adjacency\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{adjacency\_matrix()}{adjacency\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedI , typename DerivedC , typename T $>$ \\
void igl\+::adjacency\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A }\end{DoxyParamCaption})}



Constructs an vertex adjacency for a polygon mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#polygons+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\mbox{\texttt{ out}}  & {\em A} & max(\+I)+1 by max(\+I)+1 adjacency matrix, each row i corresponding to V(i,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}\label{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc} 
\index{igl@{igl}!all@{all}}
\index{all@{all}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{all()}{all()}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedB $>$ \\
void igl\+::all (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Check whether all values are logically true along a dimension. 

\begin{DoxyNote}{Note}
For Dense matrices use\+: A.\+rowwise().\doxylink{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}{all()} or A.\+colwise().\doxylink{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}{all()}
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to check for all (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em B} & n-\/long vector (if dim == 1) or m-\/long vector (if dim == 2) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad119e257b19a34797c3c9af92d7cc56b}\label{namespaceigl_ad119e257b19a34797c3c9af92d7cc56b} 
\index{igl@{igl}!all\_pairs\_distances@{all\_pairs\_distances}}
\index{all\_pairs\_distances@{all\_pairs\_distances}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{all\_pairs\_distances()}{all\_pairs\_distances()}}
{\footnotesize\ttfamily template$<$typename Mat $>$ \\
void igl\+::all\+\_\+pairs\+\_\+distances (\begin{DoxyParamCaption}\item[{const Mat \&}]{V,  }\item[{const Mat \&}]{U,  }\item[{const bool}]{squared,  }\item[{Mat \&}]{D }\end{DoxyParamCaption})}



Compute distances between each point i in V and point j in U. 

\begin{DoxyVerb}D = all_pairs_distances(V,U)
\end{DoxyVerb}
 
\begin{DoxyTemplParams}{Template Parameters}
{\em matrix} & class like Matrix\+Xd \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of points \\
\hline
\mbox{\texttt{ in}}  & {\em U} & \#U by dim list of points \\
\hline
\mbox{\texttt{ in}}  & {\em squared} & whether to return squared distances \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#V by \#U matrix of distances, where D(i,j) gives the distance or squareed distance between V(i,\+:) and U(j,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_acc5e79a82d06f353e2cc7364bb63d6ec}\label{namespaceigl_acc5e79a82d06f353e2cc7364bb63d6ec} 
\index{igl@{igl}!ambient\_occlusion@{ambient\_occlusion}}
\index{ambient\_occlusion@{ambient\_occlusion}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ambient\_occlusion()}{ambient\_occlusion()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedN , typename DerivedS $>$ \\
void igl\+::ambient\+\_\+occlusion (\begin{DoxyParamCaption}\item[{const std\+::function$<$ bool(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&) $>$ \&}]{shoot\+\_\+ray,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Compute ambient occlusion per given point using ray-\/mesh intersection function handle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em shoot\+\_\+ray} & function handle that outputs hits of a given ray against a mesh (embedded in function handles as captured variable/data) \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of origin points \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of origin normals \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+samples} & number of samples to use (e.\+g., 1000) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8e5409ff272904057655baa541161f63}\label{namespaceigl_a8e5409ff272904057655baa541161f63} 
\index{igl@{igl}!ambient\_occlusion@{ambient\_occlusion}}
\index{ambient\_occlusion@{ambient\_occlusion}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ambient\_occlusion()}{ambient\_occlusion()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ \\
void igl\+::ambient\+\_\+occlusion (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ DerivedV, DIM $>$ \&}]{aabb,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Compute ambient occlusion per given point for mesh (V,F) with precomputed \doxylink{classigl_1_1AABB}{AABB} tree. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of origin points \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of origin normals \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+samples} & number of samples to use (e.\+g., 1000) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9892f183be30982954280fde853dd8f3}\label{namespaceigl_a9892f183be30982954280fde853dd8f3} 
\index{igl@{igl}!ambient\_occlusion@{ambient\_occlusion}}
\index{ambient\_occlusion@{ambient\_occlusion}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ambient\_occlusion()}{ambient\_occlusion()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ \\
void igl\+::ambient\+\_\+occlusion (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Compute ambient occlusion per given point for mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of origin points \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of origin normals \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+samples} & number of samples to use (e.\+g., 1000) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2267549a29a1b490b0b2f56b6ec84ef6}\label{namespaceigl_a2267549a29a1b490b0b2f56b6ec84ef6} 
\index{igl@{igl}!angular\_distance@{angular\_distance}}
\index{angular\_distance@{angular\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{angular\_distance()}{angular\_distance()}}
{\footnotesize\ttfamily double igl\+::angular\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Quaterniond \&}]{A,  }\item[{const Eigen\+::\+Quaterniond \&}]{B }\end{DoxyParamCaption})}



The "{}angular distance"{} between two unit quaternions is the angle of the smallest rotation (treated as an Axis and Angle) that takes A to B. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & unit quaternion \\
\hline
\mbox{\texttt{ in}}  & {\em B} & unit quaternion \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
angular distance 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a8b265abd1563e69c5b980e38f0eff3b9}\label{namespaceigl_a8b265abd1563e69c5b980e38f0eff3b9} 
\index{igl@{igl}!any@{any}}
\index{any@{any}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{any()}{any()}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedB $>$ \\
void igl\+::any (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Check whether any values are logically true along a dimension. 

\begin{DoxyNote}{Note}
Dense matrices use\+: A.\+rowwise().\doxylink{namespaceigl_a8b265abd1563e69c5b980e38f0eff3b9}{any()} or A.\+colwise().\doxylink{namespaceigl_a8b265abd1563e69c5b980e38f0eff3b9}{any()}
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to check for any (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em B} & n-\/long vector (if dim == 1) or m-\/long vector (if dim == 2) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a48e5f486e14127dc6eb9013a7dc312bd}\label{namespaceigl_a48e5f486e14127dc6eb9013a7dc312bd} 
\index{igl@{igl}!arap\_precomputation@{arap\_precomputation}}
\index{arap\_precomputation@{arap\_precomputation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_precomputation()}{arap\_precomputation()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedb $>$ \\
bool igl\+::arap\+\_\+precomputation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{dim,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{\mbox{\hyperlink{structigl_1_1ARAPData}{ARAPData}} \&}]{data }\end{DoxyParamCaption})}



Compute necessary information to start using an ARAP deformation using local-\/global solver as described in "{}\+As-\/rigid-\/as-\/possible surface modeling"{} \mbox{[}Sorkine and Alexa 2007\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of triangle\texorpdfstring{$\vert$}{|}tet indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension being used at solve time. For deformation usually dim = V.\+cols(), for surface parameterization V.\+cols() = 3 and dim = 2 \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b list of "{}boundary"{} fixed vertex indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em data} & struct containing necessary precomputation \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether initialization succeeded
\end{DoxyReturn}
\doxylink{arap_8h}{include/igl/arap.\+h} \Hypertarget{namespaceigl_a62a45ef9782fe4b54d7487a8b3bb45e9}\label{namespaceigl_a62a45ef9782fe4b54d7487a8b3bb45e9} 
\index{igl@{igl}!arap\_solve@{arap\_solve}}
\index{arap\_solve@{arap\_solve}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_solve()}{arap\_solve()}}
{\footnotesize\ttfamily template$<$typename Derivedbc , typename DerivedU $>$ \\
bool igl\+::arap\+\_\+solve (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{\mbox{\hyperlink{structigl_1_1ARAPData}{ARAPData}} \&}]{data,  }\item[{Eigen\+::\+Matrix\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



Conduct arap solve. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em bc} & \#b by dim list of boundary conditions \\
\hline
\mbox{\texttt{ in}}  & {\em data} & struct containing necessary precomputation and parameters \\
\hline
\mbox{\texttt{ in,out}}  & {\em U} & \#V by dim initial guess\\
\hline
\end{DoxyParams}
\doxylink{arap_8h}{include/igl/arap.\+h}

\begin{DoxyNote}{Note}
While the libigl guidelines require outputs to be of type Plain\+Object\+Base so that the user does not need to worry about allocating memory for the output, in this case, the user is required to give an initial guess and hence fix the size of the problem domain. Taking a reference to Matrix\+Base in this case thus allows the user to provide e.\+g. a map to the position data, allowing seamless interoperability with user-\/defined datastructures without requiring a copy. 
\end{DoxyNote}
\Hypertarget{namespaceigl_a26233fdaaff7c535c5cf9e54d58f6f80}\label{namespaceigl_a26233fdaaff7c535c5cf9e54d58f6f80} 
\index{igl@{igl}!arap\_dof\_precomputation@{arap\_dof\_precomputation}}
\index{arap\_dof\_precomputation@{arap\_dof\_precomputation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_dof\_precomputation()}{arap\_dof\_precomputation()}}
{\footnotesize\ttfamily template$<$typename Lbs\+Matrix\+Type , typename SSCALAR $>$ \\
bool igl\+::arap\+\_\+dof\+\_\+precomputation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Lbs\+Matrix\+Type \&}]{M,  }\item[{const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{G,  }\item[{\mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}$<$ Lbs\+Matrix\+Type, SSCALAR $>$ \&}]{data }\end{DoxyParamCaption})}



Precomputes the system to optimize for "{}\+Fast Automatic Skinning \+Transformations"{} \mbox{[}Jacobson et al. 2012\mbox{]} skinning degrees of freedom optimization using as-\/rigid-\/as-\/possible energy. 

This consists of building constructor matrices (to compute covariance matrices from transformations and to build the poisson solve right hand side from rotation matrix entries) and also prefactoring the poisson system.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by \{3\texorpdfstring{$\vert$}{|}4\} list of face indices \\
\hline
\mbox{\texttt{ in}}  & {\em M} & \#V \texorpdfstring{$\ast$}{*} dim by \#handles \texorpdfstring{$\ast$}{*} dim \texorpdfstring{$\ast$}{*} (dim+1) matrix such that new\+\_\+\+V(\+:) = LBS(\+V,\+W,\+A) = reshape(\+M \texorpdfstring{$\ast$}{*} A,size(\+V)), where A is a column vectors formed by the entries in each handle\textquotesingle{}s dim by dim+1 transformation matrix. Specifcally, A = reshape(permute(\+Astack,\mbox{[}3 1 2\mbox{]}),n\texorpdfstring{$\ast$}{*}dim\texorpdfstring{$\ast$}{*}(dim+1),1) or A = \mbox{[}Lxx;Lyx;Lxy;Lyy;tx;ty\mbox{]}, and likewise for other dim if Astack(\+:,\+:,i) is the dim by (dim+1) transformation at handle i handles are ordered according to P then BE (point handles before bone handles) \\
\hline
\mbox{\texttt{ in}}  & {\em G} & \#V list of group indices (1 to k) for each vertex, such that vertex i is assigned to group G(i) \\
\hline
\mbox{\texttt{ out}}  & {\em data} & structure containing all necessary precomputation for calling arap\+\_\+dof\+\_\+update \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_abf08b3e278ea284934baa0d3f6dc4975}{lbs\+\_\+matrix\+\_\+column}
\end{DoxySeeAlso}
\doxylink{arap__dof_8h}{include/igl/arap\+\_\+dof.\+h} \Hypertarget{namespaceigl_acec31e2faca7eecae08c921a0430d0aa}\label{namespaceigl_acec31e2faca7eecae08c921a0430d0aa} 
\index{igl@{igl}!arap\_dof\_recomputation@{arap\_dof\_recomputation}}
\index{arap\_dof\_recomputation@{arap\_dof\_recomputation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_dof\_recomputation()}{arap\_dof\_recomputation()}}
{\footnotesize\ttfamily template$<$typename Lbs\+Matrix\+Type , typename SSCALAR $>$ \\
bool igl\+::arap\+\_\+dof\+\_\+recomputation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{fixed\+\_\+dim,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{A\+\_\+eq,  }\item[{\mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}$<$ Lbs\+Matrix\+Type, SSCALAR $>$ \&}]{data }\end{DoxyParamCaption})}



Should always be called after arap\+\_\+dof\+\_\+precomputation, but may be called in between successive calls to arap\+\_\+dof\+\_\+update, recomputes precomputation given that there are only changes in free and fixed. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fixed\+\_\+dim} & list of transformation element indices for fixed (or partailly fixed) handles\+: not necessarily the complement of \textquotesingle{}free\textquotesingle{} NOTE\+: the constraints for fixed transformations still need to be present in A\+\_\+eq \\
\hline
\mbox{\texttt{ in}}  & {\em A\+\_\+eq} & dim\texorpdfstring{$\ast$}{*}\#constraint\+\_\+points by m\texorpdfstring{$\ast$}{*}dim\texorpdfstring{$\ast$}{*}(dim+1) matrix of linear equality constraint coefficients. Each row corresponds to a linear constraint, so that A\+\_\+eq \texorpdfstring{$\ast$}{*} L = Beq says that the linear transformation entries in the column L should produce the user supplied positional constraints for each handle in Beq. The row A\+\_\+eq(i\texorpdfstring{$\ast$}{*}dim+d) corresponds to the constrain on coordinate d of position i \\
\hline
\mbox{\texttt{ out}}  & {\em data} & structure containing all necessary precomputation for calling arap\+\_\+dof\+\_\+update \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_abf08b3e278ea284934baa0d3f6dc4975}{lbs\+\_\+matrix\+\_\+column}
\end{DoxySeeAlso}
\doxylink{arap__dof_8h}{include/igl/arap\+\_\+dof.\+h} \Hypertarget{namespaceigl_a31279c751ae3a7d24bc56dd4c8029d1e}\label{namespaceigl_a31279c751ae3a7d24bc56dd4c8029d1e} 
\index{igl@{igl}!arap\_dof\_update@{arap\_dof\_update}}
\index{arap\_dof\_update@{arap\_dof\_update}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_dof\_update()}{arap\_dof\_update()}}
{\footnotesize\ttfamily template$<$typename Lbs\+Matrix\+Type , typename SSCALAR $>$ \\
bool igl\+::arap\+\_\+dof\+\_\+update (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structigl_1_1ArapDOFData}{Arap\+DOFData}}$<$ Lbs\+Matrix\+Type, SSCALAR $>$ \&}]{data,  }\item[{const Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, 1 $>$ \&}]{B\+\_\+eq,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{L0,  }\item[{const int}]{max\+\_\+iters,  }\item[{const double}]{tol,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{L }\end{DoxyParamCaption})}



Optimizes the transformations attached to each weight function based on precomputed system. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & precomputation data struct output from arap\+\_\+dof\+\_\+precomputation \\
\hline
\mbox{\texttt{ in}}  & {\em Beq} & dim\texorpdfstring{$\ast$}{*}\#constraint\+\_\+points constraint values. \\
\hline
\mbox{\texttt{ in}}  & {\em L0} & \#handles \texorpdfstring{$\ast$}{*} dim \texorpdfstring{$\ast$}{*} dim+1 list of initial guess transformation entries, also holds fixed transformation entries for fixed handles \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+iters} & maximum number of iterations \\
\hline
\mbox{\texttt{ in}}  & {\em tol} & stopping criteria parameter. If variables (linear transformation matrix entries) change by less than \textquotesingle{}tol\textquotesingle{} the optimization terminates, 0.\+75 (weak tolerance) 0.\+0 (extreme tolerance) \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#handles \texorpdfstring{$\ast$}{*} dim \texorpdfstring{$\ast$}{*} dim+1 list of final optimized transformation entries, allowed to be the same as L\\
\hline
\end{DoxyParams}
\doxylink{arap__dof_8h}{include/igl/arap\+\_\+dof.\+h} \Hypertarget{namespaceigl_ae1324ec871ee5fe0f3d6fa9b461ced93}\label{namespaceigl_ae1324ec871ee5fe0f3d6fa9b461ced93} 
\index{igl@{igl}!arap\_linear\_block@{arap\_linear\_block}}
\index{arap\_linear\_block@{arap\_linear\_block}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_linear\_block()}{arap\_linear\_block()}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF , typename MatK $>$ \\
void igl\+::arap\+\_\+linear\+\_\+block (\begin{DoxyParamCaption}\item[{const MatV \&}]{V,  }\item[{const MatF \&}]{F,  }\item[{const int}]{d,  }\item[{const \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{igl\+::\+ARAPEnergy\+Type}}}]{energy,  }\item[{MatK \&}]{Kd }\end{DoxyParamCaption})}



Constructs a block of the matrix which constructs the linear terms of a given arap energy. 

When treating rotations as knowns (arranged in a column) then this constructs Kd of K such that the linear portion of the energy is as a column\+: \begin{DoxyVerb}  K * R = [Kx Z  ... Ky Z  ... 
           Z  Kx ... Z  Ky ... 
           ... ]
\end{DoxyVerb}
 These blocks are also used to build the "{}covariance scatter matrices"{}. Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each.


\begin{DoxyTemplParams}{Template Parameters}
{\em MatV} & vertex position matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em MatF} & face index matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em Scalar} & e.\+g. double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of initial domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by \#simplex size list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em d} & coordinate of linear constructor to build \\
\hline
\mbox{\texttt{ in}}  & {\em energy} & ARAPEnergy\+Type enum value defining which energy is being used. See \doxylink{ARAPEnergyType_8h}{ARAPEnergy\+Type.\+h} for valid options and explanations. \\
\hline
\mbox{\texttt{ out}}  & {\em Kd} & \#V by \#V/\#F block of the linear constructor matrix corresponding to coordinate d\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{ARAPEnergy\+Type} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ad13e109be700043c1228c300bac31daf}\label{namespaceigl_ad13e109be700043c1228c300bac31daf} 
\index{igl@{igl}!arap\_linear\_block\_spokes@{arap\_linear\_block\_spokes}}
\index{arap\_linear\_block\_spokes@{arap\_linear\_block\_spokes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_linear\_block\_spokes()}{arap\_linear\_block\_spokes()}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF , typename MatK $>$ \\
void igl\+::arap\+\_\+linear\+\_\+block\+\_\+spokes (\begin{DoxyParamCaption}\item[{const MatV \&}]{V,  }\item[{const MatF \&}]{F,  }\item[{const int}]{d,  }\item[{MatK \&}]{Kd }\end{DoxyParamCaption})}



Constructs a block of the matrix which constructs the linear terms for spokes energy. 


\begin{DoxyTemplParams}{Template Parameters}
{\em MatV} & vertex position matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em MatF} & face index matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em Scalar} & e.\+g. double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of initial domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by \#simplex size list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em d} & coordinate of linear constructor to build (0 index) See \doxylink{ARAPEnergyType_8h}{ARAPEnergy\+Type.\+h} for valid options and explanations. \\
\hline
\mbox{\texttt{ out}}  & {\em Kd} & \#V by \#V block of the linear constructor matrix corresponding to coordinate d \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7280d256cac58af8c0dceb1e0ab487ca}\label{namespaceigl_a7280d256cac58af8c0dceb1e0ab487ca} 
\index{igl@{igl}!arap\_linear\_block\_spokes\_and\_rims@{arap\_linear\_block\_spokes\_and\_rims}}
\index{arap\_linear\_block\_spokes\_and\_rims@{arap\_linear\_block\_spokes\_and\_rims}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_linear\_block\_spokes\_and\_rims()}{arap\_linear\_block\_spokes\_and\_rims()}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF , typename MatK $>$ \\
void igl\+::arap\+\_\+linear\+\_\+block\+\_\+spokes\+\_\+and\+\_\+rims (\begin{DoxyParamCaption}\item[{const MatV \&}]{V,  }\item[{const MatF \&}]{F,  }\item[{const int}]{d,  }\item[{MatK \&}]{Kd }\end{DoxyParamCaption})}



Constructs a block of the matrix which constructs the linear terms for spokes and rims energy. 


\begin{DoxyTemplParams}{Template Parameters}
{\em MatV} & vertex position matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em MatF} & face index matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em Scalar} & e.\+g. double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of initial domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by \#simplex size list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em d} & coordinate of linear constructor to build (0 index) See \doxylink{ARAPEnergyType_8h}{ARAPEnergy\+Type.\+h} for valid options and explanations. \\
\hline
\mbox{\texttt{ out}}  & {\em Kd} & \#V by \#V block of the linear constructor matrix corresponding to coordinate d \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af81355594a143ab2601ce468536c0112}\label{namespaceigl_af81355594a143ab2601ce468536c0112} 
\index{igl@{igl}!arap\_linear\_block\_elements@{arap\_linear\_block\_elements}}
\index{arap\_linear\_block\_elements@{arap\_linear\_block\_elements}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_linear\_block\_elements()}{arap\_linear\_block\_elements()}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF , typename MatK $>$ \\
void igl\+::arap\+\_\+linear\+\_\+block\+\_\+elements (\begin{DoxyParamCaption}\item[{const MatV \&}]{V,  }\item[{const MatF \&}]{F,  }\item[{const int}]{d,  }\item[{MatK \&}]{Kd }\end{DoxyParamCaption})}



Constructs a block of the matrix which constructs the linear terms for per element energy. 


\begin{DoxyTemplParams}{Template Parameters}
{\em MatV} & vertex position matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em MatF} & face index matrix, e.\+g. Eigen\+::\+Matrix\+Xd \\
\hline
{\em Scalar} & e.\+g. double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of initial domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by \#simplex size list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em d} & coordinate of linear constructor to build (0 index) See \doxylink{ARAPEnergyType_8h}{ARAPEnergy\+Type.\+h} for valid options and explanations. \\
\hline
\mbox{\texttt{ out}}  & {\em Kd} & \#V by \#F block of the linear constructor matrix corresponding to coordinate d \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a02a8f8a4c016647d6f9c823ae3e32eaa}\label{namespaceigl_a02a8f8a4c016647d6f9c823ae3e32eaa} 
\index{igl@{igl}!arap\_rhs@{arap\_rhs}}
\index{arap\_rhs@{arap\_rhs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{arap\_rhs()}{arap\_rhs()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ \\
void igl\+::arap\+\_\+rhs (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{dim,  }\item[{const \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{igl\+::\+ARAPEnergy\+Type}}}]{energy,  }\item[{Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Right-\/hand side constructor of global poisson solve for various Arap energies. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by Vdim list of initial domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension being used at solve time. For deformation usually dim = V.\+cols(), for surface parameterization V.\+cols() = 3 and dim = 2 \\
\hline
\mbox{\texttt{ in}}  & {\em energy} & \doxylink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{igl\+::\+ARAPEnergy\+Type} enum value defining which energy is being used. See igl\+::\+ARAPEnergy\+Type.\+h for valid options and explanations. \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#V\texorpdfstring{$\ast$}{*}dim by \#(F\texorpdfstring{$\vert$}{|}V)\texorpdfstring{$\ast$}{*}dim\texorpdfstring{$\ast$}{*}dim matrix such that\+: b = K \texorpdfstring{$\ast$}{*} reshape(permute(\+R,\mbox{[}3 1 2\mbox{]}),size(V\texorpdfstring{$\vert$}{|}F,1)\texorpdfstring{$\ast$}{*}size(V,2)\texorpdfstring{$\ast$}{*}size(V,2),1);\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ae1324ec871ee5fe0f3d6fa9b461ced93}{arap\+\_\+linear\+\_\+block} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a2fde5a5b34007efccb521fd4f571f153}\label{namespaceigl_a2fde5a5b34007efccb521fd4f571f153} 
\index{igl@{igl}!AtA\_cached\_precompute@{AtA\_cached\_precompute}}
\index{AtA\_cached\_precompute@{AtA\_cached\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{AtA\_cached\_precompute()}{AtA\_cached\_precompute()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::\+At\+A\+\_\+cached\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{A,  }\item[{\mbox{\hyperlink{structigl_1_1AtA__cached__data}{At\+A\+\_\+cached\+\_\+data}} \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{AtA }\end{DoxyParamCaption})}



Computes At \texorpdfstring{$\ast$}{*} W \texorpdfstring{$\ast$}{*} A, where A is sparse and W is diagonal. 

Divides the construction in two phases, one for fixing the sparsity pattern, and one to populate it with values. Compared to evaluating it directly, this version is slower for the first time (since it requires a precomputation), but faster to the subsequent evaluations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m x n sparse matrix \\
\hline
\mbox{\texttt{ in,out}}  & {\em data} & stores the precomputed sparsity pattern, data.\+W contains the optional diagonal weights (stored as a dense vector). If W is not provided, it is replaced by the identity. \\
\hline
\mbox{\texttt{ out}}  & {\em AtA} & m by m matrix computed as AtA \texorpdfstring{$\ast$}{*} W \texorpdfstring{$\ast$}{*} A\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md3}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md3}

\begin{DoxyCode}{0}
\DoxyCodeLine{AtA\_data\ =\ \mbox{\hyperlink{structigl_1_1AtA__cached__data}{igl::AtA\_cached\_data}}();}
\DoxyCodeLine{AtA\_data.W\ =\ W;}
\DoxyCodeLine{\textcolor{keywordflow}{if}\ (s.AtA.rows()\ ==\ 0)}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespaceigl_a2fde5a5b34007efccb521fd4f571f153}{igl::AtA\_cached\_precompute}}(s.A,s.AtA\_data,s.AtA);}
\DoxyCodeLine{\textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \mbox{\hyperlink{namespaceigl_ac62e1e593efb31faa3ecb727695f3e53}{igl::AtA\_cached}}(s.A,s.AtA\_data,s.AtA);}

\end{DoxyCode}
 \Hypertarget{namespaceigl_ac62e1e593efb31faa3ecb727695f3e53}\label{namespaceigl_ac62e1e593efb31faa3ecb727695f3e53} 
\index{igl@{igl}!AtA\_cached@{AtA\_cached}}
\index{AtA\_cached@{AtA\_cached}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{AtA\_cached()}{AtA\_cached()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::\+At\+A\+\_\+cached (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{A,  }\item[{const \mbox{\hyperlink{structigl_1_1AtA__cached__data}{At\+A\+\_\+cached\+\_\+data}} \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{AtA }\end{DoxyParamCaption})}



Computes At \texorpdfstring{$\ast$}{*} W \texorpdfstring{$\ast$}{*} A, where A is sparse and W is diagonal precomputed into data. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m x n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em data} & stores the precomputed sparsity pattern, data.\+W contains the optional diagonal weights (stored as a dense vector). If W is not provided, it is replaced by the identity. \\
\hline
\mbox{\texttt{ out}}  & {\em AtA} & m by m matrix computed as AtA \texorpdfstring{$\ast$}{*} W \texorpdfstring{$\ast$}{*} A \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7cb9891e472fd984b8e86dfc5b7a279c}\label{namespaceigl_a7cb9891e472fd984b8e86dfc5b7a279c} 
\index{igl@{igl}!average\_from\_edges\_onto\_vertices@{average\_from\_edges\_onto\_vertices}}
\index{average\_from\_edges\_onto\_vertices@{average\_from\_edges\_onto\_vertices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{average\_from\_edges\_onto\_vertices()}{average\_from\_edges\_onto\_vertices()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DerivedoE , typename DeriveduE , typename DeriveduV $>$ \\
void igl\+::average\+\_\+from\+\_\+edges\+\_\+onto\+\_\+vertices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&}]{oE,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduV $>$ \&}]{uV }\end{DoxyParamCaption})}



Move a scalar field defined on edges to vertices by averaging. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 triangle mesh connectivity \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 3 mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#E by 3 orientation as generated by orient\+\_\+halfedges \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#E by 1 list of scalars \\
\hline
\mbox{\texttt{ out}}  & {\em uV} & \#V by 1 list of scalar defined on vertices\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ae76f879f4715d4a8596d28f12bc7161d}{orient\+\_\+halfedges} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ac457ea2c4e31fec1d7a3855fefb0260d}\label{namespaceigl_ac457ea2c4e31fec1d7a3855fefb0260d} 
\index{igl@{igl}!average\_onto\_faces@{average\_onto\_faces}}
\index{average\_onto\_faces@{average\_onto\_faces}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{average\_onto\_faces()}{average\_onto\_faces()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedS , typename Derived\+SF $>$ \\
void igl\+::average\+\_\+onto\+\_\+faces (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF }\end{DoxyParamCaption})}



Move a scalar field defined on vertices to faces by averaging. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by ss list of simples/faces \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#V by dim list of per-\/vertex values \\
\hline
\mbox{\texttt{ out}}  & {\em SF} & \#F by dim list of per-\/face values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac14f50dc6ec911af71c62d6c187fe3c2}\label{namespaceigl_ac14f50dc6ec911af71c62d6c187fe3c2} 
\index{igl@{igl}!average\_onto\_vertices@{average\_onto\_vertices}}
\index{average\_onto\_vertices@{average\_onto\_vertices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{average\_onto\_vertices()}{average\_onto\_vertices()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedS , typename Derived\+SV $>$ \\
void igl\+::average\+\_\+onto\+\_\+vertices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV }\end{DoxyParamCaption})}



Move a scalar field defined on faces to vertices by averaging. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#F by 1 scalar field defined on faces \\
\hline
\mbox{\texttt{ out}}  & {\em SV} & \#V by 1 scalar field defined on vertices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2fc598da20b66905a5f3edb6f985cfb1}\label{namespaceigl_a2fc598da20b66905a5f3edb6f985cfb1} 
\index{igl@{igl}!avg\_edge\_length@{avg\_edge\_length}}
\index{avg\_edge\_length@{avg\_edge\_length}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{avg\_edge\_length()}{avg\_edge\_length()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
double igl\+::avg\+\_\+edge\+\_\+length (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Compute the average edge length for the given triangle mesh. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived from vertex positions matrix type\+: i.\+e. Matrix\+Xd \\
\hline
{\em DerivedF} & derived from face indices matrix type\+: i.\+e. Matrix\+Xi \\
\hline
{\em DerivedL} & derived from edge lengths matrix type\+: i.\+e. Matrix\+Xd \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of mesh faces (must be simplex) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
average edge length
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a705a8f51137d1dd807bbe517c0567735}{adjacency\+\_\+matrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_af6bab06e3533fb4130d508453175889f}\label{namespaceigl_af6bab06e3533fb4130d508453175889f} 
\index{igl@{igl}!axis\_angle\_to\_quat@{axis\_angle\_to\_quat}}
\index{axis\_angle\_to\_quat@{axis\_angle\_to\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{axis\_angle\_to\_quat()}{axis\_angle\_to\_quat()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::axis\+\_\+angle\+\_\+to\+\_\+quat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{axis,  }\item[{const Q\+\_\+type}]{angle,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{out }\end{DoxyParamCaption})}



Convert axis angle representation of a rotation to a quaternion. 

A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w),

such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em axis} & 3d vector \\
\hline
\mbox{\texttt{ in}}  & {\em angle} & scalar \\
\hline
\mbox{\texttt{ out}}  & {\em out} & pointer to new quaternion\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a952c606ce07c40eb966cd5e55874f92d}\label{namespaceigl_a952c606ce07c40eb966cd5e55874f92d} 
\index{igl@{igl}!barycenter@{barycenter}}
\index{barycenter@{barycenter}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{barycenter()}{barycenter()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+BC $>$ \\
void igl\+::barycenter (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BC $>$ \&}]{BC }\end{DoxyParamCaption})}



Computes the barycenter of every simplex. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V x dim matrix of vertex coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F x simplex\+\_\+size matrix of indices of simplex corners into V \\
\hline
\mbox{\texttt{ out}}  & {\em BC} & \#F x dim matrix of 3d vertices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad4b111b83aabbda680af965294681b5b}\label{namespaceigl_ad4b111b83aabbda680af965294681b5b} 
\index{igl@{igl}!barycentric\_coordinates@{barycentric\_coordinates}}
\index{barycentric\_coordinates@{barycentric\_coordinates}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{barycentric\_coordinates()}{barycentric\_coordinates()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename DerivedL $>$ \\
void igl\+::barycentric\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



Compute barycentric coordinates of each point in a corresponding tetrahedron. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 Query points in 3d \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#P by 3 Tet corners in 3d \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#P by 3 Tet corners in 3d \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#P by 3 Tet corners in 3d \\
\hline
\mbox{\texttt{ in}}  & {\em D} & \#P by 3 Tet corners in 3d \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#P by 4 list of barycentric coordinates \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8a603159f2a82b981f00ca10be97d62e}\label{namespaceigl_a8a603159f2a82b981f00ca10be97d62e} 
\index{igl@{igl}!barycentric\_coordinates@{barycentric\_coordinates}}
\index{barycentric\_coordinates@{barycentric\_coordinates}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{barycentric\_coordinates()}{barycentric\_coordinates()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedL $>$ \\
void igl\+::barycentric\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



Compute barycentric coordinates in a triangle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by dim Query points \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#P by dim Triangle corners \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#P by dim Triangle corners \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#P by dim Triangle corners \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#P by 3 list of barycentric coordinates \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac2d34543d4673ecc638e11d0340f7c38}\label{namespaceigl_ac2d34543d4673ecc638e11d0340f7c38} 
\index{igl@{igl}!barycentric\_interpolation@{barycentric\_interpolation}}
\index{barycentric\_interpolation@{barycentric\_interpolation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{barycentric\_interpolation()}{barycentric\_interpolation()}}
{\footnotesize\ttfamily template$<$typename DerivedD , typename DerivedF , typename DerivedB , typename DerivedI , typename DerivedX $>$ \\
void igl\+::barycentric\+\_\+interpolation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X }\end{DoxyParamCaption})}



Interpolate data on a triangle mesh using barycentric coordinates. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em D} & \#D by dim list of per-\/vertex data \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#X by 3 list of barycentric corodinates \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#X list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em X} & \#X by dim list of interpolated data \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82}\label{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82} 
\index{igl@{igl}!basename@{basename}}
\index{basename@{basename}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{basename()}{basename()}}
{\footnotesize\ttfamily std\+::string igl\+::basename (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path }\end{DoxyParamCaption})}



Extract basename of file path (like PHP\textquotesingle{}s basename). 

E.\+g., /etc/sudoers.d  sudoers.\+d


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em path} & string containing input path \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string containing basename (see php\textquotesingle{}s basename)
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_aef1ff1d390be65861384b6ff764ebe09}{dirname}, \doxylink{namespaceigl_a541dccb34e02684e3d43966fca86bdaf}{pathinfo} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a33e3dc749c63b65a87635a309d322e9c}\label{namespaceigl_a33e3dc749c63b65a87635a309d322e9c} 
\index{igl@{igl}!bbw@{bbw}}
\index{bbw@{bbw}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bbw()}{bbw()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+Ele , typename Derivedb , typename Derivedbc , typename DerivedW $>$ \\
bool igl\+::bbw (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Ele $>$ \&}]{Ele,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{\mbox{\hyperlink{classigl_1_1BBWData}{BBWData}} \&}]{data,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Compute Bounded Biharmonic Weights on a given domain (V,Ele) with a given set of boundary conditions. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived type of eigen matrix for V (e.\+g. Matrix\+Xd) \\
\hline
{\em DerivedF} & derived type of eigen matrix for F (e.\+g. Matrix\+Xi) \\
\hline
{\em Derivedb} & derived type of eigen matrix for b (e.\+g. Vector\+Xi) \\
\hline
{\em Derivedbc} & derived type of eigen matrix for bc (e.\+g. Matrix\+Xd) \\
\hline
{\em DerivedW} & derived type of eigen matrix for W (e.\+g. Matrix\+Xd) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em Ele} & \#\+Elements by simplex-\/size list of element indices \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b boundary indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#b by \#W list of boundary values \\
\hline
\mbox{\texttt{ in,out}}  & {\em data} & object containing options, initial guess -\/-\/\texorpdfstring{$>$}{>} solution and results \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by \#W list of {\itshape unnormalized} weights to normalize use igl\+::normalize\+\_\+row\+\_\+sums(\+W,\+W); \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ae5227bd6077c6a709c20789e5c0d70cd}\label{namespaceigl_ae5227bd6077c6a709c20789e5c0d70cd} 
\index{igl@{igl}!bezier@{bezier}}
\index{bezier@{bezier}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bezier()}{bezier()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedP $>$ \\
void igl\+::bezier (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const typename Derived\+V\+::\+Scalar}]{t,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Evaluate a polynomial Bezier Curve at single parameter value. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of Bezier control points \\
\hline
\mbox{\texttt{ in}}  & {\em t} & evaluation parameter within \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em P} & 1 by dim output point ~\newline
 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0860a64b8a1678d63bea76c8b1999c78}\label{namespaceigl_a0860a64b8a1678d63bea76c8b1999c78} 
\index{igl@{igl}!bezier@{bezier}}
\index{bezier@{bezier}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bezier()}{bezier()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename DerivedP $>$ \\
void igl\+::bezier (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Evaluate a polynomial Bezier Curve at many parameter values. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of Bezier control points \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T evaluation parameters within \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#T by dim output points \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4be736f827b4ba341d4b2cb40f21f844}\label{namespaceigl_a4be736f827b4ba341d4b2cb40f21f844} 
\index{igl@{igl}!bezier@{bezier}}
\index{bezier@{bezier}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bezier()}{bezier()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename VMat , typename DerivedT , typename DerivedP $>$ \\
void igl\+::bezier (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ VMat $>$ \&}]{spline,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Evaluate a polynomial Bezier spline with a fixed parameter set for each sub-\/curve. 


\begin{DoxyTemplParams}{Template Parameters}
{\em VMat} & type of matrix of each list of control points \\
\hline
{\em DerivedT} & Derived type of evaluation parameters \\
\hline
{\em DerivedP} & Derived type of output points \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em spline} & \#curves list of lists of Bezier control points \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T evaluation parameters within \mbox{[}0,1\mbox{]} to use for each spline \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#curves\texorpdfstring{$\ast$}{*}\#T by dim output points \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a75b1dcc1386b54083fe6a2b70c7b7225}\label{namespaceigl_a75b1dcc1386b54083fe6a2b70c7b7225} 
\index{igl@{igl}!bfs@{bfs}}
\index{bfs@{bfs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bfs()}{bfs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedD , typename DerivedP $>$ \\
void igl\+::bfs (\begin{DoxyParamCaption}\item[{const AType \&}]{A,  }\item[{const size\+\_\+t}]{s,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Traverse a {\bfseries{directed}} graph represented by an adjacency list using. 

breadth first search; outputs Eigen types.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#V list of adjacency lists or \#V by \#V adjacency matrix \\
\hline
\mbox{\texttt{ in}}  & {\em s} & starting node (index into A) \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#V list of indices into rows of A in the order in which graph nodes are discovered. \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#V list of indices into rows of A of predecessor in resulting spanning tree \{-\/1 indicates root/not discovered), order corresponds to V {\bfseries{not}} D. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9ed9474cc5d1478971346be27092d3a2}\label{namespaceigl_a9ed9474cc5d1478971346be27092d3a2} 
\index{igl@{igl}!bfs@{bfs}}
\index{bfs@{bfs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bfs()}{bfs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename AType , typename DType , typename PType $>$ \\
void igl\+::bfs (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ AType $>$ $>$ \&}]{A,  }\item[{const size\+\_\+t}]{s,  }\item[{std\+::vector$<$ DType $>$ \&}]{D,  }\item[{std\+::vector$<$ PType $>$ \&}]{P }\end{DoxyParamCaption})}



Traverse a {\bfseries{directed}} graph represented by an adjacency list using. 

breadth first search; inputs adjacency lists, outputs lists.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#V list of adjacency lists ~\newline
 \\
\hline
\mbox{\texttt{ in}}  & {\em s} & starting node (index into A) \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#V list of indices into rows of A in the order in which graph nodes are discovered. \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#V list of indices into rows of A of predecessor in resulting spanning tree \{-\/1 indicates root/not discovered), order corresponds to V {\bfseries{not}} D. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3199a27a3e8403ef457e2a7b56f338f3}\label{namespaceigl_a3199a27a3e8403ef457e2a7b56f338f3} 
\index{igl@{igl}!bfs@{bfs}}
\index{bfs@{bfs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bfs()}{bfs()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename AType , typename DType , typename PType $>$ \\
void igl\+::bfs (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ AType $>$ \&}]{A,  }\item[{const size\+\_\+t}]{s,  }\item[{std\+::vector$<$ DType $>$ \&}]{D,  }\item[{std\+::vector$<$ PType $>$ \&}]{P }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a8b9225d219645e80e01f409b151e7cc1}\label{namespaceigl_a8b9225d219645e80e01f409b151e7cc1} 
\index{igl@{igl}!bfs\_orient@{bfs\_orient}}
\index{bfs\_orient@{bfs\_orient}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bfs\_orient()}{bfs\_orient()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+FF , typename DerivedC $>$ \\
void igl\+::bfs\+\_\+orient (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Consistently orient faces in orientable patches using BFS. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of faces \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#F by 3 list of faces (OK if same as F) \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#F list of component ids \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa0ba6f8afae42bb09f687fe9a518ee94}\label{namespaceigl_aa0ba6f8afae42bb09f687fe9a518ee94} 
\index{igl@{igl}!biharmonic\_coordinates@{biharmonic\_coordinates}}
\index{biharmonic\_coordinates@{biharmonic\_coordinates}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{biharmonic\_coordinates()}{biharmonic\_coordinates()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename SType , typename DerivedW $>$ \\
bool igl\+::biharmonic\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{const std\+::vector$<$ std\+::vector$<$ SType $>$ $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Compute "{}discrete biharmonic generalized barycentric coordinates"{} as described in "{}\+Linear Subspace Design for Real-\/\+Time Shape Deformation"{} \mbox{[}Wang et al. 

2015\mbox{]}. Not to be confused with "{}\+Bounded Biharmonic Weights for Real-\/\+Time Deformation"{} \mbox{[}Jacobson et al. 2011\mbox{]} or "{}\+Biharmonic \+Coordinates"{} (2D complex barycentric coordinates) \mbox{[}Weber et al. 2012\mbox{]}. These weights minimize a discrete version of the squared Laplacian energy subject to positional interpolation constraints at selected vertices (point handles) and transformation interpolation constraints at regions (region handles).


\begin{DoxyTemplParams}{Template Parameters}
{\em SType} & should be a simple index type e.\+g. {\ttfamily int},{\ttfamily size\+\_\+t} \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T by dim+1 list of / triangle indices into V if dim=2 \textbackslash{} tetrahedron indices into V if dim=3 \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#point-\/handles+\#region-\/handles list of lists of selected vertices for each handle. Point handles should have singleton lists and region handles should have lists of size at least dim+1 (and these points should be in general position). \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by \#points-\/handles+(\#region-\/handles \texorpdfstring{$\ast$}{*} dim+1) matrix of weights so that columns correspond to each handles generalized barycentric coordinates (for point-\/handles) or animation space weights (for region handles). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only on success
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md4}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md4}

\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd\ W;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_aa0ba6f8afae42bb09f687fe9a518ee94}{igl::biharmonic\_coordinates}}(V,F,S,W);}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keywordtype}{size\_t}\ dim\ =\ T.cols()-\/1;}
\DoxyCodeLine{MatrixXd\ H(W.cols(),dim);}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{int}\ c\ =\ 0;}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ h\ =\ 0;h<S.size();h++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}(S[h].size()==1)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ H.row(c++)\ =\ V.block(S[h][0],0,1,dim);}
\DoxyCodeLine{\ \ \ \ \}\textcolor{keywordflow}{else}}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ H.block(c,0,dim+1,dim).setIdentity();}
\DoxyCodeLine{\ \ \ \ \ \ c+=dim+1;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{assert(\ (V-\/(W*H)).array().maxCoeff()\ <\ 1e-\/7\ );}

\end{DoxyCode}
 \Hypertarget{namespaceigl_abb917f3b67e2fe53d03e8a2c98b6a276}\label{namespaceigl_abb917f3b67e2fe53d03e8a2c98b6a276} 
\index{igl@{igl}!biharmonic\_coordinates@{biharmonic\_coordinates}}
\index{biharmonic\_coordinates@{biharmonic\_coordinates}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{biharmonic\_coordinates()}{biharmonic\_coordinates()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename SType , typename DerivedW $>$ \\
bool igl\+::biharmonic\+\_\+coordinates (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{const std\+::vector$<$ std\+::vector$<$ SType $>$ $>$ \&}]{S,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em k} & power of Laplacian (experimental) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6867e7d0b5a7f134059e8205e6e16cc9}\label{namespaceigl_a6867e7d0b5a7f134059e8205e6e16cc9} 
\index{igl@{igl}!bijective\_composite\_harmonic\_mapping@{bijective\_composite\_harmonic\_mapping}}
\index{bijective\_composite\_harmonic\_mapping@{bijective\_composite\_harmonic\_mapping}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bijective\_composite\_harmonic\_mapping()}{bijective\_composite\_harmonic\_mapping()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU $>$ \\
bool igl\+::bijective\+\_\+composite\+\_\+harmonic\+\_\+mapping (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



Compute a injective planar mapping of a triangulated polygon (V,F) subjected to boundary conditions (b,bc). 

The mapping should be bijective in the sense that no triangles\textquotesingle{} areas become negative (this assumes they started positive). This mapping is computed by "{}composing"{} harmonic mappings between incremental morphs of the boundary conditions. This is a bit like a discrete version of "{}\+Bijective Composite Mean Value Mappings"{} \mbox{[}Schneider et al. 2013\mbox{]} but with a discrete harmonic map (cf. harmonic coordinates) instead of mean value coordinates. This is inspired by "{}\+Embedding a triangular graph within a given boundary"{} \mbox{[}Xu et al. 2011\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of triangle mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b list of boundary indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#b by 2 list of boundary conditions corresponding to b \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#V by 2 list of output mesh vertex locations \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if and only if U contains a successful bijectie mapping 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a7ef34b7c5ad3903df6e31eb7d57bc6aa}\label{namespaceigl_a7ef34b7c5ad3903df6e31eb7d57bc6aa} 
\index{igl@{igl}!bijective\_composite\_harmonic\_mapping@{bijective\_composite\_harmonic\_mapping}}
\index{bijective\_composite\_harmonic\_mapping@{bijective\_composite\_harmonic\_mapping}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bijective\_composite\_harmonic\_mapping()}{bijective\_composite\_harmonic\_mapping()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU $>$ \\
bool igl\+::bijective\+\_\+composite\+\_\+harmonic\+\_\+mapping (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{const int}]{min\+\_\+steps,  }\item[{const int}]{max\+\_\+steps,  }\item[{const int}]{num\+\_\+inner\+\_\+iters,  }\item[{const bool}]{test\+\_\+for\+\_\+flips,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em min\+\_\+steps} & minimum number of steps to take from V(b,\+:) to bc \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+steps} & minimum number of steps to take from V(b,\+:) to bc (if max\+\_\+steps == min\+\_\+steps then no further number of steps will be tried) \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+inner\+\_\+iters} & number of iterations of harmonic solves to run after for each morph step (to try to push flips back in) \\
\hline
\mbox{\texttt{ in}}  & {\em test\+\_\+for\+\_\+flips} & whether to check if flips occurred (and trigger more steps). if test\+\_\+for\+\_\+flips = false then this function always returns true \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a72b12780a4ac9de89f929034ab464726}\label{namespaceigl_a72b12780a4ac9de89f929034ab464726} 
\index{igl@{igl}!blkdiag@{blkdiag}}
\index{blkdiag@{blkdiag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{blkdiag()}{blkdiag()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::blkdiag (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ $>$ \&}]{L,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{Y }\end{DoxyParamCaption})}



Given a list of matrices place them along the diagonal as blocks of the output matrix. 

Like matlab\textquotesingle{}s blkdiag.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L} & list of matrices \{A,B, ...\} \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & A.\+rows()+B.\+rows()+... by A.\+cols()+B.\+cols()+... block diagonal\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ad5f624eb7c4015b813215c87880eb54d}{cat}, \doxylink{namespaceigl_ad35357b4f4e8dbf29c3fad77850fb957}{repdiag} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a137f77a6ebc0d59e4f7f3f43e862274e}\label{namespaceigl_a137f77a6ebc0d59e4f7f3f43e862274e} 
\index{igl@{igl}!blkdiag@{blkdiag}}
\index{blkdiag@{blkdiag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{blkdiag()}{blkdiag()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedY $>$ \\
void igl\+::blkdiag (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ DerivedY $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af6fdfaea612ac6f626571df84ba43dd0}\label{namespaceigl_af6fdfaea612ac6f626571df84ba43dd0} 
\index{igl@{igl}!blue\_noise@{blue\_noise}}
\index{blue\_noise@{blue\_noise}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{blue\_noise()}{blue\_noise()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedB , typename Derived\+FI , typename DerivedP , typename URBG  = DEFAULT\+\_\+\+URBG$>$ \\
void igl\+::blue\+\_\+noise (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+V\+::\+Scalar}]{r,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&}]{FI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{URBG \&\&}]{urbg = {\ttfamily \mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}()} }\end{DoxyParamCaption})}



"{}\+Fast Poisson Disk Sampling in Arbitrary Dimensions"{} \mbox{[}Bridson 2007\mbox{]}. 

For very dense samplings this is faster than (up to 2x) cy\+Code\+Base\textquotesingle{}s implementation of "{}\+Sample Elimination for Generating Poisson Disk Sample \+Sets"{} \mbox{[}Yuksel 2015\mbox{]}. YMMV


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em r} & Poisson disk radius (evaluated according to Euclidean distance on V) \\
\hline
\mbox{\texttt{ out}}  & {\em B} & \#P by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) \\
\hline
\mbox{\texttt{ out}}  & {\em FI} & \#P list of indices into F \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#P by dim list of sample positions. \\
\hline
\mbox{\texttt{ in,out}}  & {\em urbg} & An instance of Unform\+Random\+Bit\+Generator (e.\+g., {\ttfamily std\+::minstd\+\_\+rand(0)}) \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a1fc88d96c492e3bf962501af8bea413e}{random\+\_\+points\+\_\+on\+\_\+mesh} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_af9bff7fe392542fa173e6665ddaf7a21}\label{namespaceigl_af9bff7fe392542fa173e6665ddaf7a21} 
\index{igl@{igl}!bone\_parents@{bone\_parents}}
\index{bone\_parents@{bone\_parents}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bone\_parents()}{bone\_parents()}}
{\footnotesize\ttfamily template$<$typename Derived\+BE , typename DerivedP $>$ \\
void igl\+::bone\+\_\+parents (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+BE $>$ \&}]{BE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Recover "{}parent"{} bones from directed graph representation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em BE} & \#\+BE by 2 list of directed bone edges \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#\+BE by 1 list of parent indices into BE, -\/1 means root. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a366cd5eb6c56116ad697c23065fb8b40}\label{namespaceigl_a366cd5eb6c56116ad697c23065fb8b40} 
\index{igl@{igl}!boundary\_conditions@{boundary\_conditions}}
\index{boundary\_conditions@{boundary\_conditions}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_conditions()}{boundary\_conditions()}}
{\footnotesize\ttfamily bool igl\+::boundary\+\_\+conditions (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Ele,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{CE,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{CF,  }\item[{Eigen\+::\+Vector\+Xi \&}]{b,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{bc }\end{DoxyParamCaption})}



Compute boundary conditions for automatic weights computation. 

This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges/faces.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of domain vertices \\
\hline
\mbox{\texttt{ in}}  & {\em Ele} & \#\+Ele by simplex-\/size list of simplex indices \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#C by dim list of handle positions \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 1 list of point handle indices into C \\
\hline
\mbox{\texttt{ in}}  & {\em BE} & \#\+BE by 2 list of bone edge indices into C \\
\hline
\mbox{\texttt{ in}}  & {\em CE} & \#\+CE by 2 list of cage edge indices into {\itshape P} \\
\hline
\mbox{\texttt{ in}}  & {\em CF} & \#\+CF by 3 list of (triangular) cage face indices into {\itshape P} \\
\hline
\mbox{\texttt{ out}}  & {\em b} & \#b list of boundary indices (indices into V of vertices which have known, fixed values) \\
\hline
\mbox{\texttt{ out}}  & {\em bc} & \#b by \#weights list of known/fixed values for boundary vertices (notice the \#b != \#weights in general because \#b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to \mbox{[}P;BE\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if boundary conditions are suspicious\+: P and BE are empty bc is empty some column of bc doesn\textquotesingle{}t have a 0 (assuming bc has \texorpdfstring{$>$}{>}1 columns) some column of bc doesn\textquotesingle{}t have a 1 (assuming bc has \texorpdfstring{$>$}{>}1 columns) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aa7d8c6202cbd9be61850e58d65fd3096}\label{namespaceigl_aa7d8c6202cbd9be61850e58d65fd3096} 
\index{igl@{igl}!boundary\_facets@{boundary\_facets}}
\index{boundary\_facets@{boundary\_facets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_facets()}{boundary\_facets()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename DerivedF , typename DerivedJ , typename DerivedK $>$ \\
void igl\+::boundary\+\_\+facets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Determine boundary faces (edges) of tetrahedra (triangles) stored in T (analogous to qptoolbox\textquotesingle{}s {\ttfamily outline} and {\ttfamily boundary\+\_\+faces}). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra \\
\hline
\mbox{\texttt{ out}}  & {\em F} & list of boundary faces, n by 3 (2), where n is the number of boundary faces \\
\hline
\mbox{\texttt{ out}}  & {\em J} & list of indices into T, n by 1 \\
\hline
\mbox{\texttt{ out}}  & {\em K} & list of indices revealing across from which vertex is this facet \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a68133ab0b5aaff2f739a42c49f769512}\label{namespaceigl_a68133ab0b5aaff2f739a42c49f769512} 
\index{igl@{igl}!boundary\_facets@{boundary\_facets}}
\index{boundary\_facets@{boundary\_facets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_facets()}{boundary\_facets()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename DerivedF $>$ \\
void igl\+::boundary\+\_\+facets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Determine boundary faces (edges) of tetrahedra (triangles) stored in T. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra \\
\hline
\mbox{\texttt{ out}}  & {\em F} & list of boundary faces, n by 3 (2), where n is the number of boundary faces \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adfd8cee60db0ccd9448521c2c828430d}\label{namespaceigl_adfd8cee60db0ccd9448521c2c828430d} 
\index{igl@{igl}!boundary\_facets@{boundary\_facets}}
\index{boundary\_facets@{boundary\_facets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_facets()}{boundary\_facets()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename Ret $>$ \\
Ret igl\+::boundary\+\_\+facets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



Determine boundary faces (edges) of tetrahedra (triangles) stored in T. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
list of boundary faces, n by 3 (2), where n is the number of boundary faces 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a782f0e0282464889f69540a72db9e88b}\label{namespaceigl_a782f0e0282464889f69540a72db9e88b} 
\index{igl@{igl}!boundary\_facets@{boundary\_facets}}
\index{boundary\_facets@{boundary\_facets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_facets()}{boundary\_facets()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename IntegerT , typename IntegerF $>$ \\
void igl\+::boundary\+\_\+facets (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ IntegerT $>$ $>$ \&}]{T,  }\item[{std\+::vector$<$ std\+::vector$<$ IntegerF $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



Determine boundary faces (edges) of tetrahedra (triangles) stored in T; inputs and outputs lists. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra \\
\hline
\mbox{\texttt{ out}}  & {\em F} & list of boundary faces, n by 3 (2), where n is the number of boundary faces \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adb06d6406b52700028680b4b2c727700}\label{namespaceigl_adb06d6406b52700028680b4b2c727700} 
\index{igl@{igl}!boundary\_loop@{boundary\_loop}}
\index{boundary\_loop@{boundary\_loop}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_loop()}{boundary\_loop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Index $>$ \\
void igl\+::boundary\+\_\+loop (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{L }\end{DoxyParamCaption})}



Compute list of ordered boundary loops for a manifold mesh. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Index} & index type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh faces \\
\hline
\mbox{\texttt{ out}}  & {\em L} & list of loops where L\mbox{[}i\mbox{]} = ordered list of boundary vertices in loop i \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a21468e50560667302d1637ed6895b29a}\label{namespaceigl_a21468e50560667302d1637ed6895b29a} 
\index{igl@{igl}!boundary\_loop@{boundary\_loop}}
\index{boundary\_loop@{boundary\_loop}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_loop()}{boundary\_loop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Index $>$ \\
void igl\+::boundary\+\_\+loop (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ Index $>$ \&}]{L }\end{DoxyParamCaption})}



Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Index} & index type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh faces \\
\hline
\mbox{\texttt{ out}}  & {\em L} & ordered list of boundary vertices of longest boundary loop \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a82fec963303eda50e7dec22793b756d8}\label{namespaceigl_a82fec963303eda50e7dec22793b756d8} 
\index{igl@{igl}!boundary\_loop@{boundary\_loop}}
\index{boundary\_loop@{boundary\_loop}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{boundary\_loop()}{boundary\_loop()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedL $>$ \\
void igl\+::boundary\+\_\+loop (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Index} & index type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh faces \\
\hline
\mbox{\texttt{ out}}  & {\em L} & ordered list of boundary vertices of longest boundary loop \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad3dc35283c38c7712366f3b0f9dd09a7}\label{namespaceigl_ad3dc35283c38c7712366f3b0f9dd09a7} 
\index{igl@{igl}!bounding\_box@{bounding\_box}}
\index{bounding\_box@{bounding\_box}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bounding\_box()}{bounding\_box()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+BV , typename Derived\+BF $>$ \\
void igl\+::bounding\+\_\+box (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BV $>$ \&}]{BV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&}]{BF }\end{DoxyParamCaption})}



Build a triangle mesh of the bounding box of a given list of vertices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of rest domain positions \\
\hline
\mbox{\texttt{ out}}  & {\em BV} & 2\texorpdfstring{$^\wedge$}{\string^}dim by dim list of bounding box corners positions \\
\hline
\mbox{\texttt{ out}}  & {\em BF} & \#\+BF by dim list of simplex facets ~\newline
 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a42a1ef8fd908031e5b30d1aba9614cb7}\label{namespaceigl_a42a1ef8fd908031e5b30d1aba9614cb7} 
\index{igl@{igl}!bounding\_box@{bounding\_box}}
\index{bounding\_box@{bounding\_box}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bounding\_box()}{bounding\_box()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+BV , typename Derived\+BF $>$ \\
void igl\+::bounding\+\_\+box (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const typename Derived\+V\+::\+Scalar}]{pad,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BV $>$ \&}]{BV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&}]{BF }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_aac1efbdec1a5c13888e2ec44b70c100a}\label{namespaceigl_aac1efbdec1a5c13888e2ec44b70c100a} 
\index{igl@{igl}!bounding\_box\_diagonal@{bounding\_box\_diagonal}}
\index{bounding\_box\_diagonal@{bounding\_box\_diagonal}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{bounding\_box\_diagonal()}{bounding\_box\_diagonal()}}
{\footnotesize\ttfamily double igl\+::bounding\+\_\+box\+\_\+diagonal (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V }\end{DoxyParamCaption})}



Compute the length of the diagonal of a given meshes axis-\/aligned bounding box. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex/point positions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
length of bounding box diagonal 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ab03aa82f1ac2c783bc64cbc9b869531e}\label{namespaceigl_ab03aa82f1ac2c783bc64cbc9b869531e} 
\index{igl@{igl}!CANONICAL\_VIEW\_QUAT@{CANONICAL\_VIEW\_QUAT}}
\index{CANONICAL\_VIEW\_QUAT@{CANONICAL\_VIEW\_QUAT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CANONICAL\_VIEW\_QUAT()}{CANONICAL\_VIEW\_QUAT()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
Q\+\_\+type igl\+::\+CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a9ac4840ccfe1570de9ff6efc2fba06a5}\label{namespaceigl_a9ac4840ccfe1570de9ff6efc2fba06a5} 
\index{igl@{igl}!CANONICAL\_VIEW\_QUAT$<$ float $>$@{CANONICAL\_VIEW\_QUAT$<$ float $>$}}
\index{CANONICAL\_VIEW\_QUAT$<$ float $>$@{CANONICAL\_VIEW\_QUAT$<$ float $>$}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CANONICAL\_VIEW\_QUAT$<$ float $>$()}{CANONICAL\_VIEW\_QUAT< float >()}}
{\footnotesize\ttfamily template$<$$>$ \\
float \mbox{\hyperlink{namespaceigl_ab03aa82f1ac2c783bc64cbc9b869531e}{igl\+::\+CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT}}$<$ float $>$ (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a834139f67af87775d3524a90be997edc}\label{namespaceigl_a834139f67af87775d3524a90be997edc} 
\index{igl@{igl}!CANONICAL\_VIEW\_QUAT$<$ double $>$@{CANONICAL\_VIEW\_QUAT$<$ double $>$}}
\index{CANONICAL\_VIEW\_QUAT$<$ double $>$@{CANONICAL\_VIEW\_QUAT$<$ double $>$}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CANONICAL\_VIEW\_QUAT$<$ double $>$()}{CANONICAL\_VIEW\_QUAT< double >()}}
{\footnotesize\ttfamily template$<$$>$ \\
double \mbox{\hyperlink{namespaceigl_ab03aa82f1ac2c783bc64cbc9b869531e}{igl\+::\+CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT}}$<$ double $>$ (\begin{DoxyParamCaption}\item[{int}]{i,  }\item[{int}]{j }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_ad5f624eb7c4015b813215c87880eb54d}\label{namespaceigl_ad5f624eb7c4015b813215c87880eb54d} 
\index{igl@{igl}!cat@{cat}}
\index{cat@{cat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cat()}{cat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::cat (\begin{DoxyParamCaption}\item[{const int}]{dim,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{A,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{B,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{C }\end{DoxyParamCaption})}



Perform concatenation of a two {\itshape sparse} matrices along a single dimension If dim == 1, then C = \mbox{[}A;B\mbox{]}; If dim == 2 then C = \mbox{[}A B\mbox{]}. 

This is an attempt to act like matlab\textquotesingle{}s cat function.


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & scalar data type for sparse matrices like double or int \\
\hline
{\em Mat} & matrix type for all matrices (e.\+g. Matrix\+Xd, Sparse\+Matrix) \\
\hline
{\em MatC} & matrix type for output matrix (e.\+g. Matrix\+Xd) needs to support resize \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to concatenate, 1 or 2 \\
\hline
\mbox{\texttt{ in}}  & {\em A} & first input matrix \\
\hline
\mbox{\texttt{ in}}  & {\em B} & second input matrix \\
\hline
\mbox{\texttt{ out}}  & {\em C} & output matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0834acd824362d58a9a06710cde2e964}\label{namespaceigl_a0834acd824362d58a9a06710cde2e964} 
\index{igl@{igl}!cat@{cat}}
\index{cat@{cat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cat()}{cat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename Derived , class MatC $>$ \\
void igl\+::cat (\begin{DoxyParamCaption}\item[{const int}]{dim,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived $>$ \&}]{B,  }\item[{MatC \&}]{C }\end{DoxyParamCaption})}



Perform concatenation of a two {\itshape dense} matrices along a single dimension If dim == 1, then C = \mbox{[}A;B\mbox{]}; If dim == 2 then C = \mbox{[}A B\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to concatenate, 1 or 2 \\
\hline
\mbox{\texttt{ in}}  & {\em A} & first input matrix \\
\hline
\mbox{\texttt{ in}}  & {\em B} & second input matrix \\
\hline
\mbox{\texttt{ out}}  & {\em C} & output matrix\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If you\textquotesingle{}re using Dense matrices you might be better off using the \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} operator 
\end{DoxyNote}
\Hypertarget{namespaceigl_a203a47235dd090370a7dccffd385002f}\label{namespaceigl_a203a47235dd090370a7dccffd385002f} 
\index{igl@{igl}!cat@{cat}}
\index{cat@{cat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cat()}{cat()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$class Mat $>$ \\
Mat igl\+::cat (\begin{DoxyParamCaption}\item[{const int}]{dim,  }\item[{const Mat \&}]{A,  }\item[{const Mat \&}]{B }\end{DoxyParamCaption})}



Perform concatenation of a two {\itshape dense} matrices along a single dimension If dim == 1, then C = \mbox{[}A;B\mbox{]}; If dim == 2 then C = \mbox{[}A B\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to concatenate, 1 or 2 \\
\hline
\mbox{\texttt{ in}}  & {\em A} & first input matrix \\
\hline
\mbox{\texttt{ in}}  & {\em B} & second input matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
C output matrix
\end{DoxyReturn}
\begin{DoxyNote}{Note}
If you\textquotesingle{}re using Dense matrices you might be better off using the \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} operator 
\end{DoxyNote}
\Hypertarget{namespaceigl_a2b1d04cfbdfdbb8a94fa5712aa9b868e}\label{namespaceigl_a2b1d04cfbdfdbb8a94fa5712aa9b868e} 
\index{igl@{igl}!cat@{cat}}
\index{cat@{cat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cat()}{cat()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$class Mat $>$ \\
void igl\+::cat (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ Mat $>$ $>$ \&}]{A,  }\item[{Mat \&}]{C }\end{DoxyParamCaption})}



Concatenate a "{}matrix"{} of sub-\/blocks C = \mbox{[}A0;A1;A2;...;An\mbox{]} where Ai = \mbox{[}A\mbox{[}i\mbox{]}\mbox{[}0\mbox{]} A\mbox{[}i\mbox{]}\mbox{[}1\mbox{]} ... A\mbox{[}i\mbox{]}\mbox{[}m\mbox{]}\mbox{]};. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & a list of list of matrices (sizes must be compatibile) \\
\hline
\mbox{\texttt{ out}}  & {\em C} & output matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a13402260035cb13a7110a755ae31c487}\label{namespaceigl_a13402260035cb13a7110a755ae31c487} 
\index{igl@{igl}!cat@{cat}}
\index{cat@{cat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cat()}{cat()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename T , typename DerivedC $>$ \\
void igl\+::cat (\begin{DoxyParamCaption}\item[{const int}]{dim,  }\item[{const std\+::vector$<$ T $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Concatenate a std\+::vector of matrices along the specified dimension. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to concatenate, 1 or 2 \\
\hline
\mbox{\texttt{ in}}  & {\em A} & std\+::vector of eigen matrices. Must have identical \# cols if dim == 1 or rows if dim == 2 \\
\hline
\mbox{\texttt{ out}}  & {\em C} & output matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_afacaeba967f62ca7f67bfddf604fd60f}\label{namespaceigl_afacaeba967f62ca7f67bfddf604fd60f} 
\index{igl@{igl}!ceil@{ceil}}
\index{ceil@{ceil}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ceil()}{ceil()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::ceil (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



Ceil a given matrix to nearest integers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix of scalars \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n matrix of ceiled integers \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adaa0102450153380ae5ecdb948352556}\label{namespaceigl_adaa0102450153380ae5ecdb948352556} 
\index{igl@{igl}!centroid@{centroid}}
\index{centroid@{centroid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{centroid()}{centroid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedc , typename Derivedvol $>$ \\
void igl\+::centroid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{Derivedvol \&}]{vol }\end{DoxyParamCaption})}



Computes the centroid and enclosed volume of a closed mesh using a surface integral. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of rest domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em c} & dim vector of centroid coordinates \\
\hline
\mbox{\texttt{ out}}  & {\em vol} & total volume of solid. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3b05ef9da68218494452d38460a07835}\label{namespaceigl_a3b05ef9da68218494452d38460a07835} 
\index{igl@{igl}!centroid@{centroid}}
\index{centroid@{centroid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{centroid()}{centroid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedc $>$ \\
void igl\+::centroid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad2779ad7549dc5da4bed4c7042e2f780}\label{namespaceigl_ad2779ad7549dc5da4bed4c7042e2f780} 
\index{igl@{igl}!circulation@{circulation}}
\index{circulation@{circulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{circulation()}{circulation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ igl\+::circulation (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const bool}]{ccw,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EI }\end{DoxyParamCaption})}



Return list of faces around the end point of an edge. 

Assumes data-\/structures are built from an edge-\/manifold {\bfseries{closed}} mesh.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e} & index into E of edge to circulate \\
\hline
\mbox{\texttt{ in}}  & {\em ccw} & whether to {\itshape continue} in ccw direction of edge (circulate around E(e,1)) \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
list of faces touched by circulation (in cyclically order).
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a984c604c49a10f557933850d8c8e2a76}{edge\+\_\+flaps} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a0491f8d6a5d5bd769ab23851f43bb2e0}\label{namespaceigl_a0491f8d6a5d5bd769ab23851f43bb2e0} 
\index{igl@{igl}!circulation@{circulation}}
\index{circulation@{circulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{circulation()}{circulation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void igl\+::circulation (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const bool}]{ccw,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{Eigen\+::\+Vector\+Xi \&}]{vN }\end{DoxyParamCaption})}



Return list of faces around the end point of an edge. 

Assumes data-\/structures are built from an edge-\/manifold {\bfseries{closed}} mesh.


\begin{DoxyParams}[2]{Parameters}
\mbox{\texttt{ in}}  &  & {\em e} & index into E of edge to circulate \\
\hline
\mbox{\texttt{ in}}  &  & {\em ccw} & whether to {\itshape continue} in ccw direction of edge (circulate around E(e,1)) \\
\hline
\mbox{\texttt{ in}}  &  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  &  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  &  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\mbox{\texttt{ out}}  &  & {\em vN} & list of of faces touched by circulation (in cyclically order).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a984c604c49a10f557933850d8c8e2a76}{edge\+\_\+flaps} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a904a58ea245b35cce0feec144140e368}\label{namespaceigl_a904a58ea245b35cce0feec144140e368} 
\index{igl@{igl}!circulation@{circulation}}
\index{circulation@{circulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{circulation()}{circulation()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void igl\+::circulation (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const bool}]{ccw,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{std\+::vector$<$ int $>$ \&}]{Nv,  }\item[{std\+::vector$<$ int $>$ \&}]{Nf }\end{DoxyParamCaption})}



Return list of faces around the end point of an edge. 

Assumes data-\/structures are built from an edge-\/manifold {\bfseries{closed}} mesh.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e} & index into E of edge to circulate \\
\hline
\mbox{\texttt{ in}}  & {\em ccw} & whether to {\itshape continue} in ccw direction of edge (circulate around E(e,1)) \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{}     e=(j-\/$>$i) @param \mbox{[}in\mbox{]} EI  \#\+E by 2 list of edge flap corners (see above). @param \mbox{[}out\mbox{]} Nv  \#\+Nv list of "{}next"{} vertex indices \\
\hline
\mbox{\texttt{ out}}  & {\em Nf} & \#\+Nf list of face indices\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a984c604c49a10f557933850d8c8e2a76}{edge\+\_\+flaps} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a8d3ed506f1a1d753e1c342b42f008170}\label{namespaceigl_a8d3ed506f1a1d753e1c342b42f008170} 
\index{igl@{igl}!circumradius@{circumradius}}
\index{circumradius@{circumradius}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{circumradius()}{circumradius()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedR $>$ \\
void igl\+::circumradius (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R }\end{DoxyParamCaption})}



Compute the circumradius of each triangle in a mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em R} & \#F list of circumradius \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa8e3cfdf30adcadd5172a4f0b862bf59}\label{namespaceigl_aa8e3cfdf30adcadd5172a4f0b862bf59} 
\index{igl@{igl}!collapse\_edge@{collapse\_edge}}
\index{collapse\_edge@{collapse\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_edge()}{collapse\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily bool igl\+::collapse\+\_\+edge (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const Eigen\+::\+Row\+Vector\+Xd \&}]{p,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{int \&}]{e1,  }\item[{int \&}]{e2,  }\item[{int \&}]{f1,  }\item[{int \&}]{f2 }\end{DoxyParamCaption})}



Attempt to collapse a given edge of a mesh. 

Assumes (V,F) is a closed manifold mesh (except for previously collapsed faces which should be set to\+: \mbox{[}IGL\+\_\+\+COLLAPSE\+\_\+\+EDGE\+\_\+\+NULL IGL\+\_\+\+COLLAPSE\+\_\+\+EDGE\+\_\+\+NULL IGL\+\_\+\+COLLAPSE\+\_\+\+EDGE\+\_\+\+NULL\mbox{]}. Collapses exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other). This is implemented in a way that it can be repeatedly called until satisfaction and then the garbage in F can be collected by removing NULL faces.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e} & index into E of edge to try to collapse. E(e,\+:) = \mbox{[}s d\mbox{]} or \mbox{[}d s\mbox{]} so that s\texorpdfstring{$<$}{<}d, then d is collapsed to s. \\
\hline
\mbox{\texttt{ in}}  & {\em p} & dim list of vertex position where to place merged vertex \mbox{[}mesh inputs\mbox{]} \\
\hline
\mbox{\texttt{ in,out}}  & {\em V} & \#V by dim list of vertex positions, lesser index of E(e,\+:) will be set to midpoint of edge. \\
\hline
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in,out}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in,out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in,out}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in,out}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \mbox{[}mesh inputs\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em e1} & index into E of edge collpased on left \\
\hline
\mbox{\texttt{ out}}  & {\em e2} & index into E of edge collpased on right \\
\hline
\mbox{\texttt{ out}}  & {\em f1} & index into F of face collpased on left \\
\hline
\mbox{\texttt{ out}}  & {\em f2} & index into F of face collpased on right \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if edge was collapsed 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a2382e1bd40b951c6f6c14da9773f2fea}\label{namespaceigl_a2382e1bd40b951c6f6c14da9773f2fea} 
\index{igl@{igl}!collapse\_edge@{collapse\_edge}}
\index{collapse\_edge@{collapse\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_edge()}{collapse\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily bool igl\+::collapse\+\_\+edge (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const Eigen\+::\+Row\+Vector\+Xd \&}]{p,  }\item[{std\+::vector$<$ int $>$ \&}]{Nsv,  }\item[{const std\+::vector$<$ int $>$ \&}]{Nsf,  }\item[{std\+::vector$<$ int $>$ \&}]{Ndv,  }\item[{const std\+::vector$<$ int $>$ \&}]{Ndf,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{int \&}]{e1,  }\item[{int \&}]{e2,  }\item[{int \&}]{f1,  }\item[{int \&}]{f2 }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Nsv} & \#\+Nsv vertex circulation around s (see circulation) \\
\hline
\mbox{\texttt{ in}}  & {\em Nsf} & \#\+Nsf face circulation around s \\
\hline
\mbox{\texttt{ in}}  & {\em Ndv} & \#\+Ndv vertex circulation around d \\
\hline
\mbox{\texttt{ in}}  & {\em Ndf} & \#\+Ndf face circulation around d \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a43afe015e0827032a90d6a916c223b2f}\label{namespaceigl_a43afe015e0827032a90d6a916c223b2f} 
\index{igl@{igl}!collapse\_edge@{collapse\_edge}}
\index{collapse\_edge@{collapse\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_edge()}{collapse\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily bool igl\+::collapse\+\_\+edge (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const Eigen\+::\+Row\+Vector\+Xd \&}]{p,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a943c00b18c9d77e42372a02ac5429bd0}\label{namespaceigl_a943c00b18c9d77e42372a02ac5429bd0} 
\index{igl@{igl}!collapse\_edge@{collapse\_edge}}
\index{collapse\_edge@{collapse\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_edge()}{collapse\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily bool igl\+::collapse\+\_\+edge (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&}]{pre\+\_\+collapse,  }\item[{const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&}]{post\+\_\+collapse,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{\mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&}]{Q,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EQ,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{int \&}]{e,  }\item[{int \&}]{e1,  }\item[{int \&}]{e2,  }\item[{int \&}]{f1,  }\item[{int \&}]{f2 }\end{DoxyParamCaption})}



Collapse least-\/cost edge from a priority queue and update queue. 

See \doxylink{decimate_8h}{decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cost\+\_\+and\+\_\+placement} & function computing cost of collapsing an edge and 3d position where it should be placed\+: cost\+\_\+and\+\_\+placement(\+V,\+F,\+E,\+EMAP,\+EF,\+EI,cost,placement); {\bfseries{If the edges is collapsed}} then this function will be called on all edges of all faces previously incident on the endpoints of the collapsed edge. \\
\hline
\mbox{\texttt{ in}}  & {\em pre\+\_\+collapse} & callback called with index of edge whose collapse is about to be attempted. This function should return whether to {\bfseries{proceed}} with the collapse\+: returning true means "{}yes, try to collapse"{}, returning false means "{}\+No, consider this edge \textquotesingle{}uncollapsable\textquotesingle{}, behave     as if collapse\+\_\+edge(e) returned false. @param \mbox{[}in\mbox{]} post\+\_\+collapse  callback called with index of edge whose collapse was     just attempted and a flag revealing whether this was successful. @param \mbox{[}in,out\mbox{]} V  \#\+V by dim list of vertex positions, lesser index of E(e,\+:) will be set     to midpoint of edge. @param \mbox{[}in,out\mbox{]} F  \#\+F by 3 list of face indices into V. @param \mbox{[}in,out\mbox{]} E  \#\+E by 2 list of edge indices into V. @param \mbox{[}in,out\mbox{]} EMAP \#\+F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique     unique edge in E @param \mbox{[}in,out\mbox{]} EF  \#\+E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/$>$j) is the edge of     F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1)     e=(j-\/$>$i) @param \mbox{[}in,out\mbox{]} EI  \#\+E by 2 list of edge flap corners (see above). @param \mbox{[}in\mbox{]} Q  queue containing pairs of costs and edge indices and insertion "{}time"{} @param \mbox{[}in\mbox{]} EQ  \#\+E list of "{}time"{} of last time pushed into Q \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#E by dim list of stored placements \\
\hline
\mbox{\texttt{ out}}  & {\em e} & index into E of attempted collapsed edge. Set to -\/1 if Q is empty or contains only infinite cost edges. \\
\hline
\mbox{\texttt{ out}}  & {\em e1} & index into E of edge collpased on left. \\
\hline
\mbox{\texttt{ out}}  & {\em e2} & index into E of edge collpased on right. \\
\hline
\mbox{\texttt{ out}}  & {\em f1} & index into F of face collpased on left. \\
\hline
\mbox{\texttt{ out}}  & {\em f2} & index into F of face collpased on right. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a134e573db7b2488d9118ebcf88419f62}\label{namespaceigl_a134e573db7b2488d9118ebcf88419f62} 
\index{igl@{igl}!collapse\_edge@{collapse\_edge}}
\index{collapse\_edge@{collapse\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_edge()}{collapse\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily bool igl\+::collapse\+\_\+edge (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{\mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&}]{Q,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EQ,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a16f5c61d84a3d91b0e701df01c97c26c}\label{namespaceigl_a16f5c61d84a3d91b0e701df01c97c26c} 
\index{igl@{igl}!collapse\_edge@{collapse\_edge}}
\index{collapse\_edge@{collapse\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_edge()}{collapse\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily bool igl\+::collapse\+\_\+edge (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&}]{pre\+\_\+collapse,  }\item[{const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&}]{post\+\_\+collapse,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{\mbox{\hyperlink{namespaceigl_acd3e0aca98df4cd1576aecb262342dbf}{igl\+::min\+\_\+heap}}$<$ std\+::tuple$<$ double, int, int $>$ $>$ \&}]{Q,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EQ,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6b31209f04c3bbfb3e3e54836c60d21f}\label{namespaceigl_a6b31209f04c3bbfb3e3e54836c60d21f} 
\index{igl@{igl}!collapse\_small\_triangles@{collapse\_small\_triangles}}
\index{collapse\_small\_triangles@{collapse\_small\_triangles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{collapse\_small\_triangles()}{collapse\_small\_triangles()}}
{\footnotesize\ttfamily void igl\+::collapse\+\_\+small\+\_\+triangles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const double}]{eps,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{FF }\end{DoxyParamCaption})}



Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. 

We are {\itshape not} following the rules in "{}\+Mesh Optimization"{} \mbox{[}Hoppe et al\mbox{]} Section 4.\+2. But for our purposes we don\textquotesingle{}t care about this criteria.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em eps} & epsilon for smallest allowed area treated as fraction of squared bounding box diagonal \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#\+FF by 3 list of triangle indices into V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3b87a97bec71e27b622eadb0ba9314ea}\label{namespaceigl_a3b87a97bec71e27b622eadb0ba9314ea} 
\index{igl@{igl}!colon@{colon}}
\index{colon@{colon}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colon()}{colon()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename L , typename S , typename H , typename T $>$ \\
void igl\+::colon (\begin{DoxyParamCaption}\item[{const L}]{low,  }\item[{const S}]{step,  }\item[{const H}]{hi,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&}]{I }\end{DoxyParamCaption})}



Colon operator like matlab\textquotesingle{}s colon operator. 

Enumerates values between low and hi with step step.


\begin{DoxyTemplParams}{Template Parameters}
{\em L} & should be a eigen matrix primitive type like int or double \\
\hline
{\em S} & should be a eigen matrix primitive type like int or double \\
\hline
{\em H} & should be a eigen matrix primitive type like int or double \\
\hline
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em low} & starting value if step is valid then this is {\itshape always} the first element of I \\
\hline
\mbox{\texttt{ in}}  & {\em step} & step difference between sequential elements returned in I, remember this will be cast to template T at compile time. If low\texorpdfstring{$<$}{<}hi then step must be positive. If low\texorpdfstring{$>$}{>}hi then step must be negative. Otherwise I will be set to empty. \\
\hline
\mbox{\texttt{ in}}  & {\em hi} & ending value, if (hi-\/low)step is zero then this will be the last element in I. If step is positive there will be no elements greater than hi, vice versa if hi\texorpdfstring{$<$}{<}low \\
\hline
\mbox{\texttt{ out}}  & {\em I} & list of values from low to hi with step size step\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This should be potentially replaced with eigen\textquotesingle{}s \doxylink{namespaceigl_ae8a4579279c09a298a5988c18f215d33}{Lin\+Spaced()} function
\end{DoxyNote}
If step = 1, it\textquotesingle{}s about 5 times faster to use\+: X = Eigen\+::\+Vector\+Xi\+::\+Lin\+Spaced(n,0,n-\/1); than X = \doxylink{namespaceigl_a3b87a97bec71e27b622eadb0ba9314ea}{igl\+::colon$<$int$>$}(0,n-\/1); \Hypertarget{namespaceigl_af0e3b6d9995f83e6e09df72c562f7dec}\label{namespaceigl_af0e3b6d9995f83e6e09df72c562f7dec} 
\index{igl@{igl}!colon@{colon}}
\index{colon@{colon}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colon()}{colon()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename L , typename H , typename T $>$ \\
void igl\+::colon (\begin{DoxyParamCaption}\item[{const L}]{low,  }\item[{const H}]{hi,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&}]{I }\end{DoxyParamCaption})}



Colon operator like matlab\textquotesingle{}s colon operator. 

Enumerates values between low and hi with unit step.


\begin{DoxyTemplParams}{Template Parameters}
{\em L} & should be a eigen matrix primitive type like int or double \\
\hline
{\em H} & should be a eigen matrix primitive type like int or double \\
\hline
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em low} & starting value if step is valid then this is {\itshape always} the first element of I \\
\hline
\mbox{\texttt{ in}}  & {\em step} & step difference between sequential elements returned in I, remember this will be cast to template T at compile time. If low\texorpdfstring{$<$}{<}hi then step must be positive. If low\texorpdfstring{$>$}{>}hi then step must be negative. Otherwise I will be set to empty. \\
\hline
\mbox{\texttt{ in}}  & {\em hi} & ending value, if (hi-\/low)step is zero then this will be the last element in I. If step is positive there will be no elements greater than hi, vice versa if hi\texorpdfstring{$<$}{<}low \\
\hline
\mbox{\texttt{ out}}  & {\em I} & list of values from low to hi with step size step \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_afcbc9102801940ac0f884e2749ac1113}\label{namespaceigl_afcbc9102801940ac0f884e2749ac1113} 
\index{igl@{igl}!colormap@{colormap}}
\index{colormap@{colormap}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colormap()}{colormap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::colormap (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}}}]{cm,  }\item[{const T}]{f,  }\item[{T \texorpdfstring{$\ast$}{*}}]{rgb }\end{DoxyParamCaption})}



Compute \mbox{[}r,g,b\mbox{]} values of the selected colormap for a given factor f between 0 and 1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em c} & colormap enum \\
\hline
\mbox{\texttt{ in}}  & {\em f} & factor determining color value as if 0 was min and 1 was max \\
\hline
\mbox{\texttt{ out}}  & {\em rgb} & red, green, blue value \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2b414ed243eb5c329d25492c74f0047a}\label{namespaceigl_a2b414ed243eb5c329d25492c74f0047a} 
\index{igl@{igl}!colormap@{colormap}}
\index{colormap@{colormap}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colormap()}{colormap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::colormap (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}}}]{cm,  }\item[{const T}]{f,  }\item[{T \&}]{r,  }\item[{T \&}]{g,  }\item[{T \&}]{b }\end{DoxyParamCaption})}



Compute \mbox{[}r,g,b\mbox{]} values of the selected colormap for a given factor f between 0 and 1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em c} & colormap enum \\
\hline
\mbox{\texttt{ in}}  & {\em f} & factor determining color value as if 0 was min and 1 was max \\
\hline
\mbox{\texttt{ out}}  & {\em r} & red value \\
\hline
\mbox{\texttt{ out}}  & {\em g} & green value \\
\hline
\mbox{\texttt{ out}}  & {\em b} & blue value \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab39d4724e45beaa1e1f8562f0e5e54fd}\label{namespaceigl_ab39d4724e45beaa1e1f8562f0e5e54fd} 
\index{igl@{igl}!colormap@{colormap}}
\index{colormap@{colormap}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colormap()}{colormap()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::colormap (\begin{DoxyParamCaption}\item[{const double}]{palette\mbox{[}256\mbox{]}\mbox{[}3\mbox{]},  }\item[{const T}]{x\+\_\+in,  }\item[{T \&}]{r,  }\item[{T \&}]{g,  }\item[{T \&}]{b }\end{DoxyParamCaption})}



Compute \mbox{[}r,g,b\mbox{]} values of the colormap palette for a given factor f between 0 and 1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em palette} & 256 by 3 array of color values \\
\hline
\mbox{\texttt{ in}}  & {\em x\+\_\+in} & factor determining color value as if 0 was min and 1 was max \\
\hline
\mbox{\texttt{ out}}  & {\em r} & red value \\
\hline
\mbox{\texttt{ out}}  & {\em g} & green value \\
\hline
\mbox{\texttt{ out}}  & {\em b} & blue value \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab3ae915229f4fed51bf2f7df5850aa5b}\label{namespaceigl_ab3ae915229f4fed51bf2f7df5850aa5b} 
\index{igl@{igl}!colormap@{colormap}}
\index{colormap@{colormap}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colormap()}{colormap()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$typename DerivedZ , typename DerivedC $>$ \\
void igl\+::colormap (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}}}]{cm,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{const bool}]{normalize,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute \mbox{[}r,g,b\mbox{]} values of the colormap palette for a given factors between 0 and 1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cm} & selected colormap palette to interpolate from \\
\hline
\mbox{\texttt{ in}}  & {\em Z} & \#Z list of factors \\
\hline
\mbox{\texttt{ in}}  & {\em normalize} & whether to normalize Z to be tightly between \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C by 3 list of rgb colors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a50d9c681c034e001a790a6c31555d429}\label{namespaceigl_a50d9c681c034e001a790a6c31555d429} 
\index{igl@{igl}!colormap@{colormap}}
\index{colormap@{colormap}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{colormap()}{colormap()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename DerivedZ , typename DerivedC $>$ \\
void igl\+::colormap (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_a1b823cd12b22dd7d7c16b36223e68dea}{Color\+Map\+Type}}}]{cm,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{const double}]{min\+\_\+Z,  }\item[{const double}]{max\+\_\+Z,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute \mbox{[}r,g,b\mbox{]} values of the colormap palette for a given factors between {\ttfamily min\+\_\+Z} and {\ttfamily max\+\_\+Z} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cm} & selected colormap palette to interpolate from \\
\hline
\mbox{\texttt{ in}}  & {\em Z} & \#Z list of factors \\
\hline
\mbox{\texttt{ in}}  & {\em min\+\_\+z} & value at "{}0"{} \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+z} & value at "{}1"{} \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C by 3 list of rgb colors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a012bb449a5e1b088fd42ed4eb801391a}\label{namespaceigl_a012bb449a5e1b088fd42ed4eb801391a} 
\index{igl@{igl}!column\_to\_quats@{column\_to\_quats}}
\index{column\_to\_quats@{column\_to\_quats}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{column\_to\_quats()}{column\_to\_quats()}}
{\footnotesize\ttfamily bool igl\+::column\+\_\+to\+\_\+quats (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector\+Xd \&}]{Q,  }\item[{std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{vQ }\end{DoxyParamCaption})}



de-\/"{}\+Columnize"{} a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Q} & n\texorpdfstring{$\ast$}{*}4-\/long list of coefficients \\
\hline
\mbox{\texttt{ out}}  & {\em vQ} & n-\/long list of quaternions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if n\%4!=0 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a2ae4ea0e51288d468b77d2303f7b60e5}\label{namespaceigl_a2ae4ea0e51288d468b77d2303f7b60e5} 
\index{igl@{igl}!columnize@{columnize}}
\index{columnize@{columnize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{columnize()}{columnize()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB $>$ \\
void igl\+::columnize (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const int}]{k,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



"{}\+Columnize"{} a stack of block matrices. 

If A = \mbox{[}A1,A2,A3,...,Ak\mbox{]} with each A\texorpdfstring{$\ast$}{*} an m by n block then this produces the column vector whose entries are B(j\texorpdfstring{$\ast$}{*}m\texorpdfstring{$\ast$}{*}k+i\texorpdfstring{$\ast$}{*}k+b) = A(i,b\texorpdfstring{$\ast$}{*}n+j); or if A = \mbox{[}A1;A2;...;Ak\mbox{]} then B(j\texorpdfstring{$\ast$}{*}m\texorpdfstring{$\ast$}{*}k+i\texorpdfstring{$\ast$}{*}k+b) = A(i+b\texorpdfstring{$\ast$}{*}m,j);


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m\texorpdfstring{$\ast$}{*}k by n (dim\+: 1) or m by n\texorpdfstring{$\ast$}{*}k (dim\+: 2) eigen Matrix of type T values \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of blocks \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension in which blocks are stacked \\
\hline
\mbox{\texttt{ out}}  & {\em B} & m\texorpdfstring{$\ast$}{*}n\texorpdfstring{$\ast$}{*}k eigen vector of type T values,\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a5fa327db1af41a1e29e474981b963409}{transpose\+\_\+blocks} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a42d3578aca0da0bea74041ca2b239c1d}\label{namespaceigl_a42d3578aca0da0bea74041ca2b239c1d} 
\index{igl@{igl}!comb\_cross\_field@{comb\_cross\_field}}
\index{comb\_cross\_field@{comb\_cross\_field}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{comb\_cross\_field()}{comb\_cross\_field()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::comb\+\_\+cross\+\_\+field (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD1in,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD2in,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{PD1out,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{PD2out }\end{DoxyParamCaption})}



Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 4 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em PD1in} & \#F by 3 eigen Matrix of the first per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em PD2in} & \#F by 3 eigen Matrix of the second per face cross field vector \\
\hline
\mbox{\texttt{ out}}  & {\em PD1out} & \#F by 3 eigen Matrix of the first combed cross field vector \\
\hline
\mbox{\texttt{ out}}  & {\em PD2out} & \#F by 3 eigen Matrix of the second combed cross field vector \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a406fa0cb0c3fafe5a7b06e31ba757329}\label{namespaceigl_a406fa0cb0c3fafe5a7b06e31ba757329} 
\index{igl@{igl}!comb\_frame\_field@{comb\_frame\_field}}
\index{comb\_frame\_field@{comb\_frame\_field}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{comb\_frame\_field()}{comb\_frame\_field()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP $>$ \\
void igl\+::comb\+\_\+frame\+\_\+field (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{PD1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{PD2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{BIS1\+\_\+combed,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{BIS2\+\_\+combed,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{PD1\+\_\+combed,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{PD2\+\_\+combed }\end{DoxyParamCaption})}



Computes principal matchings of the vectors of a frame field across face edges, and generates a combed frame field defined on the mesh faces. 

This makes use of a combed cross field generated by combing the field created by the bisectors of the frame field.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 4 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em PD1} & \#F by 3 eigen Matrix of the first per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em PD2} & \#F by 3 eigen Matrix of the second per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em BIS1\+\_\+combed} & \#F by 3 eigen Matrix of the first combed bisector field vector \\
\hline
\mbox{\texttt{ in}}  & {\em BIS2\+\_\+combed} & \#F by 3 eigen Matrix of the second combed bisector field vector \\
\hline
\mbox{\texttt{ out}}  & {\em PD1\+\_\+combed} & \#F by 3 eigen Matrix of the first combed cross field vector \\
\hline
\mbox{\texttt{ out}}  & {\em PD2\+\_\+combed} & \#F by 3 eigen Matrix of the second combed cross field vector \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a702a263c5565f41ca8e4585619b746f7}\label{namespaceigl_a702a263c5565f41ca8e4585619b746f7} 
\index{igl@{igl}!comb\_line\_field@{comb\_line\_field}}
\index{comb\_line\_field@{comb\_line\_field}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{comb\_line\_field()}{comb\_line\_field()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::comb\+\_\+line\+\_\+field (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD1in,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{PD1out }\end{DoxyParamCaption})}



Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 4 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em PD1in} & \#F by 3 eigen Matrix of the first per face cross field vector \\
\hline
\mbox{\texttt{ out}}  & {\em PD1out} & \#F by 3 eigen Matrix of the first combed cross field vector \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_add396b23f15d16510156bfa839f58661}\label{namespaceigl_add396b23f15d16510156bfa839f58661} 
\index{igl@{igl}!combine@{combine}}
\index{combine@{combine}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{combine()}{combine()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+VV , typename Derived\+FF , typename DerivedV , typename DerivedF , typename Derived\+Vsizes , typename Derived\+Fsizes $>$ \\
void igl\+::combine (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Derived\+VV $>$ \&}]{VV,  }\item[{const std\+::vector$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Vsizes $>$ \&}]{Vsizes,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Fsizes $>$ \&}]{Fsizes }\end{DoxyParamCaption})}



Concatenate k meshes into a single \texorpdfstring{$>$}{>}=k connected component mesh with a single vertex list and face list. 

Similar to Maya\textquotesingle{}s Combine operation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VV} & k-\/long list of lists of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em FF} & k-\/long list of lists of mesh face indices so that FF\mbox{[}i\mbox{]} indexes VV\mbox{[}i\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em V} & VV\mbox{[}0\mbox{]}.rows()+...+VV\mbox{[}k-\/1\mbox{]}.rows() by VV\mbox{[}0\mbox{]}.cols() list of mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & FF\mbox{[}0\mbox{]}.rows()+...+FF\mbox{[}k-\/1\mbox{]}.rows() by FF\mbox{[}0\mbox{]}.cols() list of mesh faces indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em Vsizes} & k list so that Vsizes(i) is the \#vertices in the ith input \\
\hline
\mbox{\texttt{ out}}  & {\em Fsizes} & k list so that Fsizes(i) is the \#faces in the ith input\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md5}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md5}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Suppose\ you\ have\ mesh\ A\ (VA,FA)\ and\ mesh\ B\ (VB,FB)}}
\DoxyCodeLine{igl::combine<Eigen::MatrixXd,Eigen::MatrixXi>(\{VA,VB\},\{FA,FB\},V,F);}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a75f28ec0548f636eb6dc9551eca554bc}\label{namespaceigl_a75f28ec0548f636eb6dc9551eca554bc} 
\index{igl@{igl}!combine@{combine}}
\index{combine@{combine}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{combine()}{combine()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+VV , typename Derived\+FF , typename DerivedV , typename DerivedF $>$ \\
void igl\+::combine (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Derived\+VV $>$ \&}]{VV,  }\item[{const std\+::vector$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ab190df5efbd072173791f9ae36b0c58c}\label{namespaceigl_ab190df5efbd072173791f9ae36b0c58c} 
\index{igl@{igl}!compute\_frame\_field\_bisectors@{compute\_frame\_field\_bisectors}}
\index{compute\_frame\_field\_bisectors@{compute\_frame\_field\_bisectors}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{compute\_frame\_field\_bisectors()}{compute\_frame\_field\_bisectors()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::compute\+\_\+frame\+\_\+field\+\_\+bisectors (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{B1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{B2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{BIS1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{BIS2 }\end{DoxyParamCaption})}



Compute bisectors of a frame field defined on mesh faces. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ in}}  & {\em B1} & \#F by 3 eigen Matrix of face (triangle) base vector 1 \\
\hline
\mbox{\texttt{ in}}  & {\em B2} & \#F by 3 eigen Matrix of face (triangle) base vector 2 \\
\hline
\mbox{\texttt{ in}}  & {\em PD1} & \#F by 3 eigen Matrix of the first per face frame field vector \\
\hline
\mbox{\texttt{ in}}  & {\em PD2} & \#F by 3 eigen Matrix of the second per face frame field vector \\
\hline
\mbox{\texttt{ out}}  & {\em BIS1} & \#F by 3 eigen Matrix of the first per face frame field bisector \\
\hline
\mbox{\texttt{ out}}  & {\em BIS2} & \#F by 3 eigen Matrix of the second per face frame field bisector\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a062b8f100ec84d5b9dfc68558f6e3e0b}\label{namespaceigl_a062b8f100ec84d5b9dfc68558f6e3e0b} 
\index{igl@{igl}!compute\_frame\_field\_bisectors@{compute\_frame\_field\_bisectors}}
\index{compute\_frame\_field\_bisectors@{compute\_frame\_field\_bisectors}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{compute\_frame\_field\_bisectors()}{compute\_frame\_field\_bisectors()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::compute\+\_\+frame\+\_\+field\+\_\+bisectors (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{BIS1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{BIS2 }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6c8cf9368d76d69d41ea95bc5b4fd13b}\label{namespaceigl_a6c8cf9368d76d69d41ea95bc5b4fd13b} 
\index{igl@{igl}!connect\_boundary\_to\_infinity@{connect\_boundary\_to\_infinity}}
\index{connect\_boundary\_to\_infinity@{connect\_boundary\_to\_infinity}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{connect\_boundary\_to\_infinity()}{connect\_boundary\_to\_infinity()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+FO $>$ \\
void igl\+::connect\+\_\+boundary\+\_\+to\+\_\+infinity (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FO $>$ \&}]{FO }\end{DoxyParamCaption})}



Connect all boundary edges to a fictitious point at infinity. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into some V \\
\hline
\mbox{\texttt{ out}}  & {\em FO} & \#F+\#O by 3 list of face indices into \mbox{[}V;inf inf inf\mbox{]}, original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-\/manifold vertex at infinity (but it will be edge-\/manifold). \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_abb409818f72dece08eaa0c0f71d5b2e9}\label{namespaceigl_abb409818f72dece08eaa0c0f71d5b2e9} 
\index{igl@{igl}!connect\_boundary\_to\_infinity@{connect\_boundary\_to\_infinity}}
\index{connect\_boundary\_to\_infinity@{connect\_boundary\_to\_infinity}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{connect\_boundary\_to\_infinity()}{connect\_boundary\_to\_infinity()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+FO $>$ \\
void igl\+::connect\+\_\+boundary\+\_\+to\+\_\+infinity (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+F\+::\+Scalar}]{inf\+\_\+index,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FO $>$ \&}]{FO }\end{DoxyParamCaption})}



Connect all boundary edges to a fictitious point at infinity. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into some V \\
\hline
\mbox{\texttt{ in}}  & {\em inf\+\_\+index} & index of point at infinity (usually V.\+rows() or F.\+max\+Coeff()) \\
\hline
\mbox{\texttt{ out}}  & {\em FO} & \#F+\#O by 3 list of face indices into \mbox{[}V;inf inf inf\mbox{]}, original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-\/manifold vertex at infinity (but it will be edge-\/manifold). \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1d651ddb82e5e25cc25fbab3813190da}\label{namespaceigl_a1d651ddb82e5e25cc25fbab3813190da} 
\index{igl@{igl}!connect\_boundary\_to\_infinity@{connect\_boundary\_to\_infinity}}
\index{connect\_boundary\_to\_infinity@{connect\_boundary\_to\_infinity}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{connect\_boundary\_to\_infinity()}{connect\_boundary\_to\_infinity()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VO , typename Derived\+FO $>$ \\
void igl\+::connect\+\_\+boundary\+\_\+to\+\_\+infinity (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VO $>$ \&}]{VO,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FO $>$ \&}]{FO }\end{DoxyParamCaption})}



Connect all boundary edges to a fictitious point at infinity. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into some V \\
\hline
\mbox{\texttt{ out}}  & {\em VO} & \#V+1 by 3 list of vertex positions, original V are guaranteed to come first. Last point is inf, inf, inf \\
\hline
\mbox{\texttt{ out}}  & {\em FO} & \#F+\#O by 3 list of face indices into VO \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad493c0508f1454ae875031906899d4de}\label{namespaceigl_ad493c0508f1454ae875031906899d4de} 
\index{igl@{igl}!connected\_components@{connected\_components}}
\index{connected\_components@{connected\_components}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{connected\_components()}{connected\_components()}}
{\footnotesize\ttfamily template$<$typename Atype , typename DerivedC , typename DerivedK $>$ \\
int igl\+::connected\+\_\+components (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ Atype $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Determine the connected components of a graph described by the input adjacency matrix (similar to MATLAB\textquotesingle{}s graphconncomp or gptoolbox\textquotesingle{}s conncomp, but A is transposed for unsymmetric graphs). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#A by \#A adjacency matrix (treated as describing an directed graph) \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#A list of component indices into \mbox{[}0,\#K-\/1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#K list of sizes of each component \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of connected components 
\end{DoxyReturn}
\Hypertarget{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}\label{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9} 
\index{igl@{igl}!cotmatrix@{cotmatrix}}
\index{cotmatrix@{cotmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cotmatrix()}{cotmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
void igl\+::cotmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{L }\end{DoxyParamCaption})}



Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,F). 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived type of eigen matrix for V (e.\+g. derived from Matrix\+Xd) \\
\hline
{\em DerivedF} & derived type of eigen matrix for F (e.\+g. derived from Matrix\+Xi) \\
\hline
{\em Scalar} & scalar type for eigen sparse matrix (e.\+g. double) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh elements (triangles or tetrahedra) \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#V by \#V cotangent matrix, each row i corresponding to V(i,\+:)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a705a8f51137d1dd807bbe517c0567735}{adjacency\+\_\+matrix}
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
This Laplacian uses the convention that diagonal entries are {\bfseries{minus}} the sum of off-\/diagonal entries. The diagonal entries are therefore in general negative and the matrix is {\bfseries{negative}} semi-\/definite (immediately, -\/L is {\bfseries{positive}} semi-\/definite) 
\end{DoxyNote}
\Hypertarget{namespaceigl_a42d5463d31cf82b23668e9680975301a}\label{namespaceigl_a42d5463d31cf82b23668e9680975301a} 
\index{igl@{igl}!cotmatrix@{cotmatrix}}
\index{cotmatrix@{cotmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cotmatrix()}{cotmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedI , typename DerivedC , typename Scalar $>$ \\
void igl\+::cotmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{L,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{M,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{P }\end{DoxyParamCaption})}



Cotangent Laplacian (and mass matrix) for polygon meshes according to "{}\+Polygon Laplacian Made Simple"{} \mbox{[}Bunge et al. 2020\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#polygons+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#V by \#V polygon Laplacian made simple matrix \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#V by \#V mass matrix \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#V+\#polygons by \#V prolongation operator \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4c5e7ebbe20f12078dc576d644935f83}\label{namespaceigl_a4c5e7ebbe20f12078dc576d644935f83} 
\index{igl@{igl}!cotmatrix\_entries@{cotmatrix\_entries}}
\index{cotmatrix\_entries@{cotmatrix\_entries}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cotmatrix\_entries()}{cotmatrix\_entries()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ \\
void igl\+::cotmatrix\+\_\+entries (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute the cotmatrix contributions (cotangents) of each angle in mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of rest domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by \{3\texorpdfstring{$\vert$}{|}4\} list of \{triangle\texorpdfstring{$\vert$}{|}tetrahedra\} indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#F by 3 list of 1/2\texorpdfstring{$\ast$}{*}cotangents corresponding angles for triangles, columns correspond to edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]} or C \#F by 6 list of 1/6\texorpdfstring{$\ast$}{*}cotangents of dihedral angles\texorpdfstring{$\ast$}{*}edge lengths for tets, columns along edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]},\mbox{[}3,0\mbox{]},\mbox{[}3,1\mbox{]},\mbox{[}3,2\mbox{]}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a01189493d30a0e8a2cbd6e053641545f}\label{namespaceigl_a01189493d30a0e8a2cbd6e053641545f} 
\index{igl@{igl}!cotmatrix\_entries@{cotmatrix\_entries}}
\index{cotmatrix\_entries@{cotmatrix\_entries}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cotmatrix\_entries()}{cotmatrix\_entries()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedC $>$ \\
void igl\+::cotmatrix\+\_\+entries (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute the cotmatrix contributions (cotangents) of each angle in mesh with edge lengths (l) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#F by 3 list of triangle edge lengths (see edge\+\_\+lengths) \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#F by 3 list of 1/2\texorpdfstring{$\ast$}{*}cotangents corresponding angles for triangles, columns correspond to edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ae47d4dd3239dba392f54b8dc3f62e8dd}\label{namespaceigl_ae47d4dd3239dba392f54b8dc3f62e8dd} 
\index{igl@{igl}!cotmatrix\_intrinsic@{cotmatrix\_intrinsic}}
\index{cotmatrix\_intrinsic@{cotmatrix\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cotmatrix\_intrinsic()}{cotmatrix\_intrinsic()}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedF , typename Scalar $>$ \\
void igl\+::cotmatrix\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{L }\end{DoxyParamCaption})}



Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh with faces F and edge lengths l. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#F by 3 list of (half-\/)edge lengths \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into some (not necessarily determined/embedable) list of vertex positions V. It is assumed \#V == F.\+max\+Coeff()+1 \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#V by \#V sparse Laplacian matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix}, \doxylink{namespaceigl_a6173f608f5bae73866cc21f0159562dc}{intrinsic\+\_\+delaunay\+\_\+cotmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a83819bb842f4bc4c8af21a98e1db44b3}\label{namespaceigl_a83819bb842f4bc4c8af21a98e1db44b3} 
\index{igl@{igl}!count@{count}}
\index{count@{count}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{count()}{count()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename XType , typename SType $>$ \\
void igl\+::count (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Sparse\+Vector$<$ SType $>$ \&}]{S }\end{DoxyParamCaption})}



Count the number of non-\/zeros in the columns or rows of a sparse matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to sum (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & n-\/long {\itshape sparse} vector (if dim == 1) or m-\/long sparse vector (if dim == 2)\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If your looking for dense matrix matlab like sum for eigen matrics just use\+: M.\+colwise().\doxylink{namespaceigl_a83819bb842f4bc4c8af21a98e1db44b3}{count()} or M.\+rowwise().\doxylink{namespaceigl_a83819bb842f4bc4c8af21a98e1db44b3}{count()} 
\end{DoxyNote}
\Hypertarget{namespaceigl_a91399ecb01f4828dbe0b5d3e9c51a73b}\label{namespaceigl_a91399ecb01f4828dbe0b5d3e9c51a73b} 
\index{igl@{igl}!count@{count}}
\index{count@{count}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{count()}{count()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename XType , typename DerivedS $>$ \\
void igl\+::count (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Outputs a dense vector. \Hypertarget{namespaceigl_a566bead6b8810ca47f10d8e0b184c2ab}\label{namespaceigl_a566bead6b8810ca47f10d8e0b184c2ab} 
\index{igl@{igl}!covariance\_scatter\_matrix@{covariance\_scatter\_matrix}}
\index{covariance\_scatter\_matrix@{covariance\_scatter\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{covariance\_scatter\_matrix()}{covariance\_scatter\_matrix()}}
{\footnotesize\ttfamily void igl\+::covariance\+\_\+scatter\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{ARAPEnergy\+Type}}}]{energy,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{CSM }\end{DoxyParamCaption})}



Construct the covariance scatter matrix for a given arap energy. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by Vdim list of initial domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em energy} & ARAPEnergy\+Type enum value defining which energy is being used. See \doxylink{ARAPEnergyType_8h}{ARAPEnergy\+Type.\+h} for valid options and explanations. \\
\hline
\mbox{\texttt{ out}}  & {\em CSM} & dim\texorpdfstring{$\ast$}{*}\#V/\#F by dim\texorpdfstring{$\ast$}{*}\#V sparse matrix containing special laplacians along the diagonal so that when multiplied by V gives covariance matrix elements, can be used to speed up covariance matrix computation\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ae1324ec871ee5fe0f3d6fa9b461ced93}{arap\+\_\+linear\+\_\+block}, arap, \doxylink{namespaceigl_afcbc9001656cf2d4cc135602618c97e5}{ARAPEnergy\+Type} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a9a8762cbd164779fc2b875dd73ab70d0}\label{namespaceigl_a9a8762cbd164779fc2b875dd73ab70d0} 
\index{igl@{igl}!cr\_vector\_curvature\_correction@{cr\_vector\_curvature\_correction}}
\index{cr\_vector\_curvature\_correction@{cr\_vector\_curvature\_correction}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_curvature\_correction()}{cr\_vector\_curvature\_correction()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ \\
void igl\+::cr\+\_\+vector\+\_\+curvature\+\_\+correction (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&}]{K }\end{DoxyParamCaption})}



Computes the vector Crouzeix-\/\+Raviart curvature correction term of Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. 

"{}\+A Smoothness Energy without Boundary Distortion for  Curved Surfaces"{}, but using the basis functions by Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "{}\+A Simple Discretization of the Vector Dirichlet Energy"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 4 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient\+\_\+halfedges. will be computed if not provided. \\
\hline
\mbox{\texttt{ out}}  & {\em K} & 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} by 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} computed curvature correction matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aeca2a3d390d85a9432843e481cc1b2ca}\label{namespaceigl_aeca2a3d390d85a9432843e481cc1b2ca} 
\index{igl@{igl}!cr\_vector\_curvature\_correction@{cr\_vector\_curvature\_correction}}
\index{cr\_vector\_curvature\_correction@{cr\_vector\_curvature\_correction}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_curvature\_correction()}{cr\_vector\_curvature\_correction()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ \\
void igl\+::cr\+\_\+vector\+\_\+curvature\+\_\+correction (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&}]{K }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

{\ttfamily E} and {\ttfamily oE} are computed and output. \Hypertarget{namespaceigl_a8e4ef6fb71a86a0dc23499f0d2859578}\label{namespaceigl_a8e4ef6fb71a86a0dc23499f0d2859578} 
\index{igl@{igl}!cr\_vector\_curvature\_correction\_intrinsic@{cr\_vector\_curvature\_correction\_intrinsic}}
\index{cr\_vector\_curvature\_correction\_intrinsic@{cr\_vector\_curvature\_correction\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_curvature\_correction\_intrinsic()}{cr\_vector\_curvature\_correction\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename Derivedtheta , typename Derivedkappa , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ \\
void igl\+::cr\+\_\+vector\+\_\+curvature\+\_\+correction\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedtheta $>$ \&}]{theta,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedkappa $>$ \&}]{kappa,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&}]{K }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

intrinsic version.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l\+\_\+sq} & \#F by 3 list of squared edge lengths of each halfedge \\
\hline
\mbox{\texttt{ in}}  & {\em theta} & \#F by 3 list of the tip angles at each halfedge \\
\hline
\mbox{\texttt{ in}}  & {\em kappa} & \#V by 1 list of the Gaussian curvature at each vertex\\
\hline
\end{DoxyParams}
\doxylink{cr__vector__curvature__correction_8h}{include/igl/cr\+\_\+vector\+\_\+curvature\+\_\+correction.\+h} \Hypertarget{namespaceigl_a9522053349c7920e8399af8da638720d}\label{namespaceigl_a9522053349c7920e8399af8da638720d} 
\index{igl@{igl}!cr\_vector\_curvature\_correction\_intrinsic@{cr\_vector\_curvature\_correction\_intrinsic}}
\index{cr\_vector\_curvature\_correction\_intrinsic@{cr\_vector\_curvature\_correction\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_curvature\_correction\_intrinsic()}{cr\_vector\_curvature\_correction\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ \\
void igl\+::cr\+\_\+vector\+\_\+curvature\+\_\+correction\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&}]{K }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{cr__vector__curvature__correction_8h}{include/igl/cr\+\_\+vector\+\_\+curvature\+\_\+correction.\+h}. 

\Hypertarget{namespaceigl_a27d76cb9c1bfa1cc13c9bc19f4bcbdc8}\label{namespaceigl_a27d76cb9c1bfa1cc13c9bc19f4bcbdc8} 
\index{igl@{igl}!cr\_vector\_curvature\_correction\_intrinsic@{cr\_vector\_curvature\_correction\_intrinsic}}
\index{cr\_vector\_curvature\_correction\_intrinsic@{cr\_vector\_curvature\_correction\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_curvature\_correction\_intrinsic()}{cr\_vector\_curvature\_correction\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename Derivedtheta , typename DerivedE , typename Derived\+OE , typename ScalarK $>$ \\
void igl\+::cr\+\_\+vector\+\_\+curvature\+\_\+correction\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedtheta $>$ \&}]{theta,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarK $>$ \&}]{K }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{cr__vector__curvature__correction_8h}{include/igl/cr\+\_\+vector\+\_\+curvature\+\_\+correction.\+h}. 

\Hypertarget{namespaceigl_ad3b4cd87c1b79a3e8220217907e2f92d}\label{namespaceigl_ad3b4cd87c1b79a3e8220217907e2f92d} 
\index{igl@{igl}!cr\_vector\_laplacian@{cr\_vector\_laplacian}}
\index{cr\_vector\_laplacian@{cr\_vector\_laplacian}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_laplacian()}{cr\_vector\_laplacian()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ \\
void igl\+::cr\+\_\+vector\+\_\+laplacian (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&}]{L }\end{DoxyParamCaption})}



Computes the CR vector Laplacian matrix. 

See Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "{}\+A Simple Discretization of the Vector Dirichlet Energy"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient\+\_\+halfedges. will be computed if not provided. \\
\hline
\mbox{\texttt{ out}}  & {\em L} & 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} by 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} computed Laplacian matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6cc88ca84e384cf6d28d2fc8a0f9bebf}\label{namespaceigl_a6cc88ca84e384cf6d28d2fc8a0f9bebf} 
\index{igl@{igl}!cr\_vector\_laplacian@{cr\_vector\_laplacian}}
\index{cr\_vector\_laplacian@{cr\_vector\_laplacian}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_laplacian()}{cr\_vector\_laplacian()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ \\
void igl\+::cr\+\_\+vector\+\_\+laplacian (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&}]{L }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

{\ttfamily E} and {\ttfamily oE} are computed and output. \Hypertarget{namespaceigl_a7a2c2b7f03004fbcca3d3fa8f4fef60f}\label{namespaceigl_a7a2c2b7f03004fbcca3d3fa8f4fef60f} 
\index{igl@{igl}!cr\_vector\_laplacian\_intrinsic@{cr\_vector\_laplacian\_intrinsic}}
\index{cr\_vector\_laplacian\_intrinsic@{cr\_vector\_laplacian\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_laplacian\_intrinsic()}{cr\_vector\_laplacian\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DeriveddA , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ \\
void igl\+::cr\+\_\+vector\+\_\+laplacian\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&}]{dA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&}]{L }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

intrinsic version.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l\+\_\+sq} & \#F by 3 list of squared edge lengths of each halfedge \\
\hline
\mbox{\texttt{ in}}  & {\em dA} & \#F list of double areas\\
\hline
\end{DoxyParams}
\doxylink{cr__vector__laplacian_8h}{include/igl/cr\+\_\+vector\+\_\+laplacian.\+h} \Hypertarget{namespaceigl_a74c1a4348f8eeba501dac71ffe89a71c}\label{namespaceigl_a74c1a4348f8eeba501dac71ffe89a71c} 
\index{igl@{igl}!cr\_vector\_laplacian\_intrinsic@{cr\_vector\_laplacian\_intrinsic}}
\index{cr\_vector\_laplacian\_intrinsic@{cr\_vector\_laplacian\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_laplacian\_intrinsic()}{cr\_vector\_laplacian\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarL $>$ \\
void igl\+::cr\+\_\+vector\+\_\+laplacian\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarL $>$ \&}]{L }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{cr__vector__laplacian_8h}{include/igl/cr\+\_\+vector\+\_\+laplacian.\+h}. 

\Hypertarget{namespaceigl_adb956da2f2c2355242b2c267b86d8fea}\label{namespaceigl_adb956da2f2c2355242b2c267b86d8fea} 
\index{igl@{igl}!cr\_vector\_mass@{cr\_vector\_mass}}
\index{cr\_vector\_mass@{cr\_vector\_mass}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_mass()}{cr\_vector\_mass()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM $>$ \\
void igl\+::cr\+\_\+vector\+\_\+mass (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarM $>$ \&}]{M }\end{DoxyParamCaption})}



Computes the CR vector mass matrix, using an arrangement of all parallel degrees of freedom first, and all perpendicular degrees of freedom next. 

See Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "{}\+A Simple Discretization of the Vector Dirichlet Energy"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ out}}  & {\em L} & 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} by 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} computed Mass matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab2dabc69504695d2ad3ea01676bf9353}\label{namespaceigl_ab2dabc69504695d2ad3ea01676bf9353} 
\index{igl@{igl}!cr\_vector\_mass@{cr\_vector\_mass}}
\index{cr\_vector\_mass@{cr\_vector\_mass}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_mass()}{cr\_vector\_mass()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM $>$ \\
void igl\+::cr\+\_\+vector\+\_\+mass (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarM $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

{\ttfamily E} are (possibly?) computed and output. \Hypertarget{namespaceigl_a10ed1159cd7e63e2d4993c501085be42}\label{namespaceigl_a10ed1159cd7e63e2d4993c501085be42} 
\index{igl@{igl}!cr\_vector\_mass\_intrinsic@{cr\_vector\_mass\_intrinsic}}
\index{cr\_vector\_mass\_intrinsic@{cr\_vector\_mass\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cr\_vector\_mass\_intrinsic()}{cr\_vector\_mass\_intrinsic()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DeriveddA , typename DerivedE , typename ScalarM $>$ \\
void igl\+::cr\+\_\+vector\+\_\+mass\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&}]{dA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarM $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

intrinsic version.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dA} & \#F list of double areas\\
\hline
\end{DoxyParams}
\doxylink{cr__vector__mass_8h}{include/igl/cr\+\_\+vector\+\_\+mass.\+h} \Hypertarget{namespaceigl_a8eb65039a597811fba7c59d41d039b4c}\label{namespaceigl_a8eb65039a597811fba7c59d41d039b4c} 
\index{igl@{igl}!cross@{cross}}
\index{cross@{cross}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cross()}{cross()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::cross (\begin{DoxyParamCaption}\item[{const double \texorpdfstring{$\ast$}{*}}]{a,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b,  }\item[{double \texorpdfstring{$\ast$}{*}}]{out }\end{DoxyParamCaption})}



Cross product; out = cross(a,b) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a} & left 3d vector \\
\hline
\mbox{\texttt{ in}}  & {\em b} & right 3d vector \\
\hline
\mbox{\texttt{ out}}  & {\em out} & result 3d vector \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4887506ff673ad3a57ca0697dda4d029}\label{namespaceigl_a4887506ff673ad3a57ca0697dda4d029} 
\index{igl@{igl}!cross@{cross}}
\index{cross@{cross}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cross()}{cross()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC $>$ \\
void igl\+::cross (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Computes rowwise cross product C = cross(\+A,\+B,2);. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#A by 3 list of row-\/vectors \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#A by 3 list of row-\/vectors \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#A by 3 list of row-\/vectors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a916e1792b25fb32f0554288f22dcaa21}\label{namespaceigl_a916e1792b25fb32f0554288f22dcaa21} 
\index{igl@{igl}!cross\_field\_mismatch@{cross\_field\_mismatch}}
\index{cross\_field\_mismatch@{cross\_field\_mismatch}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cross\_field\_mismatch()}{cross\_field\_mismatch()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedM $>$ \\
void igl\+::cross\+\_\+field\+\_\+mismatch (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD2,  }\item[{const bool}]{is\+Combed,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedM $>$ \&}]{mismatch }\end{DoxyParamCaption})}



Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces. 

The integer mismatch is a multiple of pi/2 that transforms the cross on one side of the edge to the cross on the other side. It represents the deviation from a Lie connection across the edge.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em PD1} & \#F by 3 eigen Matrix of the first per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em PD2} & \#F by 3 eigen Matrix of the second per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em is\+Combed} & boolean, specifying whether the field is combed (i.\+e. matching has been precomputed. If not, the field is combed first. \\
\hline
\mbox{\texttt{ out}}  & {\em mismatch} & \#F by 3 eigen Matrix containing the integer mismatch of the cross field across all face edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a528d6ff188e05af669e3369a40562268}\label{namespaceigl_a528d6ff188e05af669e3369a40562268} 
\index{igl@{igl}!crouzeix\_raviart\_cotmatrix@{crouzeix\_raviart\_cotmatrix}}
\index{crouzeix\_raviart\_cotmatrix@{crouzeix\_raviart\_cotmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{crouzeix\_raviart\_cotmatrix()}{crouzeix\_raviart\_cotmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename LT , typename DerivedE , typename Derived\+EMAP $>$ \\
void igl\+::crouzeix\+\_\+raviart\+\_\+cotmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ LT $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



Compute the Crouzeix-\/\+Raviart cotangent stiffness matrix. 

See for example "{}\+Discrete Quadratic Curvature Energies"{} \mbox{[}Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/4 list of triangle/tetrahedron indices \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#E by \#E edge/face-\/based diagonal cotangent matrix \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2/3 list of edges/faces \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3/4 list of indices mapping allE to E\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a1e1d2b58df45ae7555c3719963bb39d6}{crouzeix\+\_\+raviart\+\_\+massmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a0cba460e00e27a7947e2d7d7d569ec04}\label{namespaceigl_a0cba460e00e27a7947e2d7d7d569ec04} 
\index{igl@{igl}!crouzeix\_raviart\_cotmatrix@{crouzeix\_raviart\_cotmatrix}}
\index{crouzeix\_raviart\_cotmatrix@{crouzeix\_raviart\_cotmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{crouzeix\_raviart\_cotmatrix()}{crouzeix\_raviart\_cotmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+EMAP , typename LT $>$ \\
void igl\+::crouzeix\+\_\+raviart\+\_\+cotmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ LT $>$ \&}]{L }\end{DoxyParamCaption})}



Compute the Crouzeix-\/\+Raviart cotangent stiffness matrix. 

See for example "{}\+Discrete Quadratic Curvature Energies"{} \mbox{[}Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/4 list of triangle/tetrahedron indices \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2/3 list of edges/faces \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3/4 list of indices mapping allE to E \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#E by \#E edge/face-\/based diagonal cotangent matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a1e1d2b58df45ae7555c3719963bb39d6}{crouzeix\+\_\+raviart\+\_\+massmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a1e1d2b58df45ae7555c3719963bb39d6}\label{namespaceigl_a1e1d2b58df45ae7555c3719963bb39d6} 
\index{igl@{igl}!crouzeix\_raviart\_massmatrix@{crouzeix\_raviart\_massmatrix}}
\index{crouzeix\_raviart\_massmatrix@{crouzeix\_raviart\_massmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{crouzeix\_raviart\_massmatrix()}{crouzeix\_raviart\_massmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+EMAP $>$ \\
void igl\+::crouzeix\+\_\+raviart\+\_\+massmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ MT $>$ \&}]{M,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



CROUZEIX\+\_\+\+RAVIART\+\_\+\+MASSMATRIX Compute the Crouzeix-\/\+Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e. 

See for example "{}\+Discrete Quadratic Curvature Energies"{} \mbox{[}Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/4 list of triangle/tetrahedron indices \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#E by \#E edge/face-\/based diagonal mass matrix \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2/3 list of edges/faces \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3/4 list of indices mapping allE to E\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a528d6ff188e05af669e3369a40562268}{crouzeix\+\_\+raviart\+\_\+cotmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a4fbcad6ddce4e7c8f209f87f5deb5f81}\label{namespaceigl_a4fbcad6ddce4e7c8f209f87f5deb5f81} 
\index{igl@{igl}!crouzeix\_raviart\_massmatrix@{crouzeix\_raviart\_massmatrix}}
\index{crouzeix\_raviart\_massmatrix@{crouzeix\_raviart\_massmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{crouzeix\_raviart\_massmatrix()}{crouzeix\_raviart\_massmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+EMAP $>$ \\
void igl\+::crouzeix\+\_\+raviart\+\_\+massmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ MT $>$ \&}]{M }\end{DoxyParamCaption})}



CROUZEIX\+\_\+\+RAVIART\+\_\+\+MASSMATRIX Compute the Crouzeix-\/\+Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e. 

See for example "{}\+Discrete Quadratic Curvature Energies"{} \mbox{[}Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/4 list of triangle/tetrahedron indices \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2/3 list of edges/faces \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3/4 list of indices mapping allE to E \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#E by \#E edge/face-\/based diagonal mass matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a528d6ff188e05af669e3369a40562268}{crouzeix\+\_\+raviart\+\_\+cotmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a8115269b075eef2f1c35db347806319d}\label{namespaceigl_a8115269b075eef2f1c35db347806319d} 
\index{igl@{igl}!cumprod@{cumprod}}
\index{cumprod@{cumprod}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cumprod()}{cumprod()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::cumprod (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



Computes a cumulative product of the columns of X, like matlab\textquotesingle{}s {\ttfamily cumprod}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedX} & Type of matrix X \\
\hline
{\em DerivedY} & Type of matrix Y \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n Matrix to be cumulatively multiplied. \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension to take cumulative product (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n Matrix containing cumulative product. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6ad6bf440539af2b6aa5b38ce6d8f4ec}\label{namespaceigl_a6ad6bf440539af2b6aa5b38ce6d8f4ec} 
\index{igl@{igl}!cumsum@{cumsum}}
\index{cumsum@{cumsum}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cumsum()}{cumsum()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::cumsum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



Computes a cumulative sum of the columns of X, like matlab\textquotesingle{}s {\ttfamily cumsum}. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedX} & Type of matrix X \\
\hline
{\em DerivedY} & Type of matrix Y \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n Matrix to be cumulatively summed. \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension to take cumulative sum (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n Matrix containing cumulative sum. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a717f5ffd3d4bc3771bdd7e2e2786bb95}\label{namespaceigl_a717f5ffd3d4bc3771bdd7e2e2786bb95} 
\index{igl@{igl}!cumsum@{cumsum}}
\index{cumsum@{cumsum}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cumsum()}{cumsum()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::cumsum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{const bool}]{zero\+\_\+prefix,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



Computes a cumulative sum of the columns of \mbox{[}0;X\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n Matrix to be cumulatively summed. \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension to take cumulative sum (1 or 2) \\
\hline
\mbox{\texttt{ in}}  & {\em zero\+\_\+prefix} & whether to use zero prefix \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & if zero\+\_\+prefix == false m by n Matrix containing cumulative sum else m+1 by n Matrix containing cumulative sum if dim=1 or m by n+1 Matrix containing cumulative sum if dim=2 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adf8191d83bb2517d430b625c5416988b}\label{namespaceigl_adf8191d83bb2517d430b625c5416988b} 
\index{igl@{igl}!curved\_hessian\_energy@{curved\_hessian\_energy}}
\index{curved\_hessian\_energy@{curved\_hessian\_energy}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{curved\_hessian\_energy()}{curved\_hessian\_energy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename ScalarQ $>$ \\
void igl\+::curved\+\_\+hessian\+\_\+energy (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&}]{Q }\end{DoxyParamCaption})}



Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. 

See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "{}\+A Smoothness Energy without Boundary Distortion for Curved Surfaces"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V Hessian energy matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a805b9c22927ea42f1756d0094e373f9f}\label{namespaceigl_a805b9c22927ea42f1756d0094e373f9f} 
\index{igl@{igl}!curved\_hessian\_energy@{curved\_hessian\_energy}}
\index{curved\_hessian\_energy@{curved\_hessian\_energy}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{curved\_hessian\_energy()}{curved\_hessian\_energy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ \\
void igl\+::curved\+\_\+hessian\+\_\+energy (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&}]{Q }\end{DoxyParamCaption})}



Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. 

See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "{}\+A Smoothness Energy without Boundary Distortion for Curved Surfaces"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V Hessian energy matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a22ef8866a2a9dee7c48ba52640e2d1f0}\label{namespaceigl_a22ef8866a2a9dee7c48ba52640e2d1f0} 
\index{igl@{igl}!curved\_hessian\_energy@{curved\_hessian\_energy}}
\index{curved\_hessian\_energy@{curved\_hessian\_energy}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{curved\_hessian\_energy()}{curved\_hessian\_energy()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ \\
void igl\+::curved\+\_\+hessian\+\_\+energy (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&}]{Q }\end{DoxyParamCaption})}



Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. 

See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "{}\+A Smoothness Energy without Boundary Distortion for Curved Surfaces"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ out}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V Hessian energy matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adf2f70635c7e74512f3a00c9fbf0175f}\label{namespaceigl_adf2f70635c7e74512f3a00c9fbf0175f} 
\index{igl@{igl}!curved\_hessian\_energy\_intrinsic@{curved\_hessian\_energy\_intrinsic}}
\index{curved\_hessian\_energy\_intrinsic@{curved\_hessian\_energy\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{curved\_hessian\_energy\_intrinsic()}{curved\_hessian\_energy\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ \\
void igl\+::curved\+\_\+hessian\+\_\+energy\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&}]{Q }\end{DoxyParamCaption})}



Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. 

See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "{}\+A Smoothness Energy without Boundary Distortion for Curved Surfaces"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em l\+\_\+sq} & \#F by 3 list of squared edge lengths of each halfedge \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient\+\_\+halfedges. will be computed if not provided. \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V Hessian energy matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6ee4e11b54bb3477734d8f83e33c01c7}\label{namespaceigl_a6ee4e11b54bb3477734d8f83e33c01c7} 
\index{igl@{igl}!curved\_hessian\_energy\_intrinsic@{curved\_hessian\_energy\_intrinsic}}
\index{curved\_hessian\_energy\_intrinsic@{curved\_hessian\_energy\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{curved\_hessian\_energy\_intrinsic()}{curved\_hessian\_energy\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DeriveddA , typename DerivedE , typename Derived\+OE , typename ScalarQ $>$ \\
void igl\+::curved\+\_\+hessian\+\_\+energy\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&}]{dA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarQ $>$ \&}]{Q }\end{DoxyParamCaption})}



Computes the curved Hessian energy using the Crouzeix-\/\+Raviart discretization. 

See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "{}\+A Smoothness Energy without Boundary Distortion for Curved Surfaces"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em l\+\_\+sq} & \#F by 3 list of squared edge lengths of each halfedge \\
\hline
\mbox{\texttt{ in}}  & {\em dA} & \#F list of double areas \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient\+\_\+halfedges. will be computed if not provided. \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V Hessian energy matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3221b56ac51e76ede2f88111bd099e2c}\label{namespaceigl_a3221b56ac51e76ede2f88111bd099e2c} 
\index{igl@{igl}!cut\_mesh@{cut\_mesh}}
\index{cut\_mesh@{cut\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cut\_mesh()}{cut\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI $>$ \\
void igl\+::cut\+\_\+mesh (\begin{DoxyParamCaption}\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{cuts,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. 

\begin{DoxyNote}{Note}
Assumes mesh is edge-\/manifold.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em V} & \#V by 3 list of the vertex positions \\
\hline
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 list of the faces \\
\hline
\mbox{\texttt{ in}}  & {\em cuts} & \#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#V by 1 list of the map between Vn to original V index. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9a4e732845de9d7f23536e1e6afe4a12}\label{namespaceigl_a9a4e732845de9d7f23536e1e6afe4a12} 
\index{igl@{igl}!cut\_mesh@{cut\_mesh}}
\index{cut\_mesh@{cut\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cut\_mesh()}{cut\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FF , typename Derived\+FFi , typename DerivedC , typename DerivedI $>$ \\
void igl\+::cut\+\_\+mesh (\begin{DoxyParamCaption}\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Matrix\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Matrix\+Base$<$ Derived\+FFi $>$ \&}]{FFi,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. 

\begin{DoxyNote}{Note}
Assumes mesh is edge-\/manifold.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em V} & \#V by 3 list of the vertex positions \\
\hline
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 list of the faces \\
\hline
\mbox{\texttt{ in,out}}  & {\em FF} & \#F by \#3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i \\
\hline
\mbox{\texttt{ in,out}}  & {\em FFi} & \#F by \#3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#V by 1 list of the map between Vn to original V index.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ae07b1e4d35569138ffa0d8a874f0e24f}{triangle\+\_\+triangle\+\_\+adjacency} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ab4c53d1e5c547015ed9a3a31941c9e80}\label{namespaceigl_ab4c53d1e5c547015ed9a3a31941c9e80} 
\index{igl@{igl}!cut\_mesh@{cut\_mesh}}
\index{cut\_mesh@{cut\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cut\_mesh()}{cut\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ \\
void igl\+::cut\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{cuts,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{Vn,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{Fn }\end{DoxyParamCaption})}



Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. 

\begin{DoxyNote}{Note}
Assumes mesh is edge-\/manifold. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em V} & \#V by 3 list of the vertex positions \\
\hline
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 list of the faces \\
\hline
\mbox{\texttt{ in}}  & {\em cuts} & \#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) \\
\hline
\mbox{\texttt{ out}}  & {\em Vn} & \#V by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. \\
\hline
\mbox{\texttt{ out}}  & {\em Fn} & \#F by 3 list of the faces of the cut mesh(must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a073f4b026cc266fb9d229b0063139681}\label{namespaceigl_a073f4b026cc266fb9d229b0063139681} 
\index{igl@{igl}!cut\_mesh@{cut\_mesh}}
\index{cut\_mesh@{cut\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cut\_mesh()}{cut\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI $>$ \\
void igl\+::cut\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{cuts,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{Vn,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{Fn,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Given a mesh and a list of edges that are to be cut, the function generates a new disk-\/topology mesh that has the cuts at its boundary. 

\begin{DoxyNote}{Note}
Assumes mesh is edge-\/manifold. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em V} & \#V by 3 list of the vertex positions \\
\hline
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 list of the faces \\
\hline
\mbox{\texttt{ in}}  & {\em cuts} & \#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) \\
\hline
\mbox{\texttt{ out}}  & {\em Vn} & \#V by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. \\
\hline
\mbox{\texttt{ out}}  & {\em Fn} & \#F by 3 list of the faces of the cut mesh(must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#V by 1 list of the map between Vn to original V index. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a719fb78367f00bac1b9ef47dacead128}\label{namespaceigl_a719fb78367f00bac1b9ef47dacead128} 
\index{igl@{igl}!cut\_mesh\_from\_singularities@{cut\_mesh\_from\_singularities}}
\index{cut\_mesh\_from\_singularities@{cut\_mesh\_from\_singularities}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cut\_mesh\_from\_singularities()}{cut\_mesh\_from\_singularities()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO $>$ \\
void igl\+::cut\+\_\+mesh\+\_\+from\+\_\+singularities (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{MMatch,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{seams }\end{DoxyParamCaption})}



Given a mesh (V,F) and the integer mismatch of a cross field per edge (mismatch), finds the cut\+\_\+graph connecting the singularities (seams) and the degree of the singularities singularity\+\_\+index. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of faces \\
\hline
\mbox{\texttt{ in}}  & {\em mismatch} & \#F by 3 list of per corner integer mismatch \\
\hline
\mbox{\texttt{ out}}  & {\em seams} & \#F by 3 list of per corner booleans that denotes if an edge is a seam or not \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ace2b58d7048e2871ef70de6761fe10f2}\label{namespaceigl_ace2b58d7048e2871ef70de6761fe10f2} 
\index{igl@{igl}!cut\_to\_disk@{cut\_to\_disk}}
\index{cut\_to\_disk@{cut\_to\_disk}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cut\_to\_disk()}{cut\_to\_disk()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Index $>$ \\
void igl\+::cut\+\_\+to\+\_\+disk (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{cuts }\end{DoxyParamCaption})}



Given a triangle mesh, computes a set of edge cuts sufficient to carve the mesh into a topological disk, without disconnecting any connected components. 

Nothing else about the cuts (including number, total length, or smoothness) is guaranteed to be optimal.

Simply-\/connected components without boundary (topological spheres) are left untouched (delete any edge if you really want a disk). All other connected components are cut into disks. Meshes with boundary are supported; boundary edges will be included as cuts.

The cut mesh itself can be materialized using \doxylink{namespaceigl_a3221b56ac51e76ede2f88111bd099e2c}{cut\+\_\+mesh()}.

Implements the triangle-\/deletion approach described by Gu et al\textquotesingle{}s "{}\+Geometry Images."{}


\begin{DoxyTemplParams}{Template Parameters}
{\em Index} & Integrable type large enough to represent the total number of faces and edges in the surface represented by F, and all entries of F. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of the faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em cuts} & List of cuts. Each cut is a sequence of vertex indices (where pairs of consecutive vertices share a face), is simple, and is either a closed loop (in which the first and last indices are identical) or an open curve. Cuts are edge-\/disjoint. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab77a363af4a0fcf59e15409bd8a09fc4}\label{namespaceigl_ab77a363af4a0fcf59e15409bd8a09fc4} 
\index{igl@{igl}!cylinder@{cylinder}}
\index{cylinder@{cylinder}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{cylinder()}{cylinder()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::cylinder (\begin{DoxyParamCaption}\item[{const int}]{axis\+\_\+devisions,  }\item[{const int}]{height\+\_\+devisions,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Construct a triangle mesh of a cylinder (without caps) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em axis\+\_\+devisions} & number of vertices {\itshape around the cylinder} \\
\hline
\mbox{\texttt{ in}}  & {\em height\+\_\+devisions} & number of vertices {\itshape up the cylinder} \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a73748b03f3e779d764d30d920653aba6}\label{namespaceigl_a73748b03f3e779d764d30d920653aba6} 
\index{igl@{igl}!dated\_copy@{dated\_copy}}
\index{dated\_copy@{dated\_copy}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dated\_copy()}{dated\_copy()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::dated\+\_\+copy (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{src\+\_\+path,  }\item[{const std\+::string \&}]{dir }\end{DoxyParamCaption})}



Copy the given file to a new file with the same basename in {\ttfamily dir} directory with the current date and time as a suffix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em src\+\_\+path} & path to source file \\
\hline
\mbox{\texttt{ in}}  & {\em dir} & directory of destination file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether the copy was successful
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md8}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md8}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a73748b03f3e779d764d30d920653aba6}{dated\_copy}}(\textcolor{stringliteral}{"{}/path/to/foo"{}},\textcolor{stringliteral}{"{}/bar/"{}});}
\DoxyCodeLine{\textcolor{comment}{//\ copies\ /path/to/foo\ to\ /bar/foo-\/2013-\/12-\/12T18-\/10-\/56}}

\end{DoxyCode}
\Hypertarget{namespaceigl_ad50bddf10510ab0ef1bda0bb11641fef}\label{namespaceigl_ad50bddf10510ab0ef1bda0bb11641fef} 
\index{igl@{igl}!dated\_copy@{dated\_copy}}
\index{dated\_copy@{dated\_copy}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dated\_copy()}{dated\_copy()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::dated\+\_\+copy (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{src\+\_\+path }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Uses current working directory. \Hypertarget{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}\label{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3} 
\index{igl@{igl}!decimate@{decimate}}
\index{decimate@{decimate}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate()}{decimate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily bool igl\+::decimate (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const size\+\_\+t}]{max\+\_\+m,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{U,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{G,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J,  }\item[{Eigen\+::\+Vector\+Xi \&}]{I }\end{DoxyParamCaption})}



Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of faces is achieved. 

This uses default edge cost and merged vertex placement functions \{edge length, edge midpoint\}.

See \doxylink{decimate_8h}{include/igl/decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+m} & desired number of output faces \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#U by dim list of output vertex posistions (can be same ref as V) \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of output face indices into U (can be same ref as G) \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#G list of indices into F of birth face \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#U list of indices into V of birth vertices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if m was reached (otherwise \#G \texorpdfstring{$>$}{>} m) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a012dde4236352501b14abc42b746906e}\label{namespaceigl_a012dde4236352501b14abc42b746906e} 
\index{igl@{igl}!decimate@{decimate}}
\index{decimate@{decimate}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate()}{decimate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily bool igl\+::decimate (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const size\+\_\+t}]{max\+\_\+m,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{U,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{G,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a61885a8ab4cc1e4ed8ed1fba6e42ecb6}\label{namespaceigl_a61885a8ab4cc1e4ed8ed1fba6e42ecb6} 
\index{igl@{igl}!decimate@{decimate}}
\index{decimate@{decimate}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate()}{decimate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily bool igl\+::decimate (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{const \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&}]{stopping\+\_\+condition,  }\item[{const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&}]{pre\+\_\+collapse,  }\item[{const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&}]{post\+\_\+collapse,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{U,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{G,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J,  }\item[{Eigen\+::\+Vector\+Xi \&}]{I }\end{DoxyParamCaption})}



Collapses edges of a {\bfseries{closed manifold mesh}} (V,F) using user defined callbacks in a priority queue. 

Functions control the cost and placement of each collapse the stopping criteria for queue processing and the callbacks for pre and post collapse operations. See the first implementation in decimate.\+cpp for an example of how to deal with open/non-\/manifold meshes and how to adjust cost and placement functions accordingly.

See \doxylink{decimate_8h}{include/igl/decimate.\+h} for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em cost\+\_\+and\+\_\+placement} & function computing cost of collapsing an edge and 3d position where it should be placed\+: cost\+\_\+and\+\_\+placement(\+V,\+F,\+E,\+EMAP,\+EF,\+EI,cost,placement); \\
\hline
\mbox{\texttt{ in}}  & {\em stopping\+\_\+condition} & function returning whether to stop collapsing edges based on current state. Guaranteed to be called after {\itshape successfully} collapsing edge e removing edges (e,e1,e2) and faces (f1,f2)\+: bool should\+\_\+stop = stopping\+\_\+condition(\+V,\+F,\+E,\+EMAP,\+EF,\+EI,\+Q,\+Qit,\+C,e,e1,e2,f1,f2); \\
\hline
\mbox{\texttt{ in}}  & {\em pre\+\_\+collapse} & callback called with index of edge whose collapse is about to be attempted (see collapse\+\_\+edge) \\
\hline
\mbox{\texttt{ in}}  & {\em post\+\_\+collapse} & callback called with index of edge whose collapse was just attempted and a flag revealing whether this was successful (see collapse\+\_\+edge) \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#U by dim list of output vertex posistions (can be same ref as V) \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of output face indices into U (can be same ref as G) \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#G list of indices into F of birth face \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#U list of indices into V of birth vertices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if m was reached (otherwise \#G \texorpdfstring{$>$}{>} m)
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a6c8cf9368d76d69d41ea95bc5b4fd13b}{connect\+\_\+boundary\+\_\+to\+\_\+infinity}
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a8e383abbd367d0ed68c602a7ae7ea2f7}\label{namespaceigl_a8e383abbd367d0ed68c602a7ae7ea2f7} 
\index{igl@{igl}!decimate@{decimate}}
\index{decimate@{decimate}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate()}{decimate()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily bool igl\+::decimate (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{const \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&}]{stopping\+\_\+condition,  }\item[{const \mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&}]{pre\+\_\+collapse,  }\item[{const \mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&}]{post\+\_\+collapse,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{U,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{G,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J,  }\item[{Eigen\+::\+Vector\+Xi \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa716c4de65ed56fd9f9968f9d79ee657}\label{namespaceigl_aa716c4de65ed56fd9f9968f9d79ee657} 
\index{igl@{igl}!decimate@{decimate}}
\index{decimate@{decimate}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate()}{decimate()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily bool igl\+::decimate (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{const \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&}]{stopping\+\_\+condition,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{U,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{G,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J,  }\item[{Eigen\+::\+Vector\+Xi \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a199e2a88dcf8d16e8b0244d20e4743c1}\label{namespaceigl_a199e2a88dcf8d16e8b0244d20e4743c1} 
\index{igl@{igl}!decimate\_trivial\_callbacks@{decimate\_trivial\_callbacks}}
\index{decimate\_trivial\_callbacks@{decimate\_trivial\_callbacks}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{decimate\_trivial\_callbacks()}{decimate\_trivial\_callbacks()}}
{\footnotesize\ttfamily void igl\+::decimate\+\_\+trivial\+\_\+callbacks (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespaceigl_af695d0b4a424387592b06f466a86088e}{decimate\+\_\+pre\+\_\+collapse\+\_\+callback}} \&}]{always\+\_\+try,  }\item[{\mbox{\hyperlink{namespaceigl_a16fd55ae4f3085d4ed4d3c6bff008426}{decimate\+\_\+post\+\_\+collapse\+\_\+callback}} \&}]{never\+\_\+care }\end{DoxyParamCaption})}



Function to build trivial pre and post collapse actions. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em always\+\_\+try} & function that always returns true (always attempt the next edge collapse) \\
\hline
\mbox{\texttt{ out}}  & {\em never\+\_\+care} & fuction that is always a no-\/op (never have a post collapse response) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa03c54b4a3c8a07853528d49455f4fcc}\label{namespaceigl_aa03c54b4a3c8a07853528d49455f4fcc} 
\index{igl@{igl}!default\_num\_threads@{default\_num\_threads}}
\index{default\_num\_threads@{default\_num\_threads}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{default\_num\_threads()}{default\_num\_threads()}}
{\footnotesize\ttfamily unsigned int igl\+::default\+\_\+num\+\_\+threads (\begin{DoxyParamCaption}\item[{unsigned int}]{force\+\_\+num\+\_\+threads = {\ttfamily 0} }\end{DoxyParamCaption})}



Returns the default number of threads used in libigl. 

The value returned by the first call to this function is cached. The following strategy is used to determine the default number of threads\+:
\begin{DoxyEnumerate}
\item User-\/provided argument force\+\_\+num\+\_\+threads if != 0.
\item Environment variable IGL\+\_\+\+NUM\+\_\+\+THREADS if \texorpdfstring{$>$}{>} 0.
\item Hardware concurrency if != 0.
\item A fallback value of 8 is used otherwise.
\end{DoxyEnumerate}

\begin{DoxyNote}{Note}
It is safe to call this method from multiple threads.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em force\+\_\+num\+\_\+threads} & User-\/provided default value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Default number of threads. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a5819845b8bcf251d5e25bc93bf425e35}\label{namespaceigl_a5819845b8bcf251d5e25bc93bf425e35} 
\index{igl@{igl}!deform\_skeleton@{deform\_skeleton}}
\index{deform\_skeleton@{deform\_skeleton}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{deform\_skeleton()}{deform\_skeleton()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::deform\+\_\+skeleton (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const std\+::vector$<$ Eigen\+::\+Affine3d, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Affine3d $>$ $>$ \&}]{vA,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{CT,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{BET }\end{DoxyParamCaption})}



Deform a skeleton. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em C} & \#C by 3 list of joint positions \\
\hline
\mbox{\texttt{ in}}  & {\em BE} & \#\+BE by 2 list of bone edge indices \\
\hline
\mbox{\texttt{ in}}  & {\em vA} & \#\+BE list of bone transformations \\
\hline
\mbox{\texttt{ out}}  & {\em CT} & \#\+BE\texorpdfstring{$\ast$}{*}2 by 3 list of deformed joint positions \\
\hline
\mbox{\texttt{ out}}  & {\em BET} & \#\+BE by 2 list of bone edge indices (maintains order) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a473e4f58cfd34838b53114e315604728}\label{namespaceigl_a473e4f58cfd34838b53114e315604728} 
\index{igl@{igl}!deform\_skeleton@{deform\_skeleton}}
\index{deform\_skeleton@{deform\_skeleton}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{deform\_skeleton()}{deform\_skeleton()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void igl\+::deform\+\_\+skeleton (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{T,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{CT,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{BET }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & \#\+BE\texorpdfstring{$\ast$}{*}4 by 3 list of stacked transformation matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad85b334c412de101ce6003dabbd6ad70}\label{namespaceigl_ad85b334c412de101ce6003dabbd6ad70} 
\index{igl@{igl}!delaunay\_triangulation@{delaunay\_triangulation}}
\index{delaunay\_triangulation@{delaunay\_triangulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{delaunay\_triangulation()}{delaunay\_triangulation()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Orient2D , typename In\+Circle , typename DerivedF $>$ \\
void igl\+::delaunay\+\_\+triangulation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Orient2D}]{orient2D,  }\item[{In\+Circle}]{incircle,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Given a set of points in 2D, return a Delaunay triangulation of these points. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em orient2D} & A functor such that orient2\+D(pa, pb, pc) returns 1 if pa,pb,pc forms a conterclockwise triangle. -\/1 if pa,pb,pc forms a clockwise triangle. 0 if pa,pb,pc are collinear. where the argument pa,pb,pc are of type Scalar\mbox{[}2\mbox{]}. \\
\hline
\mbox{\texttt{ in}}  & {\em incircle} & A functor such that incircle(pa, pb, pc, pd) returns 1 if pd is on the positive size of circumcirle of (pa,pb,pc) -\/1 if pd is on the positive size of circumcirle of (pa,pb,pc) 0 if pd is cocircular with pa, pb, pc. \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 of faces in Delaunay triangulation. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9bed0a54e4a3d573a8ca709f613d2b8c}\label{namespaceigl_a9bed0a54e4a3d573a8ca709f613d2b8c} 
\index{igl@{igl}!dfs@{dfs}}
\index{dfs@{dfs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dfs()}{dfs()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedD , typename DerivedP , typename DerivedC $>$ \\
void igl\+::dfs (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ AType $>$ $>$ \&}]{A,  }\item[{const size\+\_\+t}]{s,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Traverse a {\bfseries{directed}} graph represented by an adjacency list using depth first search. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#V list of adjacency lists \\
\hline
\mbox{\texttt{ in}}  & {\em s} & starting node (index into A) \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#V list of indices into rows of A in the order in which graph nodes are discovered. \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#V list of indices into rows of A of predecessor in resulting spanning tree \{-\/1 indicates root/not discovered), order corresponds to V {\bfseries{not}} D. \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#V list of indices into rows of A in order that nodes are "{}closed"{} (all descendants have been discovered) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a95618dab6ef7c11351e352297c2d77fc}\label{namespaceigl_a95618dab6ef7c11351e352297c2d77fc} 
\index{igl@{igl}!dfs@{dfs}}
\index{dfs@{dfs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dfs()}{dfs()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename AType , typename DType , typename PType , typename CType $>$ \\
void igl\+::dfs (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ AType $>$ $>$ \&}]{A,  }\item[{const size\+\_\+t}]{s,  }\item[{std\+::vector$<$ DType $>$ \&}]{D,  }\item[{std\+::vector$<$ PType $>$ \&}]{P,  }\item[{std\+::vector$<$ CType $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ae1d2eff20a5c7b15bbe61a1d53eadc9b}\label{namespaceigl_ae1d2eff20a5c7b15bbe61a1d53eadc9b} 
\index{igl@{igl}!dihedral\_angles@{dihedral\_angles}}
\index{dihedral\_angles@{dihedral\_angles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dihedral\_angles()}{dihedral\_angles()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename Derivedtheta , typename Derivedcos\+\_\+theta $>$ \\
void igl\+::dihedral\+\_\+angles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedtheta $>$ \&}]{theta,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedcos\+\_\+theta $>$ \&}]{cos\+\_\+theta }\end{DoxyParamCaption})}



Compute dihedral angles for all tets of a given tet mesh (V,T). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#V by 4 list of tet indices \\
\hline
\mbox{\texttt{ out}}  & {\em theta} & \#T by 6 list of dihedral angles (in radians) \\
\hline
\mbox{\texttt{ out}}  & {\em cos\+\_\+theta} & \#T by 6 list of cosine of dihedral angles (in radians) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af8fd16e614bedafbd69fa739a29a7622}\label{namespaceigl_af8fd16e614bedafbd69fa739a29a7622} 
\index{igl@{igl}!dihedral\_angles\_intrinsic@{dihedral\_angles\_intrinsic}}
\index{dihedral\_angles\_intrinsic@{dihedral\_angles\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dihedral\_angles\_intrinsic()}{dihedral\_angles\_intrinsic()}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename DerivedA , typename Derivedtheta , typename Derivedcos\+\_\+theta $>$ \\
void igl\+::dihedral\+\_\+angles\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&}]{L,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedtheta $>$ \&}]{theta,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedcos\+\_\+theta $>$ \&}]{cos\+\_\+theta }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Intrinsic version.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L} & \#L by 6 list of edge lengths \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#A by 4 list of face areas \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a16b06e5e2a37a01b6648acb209437f78}\label{namespaceigl_a16b06e5e2a37a01b6648acb209437f78} 
\index{igl@{igl}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Index\+Type , typename DerivedD , typename DerivedP $>$ \\
int igl\+::dijkstra (\begin{DoxyParamCaption}\item[{const Index\+Type \&}]{source,  }\item[{const std\+::set$<$ Index\+Type $>$ \&}]{targets,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{VV,  }\item[{const std\+::vector$<$ double $>$ \&}]{weights,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{min\+\_\+distance,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{previous }\end{DoxyParamCaption})}



Dijkstra\textquotesingle{}s algorithm for vertex-\/weighted shortest paths, with multiple targets. 

Adapted from \href{http://rosettacode.org/wiki/Dijkstra\%27s_algorithm}{\texttt{ http\+://rosettacode.\+org/wiki/\+Dijkstra\%27s\+\_\+algorithm}} .


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em source} & index of source vertex \\
\hline
\mbox{\texttt{ in}}  & {\em targets} & target vector set \\
\hline
\mbox{\texttt{ in}}  & {\em VV} & \#V list of lists of incident vertices (adjacency list), e.\+g. as returned by \doxylink{namespaceigl_a4c905c0e9124bb38a79769497fa9b48b}{igl\+::adjacency\+\_\+list} \\
\hline
\mbox{\texttt{ in}}  & {\em weights} & \#V list of scalar vertex weights \\
\hline
\mbox{\texttt{ out}}  & {\em min\+\_\+distance} & \#V by 1 list of the minimum distances from source to all vertices \\
\hline
\mbox{\texttt{ out}}  & {\em previous} & \#V by 1 list of the previous visited vertices (for each vertex) -\/ used for backtracking \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5a2bd7c3c9affbdcd476b68cfe36a41d}\label{namespaceigl_a5a2bd7c3c9affbdcd476b68cfe36a41d} 
\index{igl@{igl}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Index\+Type , typename DerivedV , typename DerivedD , typename DerivedP $>$ \\
int igl\+::dijkstra (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{VV,  }\item[{const Index\+Type \&}]{source,  }\item[{const std\+::set$<$ Index\+Type $>$ \&}]{targets,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{min\+\_\+distance,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{previous }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad95f2745c0d523d9b1b8d7b7ef2707b9}\label{namespaceigl_ad95f2745c0d523d9b1b8d7b7ef2707b9} 
\index{igl@{igl}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Index\+Type , typename DerivedD , typename DerivedP $>$ \\
int igl\+::dijkstra (\begin{DoxyParamCaption}\item[{const Index\+Type \&}]{source,  }\item[{const std\+::set$<$ Index\+Type $>$ \&}]{targets,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{VV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{min\+\_\+distance,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{previous }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a574a508288788ba1c5a7c8c2adbd0c33}\label{namespaceigl_a574a508288788ba1c5a7c8c2adbd0c33} 
\index{igl@{igl}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Index\+Type , typename DerivedP $>$ \\
void igl\+::dijkstra (\begin{DoxyParamCaption}\item[{const Index\+Type \&}]{vertex,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{previous,  }\item[{std\+::vector$<$ Index\+Type $>$ \&}]{path }\end{DoxyParamCaption})}



Backtracking after Dijkstra\textquotesingle{}s algorithm, to find shortest path. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vertex} & vertex to which we want the shortest path (from same source as above) \\
\hline
\mbox{\texttt{ in}}  & {\em previous} & \#V by 1 list of the previous visited vertices (for each vertex) -\/ result of Dijkstra\textquotesingle{}s algorithm \\
\hline
\mbox{\texttt{ out}}  & {\em path} & \#P by 1 list of vertex indices in the shortest path from vertex to source \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a24aaa9b2bd870165bee8f9c18c826496}\label{namespaceigl_a24aaa9b2bd870165bee8f9c18c826496} 
\index{igl@{igl}!direct\_delta\_mush@{direct\_delta\_mush}}
\index{direct\_delta\_mush@{direct\_delta\_mush}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{direct\_delta\_mush()}{direct\_delta\_mush()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+Omega , typename DerivedU $>$ \\
void igl\+::direct\+\_\+delta\+\_\+mush (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const std\+::vector$<$ Eigen\+::\+Affine3d, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Affine3d $>$ $>$ \&}]{T,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Omega $>$ \&}]{Omega,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



Computes Direct Delta Mush Skinning (Variant 0) from "{}\+Direct Delta Mush \+Skinning and Variants"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of rest pose vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T list of bone pose transformations \\
\hline
\mbox{\texttt{ in}}  & {\em Omega} & \#V by \#T\texorpdfstring{$\ast$}{*}10 list of precomputated matrix values \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#V by 3 list of output vertex positions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a48dbae56ef5784518387be01caf9bb5c}\label{namespaceigl_a48dbae56ef5784518387be01caf9bb5c} 
\index{igl@{igl}!direct\_delta\_mush\_precomputation@{direct\_delta\_mush\_precomputation}}
\index{direct\_delta\_mush\_precomputation@{direct\_delta\_mush\_precomputation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{direct\_delta\_mush\_precomputation()}{direct\_delta\_mush\_precomputation()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedW , typename Derived\+Omega $>$ \\
void igl\+::direct\+\_\+delta\+\_\+mush\+\_\+precomputation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{const int}]{p,  }\item[{const typename Derived\+V\+::\+Scalar}]{lambda,  }\item[{const typename Derived\+V\+::\+Scalar}]{kappa,  }\item[{const typename Derived\+V\+::\+Scalar}]{alpha,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+Omega $>$ \&}]{Omega }\end{DoxyParamCaption})}



Precomputation for Direct Delta Mush Skinning. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of rest pose vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em W} & \#V by \#\+Edges list of weights \\
\hline
\mbox{\texttt{ in}}  & {\em p} & number of smoothing iterations \\
\hline
\mbox{\texttt{ in}}  & {\em lambda} & rotation smoothing step size \\
\hline
\mbox{\texttt{ in}}  & {\em kappa} & translation smoothness step size \\
\hline
\mbox{\texttt{ in}}  & {\em alpha} & translation smoothness blending weight \\
\hline
\mbox{\texttt{ out}}  & {\em Omega} & \#V by \#T\texorpdfstring{$\ast$}{*}10 list of precomputated matrix values\\
\hline
\end{DoxyParams}
\doxylink{direct__delta__mush_8h}{include/igl/direct\+\_\+delta\+\_\+mush.\+h} \Hypertarget{namespaceigl_a72a57e1816cf4b6448d72f2f98b5e071}\label{namespaceigl_a72a57e1816cf4b6448d72f2f98b5e071} 
\index{igl@{igl}!directed\_edge\_orientations@{directed\_edge\_orientations}}
\index{directed\_edge\_orientations@{directed\_edge\_orientations}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{directed\_edge\_orientations()}{directed\_edge\_orientations()}}
{\footnotesize\ttfamily template$<$typename DerivedC , typename DerivedE $>$ \\
void igl\+::directed\+\_\+edge\+\_\+orientations (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{Q }\end{DoxyParamCaption})}



Determine rotations that take each edge from the x-\/axis to its given rest orientation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em C} & \#C by 3 list of edge vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of directed edges \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#E list of quaternions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af8de9b7859fbf82291598bae63e47550}\label{namespaceigl_af8de9b7859fbf82291598bae63e47550} 
\index{igl@{igl}!directed\_edge\_parents@{directed\_edge\_parents}}
\index{directed\_edge\_parents@{directed\_edge\_parents}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{directed\_edge\_parents()}{directed\_edge\_parents()}}
{\footnotesize\ttfamily template$<$typename DerivedE , typename DerivedP $>$ \\
void igl\+::directed\+\_\+edge\+\_\+parents (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Recover "{}parents"{} (preceding edges) in a tree given just directed edges. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of directed edges \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#E list of parent indices into E (-\/1) means root \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aef1ff1d390be65861384b6ff764ebe09}\label{namespaceigl_aef1ff1d390be65861384b6ff764ebe09} 
\index{igl@{igl}!dirname@{dirname}}
\index{dirname@{dirname}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dirname()}{dirname()}}
{\footnotesize\ttfamily std\+::string igl\+::dirname (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path }\end{DoxyParamCaption})}



Function like PHP\textquotesingle{}s dirname\+: /etc/passwd -\/-\/\texorpdfstring{$>$}{>} /etc,. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em path} & string containing input path \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string containing dirname (see php\textquotesingle{}s dirname)
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82}{basename}, \doxylink{namespaceigl_a541dccb34e02684e3d43966fca86bdaf}{pathinfo}
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
This function will have undefined behavior if {\bfseries{file names}} in the path contain \textbackslash{} and / characters. This function interprets \textbackslash{} and / as file path separators. 
\end{DoxyNote}
\Hypertarget{namespaceigl_a3bdaab27eb4626ff5685a3a4f9347b6a}\label{namespaceigl_a3bdaab27eb4626ff5685a3a4f9347b6a} 
\index{igl@{igl}!dot@{dot}}
\index{dot@{dot}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dot()}{dot()}}
{\footnotesize\ttfamily double igl\+::dot (\begin{DoxyParamCaption}\item[{const double \texorpdfstring{$\ast$}{*}}]{a,  }\item[{const double \texorpdfstring{$\ast$}{*}}]{b }\end{DoxyParamCaption})}



Computes out = dot(a,b) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a} & left 3d vector \\
\hline
\mbox{\texttt{ in}}  & {\em b} & right 3d vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
scalar dot product 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a23322b4cdcba5a31a7e95dc0a29b83f1}\label{namespaceigl_a23322b4cdcba5a31a7e95dc0a29b83f1} 
\index{igl@{igl}!dot\_row@{dot\_row}}
\index{dot\_row@{dot\_row}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dot\_row()}{dot\_row()}}
{\footnotesize\ttfamily template$<$typename DerivedV $>$ \\
DerivedV igl\+::dot\+\_\+row (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{A,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{B }\end{DoxyParamCaption})}



Compute the dot product between each row of A and B. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived from vertex positions matrix type\+: i.\+e. Matrix\+Xd \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & eigen matrix r by c \\
\hline
\mbox{\texttt{ in}}  & {\em B} & eigen matrix r by c \\
\hline
\mbox{\texttt{ out}}  & {\em d} & a column vector with r entries that contains the dot product of each corresponding row of A and B\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Unfortunately, Eigen does not support {\ttfamily A.\+rowwise().dot(B.\+rowwise())} so this function is a wrapper around the less obvious and less convenient {\ttfamily (A.\+array() \texorpdfstring{$\ast$}{*} B.\+array()).rowwise().\doxylink{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}{sum()}}. 
\end{DoxyNote}
\Hypertarget{namespaceigl_a7bae61a0f8a1bbe72e7832381c9beca5}\label{namespaceigl_a7bae61a0f8a1bbe72e7832381c9beca5} 
\index{igl@{igl}!doublearea@{doublearea}}
\index{doublearea@{doublearea}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{doublearea()}{doublearea()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DeriveddblA $>$ \\
void igl\+::doublearea (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&}]{dblA }\end{DoxyParamCaption})}



Computes twice the area for each input triangle or quad. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived type of eigen matrix for V (e.\+g. derived from Matrix\+Xd) \\
\hline
{\em DerivedF} & derived type of eigen matrix for F (e.\+g. derived from Matrix\+Xi) \\
\hline
{\em DeriveddblA} & derived type of eigen matrix for dblA (e.\+g. derived from Matrix\+Xd) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh faces (must be triangles or quads) \\
\hline
\mbox{\texttt{ out}}  & {\em dblA} & \#F list of triangle\mbox{[}quad\mbox{]} double areas (SIGNED only for 2D input)\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adb2512ac1588eb6929dee61b2fb70955}\label{namespaceigl_adb2512ac1588eb6929dee61b2fb70955} 
\index{igl@{igl}!doublearea@{doublearea}}
\index{doublearea@{doublearea}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{doublearea()}{doublearea()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD $>$ \\
void igl\+::doublearea (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



Compute the twice the signed area of a each triangle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#F by dim list of triangle corner positions \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#F by dim list of triangle corner positions \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#F by dim list of triangle corner positions \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#F list of triangle double areas \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aace08ffa72a43a1758a45fe097625aef}\label{namespaceigl_aace08ffa72a43a1758a45fe097625aef} 
\index{igl@{igl}!doublearea\_single@{doublearea\_single}}
\index{doublearea\_single@{doublearea\_single}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{doublearea\_single()}{doublearea\_single()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC $>$ \\
Derived\+A\+::\+Scalar igl\+::doublearea\+\_\+single (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute the twice the signed area of a single triangle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & triangle corner position \\
\hline
\mbox{\texttt{ in}}  & {\em B} & triangle corner position \\
\hline
\mbox{\texttt{ in}}  & {\em C} & triangle corner position \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
2\texorpdfstring{$\ast$}{*}signed area of triangle
\end{DoxyReturn}
\doxylink{doublearea_8h}{include/igl/doublearea.\+h} \Hypertarget{namespaceigl_aa4f3fcc3d502d79e4617250e0ea85ef6}\label{namespaceigl_aa4f3fcc3d502d79e4617250e0ea85ef6} 
\index{igl@{igl}!doublearea@{doublearea}}
\index{doublearea@{doublearea}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{doublearea()}{doublearea()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DeriveddblA $>$ \\
void igl\+::doublearea (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const typename Derivedl\+::\+Scalar}]{nan\+\_\+replacement,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&}]{dblA }\end{DoxyParamCaption})}



Compute twice the area of each intrinsic triangle in a mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#F by dim list of edge lengths using for triangles, columns correspond to edges 23,31,12 \\
\hline
\mbox{\texttt{ in}}  & {\em nan\+\_\+replacement} & what value should be used for triangles whose given edge lengths do not obey the triangle inequality. These may be very wrong (e.\+g., \mbox{[}100 1 1\mbox{]}) or may be nearly degenerate triangles whose floating point side length computation leads to breach of the triangle inequality. One may wish to set this parameter to 0 if side lengths l are {\itshape known} to come from a valid embedding (e.\+g., some mesh (V,F)). In that case, the only circumstance the triangle inequality is broken is when the triangle is nearly degenerate and floating point error dominates\+: hence replacing with zero is reasonable. \\
\hline
\mbox{\texttt{ out}}  & {\em dblA} & \#F list of triangle double areas \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0fcad7016d7021778f7ec4ff91cec557}\label{namespaceigl_a0fcad7016d7021778f7ec4ff91cec557} 
\index{igl@{igl}!doublearea@{doublearea}}
\index{doublearea@{doublearea}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{doublearea()}{doublearea()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DeriveddblA $>$ \\
void igl\+::doublearea (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&}]{dblA }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

default behavior is to assert on Na\+Ns and leave them in place \Hypertarget{namespaceigl_a516b190062ec90a40ecce7a721951303}\label{namespaceigl_a516b190062ec90a40ecce7a721951303} 
\index{igl@{igl}!doublearea\_quad@{doublearea\_quad}}
\index{doublearea\_quad@{doublearea\_quad}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{doublearea\_quad()}{doublearea\_quad()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DeriveddblA $>$ \\
void igl\+::doublearea\+\_\+quad (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveddblA $>$ \&}]{dblA }\end{DoxyParamCaption})}



Computes twice the area for each input quadrilateral. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh faces (must be quadrilaterals) \\
\hline
\mbox{\texttt{ out}}  & {\em dblA} & \#F list of quadrilateral double areas\\
\hline
\end{DoxyParams}
\doxylink{doublearea_8h}{include/igl/doublearea.\+h} \Hypertarget{namespaceigl_ae135ef705d377be39be52549ba816de4}\label{namespaceigl_ae135ef705d377be39be52549ba816de4} 
\index{igl@{igl}!dqs@{dqs}}
\index{dqs@{dqs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dqs()}{dqs()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedW , typename Q , typename QAlloc , typename T , typename DerivedU $>$ \\
void igl\+::dqs (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{const std\+::vector$<$ Q, QAlloc $>$ \&}]{vQ,  }\item[{const std\+::vector$<$ T $>$ \&}]{vT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



Dual quaternion skinning. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of rest positions \\
\hline
\mbox{\texttt{ in}}  & {\em W} & \#W by \#C list of weights \\
\hline
\mbox{\texttt{ in}}  & {\em vQ} & \#C list of rotation quaternions \\
\hline
\mbox{\texttt{ in}}  & {\em vT} & \#C list of translation vectors \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#V by 3 list of new positions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac43379fb55c1019ff88c726aacb64b91}\label{namespaceigl_ac43379fb55c1019ff88c726aacb64b91} 
\index{igl@{igl}!dual\_contouring@{dual\_contouring}}
\index{dual\_contouring@{dual\_contouring}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dual\_contouring()}{dual\_contouring()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedQ $>$ \\
void igl\+::dual\+\_\+contouring (\begin{DoxyParamCaption}\item[{const std\+::function$<$ typename Derived\+V\+::\+Scalar(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&}]{f,  }\item[{const std\+::function$<$ Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&}]{f\+\_\+grad,  }\item[{const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&}]{min\+\_\+corner,  }\item[{const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&}]{max\+\_\+corner,  }\item[{const int}]{nx,  }\item[{const int}]{ny,  }\item[{const int}]{nz,  }\item[{const bool}]{constrained,  }\item[{const bool}]{triangles,  }\item[{const bool}]{root\+\_\+finding,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q }\end{DoxyParamCaption})}



Dual contouring to extract a pure quad mesh from differentiable implicit function using a dense grid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & function returning \texorpdfstring{$>$}{>}0 outside, \texorpdfstring{$<$}{<}0 inside and =0 on the surface \\
\hline
\mbox{\texttt{ in}}  & {\em f\+\_\+grad} & function returning f/f \\
\hline
\mbox{\texttt{ in}}  & {\em min\+\_\+corner} & position of primal grid vertex at minimum corner \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+corner} & position of primal grid vertex at maximum corner \\
\hline
\mbox{\texttt{ in}}  & {\em nx} & number of vertices on x side of primal grid \\
\hline
\mbox{\texttt{ in}}  & {\em ny} & number of vertices on y side of primal grid \\
\hline
\mbox{\texttt{ in}}  & {\em nz} & number of vertices on z side of primal grid \\
\hline
\mbox{\texttt{ in}}  & {\em constrained} & whether to force dual vertices to lie strictly inside corresponding primal cell (prevents self-\/intersections at cost of surface quality; marginally slower) \\
\hline
\mbox{\texttt{ in}}  & {\em triangles} & whether to output four triangles instead of one quad per crossing edge (quad mesh usually looks fine) \\
\hline
\mbox{\texttt{ in}}  & {\em root\+\_\+finding} & whether to use root finding to identify crossing point on each edge (improves quality a lot at cost of performance). If false, use linear interpolation. \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of outputs vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#Q by 4 (or 3 if triangles=true) face indices into rows of V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab912fd8e785a570ce48146acf3c84597}\label{namespaceigl_ab912fd8e785a570ce48146acf3c84597} 
\index{igl@{igl}!dual\_contouring@{dual\_contouring}}
\index{dual\_contouring@{dual\_contouring}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dual\_contouring()}{dual\_contouring()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+Gf , typename Derived\+GV , typename DerivedV , typename DerivedQ $>$ \\
void igl\+::dual\+\_\+contouring (\begin{DoxyParamCaption}\item[{const std\+::function$<$ typename Derived\+V\+::\+Scalar(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&}]{f,  }\item[{const std\+::function$<$ Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&}]{f\+\_\+grad,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Gf $>$ \&}]{Gf,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{const int}]{nx,  }\item[{const int}]{ny,  }\item[{const int}]{nz,  }\item[{const bool}]{constrained,  }\item[{const bool}]{triangles,  }\item[{const bool}]{root\+\_\+finding,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Gf} & nx\texorpdfstring{$\ast$}{*}ny\texorpdfstring{$\ast$}{*}nz list of function values so that Gf(k) = f(GV.\+row(k)) (only needs to be accurate near f=0 and correct sign elsewhere) \\
\hline
\mbox{\texttt{ in}}  & {\em GV} & nx\texorpdfstring{$\ast$}{*}ny\texorpdfstring{$\ast$}{*}nz list of grid positions so that the x,y,z grid position is at GV.\+row(x+nx\texorpdfstring{$\ast$}{*}(y+z\texorpdfstring{$\ast$}{*}ny)) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aab25bc6339ed9e928df2fcb7bd20ef7e}\label{namespaceigl_aab25bc6339ed9e928df2fcb7bd20ef7e} 
\index{igl@{igl}!dual\_contouring@{dual\_contouring}}
\index{dual\_contouring@{dual\_contouring}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{dual\_contouring()}{dual\_contouring()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Derived\+Gf , typename Derived\+GV , typename Derived\+GI , typename DerivedV , typename DerivedQ $>$ \\
void igl\+::dual\+\_\+contouring (\begin{DoxyParamCaption}\item[{const std\+::function$<$ typename Derived\+V\+::\+Scalar(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&}]{f,  }\item[{const std\+::function$<$ Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$(const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&)$>$ \&}]{f\+\_\+grad,  }\item[{const Eigen\+::\+Matrix$<$ typename Derived\+V\+::\+Scalar, 1, 3 $>$ \&}]{step,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Gf $>$ \&}]{Gf,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+GI $>$ \&}]{GI,  }\item[{const bool}]{constrained,  }\item[{const bool}]{triangles,  }\item[{const bool}]{root\+\_\+finding,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Sparse voxel grid


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Gf} & \#\+GV list of corresponding f values. If using root finding then only the sign needs to be correct. \\
\hline
\mbox{\texttt{ in}}  & {\em GV} & \#\+GV by 3 list of sparse grid positions referenced by GI \\
\hline
\mbox{\texttt{ in}}  & {\em GI} & \#\+GI by 2 list of edge indices into rows of GV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a484fcecc222d6c50ff16fe61ff820a80}\label{namespaceigl_a484fcecc222d6c50ff16fe61ff820a80} 
\index{igl@{igl}!ears@{ears}}
\index{ears@{ears}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ears()}{ears()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derivedear , typename Derivedear\+\_\+opp $>$ \\
void igl\+::ears (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedear $>$ \&}]{ear,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedear\+\_\+opp $>$ \&}]{ear\+\_\+opp }\end{DoxyParamCaption})}



Find all ears (faces with two boundary edges) in a given mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle mesh indices \\
\hline
\mbox{\texttt{ out}}  & {\em ears} & \doxylink{namespaceigl_a484fcecc222d6c50ff16fe61ff820a80}{ears} list of indices into F of ears \\
\hline
\mbox{\texttt{ out}}  & {\em ear\+\_\+opp} & \doxylink{namespaceigl_a484fcecc222d6c50ff16fe61ff820a80}{ears} list of indices indicating which edge is non-\/boundary (connecting to flops) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa77cd5878fb81e389480d12080f8679c}\label{namespaceigl_aa77cd5878fb81e389480d12080f8679c} 
\index{igl@{igl}!edge\_collapse\_is\_valid@{edge\_collapse\_is\_valid}}
\index{edge\_collapse\_is\_valid@{edge\_collapse\_is\_valid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_collapse\_is\_valid()}{edge\_collapse\_is\_valid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::edge\+\_\+collapse\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EI }\end{DoxyParamCaption})}



Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology. 

Assumes (V,F) is a closed manifold mesh (except for previouslly collapsed faces which should be set to\+: \mbox{[}IGL\+\_\+\+COLLAPSE\+\_\+\+EDGE\+\_\+\+NULL IGL\+\_\+\+COLLAPSE\+\_\+\+EDGE\+\_\+\+NULL IGL\+\_\+\+COLLAPSE\+\_\+\+EDGE\+\_\+\+NULL\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e} & index into E of edge to try to collapse. E(e,\+:) = \mbox{[}s d\mbox{]} or \mbox{[}d s\mbox{]} so that s\texorpdfstring{$<$}{<}d, then d is collapsed to s. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if edge collapse is valid 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a4449e689db8a9360f41451ad4980b354}\label{namespaceigl_a4449e689db8a9360f41451ad4980b354} 
\index{igl@{igl}!edge\_collapse\_is\_valid@{edge\_collapse\_is\_valid}}
\index{edge\_collapse\_is\_valid@{edge\_collapse\_is\_valid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_collapse\_is\_valid()}{edge\_collapse\_is\_valid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::edge\+\_\+collapse\+\_\+is\+\_\+valid (\begin{DoxyParamCaption}\item[{std\+::vector$<$ int $>$ \&}]{Nsv,  }\item[{std\+::vector$<$ int $>$ \&}]{Ndv }\end{DoxyParamCaption})}



Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Nsv} & \#\+Nsv list of "{}next"{} vertices circulating around starting vertex of edge \\
\hline
\mbox{\texttt{ in}}  & {\em Ndv} & \#\+Ndv list of "{}next"{} vertices circulating around destination vertex of edge \\
\hline
\mbox{\texttt{ out}}  & {\em Nsv} & (side-\/effect\+: sorted by value) \\
\hline
\mbox{\texttt{ out}}  & {\em Ndv} & (side-\/effect\+: sorted by value) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff edge collapse is valid
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ad2779ad7549dc5da4bed4c7042e2f780}{circulation} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a0cf37d2a8f8c08387438a60ba3bcb2ca}\label{namespaceigl_a0cf37d2a8f8c08387438a60ba3bcb2ca} 
\index{igl@{igl}!edge\_crossings@{edge\_crossings}}
\index{edge\_crossings@{edge\_crossings}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_crossings()}{edge\_crossings()}}
{\footnotesize\ttfamily template$<$typename DeriveduE , typename DerivedS , typename DerivedT $>$ \\
void igl\+::edge\+\_\+crossings (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{val,  }\item[{std\+::unordered\+\_\+map$<$ int, int $>$ \&}]{u\+E2I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



Compute the each point that a scalar field crosses a specified value along an edge of a mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em uE} & \#E by 2 list of edge indices \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#V by 1 list of scalar field values \\
\hline
\mbox{\texttt{ in}}  & {\em val} & value to check for crossings \\
\hline
\mbox{\texttt{ out}}  & {\em u\+E2I} & \#T map from edge index to index in T \\
\hline
\mbox{\texttt{ out}}  & {\em T} & \#T by 1 list of parametric coordinates of crossings\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a24e807a90c41e3a89ee0171b1518c27d}{isolines}, \doxylink{namespaceigl_a616f5985cbb36acb190f207f9dff82df}{isolines\+\_\+intrinsic} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a6c1b6d5e7d874099d4260df5291e63e7}\label{namespaceigl_a6c1b6d5e7d874099d4260df5291e63e7} 
\index{igl@{igl}!edge\_exists\_near@{edge\_exists\_near}}
\index{edge\_exists\_near@{edge\_exists\_near}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_exists\_near()}{edge\_exists\_near()}}
{\footnotesize\ttfamily template$<$typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType , typename Index $>$ \\
bool igl\+::edge\+\_\+exists\+\_\+near (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{const Index \&}]{a,  }\item[{const Index \&}]{b,  }\item[{const Index \&}]{uei }\end{DoxyParamCaption})}



Does edge (a,b) exist in the edges of all faces incident on existing unique edge uei. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of unique undirected edges \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique undirected edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F\texorpdfstring{$\ast$}{*}3 by 2 list of half-\/edges \\
\hline
\mbox{\texttt{ in}}  & {\em a} & 1st end-\/point of query edge \\
\hline
\mbox{\texttt{ in}}  & {\em b} & 2nd end-\/point of query edge \\
\hline
\mbox{\texttt{ in}}  & {\em uei} & index into u\+E/u\+E2E of unique edge \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if edge exists near uei.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{unique\+\_\+edge\+\_\+map} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a984c604c49a10f557933850d8c8e2a76}\label{namespaceigl_a984c604c49a10f557933850d8c8e2a76} 
\index{igl@{igl}!edge\_flaps@{edge\_flaps}}
\index{edge\_flaps@{edge\_flaps}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_flaps()}{edge\_flaps()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::edge\+\_\+flaps (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{uE,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI }\end{DoxyParamCaption})}



Determine "{}edge flaps"{}\+: two faces on either side of a unique edge (assumes edge-\/manifold mesh) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique unique edge in uE \\
\hline
\mbox{\texttt{ out}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ out}}  & {\em EI} & \#E by 2 list of edge flap corners (see above).\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{unique\+\_\+edge\+\_\+map}
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
This seems to be a duplicate of \doxylink{edge__topology_8h}{edge\+\_\+topology.\+h} 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a182268447e88dbae647fd2971598226a}{igl::edge\_topology}}(V,F,etEV,etFE,etEF);}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a984c604c49a10f557933850d8c8e2a76}{igl::edge\_flaps}}(F,efE,efEMAP,efEF,efEI);}
\DoxyCodeLine{[\string~,I]\ =\ \mbox{\hyperlink{namespaceigl_aea54a5804527aa194785e403870ba7db}{sort}}(efE,2)}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}{all}}(\ efE(sub2ind(size(efE),\mbox{\hyperlink{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38}{repmat}}(1:size(efE,1),2,1)',I))\ ==\ etEV\ )}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}{all}}(\ efEF(sub2ind(size(efE),\mbox{\hyperlink{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38}{repmat}}(1:size(efE,1),2,1)',I))\ ==\ etEF\ )}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_abf8bd73fedf2cafd491f61084874c2cc}{all}}(efEMAP(sub2ind(size(F),\mbox{\hyperlink{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38}{repmat}}(1:size(F,1),3,1)',\mbox{\hyperlink{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38}{repmat}}([1\ 2\ 3],size(F,1),1)))\ ==\ etFE(:,[2\ 3\ 1]))}

\end{DoxyCode}
 
\end{DoxyNote}
\Hypertarget{namespaceigl_a00745ad61704fb8a6dc941ebf003f628}\label{namespaceigl_a00745ad61704fb8a6dc941ebf003f628} 
\index{igl@{igl}!edge\_flaps@{edge\_flaps}}
\index{edge\_flaps@{edge\_flaps}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_flaps()}{edge\_flaps()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void igl\+::edge\+\_\+flaps (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{uE,  }\item[{Eigen\+::\+Vector\+Xi \&}]{EMAP,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{EI }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a9b2b3d2e2b569256e7704f81859b4d2a}\label{namespaceigl_a9b2b3d2e2b569256e7704f81859b4d2a} 
\index{igl@{igl}!edge\_lengths@{edge\_lengths}}
\index{edge\_lengths@{edge\_lengths}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_lengths()}{edge\_lengths()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedL $>$ \\
void igl\+::edge\+\_\+lengths (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



Constructs a list of lengths of edges opposite each index in a face (triangle/tet) list. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived from vertex positions matrix type\+: i.\+e. Matrix\+Xd \\
\hline
{\em DerivedF} & derived from face indices matrix type\+: i.\+e. Matrix\+Xi \\
\hline
{\em DerivedL} & derived from edge lengths matrix type\+: i.\+e. Matrix\+Xd \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & eigen matrix \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by (2\texorpdfstring{$\vert$}{|}3\texorpdfstring{$\vert$}{|}4) list of mesh simplex indices into rows of V \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#F by \{1\texorpdfstring{$\vert$}{|}3\texorpdfstring{$\vert$}{|}6\} list of edge lengths for edges, column of lengths for triangles, columns correspond to edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]} for tets, columns correspond to edges \mbox{[}3 0\mbox{]},\mbox{[}3 1\mbox{]},\mbox{[}3 2\mbox{]},\mbox{[}1 2\mbox{]},\mbox{[}2 0\mbox{]},\mbox{[}0 1\mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a98288ab94dfbdf3104687419fe33b704}\label{namespaceigl_a98288ab94dfbdf3104687419fe33b704} 
\index{igl@{igl}!edge\_midpoints@{edge\_midpoints}}
\index{edge\_midpoints@{edge\_midpoints}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_midpoints()}{edge\_midpoints()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedmps $>$ \\
void igl\+::edge\+\_\+midpoints (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&}]{oE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedmps $>$ \&}]{mps }\end{DoxyParamCaption})}



Computes the midpoints of edges in a triangle mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient\+\_\+halfedges. will be computed if not provided. \\
\hline
\mbox{\texttt{ out}}  & {\em mps} & \texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} list of edge midpoints\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ae76f879f4715d4a8596d28f12bc7161d}{orient\+\_\+halfedges} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a182268447e88dbae647fd2971598226a}\label{namespaceigl_a182268447e88dbae647fd2971598226a} 
\index{igl@{igl}!edge\_topology@{edge\_topology}}
\index{edge\_topology@{edge\_topology}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_topology()}{edge\_topology()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ \\
void igl\+::edge\+\_\+topology (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{EV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{FE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{EF }\end{DoxyParamCaption})}



Initialize Edges and their topological relations (assumes an edge-\/manifold mesh). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions (unused) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em EV} & \#\+Ex2 matrix storing the edge description as pair of indices to vertices \\
\hline
\mbox{\texttt{ out}}  & {\em FE} & \#\+Fx3 matrix storing the Triangle-\/\+Edge relation \\
\hline
\mbox{\texttt{ out}}  & {\em EF} & \#\+Ex2 matrix storing the Edge-\/\+Triangle relation\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This seems to be a inferior duplicate of \doxylink{edge__flaps_8h}{edge\+\_\+flaps.\+h}\+:
\begin{DoxyItemize}
\item unused input parameter V
\item roughly 2x slower than edge\+\_\+flaps
\item outputs less information\+: edge\+\_\+flaps reveals corner opposite edge
\item FE uses non-\/standard and ambiguous order\+: FE(f,c) is merely an edge incident on corner c of face f. In contrast, edge\+\_\+flaps\textquotesingle{}s EMAP(f,c) reveals the edge {\itshape opposite} corner c of face f 
\end{DoxyItemize}
\end{DoxyNote}
\Hypertarget{namespaceigl_aeb415384505882dfd1de98f678d214a2}\label{namespaceigl_aeb415384505882dfd1de98f678d214a2} 
\index{igl@{igl}!edge\_vectors@{edge\_vectors}}
\index{edge\_vectors@{edge\_vectors}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_vectors()}{edge\_vectors()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$bool compute\+Perpendicular = true, typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedvec\+Parallel , typename Derivedvec\+Perpendicular $>$ \\
void igl\+::edge\+\_\+vectors (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&}]{oE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedvec\+Parallel $>$ \&}]{vec\+Parallel,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedvec\+Perpendicular $>$ \&}]{vec\+Perpendicular }\end{DoxyParamCaption})}



Computes the normalized edge vectors for edges in a triangle mesh. 


\begin{DoxyTemplParams}{Template Parameters}
{\em whether} & to compute edge perpendiculars \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient\+\_\+halfedges. will be computed if not provided. \\
\hline
\mbox{\texttt{ out}}  & {\em vec\+Parallel} & \texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} list of edge vectors \\
\hline
\mbox{\texttt{ out}}  & {\em vec\+Perpendicular} & \texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} list of vectors perpendicular to vec \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7c252b86d3deff637414b045dce9d271}\label{namespaceigl_a7c252b86d3deff637414b045dce9d271} 
\index{igl@{igl}!edge\_vectors@{edge\_vectors}}
\index{edge\_vectors@{edge\_vectors}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edge\_vectors()}{edge\_vectors()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedvec $>$ \\
void igl\+::edge\+\_\+vectors (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedoE $>$ \&}]{oE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedvec $>$ \&}]{vec }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}\label{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee} 
\index{igl@{igl}!edges@{edges}}
\index{edges@{edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edges()}{edges()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE $>$ \\
void igl\+::edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}



Constructs a list of unique edges represented in a given mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by (3\texorpdfstring{$\vert$}{|}4) list of mesh simplex indices \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2 list of edges in no particular order\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a705a8f51137d1dd807bbe517c0567735}{adjacency\+\_\+matrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_aa0ad8afcbeffbd52acd213150ef184cc}\label{namespaceigl_aa0ad8afcbeffbd52acd213150ef184cc} 
\index{igl@{igl}!edges@{edges}}
\index{edges@{edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edges()}{edges()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedI , typename DerivedC , typename DerivedE $>$ \\
void igl\+::edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}



Constructs a list of unique edges represented in a given polygon mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#polygons+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2 list of edges in no particular order \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a93abf38f4293f5e3010211137c9a6ea4}\label{namespaceigl_a93abf38f4293f5e3010211137c9a6ea4} 
\index{igl@{igl}!edges@{edges}}
\index{edges@{edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edges()}{edges()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , typename DerivedE $>$ \\
void igl\+::edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}



Constructs a list of unique edges represented in a given adjacency matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#V by \#V symmetric adjacency matrix \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2 list of edges in no particular order \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_acfa1bf0ca6473ee9234b38b59c90e800}\label{namespaceigl_acfa1bf0ca6473ee9234b38b59c90e800} 
\index{igl@{igl}!edges\_to\_path@{edges\_to\_path}}
\index{edges\_to\_path@{edges\_to\_path}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{edges\_to\_path()}{edges\_to\_path()}}
{\footnotesize\ttfamily template$<$typename DerivedE , typename DerivedI , typename DerivedJ , typename DerivedK $>$ \\
void igl\+::edges\+\_\+to\+\_\+path (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Given a set of undirected, unique edges such that all form a single connected compoent with exactly 0 or 2 nodes with valence =1, determine the/a path visiting all nodes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of undirected edges \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#E+1 list of nodes in order tracing the chain (loop), if the output is a loop then I(1) == I(end) \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#I-\/1 list of indices into E of edges tracing I \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#I-\/1 list of indices into columns of E \{0,1\} so that K(i) means that E(i,\+K(i)) comes before the other (i.\+e., E(i,3-\/K(i)) ). This means that I(i) == E(J(i),K(i)) for i\texorpdfstring{$<$}{<}\#I, or I == E(sub2ind(size(\+E),J(\mbox{[}1\+:end end\mbox{]}),\mbox{[}K;3-\/K(end)\mbox{]})))) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a77bf75e3dc429d5ca9d830c137ac1b1f}\label{namespaceigl_a77bf75e3dc429d5ca9d830c137ac1b1f} 
\index{igl@{igl}!eigs@{eigs}}
\index{eigs@{eigs}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{eigs()}{eigs()}}
{\footnotesize\ttfamily template$<$typename Atype , typename Btype , typename DerivedU , typename DerivedS $>$ \\
bool igl\+::eigs (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ Atype $>$ \&}]{A,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ Btype $>$ \&}]{B,  }\item[{const size\+\_\+t}]{k,  }\item[{const \mbox{\hyperlink{namespaceigl_a39bb96a0597986315dc20d78ba46a50d}{Eigs\+Type}}}]{type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{sU,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{sS }\end{DoxyParamCaption})}



Compute the first/last k eigen pairs of the generalized eigen value problem\+: 

\begin{DoxyVerb}A u = s B u
\end{DoxyVerb}
 Solutions are approximate and sorted.

\begin{DoxyNote}{Note}
Ideally one should use ARPACK and the Eigen unsupported ARPACK module. This implementation does simple, naive power iterations.
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1spectra_ad3d3fe017e5b3e83eaa8c9e997eceaf5}{spectra\+::eigs}
\end{DoxySeeAlso}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#A by \#A symmetric matrix \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#A by \#A symmetric positive-\/definite matrix \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of eigen pairs to compute \\
\hline
\mbox{\texttt{ in}}  & {\em type} & whether to extract from the high or low end \\
\hline
\mbox{\texttt{ out}}  & {\em sU} & \#A by k list of sorted eigen vectors (descending) \\
\hline
\mbox{\texttt{ out}}  & {\em sS} & k list of sorted eigen values (descending)\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
only the \textquotesingle{}sm\textquotesingle{} small magnitude eigen values are well supported 
\end{DoxyWarning}
\Hypertarget{namespaceigl_ad059c2eefaa87bb31a2b03a1787f133d}\label{namespaceigl_ad059c2eefaa87bb31a2b03a1787f133d} 
\index{igl@{igl}!EPS@{EPS}}
\index{EPS@{EPS}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EPS()}{EPS()}}
{\footnotesize\ttfamily template$<$typename S\+\_\+type $>$ \\
S\+\_\+type igl\+::\+EPS (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Function returning EPS for corresponding type. 

\Hypertarget{namespaceigl_aba458ce3c4cbdd9d0cbb3c83b3a255c7}\label{namespaceigl_aba458ce3c4cbdd9d0cbb3c83b3a255c7} 
\index{igl@{igl}!EPS\_SQ@{EPS\_SQ}}
\index{EPS\_SQ@{EPS\_SQ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EPS\_SQ()}{EPS\_SQ()}}
{\footnotesize\ttfamily template$<$typename S\+\_\+type $>$ \\
S\+\_\+type igl\+::\+EPS\+\_\+\+SQ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Function returning EPS\+\_\+\+SQ for corresponding type. 

\Hypertarget{namespaceigl_abfc53046d44a2c9f6c3c6e32cb3ae024}\label{namespaceigl_abfc53046d44a2c9f6c3c6e32cb3ae024} 
\index{igl@{igl}!EPS$<$ float $>$@{EPS$<$ float $>$}}
\index{EPS$<$ float $>$@{EPS$<$ float $>$}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EPS$<$ float $>$()}{EPS< float >()}}
{\footnotesize\ttfamily template$<$$>$ \\
float \mbox{\hyperlink{namespaceigl_ad059c2eefaa87bb31a2b03a1787f133d}{igl\+::\+EPS}}$<$ float $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a8d0aed7321fc747f72cd8f680826ed8e}\label{namespaceigl_a8d0aed7321fc747f72cd8f680826ed8e} 
\index{igl@{igl}!EPS$<$ double $>$@{EPS$<$ double $>$}}
\index{EPS$<$ double $>$@{EPS$<$ double $>$}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EPS$<$ double $>$()}{EPS< double >()}}
{\footnotesize\ttfamily template$<$$>$ \\
double \mbox{\hyperlink{namespaceigl_ad059c2eefaa87bb31a2b03a1787f133d}{igl\+::\+EPS}}$<$ double $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_aa724bd6d64eb6b639407db5b87f1ac64}\label{namespaceigl_aa724bd6d64eb6b639407db5b87f1ac64} 
\index{igl@{igl}!EPS\_SQ$<$ float $>$@{EPS\_SQ$<$ float $>$}}
\index{EPS\_SQ$<$ float $>$@{EPS\_SQ$<$ float $>$}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EPS\_SQ$<$ float $>$()}{EPS\_SQ< float >()}}
{\footnotesize\ttfamily template$<$$>$ \\
float \mbox{\hyperlink{namespaceigl_aba458ce3c4cbdd9d0cbb3c83b3a255c7}{igl\+::\+EPS\+\_\+\+SQ}}$<$ float $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a5e39a8d172ad95e01e3171a06a3a0bac}\label{namespaceigl_a5e39a8d172ad95e01e3171a06a3a0bac} 
\index{igl@{igl}!EPS\_SQ$<$ double $>$@{EPS\_SQ$<$ double $>$}}
\index{EPS\_SQ$<$ double $>$@{EPS\_SQ$<$ double $>$}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EPS\_SQ$<$ double $>$()}{EPS\_SQ< double >()}}
{\footnotesize\ttfamily template$<$$>$ \\
double \mbox{\hyperlink{namespaceigl_aba458ce3c4cbdd9d0cbb3c83b3a255c7}{igl\+::\+EPS\+\_\+\+SQ}}$<$ double $>$ (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a4bda900bb61246ae8c8ec80881cf14c1}\label{namespaceigl_a4bda900bb61246ae8c8ec80881cf14c1} 
\index{igl@{igl}!euler\_characteristic@{euler\_characteristic}}
\index{euler\_characteristic@{euler\_characteristic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{euler\_characteristic()}{euler\_characteristic()}}
{\footnotesize\ttfamily template$<$typename DerivedF $>$ \\
int igl\+::euler\+\_\+characteristic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Computes the Euler characteristic of a given mesh (V,F) 

 = \texorpdfstring{$\vert$}{|}\+V\texorpdfstring{$\vert$}{|} -\/ \texorpdfstring{$\vert$}{|}\+E\texorpdfstring{$\vert$}{|} + \texorpdfstring{$\vert$}{|}\+F\texorpdfstring{$\vert$}{|}

For example,
\begin{DoxyItemize}
\item a single triangle has 3 -\/ 3 + 1 = 1
\item a tetrahedron has 4 -\/ 6 + 4 = 2
\end{DoxyItemize}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh faces (must be triangles) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An int containing the Euler characteristic
\end{DoxyReturn}
\begin{DoxyNote}{Note}
There is \href{https://github.com/libigl/libigl/issues/2249\#issue-1863608449}{\texttt{ some confusion}} over the standard definition of Euler characteristic. libigl\textquotesingle{}s definition agrees with \href{https://en.wikipedia.org/wiki/Euler_characteristic}{\texttt{ wikipedia}} and \mbox{[}David Eppstein\textquotesingle{}s proofs\mbox{]}(\href{https://www.ics.uci.edu/~eppstein/junkyard/euler/all.html}{\texttt{ https\+://www.\+ics.\+uci.\+edu/\texorpdfstring{$\sim$}{\string~}eppstein/junkyard/euler/all.\+html}}). 
\end{DoxyNote}
\Hypertarget{namespaceigl_addb59555ec8b85d9c5d492f449a24b4b}\label{namespaceigl_addb59555ec8b85d9c5d492f449a24b4b} 
\index{igl@{igl}!exact\_geodesic@{exact\_geodesic}}
\index{exact\_geodesic@{exact\_geodesic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{exact\_geodesic()}{exact\_geodesic()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VS , typename Derived\+FS , typename Derived\+VT , typename Derived\+FT , typename DerivedD $>$ \\
void igl\+::exact\+\_\+geodesic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VS $>$ \&}]{VS,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FS $>$ \&}]{FS,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VT $>$ \&}]{VT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FT $>$ \&}]{FT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



Exact geodesic algorithm for triangular mesh with the implementation from \href{https://code.google.com/archive/p/geodesic/}{\texttt{ https\+://code.\+google.\+com/archive/p/geodesic/}}, and the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of 3D vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces \\
\hline
\mbox{\texttt{ in}}  & {\em VS} & \#\+VS by 1 vector specifying indices of source vertices \\
\hline
\mbox{\texttt{ in}}  & {\em FS} & \#\+FS by 1 vector specifying indices of source faces \\
\hline
\mbox{\texttt{ in}}  & {\em VT} & \#\+VT by 1 vector specifying indices of target vertices \\
\hline
\mbox{\texttt{ in}}  & {\em FT} & \#\+FT by 1 vector specifying indices of target faces \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#\+VT+\#\+FT by 1 vector of geodesic distances of each target w.\+r.\+t. the nearest one in the source set\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
specifying a face as target/source means its center. 
\end{DoxyNote}
\Hypertarget{namespaceigl_adb99ccd45b42797c3490bf4dfefe9d02}\label{namespaceigl_adb99ccd45b42797c3490bf4dfefe9d02} 
\index{igl@{igl}!example\_fun@{example\_fun}}
\index{example\_fun@{example\_fun}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{example\_fun()}{example\_fun()}}
{\footnotesize\ttfamily template$<$typename Printable $>$ \\
bool igl\+::example\+\_\+fun (\begin{DoxyParamCaption}\item[{const Printable \&}]{input }\end{DoxyParamCaption})}



This is an example of a function, it takes a templated parameter and shovels it into cout. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type that supports \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em input} & some input of a Printable type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true for the sake of returning something 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ad617638bca753edfeed7b8cdb65794ad}\label{namespaceigl_ad617638bca753edfeed7b8cdb65794ad} 
\index{igl@{igl}!exploded\_view@{exploded\_view}}
\index{exploded\_view@{exploded\_view}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{exploded\_view()}{exploded\_view()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename Derived\+EV , typename Derived\+EF , typename DerivedI , typename DerivedJ $>$ \\
void igl\+::exploded\+\_\+view (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{const typename Derived\+V\+::\+Scalar}]{s,  }\item[{const typename Derived\+V\+::\+Scalar}]{t,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EV $>$ \&}]{EV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EF $>$ \&}]{EF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Given a tet-\/mesh, create a trivial surface mesh (4 triangles per tet) with each tet scaled individually and translated outward from the mesh\textquotesingle{}s centroid, creating an exploded-\/view visualization. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of tet mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T by 4 list of tet mesh indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em s} & amount to scale each tet indvidually, typically (0,1\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em t} & amount to scale away from mesh\textquotesingle{}s centroid, typically \texorpdfstring{$>$}{>}=1 \\
\hline
\mbox{\texttt{ out}}  & {\em EV} & \#T\texorpdfstring{$\ast$}{*}4 by 3 list of output mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em EF} & \#T\texorpdfstring{$\ast$}{*}4 by 3 list of output triangle indices into rows of EV \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#\+EV list of indices into V revealing birth parent \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+EF list of indices into F revealing birth parent \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af53e1e0ea4e1632ee9d5b5a6411093e2}\label{namespaceigl_af53e1e0ea4e1632ee9d5b5a6411093e2} 
\index{igl@{igl}!extension@{extension}}
\index{extension@{extension}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{extension()}{extension()}}
{\footnotesize\ttfamily std\+::string igl\+::extension (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path }\end{DoxyParamCaption})}



Extract file extension from path. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em path} & path with an extension (path/to/foo.\+obj) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
extension without dot (obj)
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a541dccb34e02684e3d43966fca86bdaf}{pathinfo}, \doxylink{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82}{basename}, \doxylink{namespaceigl_aef1ff1d390be65861384b6ff764ebe09}{dirname} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a269a81c6ea4fcbc58882d48720e1a4f5}\label{namespaceigl_a269a81c6ea4fcbc58882d48720e1a4f5} 
\index{igl@{igl}!exterior\_edges@{exterior\_edges}}
\index{exterior\_edges@{exterior\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{exterior\_edges()}{exterior\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::exterior\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E }\end{DoxyParamCaption})}



Determines boundary "{}edges"{} and also edges with an odd number of occurrences where seeing edge (i,j) counts as +1 and seeing the opposite edge (j,i) counts as -\/1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of "{}faces"{} \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by simplex\+\_\+size-\/1 list of exterior edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a47866518a950145c0151a245889b502f}\label{namespaceigl_a47866518a950145c0151a245889b502f} 
\index{igl@{igl}!exterior\_edges@{exterior\_edges}}
\index{exterior\_edges@{exterior\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{exterior\_edges()}{exterior\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xi igl\+::exterior\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a9b637953696bc3821b0a15ebbd4b5105}\label{namespaceigl_a9b637953696bc3821b0a15ebbd4b5105} 
\index{igl@{igl}!extract\_manifold\_patches@{extract\_manifold\_patches}}
\index{extract\_manifold\_patches@{extract\_manifold\_patches}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{extract\_manifold\_patches()}{extract\_manifold\_patches()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivedP $>$ \\
size\+\_\+t igl\+::extract\+\_\+manifold\+\_\+patches (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Extract a set of maximal patches from a given mesh. 

A maximal patch is a subset of the input faces that are connected via manifold edges; a patch is as large as possible.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list representing triangles. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices of unique undirected edges. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumsums of directed edges sharing each unique edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E (see {\ttfamily \doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{igl\+::unique\+\_\+edge\+\_\+map}}) \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#F list of patch incides. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of manifold patches. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ac86020caa06983927879da2393cf5095}\label{namespaceigl_ac86020caa06983927879da2393cf5095} 
\index{igl@{igl}!extract\_manifold\_patches@{extract\_manifold\_patches}}
\index{extract\_manifold\_patches@{extract\_manifold\_patches}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{extract\_manifold\_patches()}{extract\_manifold\_patches()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+EMAP , typename u\+E2\+EType , typename DerivedP $>$ \\
size\+\_\+t igl\+::extract\+\_\+manifold\+\_\+patches (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a644f27405a7cb3bf6b00a451381e8210}\label{namespaceigl_a644f27405a7cb3bf6b00a451381e8210} 
\index{igl@{igl}!extract\_manifold\_patches@{extract\_manifold\_patches}}
\index{extract\_manifold\_patches@{extract\_manifold\_patches}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{extract\_manifold\_patches()}{extract\_manifold\_patches()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedP $>$ \\
size\+\_\+t igl\+::extract\+\_\+manifold\+\_\+patches (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a4f66eca661e45dd9827bf7cae56c61ce}\label{namespaceigl_a4f66eca661e45dd9827bf7cae56c61ce} 
\index{igl@{igl}!extract\_non\_manifold\_edge\_curves@{extract\_non\_manifold\_edge\_curves}}
\index{extract\_non\_manifold\_edge\_curves@{extract\_non\_manifold\_edge\_curves}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{extract\_non\_manifold\_edge\_curves()}{extract\_non\_manifold\_edge\_curves()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+EMAP , typename u\+E2\+EType $>$ \\
void igl\+::extract\+\_\+non\+\_\+manifold\+\_\+edge\+\_\+curves (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{curves }\end{DoxyParamCaption})}



Extract non-\/manifold curves from a given mesh. 

A non-\/manifold curves are a set of connected non-\/manifold edges that does not touch other non-\/manifold edges except at the end points. They are also maximal in the sense that they cannot be expanded by including more edges.

Assumes the input mesh have all self-\/intersection resolved. See igl\+::cgal\+::remesh\+\_\+self\+\_\+intersection for more details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list representing triangles. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices of unique undirected edges. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges. \\
\hline
\mbox{\texttt{ out}}  & {\em curves} & An array of arrays of unique edge indices. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad7de3a366fede697c4cc178a8f36e30e}\label{namespaceigl_ad7de3a366fede697c4cc178a8f36e30e} 
\index{igl@{igl}!face\_areas@{face\_areas}}
\index{face\_areas@{face\_areas}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{face\_areas()}{face\_areas()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename DerivedA $>$ \\
void igl\+::face\+\_\+areas (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Constructs a list of face areas of faces opposite each index in a tet list. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T by 3 list of tet mesh indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#T by 4 list of face areas corresponding to faces opposite vertices 0,1,2,3 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7448c2f83363e1920d02fe6bcb12c5eb}\label{namespaceigl_a7448c2f83363e1920d02fe6bcb12c5eb} 
\index{igl@{igl}!face\_areas@{face\_areas}}
\index{face\_areas@{face\_areas}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{face\_areas()}{face\_areas()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename DerivedA $>$ \\
void igl\+::face\+\_\+areas (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Compute tet-\/mesh face areas from edge lengths.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L} & \#T by 6 list of tet-\/mesh edge lengths corresponding to edges \mbox{[}3 0\mbox{]},\mbox{[}3 1\mbox{]},\mbox{[}3 2\mbox{]},\mbox{[}1 2\mbox{]},\mbox{[}2 0\mbox{]},\mbox{[}0 1\mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a41c2271033be3dc067310683ec802e22}\label{namespaceigl_a41c2271033be3dc067310683ec802e22} 
\index{igl@{igl}!face\_areas@{face\_areas}}
\index{face\_areas@{face\_areas}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{face\_areas()}{face\_areas()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename DerivedA $>$ \\
void igl\+::face\+\_\+areas (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&}]{L,  }\item[{const typename Derived\+L\+::\+Scalar}]{doublearea\+\_\+nan\+\_\+replacement,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em doublearea\+\_\+nan\+\_\+replacement} & See \doxylink{doublearea_8h}{doublearea.\+h} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa4885ed7913bafcb653dade6c257a29e}\label{namespaceigl_aa4885ed7913bafcb653dade6c257a29e} 
\index{igl@{igl}!face\_occurrences@{face\_occurrences}}
\index{face\_occurrences@{face\_occurrences}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{face\_occurrences()}{face\_occurrences()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename IntegerF , typename IntegerC $>$ \\
void igl\+::face\+\_\+occurrences (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ IntegerF $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ IntegerC $>$ \&}]{C }\end{DoxyParamCaption})}



Count the occurances of each face (row) in a list of face indices (irrespecitive of order) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#F list of counts\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
triangles/tets only (where ignoring order still gives simplex) 
\end{DoxyPrecond}
\Hypertarget{namespaceigl_a02c8ab57f00492797e93f9da9cf3c63e}\label{namespaceigl_a02c8ab57f00492797e93f9da9cf3c63e} 
\index{igl@{igl}!face\_occurrences@{face\_occurrences}}
\index{face\_occurrences@{face\_occurrences}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{face\_occurrences()}{face\_occurrences()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedC $>$ \\
void igl\+::face\+\_\+occurrences (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af7aa77ffc481c82074bcdd0ae765c090}\label{namespaceigl_af7aa77ffc481c82074bcdd0ae765c090} 
\index{igl@{igl}!faces\_first@{faces\_first}}
\index{faces\_first@{faces\_first}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{faces\_first()}{faces\_first()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF , typename VecI $>$ \\
void igl\+::faces\+\_\+first (\begin{DoxyParamCaption}\item[{const MatV \&}]{V,  }\item[{const MatF \&}]{F,  }\item[{MatV \&}]{RV,  }\item[{MatF \&}]{RF,  }\item[{VecI \&}]{IM }\end{DoxyParamCaption})}



Reorder vertices so that vertices in face list come before vertices that don\textquotesingle{}t appear in the face list. 

This is especially useful if the face list contains only surface faces and you want surface vertices listed before internal vertices


\begin{DoxyTemplParams}{Template Parameters}
{\em MatV} & matrix for vertex positions, e.\+g. Matrix\+Xd \\
\hline
{\em MatF} & matrix for face indices, e.\+g. Matrix\+Xi \\
\hline
{\em VecI} & vector for index map, e.\+g. Vector\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \# vertices by 3 vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \# faces by 3 list of face indices \\
\hline
\mbox{\texttt{ out}}  & {\em RV} & \# vertices by 3 vertex positions, order such that if the jth vertex is some face in F, and the kth vertex is not then j comes before k \\
\hline
\mbox{\texttt{ out}}  & {\em RF} & \# faces by 3 list of face indices, reindexed to use RV \\
\hline
\mbox{\texttt{ out}}  & {\em IM} & \#V by 1 list of indices such that\+: RF = IM(\+F) and RT = IM(\+T) and RV(\+IM,\+:) = V\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md12}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md12}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Tet\ mesh\ in\ (V,T,F)}}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_af7aa77ffc481c82074bcdd0ae765c090}{faces\_first}}(V,F,IM);}
\DoxyCodeLine{T\ =\ T.unaryExpr(bind1st(mem\_fun(\ \textcolor{keyword}{static\_cast<}VectorXi::Scalar\&}
\DoxyCodeLine{\ \ (VectorXi::*)(VectorXi::Index)\textcolor{keyword}{>}(\&VectorXi::operator())),}
\DoxyCodeLine{\ \ \&IM)).eval();}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a9e44af09a10d6457aa439a6afbb3a6b2}\label{namespaceigl_a9e44af09a10d6457aa439a6afbb3a6b2} 
\index{igl@{igl}!faces\_first@{faces\_first}}
\index{faces\_first@{faces\_first}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{faces\_first()}{faces\_first()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF , typename VecI $>$ \\
void igl\+::faces\+\_\+first (\begin{DoxyParamCaption}\item[{MatV \&}]{V,  }\item[{MatF \&}]{F,  }\item[{VecI \&}]{IM }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ab3c84999e29d9e168fe33b0ca7f2b199}\label{namespaceigl_ab3c84999e29d9e168fe33b0ca7f2b199} 
\index{igl@{igl}!facet\_adjacency\_matrix@{facet\_adjacency\_matrix}}
\index{facet\_adjacency\_matrix@{facet\_adjacency\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{facet\_adjacency\_matrix()}{facet\_adjacency\_matrix()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Atype $>$ \\
void igl\+::facet\+\_\+adjacency\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Atype $>$ \&}]{A }\end{DoxyParamCaption})}



Construct a \#\+F\#F adjacency matrix with A(i,j)\texorpdfstring{$>$}{>}0 indicating that faces i and j share an edge. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of facets \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#F by \#F adjacency matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7823f08d518cb237ee3cb47bb03cdb6d}\label{namespaceigl_a7823f08d518cb237ee3cb47bb03cdb6d} 
\index{igl@{igl}!facet\_components@{facet\_components}}
\index{facet\_components@{facet\_components}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{facet\_components()}{facet\_components()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedC $>$ \\
int igl\+::facet\+\_\+components (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute connected components of facets based on edge-\/edge adjacency. 

For connected components on vertices see \doxylink{namespaceigl_ab8159118b103ccc116d788259917acdb}{igl\+::vertex\+\_\+components}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#F list of connected component ids \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of connected components 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a0320b3e4f5075ce62360f96080b57a92}\label{namespaceigl_a0320b3e4f5075ce62360f96080b57a92} 
\index{igl@{igl}!facet\_components@{facet\_components}}
\index{facet\_components@{facet\_components}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{facet\_components()}{facet\_components()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename TTIndex , typename DerivedC , typename Derivedcounts $>$ \\
void igl\+::facet\+\_\+components (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&}]{TT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedcounts $>$ \&}]{counts }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em TT} & \#\+TT by 3 list of list of adjacency triangles (see \doxylink{triangle__triangle__adjacency_8h}{triangle\+\_\+triangle\+\_\+adjacency.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em counts} & \#C list of number of facets in each components \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a772265419ff3f9f3c3716644191fa4ff}\label{namespaceigl_a772265419ff3f9f3c3716644191fa4ff} 
\index{igl@{igl}!false\_barycentric\_subdivision@{false\_barycentric\_subdivision}}
\index{false\_barycentric\_subdivision@{false\_barycentric\_subdivision}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{false\_barycentric\_subdivision()}{false\_barycentric\_subdivision()}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
void igl\+::false\+\_\+barycentric\+\_\+subdivision (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Scalar $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Index $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Scalar $>$ \&}]{VD,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Index $>$ \&}]{FD }\end{DoxyParamCaption})}



Refine the mesh by adding the barycenter of each face. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 coordinates of the vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em VD} & \#V + \#F by 3 coordinate of the vertices of the dual mesh The added vertices are added at the end of VD (should not be same references as (V,F) \\
\hline
\mbox{\texttt{ out}}  & {\em FD} & \#F\texorpdfstring{$\ast$}{*}3 by 3 faces of the dual mesh \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a30b7f81580d0eb77cfa387adaa4e9c67}\label{namespaceigl_a30b7f81580d0eb77cfa387adaa4e9c67} 
\index{igl@{igl}!fast\_find\_intersections@{fast\_find\_intersections}}
\index{fast\_find\_intersections@{fast\_find\_intersections}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_find\_intersections()}{fast\_find\_intersections()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+V1 , typename Derived\+F1 , typename Derived\+V2 , typename Derived\+F2 , typename DerivedI , typename DerivedE $>$ \\
void igl\+::fast\+\_\+find\+\_\+intersections (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+V1 $>$ \&}]{V1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F1 $>$ \&}]{F1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+V2 $>$ \&}]{V2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F2 $>$ \&}]{F2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{intersect\+\_\+pairs,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{edges }\end{DoxyParamCaption})}



Identify triangles where two meshes interesect using AABBTree and tri\+\_\+tri\+\_\+intersection\+\_\+test\+\_\+3d. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V1} & \#V by 3 list representing vertices on the first mesh \\
\hline
\mbox{\texttt{ in}}  & {\em F1} & \#F by 3 list representing triangles on the first mesh \\
\hline
\mbox{\texttt{ in}}  & {\em V2} & \#V by 3 list representing vertices on the second mesh \\
\hline
\mbox{\texttt{ in}}  & {\em F2} & \#F by 3 list representing triangles on the second mesh \\
\hline
\mbox{\texttt{ out}}  & {\em intersect\+\_\+pairs} & correspondance list of intersecting triangles column 0 -\/ mesh 1, column 1 -\/ mesh2 ~\newline
 \\
\hline
\mbox{\texttt{ out}}  & {\em edges} & list of pairs of intersection edges\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1copyleft_1_1cgal_aad0ee9bfc55573ac2ac722c5d6e6d8bc}{copyleft\+::cgal\+::intersect\+\_\+other} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a768af49174bc1daafe45f9eedda6eb8f}\label{namespaceigl_a768af49174bc1daafe45f9eedda6eb8f} 
\index{igl@{igl}!fast\_find\_intersections@{fast\_find\_intersections}}
\index{fast\_find\_intersections@{fast\_find\_intersections}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_find\_intersections()}{fast\_find\_intersections()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+V1 , typename Derived\+F1 , typename Derived\+V2 , typename Derived\+F2 , typename DerivedI , typename DerivedE $>$ \\
void igl\+::fast\+\_\+find\+\_\+intersections (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ Derived\+V1, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+V1 $>$ \&}]{V1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F1 $>$ \&}]{F1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+V2 $>$ \&}]{V2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F2 $>$ \&}]{F2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{intersect\+\_\+pairs,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{edges }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tree} & -\/ \doxylink{classigl_1_1AABB}{AABB} tree bult from the first mesh \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2f1a7f1d5201633025a2ac99846b1b78}\label{namespaceigl_a2f1a7f1d5201633025a2ac99846b1b78} 
\index{igl@{igl}!fast\_find\_self\_intersections@{fast\_find\_self\_intersections}}
\index{fast\_find\_self\_intersections@{fast\_find\_self\_intersections}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_find\_self\_intersections()}{fast\_find\_self\_intersections()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedE $>$ \\
bool igl\+::fast\+\_\+find\+\_\+self\+\_\+intersections (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{intersect,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{edges }\end{DoxyParamCaption})}



Identify triangles where mesh intersects itself using AABBTree and tri\+\_\+tri\+\_\+intersection\+\_\+test\+\_\+3d. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list representing vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list representing triangles. \\
\hline
\mbox{\texttt{ out}}  & {\em intersect} & \#F by 1 indicator that triangle intersects anothe triangle \\
\hline
\mbox{\texttt{ out}}  & {\em edges} & list of pairs of intersection edges \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether any self-\/interections were found
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1copyleft_1_1cgal_a7169f4ae2fe2c11f7e878b41aa747fc2}{copyleft\+::cgal\+::remesh\+\_\+self\+\_\+intersections} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_aa607a0b8a29847a27f3e92685a652d51}\label{namespaceigl_aa607a0b8a29847a27f3e92685a652d51} 
\index{igl@{igl}!fast\_find\_self\_intersections@{fast\_find\_self\_intersections}}
\index{fast\_find\_self\_intersections@{fast\_find\_self\_intersections}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_find\_self\_intersections()}{fast\_find\_self\_intersections()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI $>$ \\
bool igl\+::fast\+\_\+find\+\_\+self\+\_\+intersections (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{intersect }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af9a50987fefc0df065fb3e2cde90c92e}\label{namespaceigl_af9a50987fefc0df065fb3e2cde90c92e} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [1/8]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename Derived\+CH , typename Derived\+CM , typename DerivedR , typename Derived\+EC $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{point\+\_\+indices,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&}]{CH,  }\item[{const int}]{expansion\+\_\+order,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CM $>$ \&}]{CM,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EC $>$ \&}]{EC }\end{DoxyParamCaption})}



Generate the precomputation for the fast winding number for point data \mbox{[}Barill et. 

al 2018\mbox{]}.

Given a set of 3D points P, with normals N, areas A, along with octree data, and an expansion order, we define a taylor series expansion at each octree cell.

The octree data is designed to come from \doxylink{namespaceigl_a3ff69240d0614e6f4ab20ff15b2f21a4}{igl\+::octree}, and the areas (if not obtained at scan time), may be calculated using \doxylink{namespaceigl_1_1copyleft_1_1cgal_a1240cef3d039ac518baca44025fe1adc}{igl\+::copyleft\+::cgal\+::point\+\_\+areas}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of point locations \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of point normals \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#P by 1 list of point areas \\
\hline
\mbox{\texttt{ in}}  & {\em point\+\_\+indices} & a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell\textquotesingle{}s points \\
\hline
\mbox{\texttt{ in}}  & {\em CH} & \#\+Octree\+Cells by 8, where the ith row is the indices of the ith octree cell\textquotesingle{}s children \\
\hline
\mbox{\texttt{ in}}  & {\em expansion\+\_\+order} & the order of the taylor expansion. We support 0,1,2. \\
\hline
\mbox{\texttt{ out}}  & {\em CM} & \#\+Octree\+Cells by 3 list of each cell\textquotesingle{}s center of mass \\
\hline
\mbox{\texttt{ out}}  & {\em R} & \#\+Octree\+Cells by 1 list of each cell\textquotesingle{}s maximum distance of any point to the center of mass \\
\hline
\mbox{\texttt{ out}}  & {\em EC} & \#\+Octree\+Cells by \#\+Taylor\+Coefficients list of expansion coefficients. (Note that \#\+Taylor\+Coefficients = \+\_\+\{i=1\}\texorpdfstring{$^\wedge$}{\string^}\{expansion\+\_\+order\} 3\texorpdfstring{$^\wedge$}{\string^}i)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1copyleft_1_1cgal_a1240cef3d039ac518baca44025fe1adc}{copyleft\+::cgal\+::point\+\_\+areas}, \doxylink{namespaceigl_a6f2969bd735df2588ce37026375ddefe}{knn} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a9f25aa098c2a53832cc8d86022bf0691}\label{namespaceigl_a9f25aa098c2a53832cc8d86022bf0691} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [2/8]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename Derived\+CH , typename Derived\+CM , typename DerivedR , typename Derived\+EC , typename DerivedQ , typename Beta\+Type , typename Derived\+WN $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{point\+\_\+indices,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&}]{CH,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CM $>$ \&}]{CM,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EC $>$ \&}]{EC,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{const Beta\+Type}]{beta,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&}]{WN }\end{DoxyParamCaption})}



Evaluate the fast winding number for point data, having already done the the precomputation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of point locations \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of point normals \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#P by 1 list of point areas \\
\hline
\mbox{\texttt{ in}}  & {\em point\+\_\+indices} & a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell\textquotesingle{}s points \\
\hline
\mbox{\texttt{ in}}  & {\em CH} & \#\+Octree\+Cells by 8, where the ith row is the indices of the ith octree cell\textquotesingle{}s children \\
\hline
\mbox{\texttt{ in}}  & {\em CM} & \#\+Octree\+Cells by 3 list of each cell\textquotesingle{}s center of mass \\
\hline
\mbox{\texttt{ in}}  & {\em R} & \#\+Octree\+Cells by 1 list of each cell\textquotesingle{}s maximum distance of any point to the center of mass \\
\hline
\mbox{\texttt{ in}}  & {\em EC} & \#\+Octree\+Cells by \#\+Taylor\+Coefficients list of expansion coefficients. (Note that \#\+Taylor\+Coefficients = \+\_\+\{i=1\}\texorpdfstring{$^\wedge$}{\string^}\{expansion\+\_\+order\} 3\texorpdfstring{$^\wedge$}{\string^}i) \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & \#Q by 3 list of query points for the winding number \\
\hline
\mbox{\texttt{ in}}  & {\em beta} & This is a Barnes-\/\+Hut style accuracy term that separates near feild from far field. The higher the beta, the more accurate and slower the evaluation. We reccommend using a beta value of 2. Note that for a beta value  0, we use the direct evaluation, rather than the fast approximation \\
\hline
\mbox{\texttt{ out}}  & {\em WN} & \#Q by 1 list of windinng number values at each query point \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a397e83be466a676e5e932eb176222024}\label{namespaceigl_a397e83be466a676e5e932eb176222024} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [3/8]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename Beta\+Type , typename Derived\+WN $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{const int}]{expansion\+\_\+order,  }\item[{const Beta\+Type}]{beta,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&}]{WN }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Evaluate the fast winding number for point data without caching the precomputation. \Hypertarget{namespaceigl_ad8da00864c2893af6726906818520d94}\label{namespaceigl_ad8da00864c2893af6726906818520d94} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [4/8]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename Derived\+WN $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WN $>$ \&}]{WN }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ab8c8f607d6379a200ca2b06d48a177c7}\label{namespaceigl_ab8c8f607d6379a200ca2b06d48a177c7} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [5/8]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedQ , typename DerivedW $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Compute approximate winding number of a triangle soup mesh according to "{}\+Fast Winding Numbers for Soups and Clouds"{} \mbox{[}Barill et al. 

2018\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle mesh indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & \#Q by 3 list of query positions \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#Q list of winding number values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a903c781c6e83ef8f7cf2f8791a603cff}\label{namespaceigl_a903c781c6e83ef8f7cf2f8791a603cff} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [6/8]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{order,  }\item[{Fast\+Winding\+Number\+BVH \&}]{fwn\+\_\+bvh }\end{DoxyParamCaption})}



Precomputation for computing approximate winding numbers of a triangle soup. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle mesh indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em order} & Taylor series expansion order to use (e.\+g., 2) \\
\hline
\mbox{\texttt{ out}}  & {\em fwn\+\_\+bvh} & Precomputed bounding volume hierarchy \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a82cd97bb9dcfdb31036cb2d61a8feec7}\label{namespaceigl_a82cd97bb9dcfdb31036cb2d61a8feec7} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [7/8]}}
{\footnotesize\ttfamily template$<$typename DerivedQ , typename DerivedW $>$ \\
void igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Fast\+Winding\+Number\+BVH \&}]{fwn\+\_\+bvh,  }\item[{const float}]{accuracy\+\_\+scale,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



After precomputation, compute winding number at a each of many points in a list. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fwn\+\_\+bvh} & Precomputed bounding volume hierarchy \\
\hline
\mbox{\texttt{ in}}  & {\em accuracy\+\_\+scale} & parameter controlling accuracy (e.\+g., 2) \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & \#Q by 3 list of query positions \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#Q list of winding number values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3142103ed9b3cdf64d5a81fbaa34dc4c}\label{namespaceigl_a3142103ed9b3cdf64d5a81fbaa34dc4c} 
\index{igl@{igl}!fast\_winding\_number@{fast\_winding\_number}}
\index{fast\_winding\_number@{fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fast\_winding\_number()}{fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [8/8]}}
{\footnotesize\ttfamily template$<$typename Derivedp $>$ \\
Derivedp\+::\+Scalar igl\+::fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Fast\+Winding\+Number\+BVH \&}]{fwn\+\_\+bvh,  }\item[{const float}]{accuracy\+\_\+scale,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&}]{p }\end{DoxyParamCaption})}



After precomputation, compute winding number at a single point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em fwn\+\_\+bvh} & Precomputed bounding volume hierarchy \\
\hline
\mbox{\texttt{ in}}  & {\em accuracy\+\_\+scale} & parameter controlling accuracy (e.\+g., 2) \\
\hline
\mbox{\texttt{ in}}  & {\em p} & single position \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
w winding number of this point 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a740022c998c2a894e28fb49bb7ed4d24}\label{namespaceigl_a740022c998c2a894e28fb49bb7ed4d24} 
\index{igl@{igl}!file\_contents\_as\_string@{file\_contents\_as\_string}}
\index{file\_contents\_as\_string@{file\_contents\_as\_string}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{file\_contents\_as\_string()}{file\_contents\_as\_string()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::file\+\_\+contents\+\_\+as\+\_\+string (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{std\+::string \&}]{content }\end{DoxyParamCaption})}



Read a files contents as plain text into a given string. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+\_\+name} & path to file to be read \\
\hline
\mbox{\texttt{ out}}  & {\em content} & output string containing contents of the given file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on succes, false on error 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a555b9d7f83d39b3fc2dee6eabb79c0ec}\label{namespaceigl_a555b9d7f83d39b3fc2dee6eabb79c0ec} 
\index{igl@{igl}!file\_contents\_as\_string@{file\_contents\_as\_string}}
\index{file\_contents\_as\_string@{file\_contents\_as\_string}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{file\_contents\_as\_string()}{file\_contents\_as\_string()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string igl\+::file\+\_\+contents\+\_\+as\+\_\+string (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a784c417892e831c40ced7805b23be275}\label{namespaceigl_a784c417892e831c40ced7805b23be275} 
\index{igl@{igl}!file\_dialog\_open@{file\_dialog\_open}}
\index{file\_dialog\_open@{file\_dialog\_open}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{file\_dialog\_open()}{file\_dialog\_open()}}
{\footnotesize\ttfamily std\+::string igl\+::file\+\_\+dialog\+\_\+open (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Open a file dialog to select a file. 

\begin{DoxyReturn}{Returns}
string with a path to an existing file or empty if no file is selected (on Linux machines, it assumes that Zenity is installed) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a85f585cff929022ed45d00faee99eea3}\label{namespaceigl_a85f585cff929022ed45d00faee99eea3} 
\index{igl@{igl}!file\_dialog\_save@{file\_dialog\_save}}
\index{file\_dialog\_save@{file\_dialog\_save}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{file\_dialog\_save()}{file\_dialog\_save()}}
{\footnotesize\ttfamily std\+::string igl\+::file\+\_\+dialog\+\_\+save (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Open a file dialog to select a file. 

\begin{DoxyReturn}{Returns}
string with a path to a new or existing file or empty if no file is selected (on Linux machines, it assumes that Zenity is installed) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a63e14036599fdc6d4f6706d26a542e92}\label{namespaceigl_a63e14036599fdc6d4f6706d26a542e92} 
\index{igl@{igl}!file\_exists@{file\_exists}}
\index{file\_exists@{file\_exists}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{file\_exists()}{file\_exists()}}
{\footnotesize\ttfamily bool igl\+::file\+\_\+exists (\begin{DoxyParamCaption}\item[{const std\+::string}]{filename }\end{DoxyParamCaption})}



Check if a file or directory exists like PHP\textquotesingle{}s file\+\_\+exists function\+: 

\href{http://php.net/manual/en/function.file-exists.php}{\texttt{ http\+://php.\+net/manual/en/function.\+file-\/exists.\+php}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & path to file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if file exists and is readable and false if file doesn\textquotesingle{}t exist or {\itshape is not readable} 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ad0ba264f987871035fb7d12de96fccab}\label{namespaceigl_ad0ba264f987871035fb7d12de96fccab} 
\index{igl@{igl}!find@{find}}
\index{find@{find}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$typename T , typename DerivedI , typename DerivedJ , typename DerivedV $>$ \\
void igl\+::find (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X,  }\item[{Eigen\+::\+Dense\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Dense\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Dense\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



Find the non-\/zero entries and there respective indices in a sparse matrix. 

Like matlab\textquotesingle{}s \mbox{[}I,J,V\mbox{]} = find(\+X)


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix whose entries are to be found \\
\hline
\mbox{\texttt{ out}}  & {\em I} & nnz vector of row indices of non zeros entries in X \\
\hline
\mbox{\texttt{ out}}  & {\em J} & nnz vector of column indices of non zeros entries in X \\
\hline
\mbox{\texttt{ out}}  & {\em V} & nnz vector of type T non-\/zeros entries in X \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7ed5d2d6c493023192c2b2f1c5ed0bf0}\label{namespaceigl_a7ed5d2d6c493023192c2b2f1c5ed0bf0} 
\index{igl@{igl}!find@{find}}
\index{find@{find}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$ Eigen\+::\+Triplet$<$ T $>$ $>$ igl\+::find (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a2f6c699f94449b23813f0d80df36db8e}\label{namespaceigl_a2f6c699f94449b23813f0d80df36db8e} 
\index{igl@{igl}!find@{find}}
\index{find@{find}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedI , typename DerivedJ , typename DerivedV $>$ \\
void igl\+::find (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a1c874cf1ad179744026898ded3da4ea7}\label{namespaceigl_a1c874cf1ad179744026898ded3da4ea7} 
\index{igl@{igl}!find@{find}}
\index{find@{find}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedI $>$ \\
void igl\+::find (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em I} & nnz vector of indices into vectorization of X \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab6758ca13380f9bd099c860aba705d45}\label{namespaceigl_ab6758ca13380f9bd099c860aba705d45} 
\index{igl@{igl}!find@{find}}
\index{find@{find}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::find (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Vector$<$ T $>$ \&}]{X,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{I,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&}]{V }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a35cd54b6c6bf02c39e4caf02782fcfbc}\label{namespaceigl_a35cd54b6c6bf02c39e4caf02782fcfbc} 
\index{igl@{igl}!find@{find}}
\index{find@{find}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find()}{find()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$int Rows\+At\+Compile\+Time, int Max\+Rows\+At\+Compile\+Time$>$ \\
std\+::vector$<$ int $>$ igl\+::find (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Array$<$ bool, Rows\+At\+Compile\+Time, 1, 0, Max\+Rows\+At\+Compile\+Time, 1 $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

This overload facilitates the use of bool masks for Eigen slicing 
\begin{DoxyTemplParams}{Template Parameters}
{\em Rows\+At\+Compile\+Time} & number of rows in M at compile time \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
indices of true entries in M
\end{DoxyReturn}
\label{namespaceigl_autotoc_md13}%
\Hypertarget{namespaceigl_autotoc_md13}%
 \doxysubparagraph*{Example}


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_acb30d6061d773254628256682b88b427}{igl::slice\_mask}}(A,\mbox{\hyperlink{namespaceigl_ad0ba264f987871035fb7d12de96fccab}{igl::find}}(M),\mbox{\hyperlink{namespaceigl_ad0ba264f987871035fb7d12de96fccab}{igl::find}}(N),B);}
\DoxyCodeLine{\textcolor{comment}{//\ Is\ the\ same\ as}}
\DoxyCodeLine{B\ =\ A(\mbox{\hyperlink{namespaceigl_ad0ba264f987871035fb7d12de96fccab}{igl::find}}(M),\mbox{\hyperlink{namespaceigl_ad0ba264f987871035fb7d12de96fccab}{igl::find}}(N));}

\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acb30d6061d773254628256682b88b427}{slice\+\_\+mask} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_abb0edb6d4f1aed375b757bdc5c273246}\label{namespaceigl_abb0edb6d4f1aed375b757bdc5c273246} 
\index{igl@{igl}!find\_cross\_field\_singularities@{find\_cross\_field\_singularities}}
\index{find\_cross\_field\_singularities@{find\_cross\_field\_singularities}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find\_cross\_field\_singularities()}{find\_cross\_field\_singularities()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO $>$ \\
void igl\+::find\+\_\+cross\+\_\+field\+\_\+singularities (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{mismatch,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{is\+Singularity,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{singularity\+Index }\end{DoxyParamCaption})}



Computes singularities of a cross field, assumed combed. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em mismatch} & \#F by 3 eigen Matrix containing the integer mismatch of the cross field across all face edges \\
\hline
\mbox{\texttt{ out}}  & {\em is\+Singularity} & \#V by 1 boolean eigen Vector indicating the presence of a singularity on a vertex \\
\hline
\mbox{\texttt{ out}}  & {\em singularity\+Index} & \#V by 1 integer eigen Vector containing the singularity indices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6081a94201c4aee0d64d44fb108b82b3}\label{namespaceigl_a6081a94201c4aee0d64d44fb108b82b3} 
\index{igl@{igl}!find\_cross\_field\_singularities@{find\_cross\_field\_singularities}}
\index{find\_cross\_field\_singularities@{find\_cross\_field\_singularities}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find\_cross\_field\_singularities()}{find\_cross\_field\_singularities()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedO $>$ \\
void igl\+::find\+\_\+cross\+\_\+field\+\_\+singularities (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{PD2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{is\+Singularity,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{singularity\+Index,  }\item[{bool}]{is\+Combed = {\ttfamily false} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper that calculates the mismatch if it is not provided.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em PD1} & \#F by 3 eigen Matrix of the first per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em PD2} & \#F by 3 eigen Matrix of the second per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em is\+Combed} & boolean indicating whether the cross field is combed\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
the field in PD1 and PD2 MUST BE combed (see \doxylink{namespaceigl_a42d3578aca0da0bea74041ca2b239c1d}{igl\+::comb\+\_\+cross\+\_\+field}). 
\end{DoxyNote}
\Hypertarget{namespaceigl_a805390aaedf0c7993e52697b46e85be8}\label{namespaceigl_a805390aaedf0c7993e52697b46e85be8} 
\index{igl@{igl}!find\_zero@{find\_zero}}
\index{find\_zero@{find\_zero}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{find\_zero()}{find\_zero()}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedI $>$ \\
void igl\+::find\+\_\+zero (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Find the first zero (whether implicit or explicitly stored) in the rows/columns of a matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to check for any (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & n-\/long vector (if dim == 1) \{m means no zeros found\} or m-\/long vector (if dim == 2) \{n means no zeros found\} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7e61e6506e142c21944010806e350df3}\label{namespaceigl_a7e61e6506e142c21944010806e350df3} 
\index{igl@{igl}!fit\_cubic\_bezier@{fit\_cubic\_bezier}}
\index{fit\_cubic\_bezier@{fit\_cubic\_bezier}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fit\_cubic\_bezier()}{fit\_cubic\_bezier()}}
{\footnotesize\ttfamily void igl\+::fit\+\_\+cubic\+\_\+bezier (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{d,  }\item[{const double}]{error,  }\item[{std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{cubics }\end{DoxyParamCaption})}



Fit a cubic bezier spline (G1 continuous) to an ordered list of input points in any dimension, according to "{}\+An algorithm for automatically fitting digitized curves"{} \mbox{[}Schneider 1990\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em d} & \#d by dim list of points along a curve to be fit with a cubic bezier spline (should probably be roughly uniformly spaced). If d(0)==d(end), then will treat as a closed curve. \\
\hline
\mbox{\texttt{ in}}  & {\em error} & maximum squared distance allowed \\
\hline
\mbox{\texttt{ out}}  & {\em cubics} & \#cubics list of 4 by dim lists of cubic control points \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a30fbe8999a386dbd7193683db1ed7ea7}\label{namespaceigl_a30fbe8999a386dbd7193683db1ed7ea7} 
\index{igl@{igl}!fit\_cubic\_bezier\_substring@{fit\_cubic\_bezier\_substring}}
\index{fit\_cubic\_bezier\_substring@{fit\_cubic\_bezier\_substring}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fit\_cubic\_bezier\_substring()}{fit\_cubic\_bezier\_substring()}}
{\footnotesize\ttfamily void igl\+::fit\+\_\+cubic\+\_\+bezier\+\_\+substring (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{d,  }\item[{const int}]{first,  }\item[{const int}]{last,  }\item[{const Eigen\+::\+Row\+Vector\+Xd \&}]{t\+Hat1,  }\item[{const Eigen\+::\+Row\+Vector\+Xd \&}]{t\+Hat2,  }\item[{const double}]{error,  }\item[{const bool}]{force\+\_\+split,  }\item[{std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{cubics }\end{DoxyParamCaption})}



Recursive helper function for fit\+\_\+cubic\+\_\+bezier. 

\doxylink{fit__cubic__bezier_8h}{include/igl/fit\+\_\+cubic\+\_\+bezier.\+h}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em first} & index of first point in d of substring \\
\hline
\mbox{\texttt{ in}}  & {\em last} & index of last point in d of substring \\
\hline
\mbox{\texttt{ in}}  & {\em t\+Hat1} & tangent to use at beginning of spline \\
\hline
\mbox{\texttt{ in}}  & {\em t\+Hat2} & tangent to use at end of spline \\
\hline
\mbox{\texttt{ in}}  & {\em error} & see above \\
\hline
\mbox{\texttt{ in}}  & {\em force\+\_\+split} & whether to force a split (i.\+e., force a recursive call) \\
\hline
\mbox{\texttt{ in}}  & {\em cubics} & running list of cubics so far \\
\hline
\mbox{\texttt{ out}}  & {\em cubics} & running list of cubics so far (new cubics appended) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ade7e5fc6b5fac0540a715a429d1196da}\label{namespaceigl_ade7e5fc6b5fac0540a715a429d1196da} 
\index{igl@{igl}!fit\_plane@{fit\_plane}}
\index{fit\_plane@{fit\_plane}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fit\_plane()}{fit\_plane()}}
{\footnotesize\ttfamily void igl\+::fit\+\_\+plane (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Row\+Vector3d \&}]{N,  }\item[{Eigen\+::\+Row\+Vector3d \&}]{C }\end{DoxyParamCaption})}



Fit a plane to a point cloud. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#\+Vx3 matrix. The 3D point cloud, one row for each vertex. \\
\hline
\mbox{\texttt{ out}}  & {\em N} & 1x3 Vector. The normal of the fitted plane. \\
\hline
\mbox{\texttt{ out}}  & {\em C} & 1x3 Vector. A point that lies in the fitted plane.\\
\hline
\end{DoxyParams}
From \href{http://missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html}{\texttt{ http\+://missingbytes.\+blogspot.\+com/2012/06/fitting-\/plane-\/to-\/point-\/cloud.\+html}} \Hypertarget{namespaceigl_aab9cbb962b540c16acdca0c7d168345d}\label{namespaceigl_aab9cbb962b540c16acdca0c7d168345d} 
\index{igl@{igl}!fit\_rotations@{fit\_rotations}}
\index{fit\_rotations@{fit\_rotations}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fit\_rotations()}{fit\_rotations()}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedD $>$ \\
void igl\+::fit\+\_\+rotations (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const bool}]{single\+\_\+precision,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{R }\end{DoxyParamCaption})}



Given an input mesh and new positions find rotations for every covariance matrix in a stack of covariance matrices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & nr\texorpdfstring{$\ast$}{*}dim by dim stack of covariance matrices \\
\hline
\mbox{\texttt{ in}}  & {\em single\+\_\+precision} & whether to use single precision (faster) \\
\hline
\mbox{\texttt{ out}}  & {\em R} & dim by dim \texorpdfstring{$\ast$}{*} nr list of rotations\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This seems to be implemented in Eigen/\+Geometry\+: Eigen\+::umeyama 
\end{DoxyNote}
\Hypertarget{namespaceigl_ac84591b34ac42f8f958c015edabec2d6}\label{namespaceigl_ac84591b34ac42f8f958c015edabec2d6} 
\index{igl@{igl}!fit\_rotations\_planar@{fit\_rotations\_planar}}
\index{fit\_rotations\_planar@{fit\_rotations\_planar}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{fit\_rotations\_planar()}{fit\_rotations\_planar()}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedD $>$ \\
void igl\+::fit\+\_\+rotations\+\_\+planar (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{R }\end{DoxyParamCaption})}



Given an input mesh and new positions find 2D rotations for every vertex that best maps its one ring to the new one ring. 

\doxylink{fit__rotations_8h}{include/igl/fit\+\_\+rotations.\+h}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & nr\texorpdfstring{$\ast$}{*}dim by dim stack of covariance matrices, third column and every third row will be ignored \\
\hline
\mbox{\texttt{ out}}  & {\em R} & dim by dim \texorpdfstring{$\ast$}{*} nr list of rotations, third row and third column of each rotation will just be identity \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae63ab7ae87908c83fc544443d41b87e5}\label{namespaceigl_ae63ab7ae87908c83fc544443d41b87e5} 
\index{igl@{igl}!flip\_avoiding\_line\_search@{flip\_avoiding\_line\_search}}
\index{flip\_avoiding\_line\_search@{flip\_avoiding\_line\_search}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{flip\_avoiding\_line\_search()}{flip\_avoiding\_line\_search()}}
{\footnotesize\ttfamily double igl\+::flip\+\_\+avoiding\+\_\+line\+\_\+search (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{cur\+\_\+v,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{dst\+\_\+v,  }\item[{std\+::function$<$ double(Eigen\+::\+Matrix\+Xd \&)$>$ \&}]{energy,  }\item[{double}]{cur\+\_\+energy = {\ttfamily -\/1} }\end{DoxyParamCaption})}



A bisection line search for a mesh based energy that avoids triangle flips as suggested in "{}\+Bijective Parameterization with Free Boundaries"{} (Smith J. 

and Schaefer S., 2015).

The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see \doxylink{namespaceigl_a9145bd261a2cf691294d8104c99a4ab9}{igl\+::line\+\_\+search}).

Supports both triangle and tet meshes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/4 list of mesh faces or tets \\
\hline
\mbox{\texttt{ in}}  & {\em cur\+\_\+v} & \#V by dim list of variables \\
\hline
\mbox{\texttt{ in}}  & {\em dst\+\_\+v} & \#V by dim list of target vertices. This mesh may have flipped triangles \\
\hline
\mbox{\texttt{ in}}  & {\em energy} & A function to compute the mesh-\/based energy (return an energy that is bigger than 0) \\
\hline
\mbox{\texttt{ in}}  & {\em cur\+\_\+energy(\+OPTIONAL)} & The energy at the given point. Helps save redundant computations. This is optional. If not specified, the function will compute it. \\
\hline
\mbox{\texttt{ out}}  & {\em cur\+\_\+v} & \#V by dim list of variables at the new location \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the energy at the new point 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ac891db77f570329431e6c333c3d08b26}\label{namespaceigl_ac891db77f570329431e6c333c3d08b26} 
\index{igl@{igl}!flip\_edge@{flip\_edge}}
\index{flip\_edge@{flip\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{flip\_edge()}{flip\_edge()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType $>$ \\
void igl\+::flip\+\_\+edge (\begin{DoxyParamCaption}\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{const size\+\_\+t}]{uei }\end{DoxyParamCaption})}



Flip an edge in a triangle mesh. 

The edge specified by uei must have exactly {\bfseries{two}} adjacent faces. Violation will result in exception. Another warning\+: edge flipping could convert manifold mesh into non-\/manifold.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 list of triangles. \\
\hline
\mbox{\texttt{ in,out}}  & {\em E} & \#F\texorpdfstring{$\ast$}{*}3 by 2 list of all of directed edges \\
\hline
\mbox{\texttt{ in,out}}  & {\em uE} & \#uE by 2 list of unique undirected edges \\
\hline
\mbox{\texttt{ in,out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique undirected edge \\
\hline
\mbox{\texttt{ in,out}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges \\
\hline
\mbox{\texttt{ in}}  & {\em ue} & index into uE the edge to be flipped. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6f82175bae9b6801c8c9012785317f2a}\label{namespaceigl_a6f82175bae9b6801c8c9012785317f2a} 
\index{igl@{igl}!flipped\_triangles@{flipped\_triangles}}
\index{flipped\_triangles@{flipped\_triangles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{flipped\_triangles()}{flipped\_triangles()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedX $>$ \\
void igl\+::flipped\+\_\+triangles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X }\end{DoxyParamCaption})}



Finds the ids of the flipped triangles of the mesh V,F in the UV mapping uv. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em X} & \#flipped list of containing the indices into F of the flipped triangles \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a20a1df627820c7b21a02a7ec429af4e7}\label{namespaceigl_a20a1df627820c7b21a02a7ec429af4e7} 
\index{igl@{igl}!flipped\_triangles@{flipped\_triangles}}
\index{flipped\_triangles@{flipped\_triangles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{flipped\_triangles()}{flipped\_triangles()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
Eigen\+::\+Vector\+Xi igl\+::flipped\+\_\+triangles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Scalar $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Index $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ac512b1b084fa118f737ffc49db7a5ba6}\label{namespaceigl_ac512b1b084fa118f737ffc49db7a5ba6} 
\index{igl@{igl}!flood\_fill@{flood\_fill}}
\index{flood\_fill@{flood\_fill}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{flood\_fill()}{flood\_fill()}}
{\footnotesize\ttfamily template$<$typename Derivedres , typename DerivedS $>$ \\
void igl\+::flood\+\_\+fill (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedres $>$ \&}]{res,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Given a 3D array with sparse non-\/nan (number?) data fill in the Na\+Ns via flood fill. 

This should ensure that, e.\+g., if data near 0 always has a band (surface) of numbered and signed data, then components of nans will be correctly signed.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em res} & 3-\/long list of dimensions of grid \\
\hline
\mbox{\texttt{ in,out}}  & {\em S} & res(0)\texorpdfstring{$\ast$}{*}res(1)\texorpdfstring{$\ast$}{*}res(2) list of scalar values (with (many) nans), flood fill data in place \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a52b113177cc099be08ae55cad66b4dcb}\label{namespaceigl_a52b113177cc099be08ae55cad66b4dcb} 
\index{igl@{igl}!floor@{floor}}
\index{floor@{floor}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{floor()}{floor()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::floor (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



Floor a given matrix to nearest integers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix of scalars \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n matrix of floored integers \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a09311547ed4f12bee75c2631d2d19bfd}\label{namespaceigl_a09311547ed4f12bee75c2631d2d19bfd} 
\index{igl@{igl}!for\_each@{for\_each}}
\index{for\_each@{for\_each}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{for\_each()}{for\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename AType , typename Func $>$ \\
void igl\+::for\+\_\+each (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const Func \&}]{func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



FOR\+\_\+\+EACH Call a given function for each non-\/zero (i.\+e., explicit value might actually be ==0) in a Sparse Matrix A {\itshape in order (of storage)}. 

This is useless unless func has {\itshape side-\/effects}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em func} & function handle with prototype "{}compatible with"{} {\ttfamily void (Index i, Index j, Scalar \& v)}. Return values will be ignored.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
std\+::for\+\_\+each 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a99ebd81ebaff178e507beedf87766722}\label{namespaceigl_a99ebd81ebaff178e507beedf87766722} 
\index{igl@{igl}!for\_each@{for\_each}}
\index{for\_each@{for\_each}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{for\_each()}{for\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename Func $>$ \\
void igl\+::for\+\_\+each (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Func \&}]{func }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a583ee685a22b43577be16d088b6d3f29}\label{namespaceigl_a583ee685a22b43577be16d088b6d3f29} 
\index{igl@{igl}!forward\_kinematics@{forward\_kinematics}}
\index{forward\_kinematics@{forward\_kinematics}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{forward\_kinematics()}{forward\_kinematics()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void igl\+::forward\+\_\+kinematics (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{P,  }\item[{const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{dQ,  }\item[{const std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&}]{dT,  }\item[{std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{vQ,  }\item[{std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&}]{vT }\end{DoxyParamCaption})}



Given a skeleton and a set of relative bone rotations compute absolute rigid transformations for each bone. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em C} & \#C by dim list of joint positions \\
\hline
\mbox{\texttt{ in}}  & {\em BE} & \#\+BE by 2 list of bone edge indices \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#\+BE list of parent indices into BE \\
\hline
\mbox{\texttt{ in}}  & {\em dQ} & \#\+BE list of relative rotations \\
\hline
\mbox{\texttt{ in}}  & {\em dT} & \#\+BE list of relative translations \\
\hline
\mbox{\texttt{ out}}  & {\em vQ} & \#\+BE list of absolute rotations \\
\hline
\mbox{\texttt{ out}}  & {\em vT} & \#\+BE list of absolute translations \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4346a6b4e9b7d07955fe6ab59399e82e}\label{namespaceigl_a4346a6b4e9b7d07955fe6ab59399e82e} 
\index{igl@{igl}!forward\_kinematics@{forward\_kinematics}}
\index{forward\_kinematics@{forward\_kinematics}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{forward\_kinematics()}{forward\_kinematics()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void igl\+::forward\+\_\+kinematics (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{P,  }\item[{const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{dQ,  }\item[{std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{vQ,  }\item[{std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&}]{vT }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

assuming each dT\mbox{[}i\mbox{]} == \{0,0,0\} \Hypertarget{namespaceigl_a9be847e42a2d294cdb9014c5b04d5649}\label{namespaceigl_a9be847e42a2d294cdb9014c5b04d5649} 
\index{igl@{igl}!forward\_kinematics@{forward\_kinematics}}
\index{forward\_kinematics@{forward\_kinematics}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{forward\_kinematics()}{forward\_kinematics()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void igl\+::forward\+\_\+kinematics (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{P,  }\item[{const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{dQ,  }\item[{const std\+::vector$<$ Eigen\+::\+Vector3d $>$ \&}]{dT,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em T} & \#\+BE\texorpdfstring{$\ast$}{*}(dim+1) by dim stack of transposed transformation matrices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adedacc380a9c0e97fcb830413a407aee}\label{namespaceigl_adedacc380a9c0e97fcb830413a407aee} 
\index{igl@{igl}!forward\_kinematics@{forward\_kinematics}}
\index{forward\_kinematics@{forward\_kinematics}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{forward\_kinematics()}{forward\_kinematics()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void igl\+::forward\+\_\+kinematics (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{P,  }\item[{const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$ \&}]{dQ,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a2da75428de04db095ad2b8c01861d9e7}\label{namespaceigl_a2da75428de04db095ad2b8c01861d9e7} 
\index{igl@{igl}!frame\_field\_deformer@{frame\_field\_deformer}}
\index{frame\_field\_deformer@{frame\_field\_deformer}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{frame\_field\_deformer()}{frame\_field\_deformer()}}
{\footnotesize\ttfamily void igl\+::frame\+\_\+field\+\_\+deformer (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{FF1,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{FF2,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V\+\_\+d,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{FF1\+\_\+d,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{FF2\+\_\+d,  }\item[{const int}]{iterations = {\ttfamily 50},  }\item[{const double}]{lambda = {\ttfamily 0.1},  }\item[{const bool}]{perturb\+\_\+initial\+\_\+guess = {\ttfamily true} }\end{DoxyParamCaption})}



Deform a mesh to transform the given per-\/face frame field to be as close as possible to a cross field, in the least square sense. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 coordinates of the vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em FF1} & \#F by 3 first representative vector of the frame field \\
\hline
\mbox{\texttt{ in}}  & {\em FF2} & \#F by 3 second representative vector of the frame field \\
\hline
\mbox{\texttt{ out}}  & {\em V\+\_\+d} & \#V? by 3 deformed, first representative vector?? \\
\hline
\mbox{\texttt{ out}}  & {\em FF1\+\_\+d} & \#F by 3 deformed, first representative vector?? \\
\hline
\mbox{\texttt{ out}}  & {\em FF2\+\_\+d} & \#F by 3 deformed, first representative vector?? \\
\hline
\mbox{\texttt{ in}}  & {\em iterations} & number of iterations \\
\hline
\mbox{\texttt{ in}}  & {\em lambda} & laplacian regularization parameter 0=no regularization 1=full regularization \\
\hline
\mbox{\texttt{ in}}  & {\em perturb\+\_\+initial\+\_\+guess} & whether to perturb the initial guess \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9b1822be03089dbefc97ae0274f7f744}\label{namespaceigl_a9b1822be03089dbefc97ae0274f7f744} 
\index{igl@{igl}!frame\_to\_cross\_field@{frame\_to\_cross\_field}}
\index{frame\_to\_cross\_field@{frame\_to\_cross\_field}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{frame\_to\_cross\_field()}{frame\_to\_cross\_field()}}
{\footnotesize\ttfamily void igl\+::frame\+\_\+to\+\_\+cross\+\_\+field (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{FF1,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{FF2,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{X }\end{DoxyParamCaption})}



Convert a frame field into its closest cross field. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 coordinates of the vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em FF1} & \#F by 3 the first representative vector of the frame field (up to permutation and sign) \\
\hline
\mbox{\texttt{ in}}  & {\em FF2} & \#F by 3 the second representative vector of the frame field (up to permutation and sign) \\
\hline
\mbox{\texttt{ out}}  & {\em X} & \#F by 3 representative vector of the closest cross field \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_acd2f248b52f9534c49484e76be8aa0bc}\label{namespaceigl_acd2f248b52f9534c49484e76be8aa0bc} 
\index{igl@{igl}!frustum@{frustum}}
\index{frustum@{frustum}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{frustum()}{frustum()}}
{\footnotesize\ttfamily template$<$typename DerivedP $>$ \\
void igl\+::frustum (\begin{DoxyParamCaption}\item[{const typename Derived\+P\+::\+Scalar}]{left,  }\item[{const typename Derived\+P\+::\+Scalar}]{right,  }\item[{const typename Derived\+P\+::\+Scalar}]{bottom,  }\item[{const typename Derived\+P\+::\+Scalar}]{top,  }\item[{const typename Derived\+P\+::\+Scalar}]{near\+Val,  }\item[{const typename Derived\+P\+::\+Scalar}]{far\+Val,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Implementation of the deprecated gl\+Frustum function. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em left} & coordinate of left vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em right} & coordinate of right vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em bottom} & coordinate of bottom vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em top} & coordinate of top vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em near\+Val} & distance to near plane \\
\hline
\mbox{\texttt{ in}}  & {\em far\+Val} & distance to far plane \\
\hline
\mbox{\texttt{ out}}  & {\em P} & 4x4 perspective matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad31a0406b0fb32f5345361442c0e85c9}\label{namespaceigl_ad31a0406b0fb32f5345361442c0e85c9} 
\index{igl@{igl}!gaussian\_curvature@{gaussian\_curvature}}
\index{gaussian\_curvature@{gaussian\_curvature}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{gaussian\_curvature()}{gaussian\_curvature()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ \\
void igl\+::gaussian\+\_\+curvature (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Compute the 2 minus the sum of interior angles at each vertex. 

For interior vertices of a manifold mesh this corresponds to the local integral gaussian curvature ("{}angle deficit"{}, without averaging by local area). For boundary vertices, this quantity is not so meaninful. FWIW, adding  to the output for boundary vertices would produce local integral geodesic curvature along the boundary curve.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#V by 1 eigen Matrix of discrete gaussian curvature values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}\label{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e} 
\index{igl@{igl}!generate\_default\_urbg@{generate\_default\_urbg}}
\index{generate\_default\_urbg@{generate\_default\_urbg}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{generate\_default\_urbg()}{generate\_default\_urbg()}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceigl_a60bbc303acee156af52ab587c4680502}{DEFAULT\+\_\+\+URBG}} igl\+::generate\+\_\+default\+\_\+urbg (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_a14a7a848b8b1eb296b5c8b80efc05efc}\label{namespaceigl_a14a7a848b8b1eb296b5c8b80efc05efc} 
\index{igl@{igl}!get\_seconds@{get\_seconds}}
\index{get\_seconds@{get\_seconds}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{get\_seconds()}{get\_seconds()}}
{\footnotesize\ttfamily double igl\+::get\+\_\+seconds (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Current time in seconds. 

\begin{DoxyReturn}{Returns}
the current time in seconds since epoch
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md14}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md14}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \&\ tictoc\ =\ []()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keyword}{static}\ \textcolor{keywordtype}{double}\ t\_start\ =\ \mbox{\hyperlink{namespaceigl_a14a7a848b8b1eb296b5c8b80efc05efc}{igl::get\_seconds}}();}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{double}\ diff\ =\ \mbox{\hyperlink{namespaceigl_a14a7a848b8b1eb296b5c8b80efc05efc}{igl::get\_seconds}}()-\/t\_start;}
\DoxyCodeLine{\ \ t\_start\ +=\ diff;}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{return}\ diff;}
\DoxyCodeLine{\};}
\DoxyCodeLine{tictoc();}
\DoxyCodeLine{...\ \textcolor{comment}{//\ part\ 1}}
\DoxyCodeLine{cout<<\textcolor{stringliteral}{"{}part\ 1:\ "{}}<<tictoc()<<endl;}
\DoxyCodeLine{...\ \textcolor{comment}{//\ part\ 2}}
\DoxyCodeLine{cout<<\textcolor{stringliteral}{"{}part\ 2:\ "{}}<<tictoc()<<endl;}
\DoxyCodeLine{...\ \textcolor{comment}{//\ etc}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_afc61afb5c46c76e8be9fcca2e4783d53}\label{namespaceigl_afc61afb5c46c76e8be9fcca2e4783d53} 
\index{igl@{igl}!grad@{grad}}
\index{grad@{grad}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{grad()}{grad()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::grad (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ typename Derived\+V\+::\+Scalar $>$ \&}]{G,  }\item[{bool}]{uniform = {\ttfamily false} }\end{DoxyParamCaption})}



Gradient operator on a triangle mesh. 

Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle \mbox{[}tetrahedron\mbox{]} i,j,k\+: grad(\+Xijk) = (Xj-\/\+Xi) \texorpdfstring{$\ast$}{*} (Vi -\/ Vk)\texorpdfstring{$^\wedge$}{\string^}\+R90 / 2A + (Xk-\/\+Xi) \texorpdfstring{$\ast$}{*} (Vj -\/ Vi)\texorpdfstring{$^\wedge$}{\string^}\+R90 / 2A where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). \texorpdfstring{$^\wedge$}{\string^}\+R90 represent a rotation of 90 degrees


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#vertices by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#faces by 3 list of mesh face indices \mbox{[}or a \#faces by 4 list of tetrahedral indices\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#faces\texorpdfstring{$\ast$}{*}dim by \#V Gradient operator \\
\hline
\mbox{\texttt{ in}}  & {\em uniform} & boolean (default false) -\/ Use a uniform mesh instead of the vertices V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae277a1d4cf02f1612ad3c7bb47fc93f7}\label{namespaceigl_ae277a1d4cf02f1612ad3c7bb47fc93f7} 
\index{igl@{igl}!grad\_intrinsic@{grad\_intrinsic}}
\index{grad\_intrinsic@{grad\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{grad\_intrinsic()}{grad\_intrinsic()}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedF , typename Gtype $>$ \\
void igl\+::grad\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Gtype $>$ \&}]{G }\end{DoxyParamCaption})}



Construct an intrinsic gradient operator. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#F by 3 list of edge lengths \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into some vertex list V \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#F\texorpdfstring{$\ast$}{*}2 by \#V gradient matrix\+: G=\mbox{[}Gx;Gy\mbox{]} where x runs along the 23 edge and y runs in the counter-\/clockwise 90 rotation. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adfb4bab2b437369dce2059e85836bd9a}\label{namespaceigl_adfb4bab2b437369dce2059e85836bd9a} 
\index{igl@{igl}!grid@{grid}}
\index{grid@{grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{grid()}{grid()}}
{\footnotesize\ttfamily template$<$typename Derivedres , typename Derived\+GV $>$ \\
void igl\+::grid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedres $>$ \&}]{res,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&}]{GV }\end{DoxyParamCaption})}



Construct vertices of a regular grid, suitable for input to {\ttfamily \doxylink{namespaceigl_a3e677970b7188cac95bc9f93181f2ed7}{igl\+::marching\+\_\+cubes}} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em res} & \#res list of number of vertices along each dimension filling a unit \#res-\/cube \\
\hline
\mbox{\texttt{ out}}  & {\em GV} & res.\+array().prod() by \#res list of mesh vertex positions.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a3be3b842294c1e29d654ace1e4f735ca}{triangulated\+\_\+grid}, \doxylink{namespaceigl_acb165fc9bf550b7a4248ef3e4750c7b5}{quad\+\_\+grid} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a9a189dbba012d12c812bb7b0970b4ab9}\label{namespaceigl_a9a189dbba012d12c812bb7b0970b4ab9} 
\index{igl@{igl}!grid\_search@{grid\_search}}
\index{grid\_search@{grid\_search}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{grid\_search()}{grid\_search()}}
{\footnotesize\ttfamily template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB , typename DerivedI $>$ \\
Scalar igl\+::grid\+\_\+search (\begin{DoxyParamCaption}\item[{const std\+::function$<$ Scalar(DerivedX \&) $>$}]{f,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&}]{LB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&}]{UB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{DerivedX \&}]{X }\end{DoxyParamCaption})}



Global optimization via grid search. 

Solve the problem\+:

minimize f(x) subject to lb  x  ub

by exhaustive grid search.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & function to minimize \\
\hline
\mbox{\texttt{ in}}  & {\em LB} & \#X vector of finite lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em UB} & \#X vector of finite upper bounds \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#X vector of number of steps for each variable \\
\hline
\mbox{\texttt{ out}}  & {\em X} & \#X optimal parameter vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
f(\+X) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_af3d530c8efa1612e1bb3aa180064451d}\label{namespaceigl_af3d530c8efa1612e1bb3aa180064451d} 
\index{igl@{igl}!group\_sum\_matrix@{group\_sum\_matrix}}
\index{group\_sum\_matrix@{group\_sum\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{group\_sum\_matrix()}{group\_sum\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::group\+\_\+sum\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{G,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A }\end{DoxyParamCaption})}



Builds a matrix A such that A\texorpdfstring{$\ast$}{*}V computes the sum of vertices in each group specified by G. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em G} & \#V list of group indices (0 to k-\/1) for each vertex, such that vertex i is assigned to group G(i) \\
\hline
\mbox{\texttt{ in}}  & {\em k} & \#groups, good choice is max(\+G)+1 \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#groups by \#V sparse matrix such that A\texorpdfstring{$\ast$}{*}V = group\+\_\+sums \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3ef361caeca0b62001b9d59df11b5c06}\label{namespaceigl_a3ef361caeca0b62001b9d59df11b5c06} 
\index{igl@{igl}!group\_sum\_matrix@{group\_sum\_matrix}}
\index{group\_sum\_matrix@{group\_sum\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{group\_sum\_matrix()}{group\_sum\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::group\+\_\+sum\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{G,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a229749fb9c004cc9a77f83a4c1881adb}\label{namespaceigl_a229749fb9c004cc9a77f83a4c1881adb} 
\index{igl@{igl}!guess\_extension@{guess\_extension}}
\index{guess\_extension@{guess\_extension}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{guess\_extension()}{guess\_extension()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::guess\+\_\+extension (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp,  }\item[{std\+::string \&}]{guess }\end{DoxyParamCaption})}



Given a file pointer at the beginning of a "{}mesh"{} file, try to guess the extension of the file format it comes from. 

The file pointer is rewound on return.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em fp} & file pointer, rewound after \\
\hline
\mbox{\texttt{ out}}  & {\em guess} & extension as string. One of "{}mesh"{},\{"{}obj"{}\},"{}off"{},"{}ply"{},"{}stl"{}, or "{}wrl"{} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab79410fbbb723767aecc21edcc5941cb}\label{namespaceigl_ab79410fbbb723767aecc21edcc5941cb} 
\index{igl@{igl}!guess\_extension@{guess\_extension}}
\index{guess\_extension@{guess\_extension}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{guess\_extension()}{guess\_extension()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::string igl\+::guess\+\_\+extension (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5ade90c5c56252e2c88f4452996c50a0}\label{namespaceigl_a5ade90c5c56252e2c88f4452996c50a0} 
\index{igl@{igl}!harmonic@{harmonic}}
\index{harmonic@{harmonic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{harmonic()}{harmonic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW $>$ \\
bool igl\+::harmonic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Compute k-\/harmonic weight functions "{}coordinates"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of element indices \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b boundary indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#b by \#W list of boundary values \\
\hline
\mbox{\texttt{ in}}  & {\em k} & power of harmonic operation (1\+: harmonic, 2\+: biharmonic, etc) \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by \#W list of weights \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac3baf24e87966423e7c6dac58f40c406}\label{namespaceigl_ac3baf24e87966423e7c6dac58f40c406} 
\index{igl@{igl}!harmonic@{harmonic}}
\index{harmonic@{harmonic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{harmonic()}{harmonic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW $>$ \\
bool igl\+::harmonic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Compute harmonic map using uniform laplacian operator \Hypertarget{namespaceigl_a720d55d920ca7659102fd8dd267e7936}\label{namespaceigl_a720d55d920ca7659102fd8dd267e7936} 
\index{igl@{igl}!harmonic@{harmonic}}
\index{harmonic@{harmonic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{harmonic()}{harmonic()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename DerivedM , typename Derivedb , typename Derivedbc , typename DerivedW $>$ \\
bool igl\+::harmonic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedL $>$ \&}]{L,  }\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Compute a harmonic map using a given Laplacian and mass matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L} & \#V by \#V discrete (integrated) Laplacian ~\newline
 \\
\hline
\mbox{\texttt{ in}}  & {\em M} & \#V by \#V mass matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aba39f8e29962d636cfae080188ec1da7}\label{namespaceigl_aba39f8e29962d636cfae080188ec1da7} 
\index{igl@{igl}!harmonic@{harmonic}}
\index{harmonic@{harmonic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{harmonic()}{harmonic()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename DerivedM , typename DerivedQ $>$ \\
void igl\+::harmonic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedL $>$ \&}]{L,  }\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const int}]{k,  }\item[{DerivedQ \&}]{Q }\end{DoxyParamCaption})}



Build the discrete k-\/harmonic operator (computing integrated quantities). 

That is, if the k-\/harmonic PDE is Q x = 0, then this minimizes x\textquotesingle{} Q x


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L} & \#V by \#V discrete (integrated) Laplacian ~\newline
 \\
\hline
\mbox{\texttt{ in}}  & {\em M} & \#V by \#V mass matrix \\
\hline
\mbox{\texttt{ in}}  & {\em k} & power of harmonic operation (1\+: harmonic, 2\+: biharmonic, etc) \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V discrete (integrated) k-\/\+Laplacian ~\newline
 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_accdfdc1795f3cd0fbf66aeb3ca316604}\label{namespaceigl_accdfdc1795f3cd0fbf66aeb3ca316604} 
\index{igl@{igl}!harmonic@{harmonic}}
\index{harmonic@{harmonic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{harmonic()}{harmonic()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedQ $>$ \\
void igl\+::harmonic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{k,  }\item[{DerivedQ \&}]{Q }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of element indices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a073322f93d4fd2e161868d738abdfc09}\label{namespaceigl_a073322f93d4fd2e161868d738abdfc09} 
\index{igl@{igl}!harwell\_boeing@{harwell\_boeing}}
\index{harwell\_boeing@{harwell\_boeing}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{harwell\_boeing()}{harwell\_boeing()}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
void igl\+::harwell\+\_\+boeing (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{A,  }\item[{int \&}]{num\+\_\+rows,  }\item[{std\+::vector$<$ Scalar $>$ \&}]{V,  }\item[{std\+::vector$<$ Index $>$ \&}]{R,  }\item[{std\+::vector$<$ Index $>$ \&}]{C }\end{DoxyParamCaption})}



Convert the matrix to Compressed sparse column (CSC or CCS) format, also known as Harwell Boeing format. 

As described\+: \href{http://netlib.org/linalg/html_templates/node92.html}{\texttt{ http\+://netlib.\+org/linalg/html\+\_\+templates/node92.\+html}} or \href{http://en.wikipedia.org/wiki/Sparse_matrix}{\texttt{ http\+://en.\+wikipedia.\+org/wiki/\+Sparse\+\_\+matrix}} \#\+Compressed\+\_\+sparse\+\_\+column\+\_\+.28\+CSC\+\_\+or\+\_\+\+CCS.\+29 
\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type of sparse matrix like double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & sparse m by n matrix \\
\hline
\mbox{\texttt{ out}}  & {\em num\+\_\+rows} & number of rows \\
\hline
\mbox{\texttt{ out}}  & {\em V} & non-\/zero values, row indices running fastest, size(\+V) = nnz \\
\hline
\mbox{\texttt{ out}}  & {\em R} & row indices corresponding to vals, size(\+R) = nnz \\
\hline
\mbox{\texttt{ out}}  & {\em C} & index in vals of first entry in each column, size(\+C) = num\+\_\+cols+1\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
All indices and pointers are 0-\/based 
\end{DoxyNote}
\Hypertarget{namespaceigl_a64901d7f496bd1cccbccceddbc091603}\label{namespaceigl_a64901d7f496bd1cccbccceddbc091603} 
\index{igl@{igl}!hausdorff@{hausdorff}}
\index{hausdorff@{hausdorff}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hausdorff()}{hausdorff()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+VA , typename Derived\+FA , typename Derived\+VB , typename Derived\+FB , typename Scalar $>$ \\
void igl\+::hausdorff (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VA $>$ \&}]{VA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FA $>$ \&}]{FA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VB $>$ \&}]{VB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FB $>$ \&}]{FB,  }\item[{Scalar \&}]{d }\end{DoxyParamCaption})}



Compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). 

This is the

d(\+A,\+B) = max ( max min d(a,b) , max min d(b,a) ) aA bB bB aA


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VA} & \#\+VA by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em FA} & \#\+FA by 3 list of face indices into VA \\
\hline
\mbox{\texttt{ in}}  & {\em VB} & \#\+VB by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em FB} & \#\+FB by 3 list of face indices into VB \\
\hline
\mbox{\texttt{ out}}  & {\em d} & hausdorff distance \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3de06347c75f90acb8cc0114c7249e58}\label{namespaceigl_a3de06347c75f90acb8cc0114c7249e58} 
\index{igl@{igl}!hausdorff@{hausdorff}}
\index{hausdorff@{hausdorff}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hausdorff()}{hausdorff()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Scalar $>$ \\
void igl\+::hausdorff (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const std\+::function$<$ Scalar(const Scalar \&, const Scalar \&, const Scalar \&)$>$ \&}]{dist\+\_\+to\+\_\+B,  }\item[{Scalar \&}]{l,  }\item[{Scalar \&}]{u }\end{DoxyParamCaption})}



Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.\+g., mesh, triangle soup) given by a distance function handle (dist\+\_\+to\+\_\+B). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of corner positions so that V.\+row(i) is the position of the ith corner \\
\hline
\mbox{\texttt{ in}}  & {\em dist\+\_\+to\+\_\+B} & function taking the x,y,z coordinate of a query position and outputting the closest-\/point distance to some point-\/set B \\
\hline
\mbox{\texttt{ out}}  & {\em l} & lower bound on Hausdorff distance \\
\hline
\mbox{\texttt{ out}}  & {\em u} & upper bound on Hausdorff distance \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_affbddd3e363a529044cd4bd848b278f4}\label{namespaceigl_affbddd3e363a529044cd4bd848b278f4} 
\index{igl@{igl}!heat\_geodesics\_precompute@{heat\_geodesics\_precompute}}
\index{heat\_geodesics\_precompute@{heat\_geodesics\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{heat\_geodesics\_precompute()}{heat\_geodesics\_precompute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
bool igl\+::heat\+\_\+geodesics\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{\mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}$<$ Scalar $>$ \&}]{data }\end{DoxyParamCaption})}



Precompute factorized solvers for computing a fast approximation of geodesic distances on a mesh (V,F). 

\mbox{[}Crane et al. 2013\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em data} & precomputation data (see heat\+\_\+geodesics\+\_\+solve)\\
\hline
\end{DoxyParams}
\doxylink{heat__geodesics_8h}{include/igl/heat\+\_\+geodesics.\+h} \Hypertarget{namespaceigl_a12efa6b8fc863b52dd131d478a456802}\label{namespaceigl_a12efa6b8fc863b52dd131d478a456802} 
\index{igl@{igl}!heat\_geodesics\_precompute@{heat\_geodesics\_precompute}}
\index{heat\_geodesics\_precompute@{heat\_geodesics\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{heat\_geodesics\_precompute()}{heat\_geodesics\_precompute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
bool igl\+::heat\+\_\+geodesics\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Scalar}]{t,  }\item[{\mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}$<$ Scalar $>$ \&}]{data }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em t} & "{}heat"{} parameter (smaller -\/-\/\texorpdfstring{$>$}{>} more accurate, less stable)\\
\hline
\end{DoxyParams}
\doxylink{heat__geodesics_8h}{include/igl/heat\+\_\+geodesics.\+h} \Hypertarget{namespaceigl_ae558cd690e05ad2e41caa655251e23c4}\label{namespaceigl_ae558cd690e05ad2e41caa655251e23c4} 
\index{igl@{igl}!heat\_geodesics\_solve@{heat\_geodesics\_solve}}
\index{heat\_geodesics\_solve@{heat\_geodesics\_solve}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{heat\_geodesics\_solve()}{heat\_geodesics\_solve()}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Derivedgamma , typename DerivedD $>$ \\
void igl\+::heat\+\_\+geodesics\+\_\+solve (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structigl_1_1HeatGeodesicsData}{Heat\+Geodesics\+Data}}$<$ Scalar $>$ \&}]{data,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedgamma $>$ \&}]{gamma,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



Compute fast approximate geodesic distances using precomputed data from a set of selected source vertices (gamma). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & precomputation data (see heat\+\_\+geodesics\+\_\+precompute) \\
\hline
\mbox{\texttt{ in}}  & {\em gamma} & \#gamma list of indices into V of source vertices \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#V list of distances to gamma\\
\hline
\end{DoxyParams}
\doxylink{heat__geodesics_8h}{include/igl/heat\+\_\+geodesics.\+h} \Hypertarget{namespaceigl_a8e6dbdaae94657379ac8491942082d20}\label{namespaceigl_a8e6dbdaae94657379ac8491942082d20} 
\index{igl@{igl}!hessian@{hessian}}
\index{hessian@{hessian}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hessian()}{hessian()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
void igl\+::hessian (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{H }\end{DoxyParamCaption})}



Constructs the finite element Hessian matrix as described in \href{https://arxiv.org/abs/1707.04348}{\texttt{ https\+://arxiv.\+org/abs/1707.\+04348}}, Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) The interior vertices are NOT set to zero yet. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em H} & dim\+::V by \#V Hessian matrix, each column i corresponding to V(i,\+:)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_adf8191d83bb2517d430b625c5416988b}{curved\+\_\+hessian\+\_\+energy}, \doxylink{namespaceigl_a5d3d292215a6020d9e70cd7cfdd29ec1}{hessian\+\_\+energy} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a5d3d292215a6020d9e70cd7cfdd29ec1}\label{namespaceigl_a5d3d292215a6020d9e70cd7cfdd29ec1} 
\index{igl@{igl}!hessian\_energy@{hessian\_energy}}
\index{hessian\_energy@{hessian\_energy}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hessian\_energy()}{hessian\_energy()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
void igl\+::hessian\+\_\+energy (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{Q }\end{DoxyParamCaption})}



Constructs the Hessian energy matrix using mixed FEM as described in \href{https://arxiv.org/abs/1707.04348}{\texttt{ https\+://arxiv.\+org/abs/1707.\+04348}} Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#V by \#V Hessian energy matrix, each row/column i corresponding to V(i,\+:)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a8e6dbdaae94657379ac8491942082d20}{hessian}, \doxylink{namespaceigl_adf8191d83bb2517d430b625c5416988b}{curved\+\_\+hessian\+\_\+energy} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a7e66c7ad3404c4e5a43a2ecaf1c21819}\label{namespaceigl_a7e66c7ad3404c4e5a43a2ecaf1c21819} 
\index{igl@{igl}!histc@{histc}}
\index{histc@{histc}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{histc()}{histc()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedE , typename DerivedN , typename DerivedB $>$ \\
void igl\+::histc (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Count occurrences of values in X between consecutive entries in E. 

Like matlab\textquotesingle{}s histc. O(n+m\texorpdfstring{$\ast$}{*}log(n))


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m-\/long Vector of values \\
\hline
\mbox{\texttt{ in}}  & {\em E} & n-\/long Monotonically increasing vector of edges \\
\hline
\mbox{\texttt{ out}}  & {\em N} & n-\/long vector where N(k) reveals how many values in X fall between E(k) \texorpdfstring{$<$}{<}= X \texorpdfstring{$<$}{<} E(k+1) \\
\hline
\mbox{\texttt{ out}}  & {\em B} & m-\/long vector of bin ids so that B(j) = k if E(k) \texorpdfstring{$<$}{<}= X(j) \texorpdfstring{$<$}{<} E(k+1). B(j) = -\/1 if X(j) is outside of E. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af74c4ce0e45c4fc1ab9e958c93ef4437}\label{namespaceigl_af74c4ce0e45c4fc1ab9e958c93ef4437} 
\index{igl@{igl}!histc@{histc}}
\index{histc@{histc}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{histc()}{histc()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedE , typename DerivedB $>$ \\
void igl\+::histc (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Truly O(m\texorpdfstring{$\ast$}{*}log(n)) \Hypertarget{namespaceigl_a946a214630848d43ddc7df74e00f4d57}\label{namespaceigl_a946a214630848d43ddc7df74e00f4d57} 
\index{igl@{igl}!histc@{histc}}
\index{histc@{histc}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{histc()}{histc()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedE $>$ \\
void igl\+::histc (\begin{DoxyParamCaption}\item[{const typename Derived\+E\+::\+Scalar \&}]{x,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{typename Derived\+E\+::\+Index \&}]{b }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Scalar search wrapper \Hypertarget{namespaceigl_a840674ca4222700909ca8197e27800a5}\label{namespaceigl_a840674ca4222700909ca8197e27800a5} 
\index{igl@{igl}!hsv\_to\_rgb@{hsv\_to\_rgb}}
\index{hsv\_to\_rgb@{hsv\_to\_rgb}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hsv\_to\_rgb()}{hsv\_to\_rgb()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::hsv\+\_\+to\+\_\+rgb (\begin{DoxyParamCaption}\item[{const T \texorpdfstring{$\ast$}{*}}]{hsv,  }\item[{T \texorpdfstring{$\ast$}{*}}]{rgb }\end{DoxyParamCaption})}



Convert RGB to HSV. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em hsv} & with
\begin{DoxyItemize}
\item h hue value (degrees\+: \mbox{[}0,360\mbox{]}. Values outside this range will be mapped periodically to \mbox{[}0,360\mbox{]}.)
\item s saturation value (\mbox{[}0,1\mbox{]})
\item v value value (\mbox{[}0,1\mbox{]}) 
\end{DoxyItemize}\\
\hline
\mbox{\texttt{ out}}  & {\em rgb} & with\+:
\begin{DoxyItemize}
\item r red value (\mbox{[}0,1\mbox{]})
\item g green value (\mbox{[}0,1\mbox{]})
\item b blue value (\mbox{[}0,1\mbox{]}) 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a67a8efe9fd3b48830cd07fd2fb45ece6}\label{namespaceigl_a67a8efe9fd3b48830cd07fd2fb45ece6} 
\index{igl@{igl}!hsv\_to\_rgb@{hsv\_to\_rgb}}
\index{hsv\_to\_rgb@{hsv\_to\_rgb}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hsv\_to\_rgb()}{hsv\_to\_rgb()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::hsv\+\_\+to\+\_\+rgb (\begin{DoxyParamCaption}\item[{const T \&}]{h,  }\item[{const T \&}]{s,  }\item[{const T \&}]{v,  }\item[{T \&}]{r,  }\item[{T \&}]{g,  }\item[{T \&}]{b }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a3e2573040155e553e83f6b2098417ed2}\label{namespaceigl_a3e2573040155e553e83f6b2098417ed2} 
\index{igl@{igl}!hsv\_to\_rgb@{hsv\_to\_rgb}}
\index{hsv\_to\_rgb@{hsv\_to\_rgb}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{hsv\_to\_rgb()}{hsv\_to\_rgb()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedH , typename DerivedR $>$ \\
void igl\+::hsv\+\_\+to\+\_\+rgb (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedH $>$ \&}]{H,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em H} & \#H by 3 list of hsv values \\
\hline
\mbox{\texttt{ out}}  & {\em R} & \#H by 3 list of rgb values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a91986768165db4e2fe4f6541db3a100e}\label{namespaceigl_a91986768165db4e2fe4f6541db3a100e} 
\index{igl@{igl}!icosahedron@{icosahedron}}
\index{icosahedron@{icosahedron}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{icosahedron()}{icosahedron()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::icosahedron (\begin{DoxyParamCaption}\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_ae6a48ea815ed7c6fce66c5fb16643592}\label{namespaceigl_ae6a48ea815ed7c6fce66c5fb16643592} 
\index{igl@{igl}!in\_element@{in\_element}}
\index{in\_element@{in\_element}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{in\_element()}{in\_element()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedQ , int DIM$>$ \\
void igl\+::in\+\_\+element (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Ele,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, DIM $>$ \&}]{aabb,  }\item[{Eigen\+::\+Vector\+Xi \&}]{I }\end{DoxyParamCaption})}



Determine whether each point in a list of points is in the elements of a mesh. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DIM} & dimension of vertices in V (\# of columns) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions. \\
\hline
\mbox{\texttt{ in}}  & {\em Ele} & \#\+Ele by dim+1 list of mesh indices into \#V. \\
\hline
\mbox{\texttt{ in}}  & {\em Q} & \#Q by dim list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em aabb} & axis-\/aligned bounding box tree object (see \doxylink{AABB_8h}{AABB.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#Q list of indices into Ele of first containing element (-\/1 means no containing element) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1cc28747ccc281b8790d1ec2a07daf42}\label{namespaceigl_a1cc28747ccc281b8790d1ec2a07daf42} 
\index{igl@{igl}!in\_element@{in\_element}}
\index{in\_element@{in\_element}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{in\_element()}{in\_element()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedQ , int DIM, typename Scalar $>$ \\
void igl\+::in\+\_\+element (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Ele,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, DIM $>$ \&}]{aabb,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em I} & \#Q by \#\+Ele sparse matrix revealing whether each element contains each point\+: I(q,e) means point q is in element e \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac35f10d1dc8993c19f76b5c2ba6c48e7}\label{namespaceigl_ac35f10d1dc8993c19f76b5c2ba6c48e7} 
\index{igl@{igl}!increment\_ulp@{increment\_ulp}}
\index{increment\_ulp@{increment\_ulp}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{increment\_ulp()}{increment\_ulp()}}
{\footnotesize\ttfamily template$<$typename Derived $>$ \\
void igl\+::increment\+\_\+ulp (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Base$<$ Derived $>$ \&}]{inout,  }\item[{int}]{it }\end{DoxyParamCaption})}



Increment Unit in Last Place of a matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em inout} & input matrix \\
\hline
\mbox{\texttt{ in}}  & {\em it} & number of increments \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0cba56449805461c9713bc29b8ebcc79}\label{namespaceigl_a0cba56449805461c9713bc29b8ebcc79} 
\index{igl@{igl}!infinite\_cost\_stopping\_condition@{infinite\_cost\_stopping\_condition}}
\index{infinite\_cost\_stopping\_condition@{infinite\_cost\_stopping\_condition}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{infinite\_cost\_stopping\_condition()}{infinite\_cost\_stopping\_condition()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::infinite\+\_\+cost\+\_\+stopping\+\_\+condition (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement,  }\item[{\mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&}]{stopping\+\_\+condition }\end{DoxyParamCaption})}



Stopping condition function compatible with \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. 

The output function handle will return true if cost of next edge is infinite.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em cost\+\_\+and\+\_\+placement} & handle being used by \doxylink{namespaceigl_aa8e3cfdf30adcadd5172a4f0b862bf59}{igl\+::collapse\+\_\+edge} \\
\hline
\mbox{\texttt{ out}}  & {\em stopping\+\_\+condition} & \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6f95773129e4cd1a29171858e1f313b5}\label{namespaceigl_a6f95773129e4cd1a29171858e1f313b5} 
\index{igl@{igl}!infinite\_cost\_stopping\_condition@{infinite\_cost\_stopping\_condition}}
\index{infinite\_cost\_stopping\_condition@{infinite\_cost\_stopping\_condition}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{infinite\_cost\_stopping\_condition()}{infinite\_cost\_stopping\_condition()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} igl\+::infinite\+\_\+cost\+\_\+stopping\+\_\+condition (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceigl_af967096efcc39e806f0c2b374e2ccc5f}{decimate\+\_\+cost\+\_\+and\+\_\+placement\+\_\+callback}} \&}]{cost\+\_\+and\+\_\+placement }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a461e3490769bd9ac20f48a0179f58b0f}\label{namespaceigl_a461e3490769bd9ac20f48a0179f58b0f} 
\index{igl@{igl}!inradius@{inradius}}
\index{inradius@{inradius}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{inradius()}{inradius()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedR $>$ \\
void igl\+::inradius (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R }\end{DoxyParamCaption})}



Compute the inradius of each triangle in a mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em R} & \#F list of inradii \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a748a89868e9e150c9d02736c6f304318}\label{namespaceigl_a748a89868e9e150c9d02736c6f304318} 
\index{igl@{igl}!internal\_angles@{internal\_angles}}
\index{internal\_angles@{internal\_angles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{internal\_angles()}{internal\_angles()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ \\
void igl\+::internal\+\_\+angles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Compute internal angles for a triangle mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim eigen Matrix of mesh vertex nD positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by poly-\/size eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#F by poly-\/size eigen Matrix of internal angles for triangles, columns correspond to edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]}\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
if poly-\/size  3 then dim must equal 3. 
\end{DoxyNote}
\Hypertarget{namespaceigl_a42cf87a6db6ebff753475465b9e0a6f3}\label{namespaceigl_a42cf87a6db6ebff753475465b9e0a6f3} 
\index{igl@{igl}!internal\_angles\_intrinsic@{internal\_angles\_intrinsic}}
\index{internal\_angles\_intrinsic@{internal\_angles\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{internal\_angles\_intrinsic()}{internal\_angles\_intrinsic()}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename DerivedK $>$ \\
void igl\+::internal\+\_\+angles\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&}]{L\+\_\+sq,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Compute internal angles for a triangle mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L\+\_\+sq} & \#F by 3 list of squared edge lengths \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#F by poly-\/size eigen Matrix of internal angles for triangles, columns correspond to edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4f72acbb659a5c1d291a4cff36910a87}\label{namespaceigl_a4f72acbb659a5c1d291a4cff36910a87} 
\index{igl@{igl}!intersect@{intersect}}
\index{intersect@{intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{intersect()}{intersect()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class M $>$ \\
void igl\+::intersect (\begin{DoxyParamCaption}\item[{const M \&}]{A,  }\item[{const M \&}]{B,  }\item[{M \&}]{C }\end{DoxyParamCaption})}



Determine the intersect between two sets of coefficients using ==. 


\begin{DoxyTemplParams}{Template Parameters}
{\em M} & matrix type that implements indexing by global index M(i) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & matrix of coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em B} & matrix of coefficients \\
\hline
\mbox{\texttt{ out}}  & {\em C} & matrix of elements appearing in both A and B, C is always resized to have a single column \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a41a6a9d793818a4836de7c3faa524e26}\label{namespaceigl_a41a6a9d793818a4836de7c3faa524e26} 
\index{igl@{igl}!intersect@{intersect}}
\index{intersect@{intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{intersect()}{intersect()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class M $>$ \\
M igl\+::intersect (\begin{DoxyParamCaption}\item[{const M \&}]{A,  }\item[{const M \&}]{B }\end{DoxyParamCaption})}



overload 

\Hypertarget{namespaceigl_a6173f608f5bae73866cc21f0159562dc}\label{namespaceigl_a6173f608f5bae73866cc21f0159562dc} 
\index{igl@{igl}!intrinsic\_delaunay\_cotmatrix@{intrinsic\_delaunay\_cotmatrix}}
\index{intrinsic\_delaunay\_cotmatrix@{intrinsic\_delaunay\_cotmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{intrinsic\_delaunay\_cotmatrix()}{intrinsic\_delaunay\_cotmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar , typename Derivedl\+\_\+intrinsic , typename Derived\+F\+\_\+intrinsic $>$ \\
void igl\+::intrinsic\+\_\+delaunay\+\_\+cotmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedl\+\_\+intrinsic $>$ \&}]{l\+\_\+intrinsic,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F\+\_\+intrinsic $>$ \&}]{F\+\_\+intrinsic }\end{DoxyParamCaption})}



Computes the discrete cotangent Laplacian of a mesh after converting it into its intrinsic Delaunay triangulation (see, e.\+g., \mbox{[}Fisher et al. 

2007\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh elements (triangles or tetrahedra) \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#V by \#V cotangent matrix, each row i corresponding to V(i,\+:) \\
\hline
\mbox{\texttt{ out}}  & {\em l\+\_\+intrinsic} & \#F by 3 list of intrinsic edge-\/lengths used to compute L \\
\hline
\mbox{\texttt{ out}}  & {\em F\+\_\+intrinsic} & \#F by 3 list of intrinsic face indices used to compute L\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_abf4975f69822136269d681f02b2c3279}{intrinsic\+\_\+delaunay\+\_\+triangulation}, \doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix}, \doxylink{namespaceigl_ae47d4dd3239dba392f54b8dc3f62e8dd}{cotmatrix\+\_\+intrinsic} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ab774229e4511d5f186a394c39f813d2f}\label{namespaceigl_ab774229e4511d5f186a394c39f813d2f} 
\index{igl@{igl}!intrinsic\_delaunay\_cotmatrix@{intrinsic\_delaunay\_cotmatrix}}
\index{intrinsic\_delaunay\_cotmatrix@{intrinsic\_delaunay\_cotmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{intrinsic\_delaunay\_cotmatrix()}{intrinsic\_delaunay\_cotmatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
void igl\+::intrinsic\+\_\+delaunay\+\_\+cotmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{L }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_abf4975f69822136269d681f02b2c3279}\label{namespaceigl_abf4975f69822136269d681f02b2c3279} 
\index{igl@{igl}!intrinsic\_delaunay\_triangulation@{intrinsic\_delaunay\_triangulation}}
\index{intrinsic\_delaunay\_triangulation@{intrinsic\_delaunay\_triangulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{intrinsic\_delaunay\_triangulation()}{intrinsic\_delaunay\_triangulation()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derivedl\+\_\+in , typename Derived\+F\+\_\+in , typename Derivedl , typename DerivedF $>$ \\
void igl\+::intrinsic\+\_\+delaunay\+\_\+triangulation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl\+\_\+in $>$ \&}]{l\+\_\+in,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F\+\_\+in $>$ \&}]{F\+\_\+in,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



INTRINSIC\+\_\+\+DELAUNAY\+\_\+\+TRIANGULATION Flip edges {\itshape intrinsically} until all are "{}intrinsic Delaunay"{}. 

See "{}\+An algorithm for the construction of intrinsic delaunay triangulations with applications to digital geometry processing"{} \mbox{[}Fisher et al. 2007\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l\+\_\+in} & \#\+F\+\_\+in by 3 list of edge lengths (see edge\+\_\+lengths) \\
\hline
\mbox{\texttt{ in}}  & {\em F\+\_\+in} & \#\+F\+\_\+in by 3 list of face indices into some unspecified vertex list V \\
\hline
\mbox{\texttt{ out}}  & {\em l} & \#F by 3 list of edge lengths \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of new face indices. Note\+: Combinatorially F may contain non-\/manifold edges, duplicate faces and self-\/loops (e.\+g., an edge \mbox{[}1,1\mbox{]} or a face \mbox{[}1,1,1\mbox{]}). However, the {\itshape intrinsic geometry} is still well-\/defined and correct. See \mbox{[}Fisher et al. 2007\mbox{]} Figure 3 and 2nd to last paragraph of 1st page. Since F may be "{}non-\/eddge-\/manifold"{} in the usual combinatorial sense, it may be useful to call the more verbose overload below if disentangling edges will be necessary later on. Calling unique\+\_\+edge\+\_\+map on this F will give a {\itshape different} result than those outputs.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a95a946e409259bd08727637f7fd15b74}{is\+\_\+intrinsic\+\_\+delaunay} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a6c0bd085d3b95f40fe92ef1c75f6ad32}\label{namespaceigl_a6c0bd085d3b95f40fe92ef1c75f6ad32} 
\index{igl@{igl}!intrinsic\_delaunay\_triangulation@{intrinsic\_delaunay\_triangulation}}
\index{intrinsic\_delaunay\_triangulation@{intrinsic\_delaunay\_triangulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{intrinsic\_delaunay\_triangulation()}{intrinsic\_delaunay\_triangulation()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedl\+\_\+in , typename Derived\+F\+\_\+in , typename Derivedl , typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType $>$ \\
void igl\+::intrinsic\+\_\+delaunay\+\_\+triangulation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl\+\_\+in $>$ \&}]{l\+\_\+in,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F\+\_\+in $>$ \&}]{F\+\_\+in,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em E} & \#F\texorpdfstring{$\ast$}{*}3 by 2 list of all directed edges, such that E.\+row(f+\#F\texorpdfstring{$\ast$}{*}c) is the \\
\hline
\mbox{\texttt{ out}}  & {\em edge} & opposite F(f,c) \\
\hline
\mbox{\texttt{ out}}  & {\em uE} & \#uE by 2 list of unique undirected edges \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique \\
\hline
\mbox{\texttt{ out}}  & {\em undirected} & edge \\
\hline
\mbox{\texttt{ out}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{unique\+\_\+edge\+\_\+map} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ad6fc59b895f5ad4472ca15758fd947b5}\label{namespaceigl_ad6fc59b895f5ad4472ca15758fd947b5} 
\index{igl@{igl}!invert\_diag@{invert\_diag}}
\index{invert\_diag@{invert\_diag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{invert\_diag()}{invert\_diag()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename MatY $>$ \\
void igl\+::invert\+\_\+diag (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{MatY \&}]{Y }\end{DoxyParamCaption})}



Invert the diagonal entries of a matrix (if the matrix is a diagonal matrix then this amounts to inverting the matrix) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & an m by n sparse matrix \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & an m by n sparse matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_addf49f5f7e92069382f5607639d92555}\label{namespaceigl_addf49f5f7e92069382f5607639d92555} 
\index{igl@{igl}!is\_border\_vertex@{is\_border\_vertex}}
\index{is\_border\_vertex@{is\_border\_vertex}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_border\_vertex()}{is\_border\_vertex()}}
{\footnotesize\ttfamily template$<$typename DerivedF $>$ \\
std\+::vector$<$ bool $>$ igl\+::is\+\_\+border\+\_\+vertex (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Determine vertices on open boundary of a (manifold) mesh with triangle faces F. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#V vector of bools revealing whether vertices are on boundary
\end{DoxyReturn}
\begin{DoxyNote}{Note}
assumes mesh is edge manifold 
\end{DoxyNote}
\Hypertarget{namespaceigl_a39d02bea0e57dce707ada6bc3228d22a}\label{namespaceigl_a39d02bea0e57dce707ada6bc3228d22a} 
\index{igl@{igl}!is\_boundary\_edge@{is\_boundary\_edge}}
\index{is\_boundary\_edge@{is\_boundary\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_boundary\_edge()}{is\_boundary\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DerivedB $>$ \\
void igl\+::is\+\_\+boundary\+\_\+edge (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Determine for each edge E if it is a "{}boundary edge"{} in F. 

Boundary edges are undirected edges which occur only once.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edges \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangles \\
\hline
\mbox{\texttt{ out}}  & {\em B} & \#E list bools. true iff unoriented edge occurs exactly once in F (non-\/manifold and non-\/existant edges will be false) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2687ea500d0a998cf01ab3ff7456ba25}\label{namespaceigl_a2687ea500d0a998cf01ab3ff7456ba25} 
\index{igl@{igl}!is\_boundary\_edge@{is\_boundary\_edge}}
\index{is\_boundary\_edge@{is\_boundary\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_boundary\_edge()}{is\_boundary\_edge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DerivedB , typename Derived\+EMAP $>$ \\
void igl\+::is\+\_\+boundary\+\_\+edge (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em E} & \#E by 2 list of edges \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices mapping allE to E \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8670d8afa68524c4d0e4745faa89efc7}\label{namespaceigl_a8670d8afa68524c4d0e4745faa89efc7} 
\index{igl@{igl}!is\_delaunay@{is\_delaunay}}
\index{is\_delaunay@{is\_delaunay}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_delaunay()}{is\_delaunay()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedD $>$ \\
void igl\+::is\+\_\+delaunay (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



IDetermine if each edge in the mesh (V,F) is Delaunay. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangles indices \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#F by 3 list of bools revealing whether edges corresponding 23 31 12 are locally Delaunay. Boundary edges are by definition Delaunay. Non-\/\+Manifold edges are by definition not Delaunay. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae3e60388b9f45015b2d555acf24b9b4e}\label{namespaceigl_ae3e60388b9f45015b2d555acf24b9b4e} 
\index{igl@{igl}!is\_delaunay@{is\_delaunay}}
\index{is\_delaunay@{is\_delaunay}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_delaunay()}{is\_delaunay()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename u\+E2\+EType , typename In\+Circle , typename uei\+Type $>$ \\
bool igl\+::is\+\_\+delaunay (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{const In\+Circle}]{incircle,  }\item[{const uei\+Type}]{uei }\end{DoxyParamCaption})}



Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangles indices \\
\hline
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges (see unique\+\_\+edge\+\_\+map) \\
\hline
\mbox{\texttt{ in}}  & {\em incircle} & A functor such that incircle(pa, pb, pc, pd) returns 1 if pd is on the positive size of circumcirle of (pa,pb,pc) -\/1 if pd is on the positive size of circumcirle of (pa,pb,pc) 0 if pd is cocircular with pa, pb, pc. (see delaunay\+\_\+triangulation) \\
\hline
\mbox{\texttt{ in}}  & {\em uei} & index into u\+E2E of edge to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff edge is Delaunay 
\end{DoxyReturn}
\Hypertarget{namespaceigl_acc2105d7b15672349f4662a1c77ea4d5}\label{namespaceigl_acc2105d7b15672349f4662a1c77ea4d5} 
\index{igl@{igl}!is\_dir@{is\_dir}}
\index{is\_dir@{is\_dir}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_dir()}{is\_dir()}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+dir (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{filename }\end{DoxyParamCaption})}



Tells whether the given filename is a directory. 

Act like php\textquotesingle{}s is\+\_\+dir function \href{http://php.net/manual/en/function.is-dir.php}{\texttt{ http\+://php.\+net/manual/en/function.\+is-\/dir.\+php}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & Path to the file. If filename is a relative filename, it will be checked relative to the current working directory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
TRUE if the filename exists and is a directory, FALSE otherwise. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ab086008065bab7abde580f8bdea5d156}\label{namespaceigl_ab086008065bab7abde580f8bdea5d156} 
\index{igl@{igl}!is\_edge\_manifold@{is\_edge\_manifold}}
\index{is\_edge\_manifold@{is\_edge\_manifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_edge\_manifold()}{is\_edge\_manifold()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF $>$ \\
bool igl\+::is\+\_\+edge\+\_\+manifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Check if the mesh is edge-\/manifold (every edge is incident one one face (boundary) or two oppositely oriented faces). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff all edges are manifold
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_abd0dbef9a4a2738b2c33de0cb6938bfb}{is\+\_\+vertex\+\_\+manifold} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a7d04d883ce83ec8376b7eb4f22db6f03}\label{namespaceigl_a7d04d883ce83ec8376b7eb4f22db6f03} 
\index{igl@{igl}!is\_edge\_manifold@{is\_edge\_manifold}}
\index{is\_edge\_manifold@{is\_edge\_manifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_edge\_manifold()}{is\_edge\_manifold()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+BF , typename DerivedE , typename Derived\+EMAP , typename Derived\+BE $>$ \\
bool igl\+::is\+\_\+edge\+\_\+manifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&}]{BF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BE $>$ \&}]{BE }\end{DoxyParamCaption})}



Checks if mesh is edge-\/manifold and outputs per-\/edge info. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em BF} & \#F by 3 list of flags revealing if edge opposite corresponding vertex \\
\hline
\mbox{\texttt{ out}}  & {\em is} & non-\/manifold. \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2 list of unique edges \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & 3\texorpdfstring{$\ast$}{*}\#F list of indices of opposite edges in "{}\+E"{} \\
\hline
\mbox{\texttt{ out}}  & {\em BE} & \#E list of flages whether edge is non-\/manifold \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1bd5dfc80e3180cb9f8cfbeb0049c2b5}\label{namespaceigl_a1bd5dfc80e3180cb9f8cfbeb0049c2b5} 
\index{igl@{igl}!is\_edge\_manifold@{is\_edge\_manifold}}
\index{is\_edge\_manifold@{is\_edge\_manifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_edge\_manifold()}{is\_edge\_manifold()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+EMAP , typename Derived\+BF , typename Derived\+BE $>$ \\
bool igl\+::is\+\_\+edge\+\_\+manifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+F\+::\+Index}]{ne,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BF $>$ \&}]{BF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BE $>$ \&}]{BE }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5d660daa58e9ec65ac1756adc4b61454}\label{namespaceigl_a5d660daa58e9ec65ac1756adc4b61454} 
\index{igl@{igl}!is\_file@{is\_file}}
\index{is\_file@{is\_file}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_file()}{is\_file()}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+file (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{filename }\end{DoxyParamCaption})}



Tells whether the given filename is a regular file. 

Act like php\textquotesingle{}s is\+\_\+file function \href{http://php.net/manual/en/function.is-file.php}{\texttt{ http\+://php.\+net/manual/en/function.\+is-\/file.\+php}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & Path to the file. If filename is a relative filename, it will be checked relative to the current working directory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
TRUE if the filename exists and is a regular file, FALSE otherwise. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a95a946e409259bd08727637f7fd15b74}\label{namespaceigl_a95a946e409259bd08727637f7fd15b74} 
\index{igl@{igl}!is\_intrinsic\_delaunay@{is\_intrinsic\_delaunay}}
\index{is\_intrinsic\_delaunay@{is\_intrinsic\_delaunay}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_intrinsic\_delaunay()}{is\_intrinsic\_delaunay()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedF , typename DerivedD $>$ \\
void igl\+::is\+\_\+intrinsic\+\_\+delaunay (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



Determine if each edge in the mesh (V,F) is Delaunay. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#l by dim list of edge lengths \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangles indices \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#F by 3 list of bools revealing whether edges corresponding 23 31 12 are locally Delaunay. Boundary edges are by definition Delaunay. Non-\/\+Manifold edges are by definition not Delaunay. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ada6b3f9347053522b1fc5da210be1968}\label{namespaceigl_ada6b3f9347053522b1fc5da210be1968} 
\index{igl@{igl}!is\_intrinsic\_delaunay@{is\_intrinsic\_delaunay}}
\index{is\_intrinsic\_delaunay@{is\_intrinsic\_delaunay}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_intrinsic\_delaunay()}{is\_intrinsic\_delaunay()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedF , typename u\+E2\+EType , typename DerivedD $>$ \\
void igl\+::is\+\_\+intrinsic\+\_\+delaunay (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists mapping unique edges to (half-\/)edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae63e0780a4c5344cbafb31919f77bd0a}\label{namespaceigl_ae63e0780a4c5344cbafb31919f77bd0a} 
\index{igl@{igl}!is\_intrinsic\_delaunay@{is\_intrinsic\_delaunay}}
\index{is\_intrinsic\_delaunay@{is\_intrinsic\_delaunay}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_intrinsic\_delaunay()}{is\_intrinsic\_delaunay()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename u\+E2\+EType , typename Index $>$ \\
bool igl\+::is\+\_\+intrinsic\+\_\+delaunay (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{const Index}]{num\+\_\+faces,  }\item[{const Index}]{uei }\end{DoxyParamCaption})}



Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#l by dim list of edge lengths \\
\hline
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges (see unique\+\_\+edge\+\_\+map) \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+faces} & number of faces (==\#F) \\
\hline
\mbox{\texttt{ in}}  & {\em uei} & index into u\+E2E of edge to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff edge is Delaunay 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a05f076e50c33c9998c7f9c9559ed36e0}\label{namespaceigl_a05f076e50c33c9998c7f9c9559ed36e0} 
\index{igl@{igl}!is\_irregular\_vertex@{is\_irregular\_vertex}}
\index{is\_irregular\_vertex@{is\_irregular\_vertex}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_irregular\_vertex()}{is\_irregular\_vertex()}}
{\footnotesize\ttfamily template$<$typename DerivedF $>$ \\
std\+::vector$<$ bool $>$ igl\+::is\+\_\+irregular\+\_\+vertex (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Determine if a vertex is irregular, i.\+e. 

it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3\mbox{[}4\mbox{]} list of triangle\mbox{[}quads\mbox{]} indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#V vector of bools revealing whether vertices are singular 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aedd09a46e564a0d19ae4f97891b95de9}\label{namespaceigl_aedd09a46e564a0d19ae4f97891b95de9} 
\index{igl@{igl}!is\_planar@{is\_planar}}
\index{is\_planar@{is\_planar}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_planar()}{is\_planar()}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+planar (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V }\end{DoxyParamCaption})}



Determine if a set of points lies on the XY plane. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if a mesh has constant value of 0 in z coordinate
\end{DoxyReturn}
\Hypertarget{namespaceigl_a036d4412fb94156420eff091457a73b3}\label{namespaceigl_a036d4412fb94156420eff091457a73b3} 
\index{igl@{igl}!is\_readable@{is\_readable}}
\index{is\_readable@{is\_readable}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_readable()}{is\_readable()}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+readable (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{filename }\end{DoxyParamCaption})}



Check if a file is reabable like PHP\textquotesingle{}s is\+\_\+readable function\+: \href{http://www.php.net/manual/en/function.is-readable.php}{\texttt{ http\+://www.\+php.\+net/manual/en/function.\+is-\/readable.\+php}}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & path to file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if file exists and is readable and false if file doesn\textquotesingle{}t exist or {\itshape is not readable}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Windows version will not check user or group ids 
\end{DoxyNote}
\Hypertarget{namespaceigl_ad7968d06fbb2bcb8b64f707ec4b29f87}\label{namespaceigl_ad7968d06fbb2bcb8b64f707ec4b29f87} 
\index{igl@{igl}!is\_sparse@{is\_sparse}}
\index{is\_sparse@{is\_sparse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_sparse()}{is\_sparse()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::is\+\_\+sparse (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A }\end{DoxyParamCaption})}



Determine if a matrix A is sparse. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T,DerivedA} & defines scalar type \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & matrix in question \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if A is represented with a sparse matrix
\end{DoxyReturn}
\Hypertarget{namespaceigl_a910c84c58fdea4379d5e0ff34588ffe6}\label{namespaceigl_a910c84c58fdea4379d5e0ff34588ffe6} 
\index{igl@{igl}!is\_sparse@{is\_sparse}}
\index{is\_sparse@{is\_sparse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_sparse()}{is\_sparse()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA $>$ \\
bool igl\+::is\+\_\+sparse (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a1f40e6e779275ad817df4c8d1ac22aa6}\label{namespaceigl_a1f40e6e779275ad817df4c8d1ac22aa6} 
\index{igl@{igl}!is\_stl@{is\_stl}}
\index{is\_stl@{is\_stl}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_stl()}{is\_stl()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+stl (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{stl\+\_\+file,  }\item[{bool \&}]{is\+\_\+ascii }\end{DoxyParamCaption})}



Given a file pointer, determine if it contains an .stl file and then rewind it. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em stl\+\_\+file} & pointer to file \\
\hline
\mbox{\texttt{ in}}  & {\em is\+\_\+ascii} & flag whether stl is ascii \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether stl\+\_\+file is an .stl file 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a623b66ea2a39ba8c09f3c72599272562}\label{namespaceigl_a623b66ea2a39ba8c09f3c72599272562} 
\index{igl@{igl}!is\_stl@{is\_stl}}
\index{is\_stl@{is\_stl}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_stl()}{is\_stl()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+stl (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{stl\+\_\+file }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a4f840791a21ca650ec1d68910c3ec900}\label{namespaceigl_a4f840791a21ca650ec1d68910c3ec900} 
\index{igl@{igl}!is\_symmetric@{is\_symmetric}}
\index{is\_symmetric@{is\_symmetric}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_symmetric()}{is\_symmetric()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename AT $>$ \\
bool igl\+::is\+\_\+symmetric (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AT $>$ \&}]{A }\end{DoxyParamCaption})}



Returns true if the given matrix is symmetric. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by m matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the matrix is square and symmetric 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a819c37589176cb7dde8fb52796314fc3}\label{namespaceigl_a819c37589176cb7dde8fb52796314fc3} 
\index{igl@{igl}!is\_symmetric@{is\_symmetric}}
\index{is\_symmetric@{is\_symmetric}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_symmetric()}{is\_symmetric()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename AT , typename epsilonT $>$ \\
bool igl\+::is\+\_\+symmetric (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AT $>$ \&}]{A,  }\item[{const epsilonT}]{epsilon }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em epsilon} & threshold on L1 difference between A and A\textquotesingle{} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a00ac1f26b40979584dfa370cee528d71}\label{namespaceigl_a00ac1f26b40979584dfa370cee528d71} 
\index{igl@{igl}!is\_symmetric@{is\_symmetric}}
\index{is\_symmetric@{is\_symmetric}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_symmetric()}{is\_symmetric()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedA $>$ \\
bool igl\+::is\+\_\+symmetric (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_abd0dbef9a4a2738b2c33de0cb6938bfb}\label{namespaceigl_abd0dbef9a4a2738b2c33de0cb6938bfb} 
\index{igl@{igl}!is\_vertex\_manifold@{is\_vertex\_manifold}}
\index{is\_vertex\_manifold@{is\_vertex\_manifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_vertex\_manifold()}{is\_vertex\_manifold()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedB $>$ \\
bool igl\+::is\+\_\+vertex\+\_\+manifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Check if a mesh is vertex-\/manifold. 

This only checks whether the faces incident on each vertex form exactly one connected component. Vertices incident on non-\/manifold edges are not consider non-\/manifold by this function (see \doxylink{is__edge__manifold_8h}{is\+\_\+edge\+\_\+manifold.\+h}). Unreferenced verties are considered non-\/manifold (zero components).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em B} & \#V list indicate whether each vertex is locally manifold. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
whether mesh is vertex manifold.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ab086008065bab7abde580f8bdea5d156}{is\+\_\+edge\+\_\+manifold} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a081c3e366717287e1be24e695b5b034e}\label{namespaceigl_a081c3e366717287e1be24e695b5b034e} 
\index{igl@{igl}!is\_vertex\_manifold@{is\_vertex\_manifold}}
\index{is\_vertex\_manifold@{is\_vertex\_manifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_vertex\_manifold()}{is\_vertex\_manifold()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF $>$ \\
bool igl\+::is\+\_\+vertex\+\_\+manifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6584dca7db2b1e9f2601973c2609e6c1}\label{namespaceigl_a6584dca7db2b1e9f2601973c2609e6c1} 
\index{igl@{igl}!is\_writable@{is\_writable}}
\index{is\_writable@{is\_writable}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{is\_writable()}{is\_writable()}}
{\footnotesize\ttfamily bool igl\+::is\+\_\+writable (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{filename }\end{DoxyParamCaption})}



Check if a file exists {\itshape and} is writable like PHP\textquotesingle{}s is\+\_\+writable function\+: \href{http://www.php.net/manual/en/function.is-writable.php}{\texttt{ http\+://www.\+php.\+net/manual/en/function.\+is-\/writable.\+php}}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & path to file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if file exists and is writable and false if file doesn\textquotesingle{}t exist or {\itshape is not writable}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Windows version will not test group and user id 
\end{DoxyNote}
\Hypertarget{namespaceigl_a28fb666256b9e2c9aa5bd79cbfb5397b}\label{namespaceigl_a28fb666256b9e2c9aa5bd79cbfb5397b} 
\index{igl@{igl}!isdiag@{isdiag}}
\index{isdiag@{isdiag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{isdiag()}{isdiag()}}
{\footnotesize\ttfamily template$<$typename Derived $>$ \\
bool igl\+::isdiag (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ Derived $>$ \&}]{A }\end{DoxyParamCaption})}



Determine if a given matrix is diagonal\+: all non-\/zeros lie on the main diagonal. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n sparse matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff and only if the matrix is diagonal. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a3b1dfc725b9f364c46cc835853c4d154}\label{namespaceigl_a3b1dfc725b9f364c46cc835853c4d154} 
\index{igl@{igl}!ismember@{ismember}}
\index{ismember@{ismember}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ismember()}{ismember()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename Derived\+IA , typename Derived\+LOCB $>$ \\
void igl\+::ismember (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+LOCB $>$ \&}]{LOCB }\end{DoxyParamCaption})}



Determine if elements of A exist in elements of B. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & ma by na matrix \\
\hline
\mbox{\texttt{ in}}  & {\em B} & mb by nb matrix \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & ma by na matrix of flags whether corresponding element of A exists in B \\
\hline
\mbox{\texttt{ out}}  & {\em LOCB} & ma by na matrix of indices in B locating matching element (-\/1 if not found), indices assume column major ordering \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a22eecc8e676dfea634eedb0f1121ed88}\label{namespaceigl_a22eecc8e676dfea634eedb0f1121ed88} 
\index{igl@{igl}!ismember\_rows@{ismember\_rows}}
\index{ismember\_rows@{ismember\_rows}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ismember\_rows()}{ismember\_rows()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename Derived\+IA , typename Derived\+LOCB $>$ \\
void igl\+::ismember\+\_\+rows (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+LOCB $>$ \&}]{LOCB }\end{DoxyParamCaption})}



Determine if row of A exist in rows of B. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & ma by na matrix \\
\hline
\mbox{\texttt{ in}}  & {\em B} & mb by nb matrix \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & ma by 1 lest of flags whether corresponding element of A exists in B \\
\hline
\mbox{\texttt{ out}}  & {\em LOCB} & ma by 1 list matrix of indices in B locating matching element (-\/1 if not found), indices assume column major ordering \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a24e807a90c41e3a89ee0171b1518c27d}\label{namespaceigl_a24e807a90c41e3a89ee0171b1518c27d} 
\index{igl@{igl}!isolines@{isolines}}
\index{isolines@{isolines}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{isolines()}{isolines()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediV , typename DerivediE , typename DerivedI $>$ \\
void igl\+::isolines (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedvals $>$ \&}]{vals,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivediV $>$ \&}]{iV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivediE $>$ \&}]{iE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Compute isolines of a scalar field on a triangle mesh. 

Isolines may cross perfectly at vertices. The output should not contain degenerate segments (so long as the input does not contain degenerate faces). The output segments are {\itshape oriented} so that isolines curl counter-\/clockwise around local maxima (i.\+e., for 2D scalar fields). Unless an isoline hits a boundary, it should be a closed loop. Isolines may run perfectly along boundaries. Isolines should appear just "{}above"{} constants regions.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#S by 1 list of per-\/vertex scalar values \\
\hline
\mbox{\texttt{ in}}  & {\em vals} & \#vals by 1 list of values to compute isolines for \\
\hline
\mbox{\texttt{ out}}  & {\em iV} & \#iV by dim list of isoline vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em iE} & \#iE by 2 list of edge indices into iV \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#iE by 1 list of indices into vals indicating which value each segment belongs to\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a616f5985cbb36acb190f207f9dff82df}{isolines\+\_\+intrinsic}, \doxylink{namespaceigl_a0cf37d2a8f8c08387438a60ba3bcb2ca}{edge\+\_\+crossings} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a616f5985cbb36acb190f207f9dff82df}\label{namespaceigl_a616f5985cbb36acb190f207f9dff82df} 
\index{igl@{igl}!isolines\_intrinsic@{isolines\_intrinsic}}
\index{isolines\_intrinsic@{isolines\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{isolines\_intrinsic()}{isolines\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediB , typename Derivedi\+FI , typename DerivediE , typename DerivedI $>$ \\
void igl\+::isolines\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedvals $>$ \&}]{vals,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivediB $>$ \&}]{iB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedi\+FI $>$ \&}]{i\+FI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivediE $>$ \&}]{iE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Compute isolines of a scalar field on a triangle mesh intrinsically. 

See \doxylink{isolines_8h}{isolines.\+h} for details.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into some V \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#S by 1 list of per-\/vertex scalar values \\
\hline
\mbox{\texttt{ in}}  & {\em vals} & \#vals by 1 list of values to compute isolines for \\
\hline
\mbox{\texttt{ out}}  & {\em iB} & \#iB by 3 list of barycentric coordinates so that i\+V.\+row(i) = i\+B(i,0)\texorpdfstring{$\ast$}{*}V.row(F(i\+FI(i,0)) + i\+B(i,1)\texorpdfstring{$\ast$}{*}V.row(F(i\+FI(i,1)) + i\+B(i,2)\texorpdfstring{$\ast$}{*}V.row(F(i\+FI(i,2)) \\
\hline
\mbox{\texttt{ out}}  & {\em iF} & \#iB list of triangle indices for each row of iB (all points will either lie on an edge or vertex\+: an arbitrary incident face will be given). \\
\hline
\mbox{\texttt{ out}}  & {\em iE} & \#iE by 2 list of edge indices into iB \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#iE by 1 list of indices into vals indicating which value each segment belongs to\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a24e807a90c41e3a89ee0171b1518c27d}{isolines}, \doxylink{namespaceigl_a0cf37d2a8f8c08387438a60ba3bcb2ca}{edge\+\_\+crossings} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a276bde6ae2e23fb1811ec18a353b15be}\label{namespaceigl_a276bde6ae2e23fb1811ec18a353b15be} 
\index{igl@{igl}!isolines\_intrinsic@{isolines\_intrinsic}}
\index{isolines\_intrinsic@{isolines\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{isolines\_intrinsic()}{isolines\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedS , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename DerivediB , typename Derivedi\+FI , typename DerivediE $>$ \\
void igl\+::isolines\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{const typename Derived\+S\+::\+Scalar}]{val,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivediB $>$ \&}]{iB,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedi\+FI $>$ \&}]{i\+FI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivediE $>$ \&}]{iE }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em val} & scalar value to compute isoline at \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of unique undirected edges \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+\#F\texorpdfstring{$\ast$}{*}c)) is the unique edge corresponding to E.\+row(f+\#F\texorpdfstring{$\ast$}{*}c) \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumulative counts of directed edges sharing each unique edge so the u\+EC(i+1)-\/u\+EC(i) is the number of directed edges sharing the ith unique edge. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#E list of indices into E, so that the consecutive segment of indices u\+EE.\+segment(u\+EC(i),u\+EC(i+1)-\/u\+EC(i)) lists all directed edges sharing the ith unique edge.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{unique\+\_\+edge\+\_\+map} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ac262ba447b16b5edccade00d31f39722}\label{namespaceigl_ac262ba447b16b5edccade00d31f39722} 
\index{igl@{igl}!isolines\_map@{isolines\_map}}
\index{isolines\_map@{isolines\_map}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{isolines\_map()}{isolines\_map()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+CM , typename Derivediso\+\_\+color , typename Derived\+ICM $>$ \\
void igl\+::isolines\+\_\+map (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CM $>$ \&}]{CM,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivediso\+\_\+color $>$ \&}]{iso\+\_\+color,  }\item[{const int}]{interval\+\_\+thickness,  }\item[{const int}]{iso\+\_\+thickness,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ICM $>$ \&}]{ICM }\end{DoxyParamCaption})}



Inject a given colormap with evenly spaced isolines. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em CM} & \#\+CM by 3 list of colors \\
\hline
\mbox{\texttt{ in}}  & {\em ico\+\_\+color} & 1 by 3 isoline color \\
\hline
\mbox{\texttt{ in}}  & {\em interval\+\_\+thickness} & number of times to repeat intervals (original colors) \\
\hline
\mbox{\texttt{ in}}  & {\em iso\+\_\+thickness} & number of times to repeat isoline color (in between intervals) \\
\hline
\mbox{\texttt{ out}}  & {\em ICM} & \#\+CM\texorpdfstring{$\ast$}{*}interval\+\_\+thickness + (\#\+CM-\/1)\texorpdfstring{$\ast$}{*}iso\+\_\+thickness by 3 list of outputs colors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a807d847189eeb2aa93fb387f81452494}\label{namespaceigl_a807d847189eeb2aa93fb387f81452494} 
\index{igl@{igl}!isolines\_map@{isolines\_map}}
\index{isolines\_map@{isolines\_map}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{isolines\_map()}{isolines\_map()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+CM , typename Derived\+ICM $>$ \\
void igl\+::isolines\+\_\+map (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CM $>$ \&}]{CM,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ICM $>$ \&}]{ICM }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa7b2dbd6e4ee3d5ca15dd5dce9928453}\label{namespaceigl_aa7b2dbd6e4ee3d5ca15dd5dce9928453} 
\index{igl@{igl}!iterative\_closest\_point@{iterative\_closest\_point}}
\index{iterative\_closest\_point@{iterative\_closest\_point}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{iterative\_closest\_point()}{iterative\_closest\_point()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+VX , typename Derived\+FX , typename Derived\+VY , typename Derived\+FY , typename DerivedR , typename Derivedt $>$ \\
void igl\+::iterative\+\_\+closest\+\_\+point (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VX $>$ \&}]{VX,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FX $>$ \&}]{FX,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VY $>$ \&}]{VY,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FY $>$ \&}]{FY,  }\item[{const int}]{num\+\_\+samples,  }\item[{const int}]{max\+\_\+iters,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&}]{t }\end{DoxyParamCaption})}



Solve for the rigid transformation that places mesh X onto mesh Y using the iterative closest point method. 

In particular, optimize\+:

min \+\_\+X inf x\texorpdfstring{$\ast$}{*}\+R+t -\/ y dx R\+SO(3) yY t\+R

Typically optimization strategies include using Gauss Newton ("{}point-\/to-\/plane"{} linearization) and stochastic descent (sparse random sampling each iteration).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VX} & \#\+VX by 3 list of mesh X vertices \\
\hline
\mbox{\texttt{ in}}  & {\em FX} & \#\+FX by 3 list of mesh X triangle indices into rows of VX \\
\hline
\mbox{\texttt{ in}}  & {\em VY} & \#\+VY by 3 list of mesh Y vertices \\
\hline
\mbox{\texttt{ in}}  & {\em FY} & \#\+FY by 3 list of mesh Y triangle indices into rows of VY \\
\hline
\mbox{\texttt{ in}}  & {\em num\+\_\+samples} & number of random samples to use (larger -\/-\/\texorpdfstring{$>$}{>} more accurate, but also more suceptible to sticking to local minimum) \\
\hline
\mbox{\texttt{ out}}  & {\em R} & 3x3 rotation matrix so that (VX\texorpdfstring{$\ast$}{*}\+R+t,FX) \texorpdfstring{$\sim$}{\string~}\texorpdfstring{$\sim$}{\string~} (VY,FY) \\
\hline
\mbox{\texttt{ out}}  & {\em t} & 1x3 translation row vector \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1cd54b56f1bb183ab3898eb0e78949da}\label{namespaceigl_a1cd54b56f1bb183ab3898eb0e78949da} 
\index{igl@{igl}!iterative\_closest\_point@{iterative\_closest\_point}}
\index{iterative\_closest\_point@{iterative\_closest\_point}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{iterative\_closest\_point()}{iterative\_closest\_point()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+VX , typename Derived\+FX , typename Derived\+VY , typename Derived\+FY , typename Derived\+NY , typename DerivedR , typename Derivedt $>$ \\
void igl\+::iterative\+\_\+closest\+\_\+point (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VX $>$ \&}]{VX,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FX $>$ \&}]{FX,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VY $>$ \&}]{VY,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FY $>$ \&}]{FY,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ Derived\+VY, 3 $>$ \&}]{Ytree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+NY $>$ \&}]{NY,  }\item[{const int}]{num\+\_\+samples,  }\item[{const int}]{max\+\_\+iters,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&}]{t }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Ytree} & precomputed \doxylink{classigl_1_1AABB}{AABB} tree for accelerating closest point queries \\
\hline
\mbox{\texttt{ in}}  & {\em NY} & \#\+FY by 3 list of precomputed unit face normals \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a86feeac6e40d21e10cc147d82782000a}\label{namespaceigl_a86feeac6e40d21e10cc147d82782000a} 
\index{igl@{igl}!jet@{jet}}
\index{jet@{jet}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{jet()}{jet()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::jet (\begin{DoxyParamCaption}\item[{const T}]{f,  }\item[{T \texorpdfstring{$\ast$}{*}}]{rgb }\end{DoxyParamCaption})}



Jet colormap like MATLAB\textquotesingle{}s jet. 

\begin{DoxyNote}{Note}
that we actually use the Turbo colormap instead, since jet is a bad colormap\+: \href{https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html}{\texttt{ https\+://ai.\+googleblog.\+com/2019/08/turbo-\/improved-\/rainbow-\/colormap-\/for.\+html}}
\end{DoxyNote}
Wrapper for directly computing \mbox{[}r,g,b\mbox{]} values for a given factor f between 0 and 1


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & factor determining color value as if 0 was min and 1 was max \\
\hline
\mbox{\texttt{ out}}  & {\em rgb} & resulting rgb color
\begin{DoxyItemize}
\item r red value
\item g green value
\item b blue value 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7b40235bb5881e629930f522e5f3ee1a}\label{namespaceigl_a7b40235bb5881e629930f522e5f3ee1a} 
\index{igl@{igl}!jet@{jet}}
\index{jet@{jet}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{jet()}{jet()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::jet (\begin{DoxyParamCaption}\item[{const T}]{f,  }\item[{T \&}]{r,  }\item[{T \&}]{g,  }\item[{T \&}]{b }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a495fc46dda1dad8354b6aa9f9f146c89}\label{namespaceigl_a495fc46dda1dad8354b6aa9f9f146c89} 
\index{igl@{igl}!jet@{jet}}
\index{jet@{jet}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{jet()}{jet()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedZ , typename DerivedC $>$ \\
void igl\+::jet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{const bool}]{normalize,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Z} & \#Z list of factors \\
\hline
\mbox{\texttt{ in}}  & {\em normalize} & whether to normalize Z to be tightly between \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C by 3 list of rgb colors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5ecfd839e37628b61641d0e766eaf12b}\label{namespaceigl_a5ecfd839e37628b61641d0e766eaf12b} 
\index{igl@{igl}!jet@{jet}}
\index{jet@{jet}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{jet()}{jet()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedZ , typename DerivedC $>$ \\
void igl\+::jet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{const double}]{min\+\_\+Z,  }\item[{const double}]{max\+\_\+Z,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em min\+\_\+z} & value at blue \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+z} & value at red \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0a85e70cd58bcb5ebb5b36ef4a010fde}\label{namespaceigl_a0a85e70cd58bcb5ebb5b36ef4a010fde} 
\index{igl@{igl}!kelvinlets@{kelvinlets}}
\index{kelvinlets@{kelvinlets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{kelvinlets()}{kelvinlets()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derivedx0 , typename Derivedf , typename DerivedF , typename DerivedU $>$ \\
void igl\+::kelvinlets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedx0 $>$ \&}]{x0,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedf $>$ \&}]{f,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{structigl_1_1KelvinletParams}{Kelvinlet\+Params}}$<$ typename Derived\+V\+::\+Scalar $>$ \&}]{params,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



Implements Pixar\textquotesingle{}s Regularized Kelvinlets (Pixar Technical Memo \#17-\/03)\+: Sculpting Brushes based on Fundamental Solutions of Elasticity, a technique for real-\/time physically based volume sculpting of virtual elastic materials. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of input points in space \\
\hline
\mbox{\texttt{ in}}  & {\em x0} & dim-\/vector of brush tip \\
\hline
\mbox{\texttt{ in}}  & {\em f} & dim-\/vector of brush force (translation) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & dim by dim matrix of brush force matrix (linear) \\
\hline
\mbox{\texttt{ in}}  & {\em params} & parameters for the kelvinlet brush like brush radius, scale etc \\
\hline
\mbox{\texttt{ out}}  & {\em X} & \#V by dim list of output points in space \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2c092ead172c396770ffeda0fcb56089}\label{namespaceigl_a2c092ead172c396770ffeda0fcb56089} 
\index{igl@{igl}!kkt\_inverse@{kkt\_inverse}}
\index{kkt\_inverse@{kkt\_inverse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{kkt\_inverse()}{kkt\_inverse()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::kkt\+\_\+inverse (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{Aeq,  }\item[{const bool}]{use\+\_\+lu\+\_\+decomposition,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{S }\end{DoxyParamCaption})}



Constructs the inverse of the KKT matrix of a convex, linear equality constrained quadratic minimization problem. 

Systems of the form\+: \begin{DoxyVerb} / A   Aeq \  / x \ = / b   \
 \ Aeq    0 /  \  /   \ beq /
\_____.______/\__.__/ \___.___/
      M          z        c
\end{DoxyVerb}
 Arise, for example, when solve convex, linear equality constrained quadratic minimization problems\+: \begin{DoxyVerb}min  x A x - xb  subject to Aeq x = beq
\end{DoxyVerb}
 This function constructs a matrix S such that x = S c solves the system above. That is\+: \begin{DoxyVerb}S = [In 0] M

so that 

x = S c
\end{DoxyVerb}
 
\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like float or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & n by n matrix of quadratic coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em B} & n by 1 column of linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em Aeq} & m by n list of linear equality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em Beq} & m by 1 list of linear equality constraint constant values \\
\hline
\mbox{\texttt{ in}}  & {\em use\+\_\+lu\+\_\+decomposition} & use lu rather than SVD \\
\hline
\mbox{\texttt{ out}}  & {\em S} & n by (n + m) "{}solve"{} matrix, such that S\texorpdfstring{$\ast$}{*}\mbox{[}B\textquotesingle{}, Beq\textquotesingle{}\mbox{]} is a solution \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a6f2969bd735df2588ce37026375ddefe}\label{namespaceigl_a6f2969bd735df2588ce37026375ddefe} 
\index{igl@{igl}!knn@{knn}}
\index{knn@{knn}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{knn()}{knn()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename Index\+Type , typename Derived\+CH , typename Derived\+CN , typename DerivedW , typename DerivedI $>$ \\
void igl\+::knn (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{size\+\_\+t}]{k,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{point\+\_\+indices,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&}]{CH,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CN $>$ \&}]{CN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neighbors for each point in P. 

Note that each point is its own neighbor.

The octree data structures used in this function are intended to be the same ones output from \doxylink{namespaceigl_a3ff69240d0614e6f4ab20ff15b2f21a4}{igl\+::octree}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of point locations \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of neighbors to find \\
\hline
\mbox{\texttt{ in}}  & {\em point\+\_\+indices} & a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell\textquotesingle{}s points \\
\hline
\mbox{\texttt{ in}}  & {\em CH} & \#\+Octree\+Cells by 8, where the ith row is the indices of the ith octree cell\textquotesingle{}s children \\
\hline
\mbox{\texttt{ in}}  & {\em CN} & \#\+Octree\+Cells by 3, where the ith row is a 3d row vector representing the position of the ith cell\textquotesingle{}s center \\
\hline
\mbox{\texttt{ in}}  & {\em W} & \#\+Octree\+Cells, a vector where the ith entry is the width of the ith octree cell \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#P by k list of k-\/nearest-\/neighbor indices into P \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8937a7fe108b5aa0669d3731c34e281d}\label{namespaceigl_a8937a7fe108b5aa0669d3731c34e281d} 
\index{igl@{igl}!knn@{knn}}
\index{knn@{knn}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{knn()}{knn()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedV , typename Index\+Type , typename Derived\+CH , typename Derived\+CN , typename DerivedW , typename DerivedI $>$ \\
void igl\+::knn (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{size\+\_\+t}]{k,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{point\+\_\+indices,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CH $>$ \&}]{CH,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CN $>$ \&}]{CN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

only neighbors found in V 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of point locations for which may be neighbors \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#P by k list of k-\/nearest-\/neighbor indices into V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af44b520d132c6b6d1941fe5819f45ae1}\label{namespaceigl_af44b520d132c6b6d1941fe5819f45ae1} 
\index{igl@{igl}!launch\_medit@{launch\_medit}}
\index{launch\_medit@{launch\_medit}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{launch\_medit()}{launch\_medit()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename DerivedF $>$ \\
int igl\+::launch\+\_\+medit (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const bool}]{wait }\end{DoxyParamCaption})}



Writes the tetmesh in (V,T,F) to a temporary file, opens it with medit (forking with a system call) and returns. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & real-\/value\+: i.\+e. from Matrix\+Xd \\
\hline
{\em DerivedT} & integer-\/value\+: i.\+e. from Matrix\+Xi \\
\hline
{\em DerivedF} & integer-\/value\+: i.\+e. from Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & double matrix of vertex positions \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T list of tet indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F list of face indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em wait} & whether to wait for medit process to finish before returning \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returned value of system call (probably not useful if wait=false because of the fork) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a7e6a7f8c0fb33cae88074977a12e12fc}\label{namespaceigl_a7e6a7f8c0fb33cae88074977a12e12fc} 
\index{igl@{igl}!lbs\_matrix@{lbs\_matrix}}
\index{lbs\_matrix@{lbs\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lbs\_matrix()}{lbs\_matrix()}}
{\footnotesize\ttfamily void igl\+::lbs\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{M }\end{DoxyParamCaption})}



Linear blend skinning can be expressed by V\textquotesingle{} = M \texorpdfstring{$\ast$}{*} T where V\textquotesingle{} is a \#V by dim matrix of deformed vertex positions (one vertex per row), M is a \#V by (dim+1)\texorpdfstring{$\ast$}{*}\#T (composed of weights and rest positions) and T is a \#T\texorpdfstring{$\ast$}{*}(dim+1) by dim matrix of \#T stacked transposed transformation matrices. 

See equations (1) and (2) in "{}\+Fast Automatic Skinning Transformations"{} \mbox{[}Jacobson et al 2012\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of rest positions \\
\hline
\mbox{\texttt{ in}}  & {\em W} & \#V+ by \#T list of weights \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#V by \#T\texorpdfstring{$\ast$}{*}(dim+1)\\
\hline
\end{DoxyParams}
In MATLAB\+: \begin{DoxyVerb} kron(ones(1,size(W,2)),[V ones(size(V,1),1)]).*kron(W,ones(1,size(V,2)+1)) 
\end{DoxyVerb}
 \Hypertarget{namespaceigl_abf08b3e278ea284934baa0d3f6dc4975}\label{namespaceigl_abf08b3e278ea284934baa0d3f6dc4975} 
\index{igl@{igl}!lbs\_matrix\_column@{lbs\_matrix\_column}}
\index{lbs\_matrix\_column@{lbs\_matrix\_column}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lbs\_matrix\_column()}{lbs\_matrix\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily void igl\+::lbs\+\_\+matrix\+\_\+column (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{M }\end{DoxyParamCaption})}



Construct a matrix that when multiplied against a column of affine transformation entries computes new coordinates of the vertices. 

\begin{DoxyNote}{Note}
I\textquotesingle{}m not sure it makes since that the result is stored as a sparse matrix. The number of non-\/zeros per row {\itshape is} dependent on the number of mesh vertices and handles.
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex rest positions \\
\hline
\mbox{\texttt{ in}}  & {\em W} & \#V by \#handles list of correspondence weights \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#V \texorpdfstring{$\ast$}{*} dim by \#handles \texorpdfstring{$\ast$}{*} dim \texorpdfstring{$\ast$}{*} (dim+1) matrix such that new\+\_\+\+V(\+:) = LBS(\+V,\+W,\+A) = reshape(\+M \texorpdfstring{$\ast$}{*} A,size(\+V)), where A is a column vectors formed by the entries in each handle\textquotesingle{}s dim by dim+1 transformation matrix. Specifcally, A = reshape(permute(\+Astack,\mbox{[}3 1 2\mbox{]}),n\texorpdfstring{$\ast$}{*}dim\texorpdfstring{$\ast$}{*}(dim+1),1) or A = \mbox{[}Lxx;Lyx;Lxy;Lyy;tx;ty\mbox{]}, and likewise for other dim if Astack(\+:,\+:,i) is the dim by (dim+1) transformation at handle i\\
\hline
\end{DoxyParams}
\doxylink{lbs__matrix_8h}{include/igl/lbs\+\_\+matrix.\+h} \Hypertarget{namespaceigl_aaafa8162de573ea1c1c90b3f4ffad4a7}\label{namespaceigl_aaafa8162de573ea1c1c90b3f4ffad4a7} 
\index{igl@{igl}!lbs\_matrix\_column@{lbs\_matrix\_column}}
\index{lbs\_matrix\_column@{lbs\_matrix\_column}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lbs\_matrix\_column()}{lbs\_matrix\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily void igl\+::lbs\+\_\+matrix\+\_\+column (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5f0754d811bd0e0c95fac0317917c255}\label{namespaceigl_a5f0754d811bd0e0c95fac0317917c255} 
\index{igl@{igl}!lbs\_matrix\_column@{lbs\_matrix\_column}}
\index{lbs\_matrix\_column@{lbs\_matrix\_column}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lbs\_matrix\_column()}{lbs\_matrix\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily void igl\+::lbs\+\_\+matrix\+\_\+column (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{WI,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

W as a full matrix of weights (each vertex has \#handles weights), a constant number of weights are given for each vertex.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em W} & \#V by k list of k correspondence weights per vertex \\
\hline
\mbox{\texttt{ in}}  & {\em WI} & \#V by k list of k correspondence weight indices per vertex. Such that W(j,\+WI(i)) gives the ith most significant correspondence weight on vertex j \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a24aaeb1753decc0b7602a6cb0432458e}\label{namespaceigl_a24aaeb1753decc0b7602a6cb0432458e} 
\index{igl@{igl}!lbs\_matrix\_column@{lbs\_matrix\_column}}
\index{lbs\_matrix\_column@{lbs\_matrix\_column}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lbs\_matrix\_column()}{lbs\_matrix\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily void igl\+::lbs\+\_\+matrix\+\_\+column (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{WI,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a7afcff53e324c859c08eaa01e48f4581}\label{namespaceigl_a7afcff53e324c859c08eaa01e48f4581} 
\index{igl@{igl}!lexicographic\_triangulation@{lexicographic\_triangulation}}
\index{lexicographic\_triangulation@{lexicographic\_triangulation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lexicographic\_triangulation()}{lexicographic\_triangulation()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename Orient2D , typename DerivedF $>$ \\
void igl\+::lexicographic\+\_\+triangulation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Orient2D}]{orient2D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Given a set of points in 2D, return a lexicographic triangulation of these points. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 2 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em orient2D} & A functor such that orient2\+D(pa, pb, pc) returns 1 if pa,pb,pc forms a conterclockwise triangle. -\/1 if pa,pb,pc forms a clockwise triangle. 0 if pa,pb,pc are collinear. where the argument pa,pb,pc are of type Scalar\mbox{[}2\mbox{]}. \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 of faces in lexicographic triangulation. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2365ceb20a3b51fb10c3050cc456e343}\label{namespaceigl_a2365ceb20a3b51fb10c3050cc456e343} 
\index{igl@{igl}!limit\_faces@{limit\_faces}}
\index{limit\_faces@{limit\_faces}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{limit\_faces()}{limit\_faces()}}
{\footnotesize\ttfamily template$<$typename MatF , typename VecL $>$ \\
void igl\+::limit\+\_\+faces (\begin{DoxyParamCaption}\item[{const MatF \&}]{F,  }\item[{const VecL \&}]{L,  }\item[{const bool}]{exclusive,  }\item[{MatF \&}]{LF }\end{DoxyParamCaption})}



Limit given faces F to those which contain (only) indices found in L. 


\begin{DoxyTemplParams}{Template Parameters}
{\em MatF} & matrix type of faces, matrix\+Xi \\
\hline
{\em VecL} & matrix type of vertex indices, Vector\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of face indices \\
\hline
\mbox{\texttt{ in}}  & {\em L} & \#L by 1 list of allowed indices \\
\hline
\mbox{\texttt{ in}}  & {\em exclusive} & flag specifying whether a face is included only if all its indices are in L, default is false \\
\hline
\mbox{\texttt{ out}}  & {\em LF} & \#\+LF by 3 list of remaining faces after limiting \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4deb0e936a117ec6c8c973f3d0670770}\label{namespaceigl_a4deb0e936a117ec6c8c973f3d0670770} 
\index{igl@{igl}!line\_field\_mismatch@{line\_field\_mismatch}}
\index{line\_field\_mismatch@{line\_field\_mismatch}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{line\_field\_mismatch()}{line\_field\_mismatch()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedO $>$ \\
void igl\+::line\+\_\+field\+\_\+mismatch (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{PD1,  }\item[{const bool}]{is\+Combed,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{mismatch }\end{DoxyParamCaption})}



Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces. 

The integer mismatch is a multiple of pi/2 that transforms the cross on one side of the edge to the cross on the other side. It represents the deviation from a Lie connection across the edge.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em PD1} & \#F by 3 eigen Matrix of the first per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em PD2} & \#F by 3 eigen Matrix of the second per face cross field vector \\
\hline
\mbox{\texttt{ in}}  & {\em is\+Combed} & boolean, specifying whether the field is combed (i.\+e. matching has been precomputed. If not, the field is combed first. \\
\hline
\mbox{\texttt{ out}}  & {\em mismatch} & \#F by 3 eigen Matrix containing the integer mismatch of the cross field across all face edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9145bd261a2cf691294d8104c99a4ab9}\label{namespaceigl_a9145bd261a2cf691294d8104c99a4ab9} 
\index{igl@{igl}!line\_search@{line\_search}}
\index{line\_search@{line\_search}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{line\_search()}{line\_search()}}
{\footnotesize\ttfamily double igl\+::line\+\_\+search (\begin{DoxyParamCaption}\item[{Eigen\+::\+Matrix\+Xd \&}]{x,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{d,  }\item[{double}]{i\+\_\+step\+\_\+size,  }\item[{std\+::function$<$ double(Eigen\+::\+Matrix\+Xd \&)$>$}]{energy,  }\item[{double}]{cur\+\_\+energy = {\ttfamily -\/1} }\end{DoxyParamCaption})}



Implement a bisection linesearch to minimize a mesh-\/based energy on vertices given at \textquotesingle{}x\textquotesingle{} at a search direction \textquotesingle{}d\textquotesingle{}, with initial step size. 

Stops when a point with lower energy is found, or after maximal iterations have been reached.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em x} & \#X by dim list of variables \\
\hline
\mbox{\texttt{ in}}  & {\em d} & \#X by dim list of a given search direction \\
\hline
\mbox{\texttt{ in}}  & {\em i\+\_\+step\+\_\+size} & initial step size \\
\hline
\mbox{\texttt{ in}}  & {\em energy} & A function to compute the mesh-\/based energy (return an energy that is bigger than 0) \\
\hline
\mbox{\texttt{ out}}  & {\em x} & \#X by dim list of variables at the new location \\
\hline
\mbox{\texttt{ in}}  & {\em cur\+\_\+energy(\+OPTIONAL)} & The energy at the given point. Helps save redundant computations. This is optional. If not specified, the function will compute it. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the energy at the new point \textquotesingle{}x\textquotesingle{} 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a2b5853a837850f17eadaff857ad1e463}\label{namespaceigl_a2b5853a837850f17eadaff857ad1e463} 
\index{igl@{igl}!line\_segment\_in\_rectangle@{line\_segment\_in\_rectangle}}
\index{line\_segment\_in\_rectangle@{line\_segment\_in\_rectangle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{line\_segment\_in\_rectangle()}{line\_segment\_in\_rectangle()}}
{\footnotesize\ttfamily bool igl\+::line\+\_\+segment\+\_\+in\+\_\+rectangle (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector2d \&}]{s,  }\item[{const Eigen\+::\+Vector2d \&}]{d,  }\item[{const Eigen\+::\+Vector2d \&}]{A,  }\item[{const Eigen\+::\+Vector2d \&}]{B }\end{DoxyParamCaption})}



Determine whether a line segment overlaps with a rectangle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em s} & source point of line segment \\
\hline
\mbox{\texttt{ in}}  & {\em d} & dest point of line segment \\
\hline
\mbox{\texttt{ in}}  & {\em A} & first corner of rectangle \\
\hline
\mbox{\texttt{ in}}  & {\em B} & opposite corner of rectangle \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if line segment is at all inside rectangle 
\end{DoxyReturn}
\Hypertarget{namespaceigl_afa9c39cf6f0bef4857b1dc66360e4f52}\label{namespaceigl_afa9c39cf6f0bef4857b1dc66360e4f52} 
\index{igl@{igl}!linprog@{linprog}}
\index{linprog@{linprog}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{linprog()}{linprog()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::linprog (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector\+Xd \&}]{c,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{A,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{b,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Vector\+Xd \&}]{x }\end{DoxyParamCaption})}



Solve a linear program given in "{}standard form"{}. 

\begin{DoxyVerb} min  c'x
 s.t. A(    1:k,:) x <= b(1:k)
      A(k+1:end,:) x = b(k+1:end)
   ** x >= 0 **
\end{DoxyVerb}
 In contrast to other APIs the entries in b may be negative.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em c} & \#x list of linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#A by \#x matrix of linear constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#A list of linear constraint right-\/hand sides \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of inequality constraints as first rows of A,b \\
\hline
\mbox{\texttt{ out}}  & {\em x} & \#x solution vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false on failure or detected infeasibility, returns true on termination
\end{DoxyReturn}
\begin{DoxyNote}{Note}
It appears that this implementation does not detect all infeasibile problems (e.\+g., \href{https://github.com/libigl/libigl/issues/2051}{\texttt{ https\+://github.\+com/libigl/libigl/issues/2051}}). Therefor, it\textquotesingle{}s worth double-\/checking that the output actually satisfies the constraints even if the return value is {\ttfamily true}. 
\end{DoxyNote}
\Hypertarget{namespaceigl_a9455a41cb54a91242fe498354445bd28}\label{namespaceigl_a9455a41cb54a91242fe498354445bd28} 
\index{igl@{igl}!linprog@{linprog}}
\index{linprog@{linprog}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{linprog()}{linprog()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::linprog (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector\+Xd \&}]{f,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{A,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{B,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{c,  }\item[{Eigen\+::\+Vector\+Xd \&}]{x }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper in friendlier general form (no implicit bounds on x) \begin{DoxyVerb}min  f'x
s.t. A x <= b
     B x = c
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & \#x list of linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#A by \#x matrix of linear inequality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#A list of linear constraint right-\/hand sides \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#B by \#x matrix of linear equality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em c} & \#B list of linear constraint right-\/hand sides \\
\hline
\mbox{\texttt{ out}}  & {\em x} & \#x solution vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false on failure or detected infeasibility, returns true on termination 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ae8a4579279c09a298a5988c18f215d33}\label{namespaceigl_ae8a4579279c09a298a5988c18f215d33} 
\index{igl@{igl}!LinSpaced@{LinSpaced}}
\index{LinSpaced@{LinSpaced}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{LinSpaced()}{LinSpaced()}}
{\footnotesize\ttfamily template$<$typename Derived $>$ \\
Derived igl\+::\+Lin\+Spaced (\begin{DoxyParamCaption}\item[{typename Derived\+::\+Index}]{size,  }\item[{const typename Derived\+::\+Scalar \&}]{low,  }\item[{const typename Derived\+::\+Scalar \&}]{high }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Replacement for Eigen\+::\+Dense\+Base\+::\+Lin\+Spaced. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em size} & number of elements \\
\hline
\mbox{\texttt{ in}}  & {\em low} & first element \\
\hline
\mbox{\texttt{ in}}  & {\em high} & last element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
vector of size elements linearly spaced between low and
\end{DoxyReturn}
\doxylink{LinSpaced_8h}{include/igl/\+Lin\+Spaced.\+h} \Hypertarget{namespaceigl_a6df6ee5a6c7852f628cefbb8dbb025af}\label{namespaceigl_a6df6ee5a6c7852f628cefbb8dbb025af} 
\index{igl@{igl}!list\_to\_matrix@{list\_to\_matrix}}
\index{list\_to\_matrix@{list\_to\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{list\_to\_matrix()}{list\_to\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , typename Derived $>$ \\
bool igl\+::list\+\_\+to\+\_\+matrix (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&}]{M }\end{DoxyParamCaption})}



Convert a list (std\+::vector) of row vectors of the same length to a matrix. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type that can be safely cast to type in Mat via \textquotesingle{}=\textquotesingle{} \\
\hline
{\em Mat} & Matrix type, must implement\+: .resize(m,n) .row(i) = Row \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & a m-\/long list of vectors of size n \\
\hline
\mbox{\texttt{ out}}  & {\em M} & an m by n matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ae5fd001a788d43f744d257d305ddb1b3}\label{namespaceigl_ae5fd001a788d43f744d257d305ddb1b3} 
\index{igl@{igl}!list\_to\_matrix@{list\_to\_matrix}}
\index{list\_to\_matrix@{list\_to\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{list\_to\_matrix()}{list\_to\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N, typename Derived $>$ \\
bool igl\+::list\+\_\+to\+\_\+matrix (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::array$<$ T, N $>$ $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a47b768c6f9bfb5e3e0342cbe32f91110}\label{namespaceigl_a47b768c6f9bfb5e3e0342cbe32f91110} 
\index{igl@{igl}!list\_to\_matrix@{list\_to\_matrix}}
\index{list\_to\_matrix@{list\_to\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{list\_to\_matrix()}{list\_to\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , typename Derived $>$ \\
bool igl\+::list\+\_\+to\+\_\+matrix (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Vector version. \Hypertarget{namespaceigl_a25bb0b08ed4407588cdc107ce3f99b3d}\label{namespaceigl_a25bb0b08ed4407588cdc107ce3f99b3d} 
\index{igl@{igl}!list\_to\_matrix@{list\_to\_matrix}}
\index{list\_to\_matrix@{list\_to\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{list\_to\_matrix()}{list\_to\_matrix()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , typename Derived $>$ \\
bool igl\+::list\+\_\+to\+\_\+matrix (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{V,  }\item[{const int}]{n,  }\item[{const T \&}]{padding,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived $>$ \&}]{M }\end{DoxyParamCaption})}



Convert a list of row vectors of {\ttfamily n} or less to a matrix and pad on the right with {\ttfamily padding}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & a m-\/long list of vectors of size \texorpdfstring{$<$}{<}=n \\
\hline
\mbox{\texttt{ in}}  & {\em n} & number of columns \\
\hline
\mbox{\texttt{ in}}  & {\em padding} & value to fill in from right for short rows \\
\hline
\mbox{\texttt{ out}}  & {\em M} & an m by n matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a108a662cae580e5c3459d81435f32e24}\label{namespaceigl_a108a662cae580e5c3459d81435f32e24} 
\index{igl@{igl}!local\_basis@{local\_basis}}
\index{local\_basis@{local\_basis}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{local\_basis()}{local\_basis()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::local\+\_\+basis (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{B1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{B2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{B3 }\end{DoxyParamCaption})}



Compute a local orthogonal reference system for each triangle in the given mesh. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived from vertex positions matrix type\+: i.\+e. Matrix\+Xd \\
\hline
{\em DerivedF} & derived from face indices matrix type\+: i.\+e. Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & eigen matrix \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em B1} & eigen matrix \#F by 3, each vector is tangent to the triangle \\
\hline
\mbox{\texttt{ out}}  & {\em B2} & eigen matrix \#F by 3, each vector is tangent to the triangle and perpendicular to B1 \\
\hline
\mbox{\texttt{ out}}  & {\em B3} & eigen matrix \#F by 3, normal of the triangle \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae46bcc8364a310c7a3bc0ee718b91fb1}\label{namespaceigl_ae46bcc8364a310c7a3bc0ee718b91fb1} 
\index{igl@{igl}!look\_at@{look\_at}}
\index{look\_at@{look\_at}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{look\_at()}{look\_at()}}
{\footnotesize\ttfamily template$<$typename Derivedeye , typename Derivedcenter , typename Derivedup , typename DerivedR $>$ \\
void igl\+::look\+\_\+at (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedeye $>$ \&}]{eye,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedcenter $>$ \&}]{center,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedup $>$ \&}]{up,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R }\end{DoxyParamCaption})}



Implementation of the deprecated glu\+Look\+At function. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em eye} & 3-\/vector of eye position \\
\hline
\mbox{\texttt{ in}}  & {\em center} & 3-\/vector of center reference point \\
\hline
\mbox{\texttt{ in}}  & {\em up} & 3-\/vector of up vector \\
\hline
\mbox{\texttt{ out}}  & {\em R} & 4x4 rotation matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aea9965bc615b0a851fabf90d37a73320}\label{namespaceigl_aea9965bc615b0a851fabf90d37a73320} 
\index{igl@{igl}!loop@{loop}}
\index{loop@{loop}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{loop()}{loop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename SType , typename Derived\+NF $>$ \\
void igl\+::loop (\begin{DoxyParamCaption}\item[{const int}]{n\+\_\+verts,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ SType $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&}]{NF }\end{DoxyParamCaption})}



Given the triangle mesh \mbox{[}V, F\mbox{]}, where n\+\_\+verts = V.\+rows(), computes newV and a sparse matrix S s.\+t. 

\mbox{[}newV, newF\mbox{]} is the subdivided mesh where newV = S\texorpdfstring{$\ast$}{*}V.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n\+\_\+verts} & an integer (number of mesh vertices) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & an m by 3 matrix of integers of triangle faces \\
\hline
\mbox{\texttt{ out}}  & {\em S} & a sparse matrix (will become the subdivision matrix) \\
\hline
\mbox{\texttt{ out}}  & {\em newF} & a matrix containing the new faces \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aee95891ee4e9418b27c3fbfa92542784}\label{namespaceigl_aee95891ee4e9418b27c3fbfa92542784} 
\index{igl@{igl}!loop@{loop}}
\index{loop@{loop}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{loop()}{loop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF $>$ \\
void igl\+::loop (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&}]{NV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&}]{NF,  }\item[{const int}]{number\+\_\+of\+\_\+subdivs = {\ttfamily 1} }\end{DoxyParamCaption})}



Given the triangle mesh \mbox{[}V, F\mbox{]}, computes number\+\_\+of\+\_\+subdivs steps of loop subdivision and outputs the new mesh \mbox{[}newV, newF\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & an n by 3 matrix of vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & an m by 3 matrix of integers of triangle faces \\
\hline
\mbox{\texttt{ out}}  & {\em NV} & a matrix containing the new vertices \\
\hline
\mbox{\texttt{ out}}  & {\em NF} & a matrix containing the new faces \\
\hline
\mbox{\texttt{ in}}  & {\em number\+\_\+of\+\_\+subdivs} & an integer that specifies how many subdivision steps to do \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a31de2a4d188ef681f7057d0d948edbf1}\label{namespaceigl_a31de2a4d188ef681f7057d0d948edbf1} 
\index{igl@{igl}!lscm@{lscm}}
\index{lscm@{lscm}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lscm()}{lscm()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename Derived\+V\+\_\+uv , typename QScalar $>$ \\
bool igl\+::lscm (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V\+\_\+uv $>$ \&}]{V\+\_\+uv,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ QScalar $>$ \&}]{Q }\end{DoxyParamCaption})}



Compute a Least-\/squares conformal map parametrization (equivalently derived in "{}\+Intrinsic Parameterizations of Surface Meshes"{} \mbox{[}Desbrun et al. 

2002\mbox{]} and "{}\+Least Squares Conformal Maps for Automatic Texture Atlas \+Generation"{} \mbox{[}Lvy et al. 2002\mbox{]}), though this implementation follows the derivation in\+: "{}\+Spectral Conformal Parameterization"{} \mbox{[}Mullen et al. 2008\mbox{]} (note, this does {\bfseries{not}} implement the Eigen-\/decomposition based method in \mbox{[}Mullen et al. 2008\mbox{]}, see below). Input should be a manifold mesh (also no unreferenced vertices) and "{}boundary"{} (fixed vertices) {\ttfamily b} should contain at least two vertices per connected component.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b boundary indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#b by 2 list of boundary values \\
\hline
\mbox{\texttt{ out}}  & {\em UV} & \#V by 2 list of 2D mesh vertex positions in UV space \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#\+Vx2 by \#\+Vx2 symmetric positive semi-\/definite matrix for computing LSCM energy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only on solver success. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a1c37dc9607d1629ed72cba5af4e64554}\label{namespaceigl_a1c37dc9607d1629ed72cba5af4e64554} 
\index{igl@{igl}!lscm@{lscm}}
\index{lscm@{lscm}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lscm()}{lscm()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename Derived\+V\+\_\+uv $>$ \\
bool igl\+::lscm (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedb $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedbc $>$ \&}]{bc,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V\+\_\+uv $>$ \&}]{V\+\_\+uv }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a378192fe12df93afb032da2706ff5c0a}\label{namespaceigl_a378192fe12df93afb032da2706ff5c0a} 
\index{igl@{igl}!lscm@{lscm}}
\index{lscm@{lscm}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lscm()}{lscm()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+V\+\_\+uv $>$ \\
bool igl\+::lscm (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+V\+\_\+uv $>$ \&}]{V\+\_\+uv }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Free boundary version. "{}\+Spectral Conformal Parameterization"{} using eigen decomposition; Assumes mesh is a single connected component topologically equivalent to a chunk of the plane. \Hypertarget{namespaceigl_a1cf5daa1660b341b111456aabafc1f9b}\label{namespaceigl_a1cf5daa1660b341b111456aabafc1f9b} 
\index{igl@{igl}!lscm\_hessian@{lscm\_hessian}}
\index{lscm\_hessian@{lscm\_hessian}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{lscm\_hessian()}{lscm\_hessian()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename QScalar $>$ \\
void igl\+::lscm\+\_\+hessian (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ QScalar $>$ \&}]{Q }\end{DoxyParamCaption})}



Compute a Least-\/squares conformal map parametrization (equivalently derived in "{}\+Intrinsic Parameterizations of Surface Meshes"{} \mbox{[}Desbrun et al. 

2002\mbox{]} and "{}\+Least Squares Conformal Maps for Automatic Texture Atlas \+Generation"{} \mbox{[}Lvy et al. 2002\mbox{]}), though this implementation follows the derivation in\+: "{}\+Spectral Conformal Parameterization"{} \mbox{[}Mullen et al. 2008\mbox{]} (note, this does {\bfseries{not}} implement the Eigen-\/decomposition based method in \mbox{[}Mullen et al. 2008\mbox{]}, which is not equivalent). Input should be a manifold mesh (also no unreferenced vertices) and "{}boundary"{} (fixed vertices) {\ttfamily b} should contain at least two vertices per connected component.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b boundary indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#b by 2 list of boundary values \\
\hline
\mbox{\texttt{ out}}  & {\em UV} & \#V by 2 list of 2D mesh vertex positions in UV space \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & \#\+Vx2 by \#\+Vx2 symmetric positive semi-\/definite matrix for computing LSCM energy \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only on solver success. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a8b077eb9a7d351e5b313ff150dc3eabb}\label{namespaceigl_a8b077eb9a7d351e5b313ff150dc3eabb} 
\index{igl@{igl}!map\_vertices\_to\_circle@{map\_vertices\_to\_circle}}
\index{map\_vertices\_to\_circle@{map\_vertices\_to\_circle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{map\_vertices\_to\_circle()}{map\_vertices\_to\_circle()}}
{\footnotesize\ttfamily void igl\+::map\+\_\+vertices\+\_\+to\+\_\+circle (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{bnd,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{UV }\end{DoxyParamCaption})}



Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#W list of vertex ids \\
\hline
\mbox{\texttt{ out}}  & {\em UV} & \#W by 2 list of 2D position on the unit circle for the vertices in b \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0a118619cf44f20a0956f9e856707aa2}\label{namespaceigl_a0a118619cf44f20a0956f9e856707aa2} 
\index{igl@{igl}!mapping\_energy\_with\_jacobians@{mapping\_energy\_with\_jacobians}}
\index{mapping\_energy\_with\_jacobians@{mapping\_energy\_with\_jacobians}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mapping\_energy\_with\_jacobians()}{mapping\_energy\_with\_jacobians()}}
{\footnotesize\ttfamily double igl\+::mapping\+\_\+energy\+\_\+with\+\_\+jacobians (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{Ji,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{areas,  }\item[{\mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type}}}]{slim\+\_\+energy,  }\item[{double}]{exp\+\_\+factor }\end{DoxyParamCaption})}



Compute the rotation-\/invariant energy of a mapping (represented in Jacobians and areas) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Ji} & \#F by 4 (9 if 3D) entries of jacobians \\
\hline
\mbox{\texttt{ in}}  & {\em areas} & \#F by 1 face areas \\
\hline
\mbox{\texttt{ in}}  & {\em slim\+\_\+energy} & energy type as in \doxylink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type} \\
\hline
\mbox{\texttt{ in}}  & {\em exp\+\_\+factor} & see \doxylink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
energy value
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{Mapping\+Energy\+Type} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a75c4985a12f6c71116d36492d2f6154d}\label{namespaceigl_a75c4985a12f6c71116d36492d2f6154d} 
\index{igl@{igl}!march\_cube@{march\_cube}}
\index{march\_cube@{march\_cube}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{march\_cube()}{march\_cube()}}
{\footnotesize\ttfamily template$<$typename Derived\+GV , typename Scalar , typename Index , typename DerivedV , typename DerivedF $>$ \\
void igl\+::march\+\_\+cube (\begin{DoxyParamCaption}\item[{const Derived\+GV \&}]{GV,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 8, 1 $>$ \&}]{cS,  }\item[{const Eigen\+::\+Matrix$<$ Index, 8, 1 $>$ \&}]{cI,  }\item[{const Scalar \&}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Index \&}]{n,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Index \&}]{m,  }\item[{std\+::unordered\+\_\+map$<$ int64\+\_\+t, int $>$ \&}]{E2V }\end{DoxyParamCaption})}



Process a single cube of a marching cubes grid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em GV} & \#\+GV by 3 list of grid vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em cS} & list of 8 scalar field values at grid corners \\
\hline
\mbox{\texttt{ in}}  & {\em cI} & list of 8 indices of corners into rows of GV \\
\hline
\mbox{\texttt{ in}}  & {\em isovalue} & level-\/set value being extracted (often 0) \\
\hline
\mbox{\texttt{ in,out}}  & {\em V} & \#V by 3 current list of output mesh vertex positions \\
\hline
\mbox{\texttt{ in,out}}  & {\em n} & current number of mesh vertices (i.\+e., occupied rows in V) \\
\hline
\mbox{\texttt{ in,out}}  & {\em F} & \#F by 3 current list of output mesh triangle indices into rows of V \\
\hline
\mbox{\texttt{ in,out}}  & {\em m} & current number of mesh triangles (i.\+e., occupied rows in F) \\
\hline
\mbox{\texttt{ in,out}}  & {\em E2V} & current edge (GV\+\_\+i,GV\+\_\+j) to vertex (V\+\_\+k) map\\
\hline
\end{DoxyParams}
Side-\/effects\+: V,n,F,m,E2V are updated to contain new vertices and faces of any constructed mesh elements \Hypertarget{namespaceigl_a3e677970b7188cac95bc9f93181f2ed7}\label{namespaceigl_a3e677970b7188cac95bc9f93181f2ed7} 
\index{igl@{igl}!marching\_cubes@{marching\_cubes}}
\index{marching\_cubes@{marching\_cubes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_cubes()}{marching\_cubes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename Derived\+GV , typename DerivedV , typename DerivedF $>$ \\
void igl\+::marching\+\_\+cubes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{const unsigned}]{nx,  }\item[{const unsigned}]{ny,  }\item[{const unsigned}]{nz,  }\item[{const typename Derived\+S\+::\+Scalar}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh defined by vertices and faces. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & nx\texorpdfstring{$\ast$}{*}ny\texorpdfstring{$\ast$}{*}nz list of values at each grid corner i.\+e. S(x + y\texorpdfstring{$\ast$}{*}xres + z\texorpdfstring{$\ast$}{*}xres\texorpdfstring{$\ast$}{*}yres) for corner (x,y,z) \\
\hline
\mbox{\texttt{ in}}  & {\em GV} & nx\texorpdfstring{$\ast$}{*}ny\texorpdfstring{$\ast$}{*}nz by 3 array of corresponding grid corner vertex locations \\
\hline
\mbox{\texttt{ in}}  & {\em nx} & resolutions of the grid in x dimension \\
\hline
\mbox{\texttt{ in}}  & {\em ny} & resolutions of the grid in y dimension \\
\hline
\mbox{\texttt{ in}}  & {\em nz} & resolutions of the grid in z dimension \\
\hline
\mbox{\texttt{ in}}  & {\em isovalue} & the isovalue of the surface to reconstruct \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of mesh triangle indices into rows of V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af60d3b30634f77428770f2ae32f34059}\label{namespaceigl_af60d3b30634f77428770f2ae32f34059} 
\index{igl@{igl}!marching\_cubes@{marching\_cubes}}
\index{marching\_cubes@{marching\_cubes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_cubes()}{marching\_cubes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename Derived\+GV , typename Derived\+GI , typename DerivedV , typename DerivedF $>$ \\
void igl\+::marching\+\_\+cubes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+GI $>$ \&}]{GI,  }\item[{const typename Derived\+S\+::\+Scalar}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Sparse voxel version


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & \#S list of scalar field values \\
\hline
\mbox{\texttt{ in}}  & {\em GV} & \#S by 3 list of referenced grid vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em GI} & \#\+GI by 8 list of grid corner indices into rows of GV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5512306a29939c7ac8d4ebcef2cd032a}\label{namespaceigl_a5512306a29939c7ac8d4ebcef2cd032a} 
\index{igl@{igl}!marching\_tets@{marching\_tets}}
\index{marching\_tets@{marching\_tets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_tets()}{marching\_tets()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename DerivedJ , typename BCType $>$ \\
void igl\+::marching\+\_\+tets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&}]{TV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ BCType $>$ \&}]{BC }\end{DoxyParamCaption})}



Performs the marching tetrahedra algorithm on a tet mesh defined by TV and TT with scalar values defined at each vertex in TV. 

The output is a triangle mesh approximating the isosurface coresponding to the value isovalue.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em TV} & \#tet\+\_\+vertices x 3 array -- The vertices of the tetrahedral mesh \\
\hline
\mbox{\texttt{ in}}  & {\em TT} & \#tets x 4 array -- The indexes of each tet in the tetrahedral mesh \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#tet\+\_\+vertices x 1 array -- The values defined on each tet vertex \\
\hline
\mbox{\texttt{ in}}  & {\em isovalue} & scalar -- The isovalue of the level set we want to compute \\
\hline
\mbox{\texttt{ out}}  & {\em SV} & \#\+SV x 3 array -- The vertices of the output level surface mesh \\
\hline
\mbox{\texttt{ out}}  & {\em SF} & \#\+SF x 3 array -- The face indexes of the output level surface mesh \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+SF list of indices into TT revealing which tet each face comes from \\
\hline
\mbox{\texttt{ out}}  & {\em BC} & \#\+SV x \#\+TV list of barycentric coordinates so that SV = BC\texorpdfstring{$\ast$}{*}\+TV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa49f489ae12ec4a901418253fcd3f3ed}\label{namespaceigl_aa49f489ae12ec4a901418253fcd3f3ed} 
\index{igl@{igl}!marching\_tets@{marching\_tets}}
\index{marching\_tets@{marching\_tets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_tets()}{marching\_tets()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename DerivedJ , typename BCType $>$ \\
void igl\+::marching\+\_\+tets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&}]{TV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ BCType $>$ \&}]{BC }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

assumes isovalue = 0 \Hypertarget{namespaceigl_a77b74374c21bab647512f658e050cc27}\label{namespaceigl_a77b74374c21bab647512f658e050cc27} 
\index{igl@{igl}!marching\_tets@{marching\_tets}}
\index{marching\_tets@{marching\_tets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_tets()}{marching\_tets()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename DerivedJ $>$ \\
void igl\+::marching\+\_\+tets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&}]{TV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ac630f9be345647d2008378e9489ea50e}\label{namespaceigl_ac630f9be345647d2008378e9489ea50e} 
\index{igl@{igl}!marching\_tets@{marching\_tets}}
\index{marching\_tets@{marching\_tets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_tets()}{marching\_tets()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF , typename BCType $>$ \\
void igl\+::marching\+\_\+tets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&}]{TV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ BCType $>$ \&}]{BC }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a4416636f9a80fb95a7656732a32dbf0f}\label{namespaceigl_a4416636f9a80fb95a7656732a32dbf0f} 
\index{igl@{igl}!marching\_tets@{marching\_tets}}
\index{marching\_tets@{marching\_tets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{marching\_tets()}{marching\_tets()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename Derived\+TV , typename Derived\+TT , typename DerivedS , typename Derived\+SV , typename Derived\+SF $>$ \\
void igl\+::marching\+\_\+tets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TV $>$ \&}]{TV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{isovalue,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a72cf047d8b4df743c47bbbf0ba9dc6e1}\label{namespaceigl_a72cf047d8b4df743c47bbbf0ba9dc6e1} 
\index{igl@{igl}!massmatrix@{massmatrix}}
\index{massmatrix@{massmatrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{massmatrix()}{massmatrix()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Scalar $>$ \\
void igl\+::massmatrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}}}]{type,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{M }\end{DoxyParamCaption})}



Constructs the mass (area) matrix for a given mesh (V,F). 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived type of eigen matrix for V (e.\+g. derived from Matrix\+Xd) \\
\hline
{\em DerivedF} & derived type of eigen matrix for F (e.\+g. derived from Matrix\+Xi) \\
\hline
{\em Scalar} & scalar type for eigen sparse matrix (e.\+g. double) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh elements (triangles or tetrahedra) \\
\hline
\mbox{\texttt{ in}}  & {\em type} & one of the following ints\+: MASSMATRIX\+\_\+\+TYPE\+\_\+\+BARYCENTRIC barycentric \{default for tetrahedra\} MASSMATRIX\+\_\+\+TYPE\+\_\+\+VORONOI voronoi-\/hybrid \{default for triangles, not implemented for tetrahedra\} MASSMATRIX\+\_\+\+TYPE\+\_\+\+FULL full \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#V by \#V mass matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a4ab669b8ca4aea8ed68a0ba8c58a39bb}\label{namespaceigl_a4ab669b8ca4aea8ed68a0ba8c58a39bb} 
\index{igl@{igl}!massmatrix\_intrinsic@{massmatrix\_intrinsic}}
\index{massmatrix\_intrinsic@{massmatrix\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{massmatrix\_intrinsic()}{massmatrix\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedF , typename Scalar $>$ \\
void igl\+::massmatrix\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}}}]{type,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{M }\end{DoxyParamCaption})}



Constructs the mass (area) matrix for a given mesh (V,F). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l} & \#l by simplex\+\_\+size list of mesh edge lengths \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh elements (triangles or tetrahedra) \\
\hline
\mbox{\texttt{ in}}  & {\em type} & one of the following ints\+: MASSMATRIX\+\_\+\+TYPE\+\_\+\+BARYCENTRIC barycentric MASSMATRIX\+\_\+\+TYPE\+\_\+\+VORONOI voronoi-\/hybrid \{default\} MASSMATRIX\+\_\+\+TYPE\+\_\+\+FULL full \\
\hline
\mbox{\texttt{ out}}  & {\em M} & \#V by \#V mass matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a72cf047d8b4df743c47bbbf0ba9dc6e1}{massmatrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_af2f410b7b17ce4aca5873af755825d76}\label{namespaceigl_af2f410b7b17ce4aca5873af755825d76} 
\index{igl@{igl}!massmatrix\_intrinsic@{massmatrix\_intrinsic}}
\index{massmatrix\_intrinsic@{massmatrix\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{massmatrix\_intrinsic()}{massmatrix\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedl , typename DerivedF , typename Scalar $>$ \\
void igl\+::massmatrix\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedl $>$ \&}]{l,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a8ed02513847d2f3fdb8c74dcbe55bb90}{Mass\+Matrix\+Type}}}]{type,  }\item[{const int}]{n,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of vertices (\texorpdfstring{$>$}{>}= F.\+max\+Coeff()+1) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae45c197a9b5b63af57d2791909442e41}\label{namespaceigl_ae45c197a9b5b63af57d2791909442e41} 
\index{igl@{igl}!mat4\_to\_quat@{mat4\_to\_quat}}
\index{mat4\_to\_quat@{mat4\_to\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mat4\_to\_quat()}{mat4\_to\_quat()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::mat4\+\_\+to\+\_\+quat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{m,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q }\end{DoxyParamCaption})}



Convert a Open\+GL (rotation) matrix to a quaternion. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em m} & 16-\/element opengl rotation matrix \\
\hline
\mbox{\texttt{ out}}  & {\em q} & 4-\/element quaternion (not normalized) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa21c6c4b638d223560312607397b5ba8}\label{namespaceigl_aa21c6c4b638d223560312607397b5ba8} 
\index{igl@{igl}!mat3\_to\_quat@{mat3\_to\_quat}}
\index{mat3\_to\_quat@{mat3\_to\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mat3\_to\_quat()}{mat3\_to\_quat()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::mat3\+\_\+to\+\_\+quat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{m,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_afa21880837017adbf621456039ee7682}\label{namespaceigl_afa21880837017adbf621456039ee7682} 
\index{igl@{igl}!MAYA\_GREEN@{MAYA\_GREEN}}
\index{MAYA\_GREEN@{MAYA\_GREEN}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_GREEN()}{MAYA\_GREEN()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+GREEN (\begin{DoxyParamCaption}\item[{128./}]{255.,  }\item[{242./}]{255.,  }\item[{0./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a4babb52f3f1868081e0cefa0e4f56e07}\label{namespaceigl_a4babb52f3f1868081e0cefa0e4f56e07} 
\index{igl@{igl}!MAYA\_YELLOW@{MAYA\_YELLOW}}
\index{MAYA\_YELLOW@{MAYA\_YELLOW}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_YELLOW()}{MAYA\_YELLOW()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+YELLOW (\begin{DoxyParamCaption}\item[{255./}]{255.,  }\item[{247./}]{255.,  }\item[{50./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a10e550e4712ab9495265314ad14c3372}\label{namespaceigl_a10e550e4712ab9495265314ad14c3372} 
\index{igl@{igl}!MAYA\_RED@{MAYA\_RED}}
\index{MAYA\_RED@{MAYA\_RED}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_RED()}{MAYA\_RED()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+RED (\begin{DoxyParamCaption}\item[{234./}]{255.,  }\item[{63./}]{255.,  }\item[{52./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a669df861bcae5e90ab84e929012a1007}\label{namespaceigl_a669df861bcae5e90ab84e929012a1007} 
\index{igl@{igl}!MAYA\_BLUE@{MAYA\_BLUE}}
\index{MAYA\_BLUE@{MAYA\_BLUE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_BLUE()}{MAYA\_BLUE()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+BLUE (\begin{DoxyParamCaption}\item[{0./}]{255.,  }\item[{73./}]{255.,  }\item[{252./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_af3d3a9a0275b56ed0378893b3e80f0b4}\label{namespaceigl_af3d3a9a0275b56ed0378893b3e80f0b4} 
\index{igl@{igl}!MAYA\_PURPLE@{MAYA\_PURPLE}}
\index{MAYA\_PURPLE@{MAYA\_PURPLE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_PURPLE()}{MAYA\_PURPLE()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+PURPLE (\begin{DoxyParamCaption}\item[{180./}]{255.,  }\item[{73./}]{255.,  }\item[{200./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a2348169281b988537537308cba384db3}\label{namespaceigl_a2348169281b988537537308cba384db3} 
\index{igl@{igl}!MAYA\_VIOLET@{MAYA\_VIOLET}}
\index{MAYA\_VIOLET@{MAYA\_VIOLET}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_VIOLET()}{MAYA\_VIOLET()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+VIOLET (\begin{DoxyParamCaption}\item[{31./}]{255.,  }\item[{15./}]{255.,  }\item[{66./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_acf86c730ad8ddf83e5c89d8589047364}\label{namespaceigl_acf86c730ad8ddf83e5c89d8589047364} 
\index{igl@{igl}!MAYA\_GREY@{MAYA\_GREY}}
\index{MAYA\_GREY@{MAYA\_GREY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_GREY()}{MAYA\_GREY()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+GREY (\begin{DoxyParamCaption}\item[{0.}]{5,  }\item[{0.}]{5,  }\item[{0.}]{5,  }\item[{1.}]{0 }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a362ead03e0717a9a1e39f52996e6f6db}\label{namespaceigl_a362ead03e0717a9a1e39f52996e6f6db} 
\index{igl@{igl}!MAYA\_CYAN@{MAYA\_CYAN}}
\index{MAYA\_CYAN@{MAYA\_CYAN}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_CYAN()}{MAYA\_CYAN()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+CYAN (\begin{DoxyParamCaption}\item[{131./}]{255.,  }\item[{219./}]{255.,  }\item[{252./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a576798d977c56f9ebd4699e1d9693dd3}\label{namespaceigl_a576798d977c56f9ebd4699e1d9693dd3} 
\index{igl@{igl}!MAYA\_SEA\_GREEN@{MAYA\_SEA\_GREEN}}
\index{MAYA\_SEA\_GREEN@{MAYA\_SEA\_GREEN}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MAYA\_SEA\_GREEN()}{MAYA\_SEA\_GREEN()}}
{\footnotesize\ttfamily const Eigen\+::\+Vector4f igl\+::\+MAYA\+\_\+\+SEA\+\_\+\+GREEN (\begin{DoxyParamCaption}\item[{70./}]{255.,  }\item[{252./}]{255.,  }\item[{167./}]{255.,  }\item[{1.}]{ }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a64d87355c9c3b734e7658eed10bdd764}\label{namespaceigl_a64d87355c9c3b734e7658eed10bdd764} 
\index{igl@{igl}!matlab\_format@{matlab\_format}}
\index{matlab\_format@{matlab\_format}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matlab\_format()}{matlab\_format()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename DerivedM $>$ \\
const Eigen\+::\+With\+Format$<$ DerivedM $>$ igl\+::matlab\+\_\+format (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const std\+::string}]{name = {\ttfamily "{}"{}} }\end{DoxyParamCaption})}



This is a routine to print a matrix using format suitable for pasting into the matlab IDE. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedM} & e.\+g. derived from Matrix\+Xd \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em input} & some matrix to be formatted \\
\hline
\mbox{\texttt{ in}}  & {\em name} & name of matrix (optional) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Formatted matrix
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md15}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md15}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ M\ :=\ [1\ 2\ 3;4\ 5\ 6];}}
\DoxyCodeLine{cout<<\mbox{\hyperlink{namespaceigl_a6b539a21fb577617710f5fce2046e65b}{matlab\_format}}(M)<<endl;}
\DoxyCodeLine{\textcolor{comment}{//\ Prints:}}
\DoxyCodeLine{\textcolor{comment}{//\ [}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 1\ 2\ 3}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 4\ 5\ 6}}
\DoxyCodeLine{\textcolor{comment}{//\ ];}}
\DoxyCodeLine{cout<<\mbox{\hyperlink{namespaceigl_a6b539a21fb577617710f5fce2046e65b}{matlab\_format}}(M,\textcolor{stringliteral}{"{}M"{}})<<endl;}
\DoxyCodeLine{\textcolor{comment}{//\ Prints:}}
\DoxyCodeLine{\textcolor{comment}{//\ M\ =\ [}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 1\ 2\ 3}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 4\ 5\ 6}}
\DoxyCodeLine{\textcolor{comment}{//\ ];}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_acc0f1184f42624896cf510cd82ccb6ca}\label{namespaceigl_acc0f1184f42624896cf510cd82ccb6ca} 
\index{igl@{igl}!matlab\_format\_index@{matlab\_format\_index}}
\index{matlab\_format\_index@{matlab\_format\_index}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matlab\_format\_index()}{matlab\_format\_index()}}
{\footnotesize\ttfamily template$<$typename DerivedM $>$ \\
std\+::string igl\+::matlab\+\_\+format\+\_\+index (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const std\+::string}]{name = {\ttfamily "{}"{}} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Add +1 to every entry before formatting. \Hypertarget{namespaceigl_a92ca4e0bd6d85899d88544c29389b048}\label{namespaceigl_a92ca4e0bd6d85899d88544c29389b048} 
\index{igl@{igl}!matlab\_format@{matlab\_format}}
\index{matlab\_format@{matlab\_format}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matlab\_format()}{matlab\_format()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename DerivedS $>$ \\
const std\+::string igl\+::matlab\+\_\+format (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ DerivedS $>$ \&}]{S,  }\item[{const std\+::string}]{name = {\ttfamily "{}"{}} }\end{DoxyParamCaption})}



Same but for sparse matrices. 

Print IJV format into an auxiliary variable and then print a call to sparse which will construct the sparse matrix\hypertarget{namespaceigl_autotoc_md16}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md16}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ S\ :=\ [0\ 2\ 3;4\ 5\ 0];}}
\DoxyCodeLine{cout<<\mbox{\hyperlink{namespaceigl_a6b539a21fb577617710f5fce2046e65b}{matlab\_format}}(S,\textcolor{stringliteral}{"{}S"{}})<<endl;}
\DoxyCodeLine{\textcolor{comment}{//\ Prints:}}
\DoxyCodeLine{\textcolor{comment}{//\ SIJV\ =\ [}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 2\ 1\ 4}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 1\ 2\ 2}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 2\ 2\ 5}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 1\ 3\ 3}}
\DoxyCodeLine{\textcolor{comment}{//\ ];}}
\DoxyCodeLine{\textcolor{comment}{//\ S\ =\ sparse(SIJV(:,1),SIJV(:,2),SIJV(:,3));}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a9641504c7ccb6996da7abc34c5ebe6a1}\label{namespaceigl_a9641504c7ccb6996da7abc34c5ebe6a1} 
\index{igl@{igl}!matlab\_format@{matlab\_format}}
\index{matlab\_format@{matlab\_format}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matlab\_format()}{matlab\_format()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily const std\+::string igl\+::matlab\+\_\+format (\begin{DoxyParamCaption}\item[{const double}]{v,  }\item[{const std\+::string}]{name = {\ttfamily "{}"{}} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Scalars. \Hypertarget{namespaceigl_a367414630ebe7f7fe7a243502d57b1ad}\label{namespaceigl_a367414630ebe7f7fe7a243502d57b1ad} 
\index{igl@{igl}!matlab\_format@{matlab\_format}}
\index{matlab\_format@{matlab\_format}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matlab\_format()}{matlab\_format()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily const std\+::string igl\+::matlab\+\_\+format (\begin{DoxyParamCaption}\item[{const float}]{v,  }\item[{const std\+::string}]{name = {\ttfamily "{}"{}} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6b539a21fb577617710f5fce2046e65b}\label{namespaceigl_a6b539a21fb577617710f5fce2046e65b} 
\index{igl@{igl}!matlab\_format@{matlab\_format}}
\index{matlab\_format@{matlab\_format}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matlab\_format()}{matlab\_format()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily Eigen\+::\+IOFormat igl\+::matlab\+\_\+format (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Just build and return the format. 

\begin{DoxyReturn}{Returns}
eigen IOFormat object
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md17}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md17}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ M\ :=\ [1\ 2\ 3;4\ 5\ 6];}}
\DoxyCodeLine{cout<<M.format(\mbox{\hyperlink{namespaceigl_a6b539a21fb577617710f5fce2046e65b}{matlab\_format}}())<<endl;}
\DoxyCodeLine{\textcolor{comment}{//\ Prints:}}
\DoxyCodeLine{\textcolor{comment}{//\ [}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 1\ 2\ 3}}
\DoxyCodeLine{\textcolor{comment}{//\ \ \ 4\ 5\ 6}}
\DoxyCodeLine{\textcolor{comment}{//\ ];}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_ac9d68f355e17a7ba95194bfd46f3ce49}\label{namespaceigl_ac9d68f355e17a7ba95194bfd46f3ce49} 
\index{igl@{igl}!matrix\_to\_list@{matrix\_to\_list}}
\index{matrix\_to\_list@{matrix\_to\_list}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matrix\_to\_list()}{matrix\_to\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedM $>$ \\
void igl\+::matrix\+\_\+to\+\_\+list (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{std\+::vector$<$ std\+::vector$<$ typename Derived\+M\+::\+Scalar $>$ $>$ \&}]{V }\end{DoxyParamCaption})}



Convert a matrix to a list (std\+::vector) of row vectors of the same size. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat} & Matrix type, must implement\+: .resize(m,n) .row(i) = Row \\
\hline
{\em T} & type that can be safely cast to type in Mat via \textquotesingle{}=\textquotesingle{} \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em M} & an m by n matrix \\
\hline
\mbox{\texttt{ out}}  & {\em V} & a m-\/long list of vectors of size n\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a6df6ee5a6c7852f628cefbb8dbb025af}{list\+\_\+to\+\_\+matrix} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_adc8c8289cdddc4408bc1e12579de244c}\label{namespaceigl_adc8c8289cdddc4408bc1e12579de244c} 
\index{igl@{igl}!matrix\_to\_list@{matrix\_to\_list}}
\index{matrix\_to\_list@{matrix\_to\_list}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matrix\_to\_list()}{matrix\_to\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedM $>$ \\
void igl\+::matrix\+\_\+to\+\_\+list (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{std\+::vector$<$ typename Derived\+M\+::\+Scalar $>$ \&}]{V }\end{DoxyParamCaption})}



Convert a matrix to a list (std\+::vector) of elements in column-\/major ordering. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em M} & an m by n matrix \\
\hline
\mbox{\texttt{ out}}  & {\em V} & an m\texorpdfstring{$\ast$}{*}n list of elements \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aec3a51cfa07853b2b45e1226672e16da}\label{namespaceigl_aec3a51cfa07853b2b45e1226672e16da} 
\index{igl@{igl}!matrix\_to\_list@{matrix\_to\_list}}
\index{matrix\_to\_list@{matrix\_to\_list}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{matrix\_to\_list()}{matrix\_to\_list()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedM $>$ \\
std\+::vector$<$ typename Derived\+M\+::\+Scalar $>$ igl\+::matrix\+\_\+to\+\_\+list (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a406b1c228d9a40c7c25062de5c6e20c9}\label{namespaceigl_a406b1c228d9a40c7c25062de5c6e20c9} 
\index{igl@{igl}!max@{max}}
\index{max@{max}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{max()}{max()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedB , typename DerivedI $>$ \\
void igl\+::max (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Compute the maximum along dimension dim of a matrix X. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to take max \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & n-\/long vector (if dim == 1) Y m-\/long vector (if dim == 2) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & vector the same size as Y containing the indices along dim of minimum entries \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5e2e2d77d83c68427be201b4e3a877a6}\label{namespaceigl_a5e2e2d77d83c68427be201b4e3a877a6} 
\index{igl@{igl}!max@{max}}
\index{max@{max}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{max()}{max()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedI $>$ \\
void igl\+::max (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a74b5b6981f78cc7519e2ac080f4ec561}\label{namespaceigl_a74b5b6981f78cc7519e2ac080f4ec561} 
\index{igl@{igl}!max\_faces\_stopping\_condition@{max\_faces\_stopping\_condition}}
\index{max\_faces\_stopping\_condition@{max\_faces\_stopping\_condition}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{max\_faces\_stopping\_condition()}{max\_faces\_stopping\_condition()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::max\+\_\+faces\+\_\+stopping\+\_\+condition (\begin{DoxyParamCaption}\item[{int \&}]{m,  }\item[{const int}]{orig\+\_\+m,  }\item[{const int}]{max\+\_\+m,  }\item[{\mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} \&}]{stopping\+\_\+condition }\end{DoxyParamCaption})}



Stopping condition function compatible with \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. 

The outpute function handle will return true if number of faces is less than max\+\_\+m


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em m} & reference to working variable initially should be set to current number of faces. \\
\hline
\mbox{\texttt{ in}}  & {\em orig\+\_\+m} & number (size) of original face list {\itshape {\bfseries{not}}} including any faces added to handle phony boundary faces connecting to point at infinity. For closed meshes it\textquotesingle{}s safe to set this to F.\+rows() \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+m} & maximum number of faces \\
\hline
\mbox{\texttt{ out}}  & {\em stopping\+\_\+condition} & \\
\hline
\end{DoxyParams}
See \doxylink{decimate_8h}{decimate.\+h} for more details \Hypertarget{namespaceigl_afb31e9c7165119e57a70705383c7275d}\label{namespaceigl_afb31e9c7165119e57a70705383c7275d} 
\index{igl@{igl}!max\_faces\_stopping\_condition@{max\_faces\_stopping\_condition}}
\index{max\_faces\_stopping\_condition@{max\_faces\_stopping\_condition}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{max\_faces\_stopping\_condition()}{max\_faces\_stopping\_condition()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespaceigl_a64c8b006ed52af02a20d1664722a94b3}{decimate\+\_\+stopping\+\_\+condition\+\_\+callback}} igl\+::max\+\_\+faces\+\_\+stopping\+\_\+condition (\begin{DoxyParamCaption}\item[{int \&}]{m,  }\item[{const int}]{orign\+\_\+m,  }\item[{const int}]{max\+\_\+m }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad4303b454ca438ac3e09fdc506d431df}\label{namespaceigl_ad4303b454ca438ac3e09fdc506d431df} 
\index{igl@{igl}!max\_size@{max\_size}}
\index{max\_size@{max\_size}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{max\_size()}{max\_size()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int igl\+::max\+\_\+size (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{V }\end{DoxyParamCaption})}



Determine max size of lists in a vector. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & some list type object that implements .size() \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & vector of list types T \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
max .size() found in V, returns -\/1 if V is empty 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ad73289b6fbba95eacda8174e185dcf9f}\label{namespaceigl_ad73289b6fbba95eacda8174e185dcf9f} 
\index{igl@{igl}!median@{median}}
\index{median@{median}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{median()}{median()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename m\+Type $>$ \\
bool igl\+::median (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{m\+Type \&}]{m }\end{DoxyParamCaption})}



Compute the median of an eigen vector. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V list of unsorted values \\
\hline
\mbox{\texttt{ out}}  & {\em m} & median of those values \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aea356ce5149b60ed9d36e9f7a94db372}\label{namespaceigl_aea356ce5149b60ed9d36e9f7a94db372} 
\index{igl@{igl}!min@{min}}
\index{min@{min}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min()}{min()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedB , typename DerivedI $>$ \\
void igl\+::min (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Compute the minimum along dimension dim of a matrix X. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to take min \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & n-\/long vector (if dim == 1) Y m-\/long vector (if dim == 2) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & vector the same size as Y containing the indices along dim of minimum entries \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9b9c8ab934e0d7755a6c90c0fa6486c4}\label{namespaceigl_a9b9c8ab934e0d7755a6c90c0fa6486c4} 
\index{igl@{igl}!min@{min}}
\index{min@{min}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min()}{min()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedI $>$ \\
void igl\+::min (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_adc0382628e374a5b92a226ad75ce6b8b}\label{namespaceigl_adc0382628e374a5b92a226ad75ce6b8b} 
\index{igl@{igl}!min\_quad\_with\_fixed\_precompute@{min\_quad\_with\_fixed\_precompute}}
\index{min\_quad\_with\_fixed\_precompute@{min\_quad\_with\_fixed\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed\_precompute()}{min\_quad\_with\_fixed\_precompute()}}
{\footnotesize\ttfamily template$<$typename T , typename Derivedknown $>$ \\
bool igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedknown $>$ \&}]{known,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{Aeq,  }\item[{const bool}]{pd,  }\item[{\mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}$<$ T $>$ \&}]{data }\end{DoxyParamCaption})}



Minimize a convex quadratic energy subject to fixed value and linear equality constraints. 

Problems of the form \begin{DoxyVerb}trace( 0.5*Z'*A*Z + Z'*B + constant )
\end{DoxyVerb}
 subject to

Z(known,\+:) = Y, and Aeq\texorpdfstring{$\ast$}{*}Z = Beq


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & n by n matrix of quadratic coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em known} & list of indices to known rows in Z \\
\hline
\mbox{\texttt{ in}}  & {\em Y} & list of fixed values corresponding to known rows in Z \\
\hline
\mbox{\texttt{ in}}  & {\em Aeq} & m by n list of linear equality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em pd} & flag specifying whether A(unknown,unknown) is positive definite \\
\hline
\mbox{\texttt{ in,out}}  & {\em data} & factorization struct with all necessary information to solve using min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+solve \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
rows of Aeq {\bfseries{should probably}} be linearly independent. During precomputation, the rows of a Aeq are checked via QR. But in case they\textquotesingle{}re not then resulting probably will no longer be sparse\+: it will be slow. 
\end{DoxyPrecond}
\Hypertarget{namespaceigl_ad6d436a09a132f780d5e503b39499fbb}\label{namespaceigl_ad6d436a09a132f780d5e503b39499fbb} 
\index{igl@{igl}!min\_quad\_with\_fixed\_solve@{min\_quad\_with\_fixed\_solve}}
\index{min\_quad\_with\_fixed\_solve@{min\_quad\_with\_fixed\_solve}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed\_solve()}{min\_quad\_with\_fixed\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T , typename DerivedB , typename DerivedY , typename Derived\+Beq , typename DerivedZ , typename Derivedsol $>$ \\
bool igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+solve (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}$<$ T $>$ \&}]{data,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Beq $>$ \&}]{Beq,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedsol $>$ \&}]{sol }\end{DoxyParamCaption})}



Solves a system previously factored using min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+precompute. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & type of sparse matrix (e.\+g. double) \\
\hline
{\em DerivedY} & type of Y (e.\+g. derived from Vector\+Xd or Matrix\+Xd) \\
\hline
{\em DerivedZ} & type of Z (e.\+g. derived from Vector\+Xd or Matrix\+Xd) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & factorization struct with all necessary precomputation to solve \\
\hline
\mbox{\texttt{ in}}  & {\em B} & n by k column of linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em Y} & b by k list of constant fixed values \\
\hline
\mbox{\texttt{ in}}  & {\em Beq} & m by k list of linear equality constraint constant values \\
\hline
\mbox{\texttt{ out}}  & {\em Z} & n by k solution \\
\hline
\mbox{\texttt{ out}}  & {\em sol} & \#unknowns+\#lagrange by k solution to linear system Returns true on success, false on error \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad5720740af2df4180f61b1731bd5499f}\label{namespaceigl_ad5720740af2df4180f61b1731bd5499f} 
\index{igl@{igl}!min\_quad\_with\_fixed\_solve@{min\_quad\_with\_fixed\_solve}}
\index{min\_quad\_with\_fixed\_solve@{min\_quad\_with\_fixed\_solve}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed\_solve()}{min\_quad\_with\_fixed\_solve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , typename DerivedB , typename DerivedY , typename Derived\+Beq , typename DerivedZ $>$ \\
bool igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+solve (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{structigl_1_1min__quad__with__fixed__data}{min\+\_\+quad\+\_\+with\+\_\+fixed\+\_\+data}}$<$ T $>$ \&}]{data,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Beq $>$ \&}]{Beq,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&}]{Z }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_abcdcf5c62d46412f4b5de5889e51c0d4}\label{namespaceigl_abcdcf5c62d46412f4b5de5889e51c0d4} 
\index{igl@{igl}!min\_quad\_with\_fixed@{min\_quad\_with\_fixed}}
\index{min\_quad\_with\_fixed@{min\_quad\_with\_fixed}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed()}{min\_quad\_with\_fixed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , typename Derivedknown , typename DerivedB , typename DerivedY , typename Derived\+Beq , typename DerivedZ $>$ \\
bool igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedknown $>$ \&}]{known,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{Aeq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Beq $>$ \&}]{Beq,  }\item[{const bool}]{pd,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&}]{Z }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Minimize convex quadratic energy subject to fixed value and linear equality constraints. Without prefactorization. \Hypertarget{namespaceigl_a897bf8d157d9e2b51b81603c5fd6e099}\label{namespaceigl_a897bf8d157d9e2b51b81603c5fd6e099} 
\index{igl@{igl}!min\_quad\_with\_fixed@{min\_quad\_with\_fixed}}
\index{min\_quad\_with\_fixed@{min\_quad\_with\_fixed}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed()}{min\_quad\_with\_fixed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , int n, int m, bool Hpd = true$>$ \\
Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&}]{H,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{f,  }\item[{const Eigen\+::\+Array$<$ bool, n, 1 $>$ \&}]{k,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{bc,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, m, n $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, m, 1 $>$ \&}]{b }\end{DoxyParamCaption})}



Dense version optimized for very small, known at compile time sizes. 

Still works for Eigen\+::\+Dynamic (and then everything needs to be Dynamic).

min\+\_\+x  x H x + x f subject to A x = b x(i) = bc(i) iff k(i)==true


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & (e.\+g., double) \\
\hline
{\em n} & \#H or Eigen\+::\+Dynamic if not known at compile time \\
\hline
{\em m} & \#A or Eigen\+::\+Dynamic if not known at compile time \\
\hline
{\em Hpd} & whether H is positive definite (LLT used) or not (QR used) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em H} & \#H by \#H quadratic coefficients (only lower triangle used) \\
\hline
\mbox{\texttt{ in}}  & {\em f} & \#H linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em k} & \#H list of flags whether to fix value \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#H value to fix to (if !k(i) then bc(i) is ignored) \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#A by \#H list of linear equality constraint coefficients, must be linearly independent (with self and fixed value constraints) \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#A list of linear equality right-\/hand sides \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#H-\/long solution x 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a4f2961e370b73126b4896c0f53cc8af4}\label{namespaceigl_a4f2961e370b73126b4896c0f53cc8af4} 
\index{igl@{igl}!min\_quad\_with\_fixed@{min\_quad\_with\_fixed}}
\index{min\_quad\_with\_fixed@{min\_quad\_with\_fixed}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed()}{min\_quad\_with\_fixed()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , int n, bool Hpd = true$>$ \\
Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&}]{H,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{f,  }\item[{const Eigen\+::\+Array$<$ bool, n, 1 $>$ \&}]{k,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{bc }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a810f069896eadc075940d13f7cc22a4f}\label{namespaceigl_a810f069896eadc075940d13f7cc22a4f} 
\index{igl@{igl}!min\_quad\_with\_fixed@{min\_quad\_with\_fixed}}
\index{min\_quad\_with\_fixed@{min\_quad\_with\_fixed}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_quad\_with\_fixed()}{min\_quad\_with\_fixed()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , int n, int kcount, bool Hpd$>$ \\
Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ igl\+::min\+\_\+quad\+\_\+with\+\_\+fixed (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&}]{H,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{f,  }\item[{const Eigen\+::\+Array$<$ bool, n, 1 $>$ \&}]{k,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{bc }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Special wrapper where the number of constrained values (i.\+e., true values in k) is exposed as a template parameter. Not intended to be called directly. The overhead of calling the overloads above is already minimal. \Hypertarget{namespaceigl_aea4adc0413c180d649f00d8759cf63b3}\label{namespaceigl_aea4adc0413c180d649f00d8759cf63b3} 
\index{igl@{igl}!min\_size@{min\_size}}
\index{min\_size@{min\_size}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{min\_size()}{min\_size()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int igl\+::min\+\_\+size (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{V }\end{DoxyParamCaption})}



Determine min size of lists in a vector. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & some list type object that implements .size() \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & vector of list types T \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
min .size() found in V, returns -\/1 if V is empty 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ae574038db202105a0eccec2ef233be57}\label{namespaceigl_ae574038db202105a0eccec2ef233be57} 
\index{igl@{igl}!mod@{mod}}
\index{mod@{mod}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mod()}{mod()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB $>$ \\
void igl\+::mod (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const int}]{base,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Compute elementwise mod\+: B = A \% base. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em base} & number to mod against \\
\hline
\mbox{\texttt{ out}}  & {\em B} & m by n matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0394947bf9e27382711c730186ec631c}\label{namespaceigl_a0394947bf9e27382711c730186ec631c} 
\index{igl@{igl}!mod@{mod}}
\index{mod@{mod}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mod()}{mod()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA $>$ \\
DerivedA igl\+::mod (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const int}]{base }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a037858abb04a677ebd5cdf660de0b0ae}\label{namespaceigl_a037858abb04a677ebd5cdf660de0b0ae} 
\index{igl@{igl}!mode@{mode}}
\index{mode@{mode}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mode()}{mode()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::mode (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{X,  }\item[{const int}]{d,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, 1 $>$ \&}]{M }\end{DoxyParamCaption})}



Takes mode of coefficients in a matrix along a given dimension. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n original matrix \\
\hline
\mbox{\texttt{ in}}  & {\em d} & dension along which to take mode, m or n \\
\hline
\mbox{\texttt{ out}}  & {\em M} & vector containing mode along dension d, if d==1 then this will be a n-\/long vector if d==2 then this will be a m-\/long vector \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae9c8d358cf9fdbac0bd749920e072b84}\label{namespaceigl_ae9c8d358cf9fdbac0bd749920e072b84} 
\index{igl@{igl}!moments@{moments}}
\index{moments@{moments}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{moments()}{moments()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedm0 , typename Derivedm1 , typename Derivedm2 $>$ \\
void igl\+::moments (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Derivedm0 \&}]{m0,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedm1 $>$ \&}]{m1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedm2 $>$ \&}]{m2 }\end{DoxyParamCaption})}



Computes the moments of mass for a solid object bound by a triangle mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of rest domain positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em m0} & zeroth moment of mass, total signed volume of solid. \\
\hline
\mbox{\texttt{ out}}  & {\em m1} & first moment of mass, center of mass (centroid) times total mass \\
\hline
\mbox{\texttt{ out}}  & {\em m2} & second moment of mass, moment of inertia with center of mass as reference point\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_adaa0102450153380ae5ecdb948352556}{centroid} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a2b6d36d1a68f0978c2b20b1586ccc18f}\label{namespaceigl_a2b6d36d1a68f0978c2b20b1586ccc18f} 
\index{igl@{igl}!mvc@{mvc}}
\index{mvc@{mvc}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{mvc()}{mvc()}}
{\footnotesize\ttfamily void igl\+::mvc (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{W }\end{DoxyParamCaption})}



Mean value coordinates for a polygon. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V x dim list of vertex positions (dim = 2 or dim = 3) \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#C x dim list of polygon vertex positions in counter-\/clockwise order (dim = 2 or dim = 3)\\
\hline
\mbox{\texttt{ out}}  & {\em W} & weights, \#V by \#C matrix of weights\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a330d1e74582084d2c5d7002ecab40baf}\label{namespaceigl_a330d1e74582084d2c5d7002ecab40baf} 
\index{igl@{igl}!nchoosek@{nchoosek}}
\index{nchoosek@{nchoosek}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{nchoosek()}{nchoosek()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily double igl\+::nchoosek (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const int}]{k }\end{DoxyParamCaption})}



Binomial coefficient. 

Like matlab\textquotesingle{}s nchoosek.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & total number elements \\
\hline
\mbox{\texttt{ in}}  & {\em k} & size of sub-\/set to consider \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of k-\/size combinations out of the set \mbox{[}1,...,n\mbox{]} 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a5aa3a7446d17387b412677075b546ebb}\label{namespaceigl_a5aa3a7446d17387b412677075b546ebb} 
\index{igl@{igl}!nchoosek@{nchoosek}}
\index{nchoosek@{nchoosek}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{nchoosek()}{nchoosek()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedU $>$ \\
void igl\+::nchoosek (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U }\end{DoxyParamCaption})}



All combinations . 

Like matlab\textquotesingle{}s nchoosek.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & n-\/long vector of elements \\
\hline
\mbox{\texttt{ in}}  & {\em k} & size of sub-\/set to consider \\
\hline
\mbox{\texttt{ out}}  & {\em U} & nchoosek by k long matrix where each row is a unique k-\/size combination \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a368a81066e3790575847edac849c6aa9}\label{namespaceigl_a368a81066e3790575847edac849c6aa9} 
\index{igl@{igl}!next\_filename@{next\_filename}}
\index{next\_filename@{next\_filename}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{next\_filename()}{next\_filename()}}
{\footnotesize\ttfamily bool igl\+::next\+\_\+filename (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{prefix,  }\item[{const int}]{zeros,  }\item[{const std\+::string \&}]{suffix,  }\item[{std\+::string \&}]{next }\end{DoxyParamCaption})}



Find the file with the first filename of the form "{}prefix\%0\mbox{[}zeros\mbox{]}dsuffix"{}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em prefix} & path to containing dir and filename prefix \\
\hline
\mbox{\texttt{ in}}  & {\em zeros} & number of leading zeros as if digit printed with printf \\
\hline
\mbox{\texttt{ in}}  & {\em suffix} & suffix of filename and extension (should include dot) \\
\hline
\mbox{\texttt{ out}}  & {\em next} & path to next file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if found, false if exceeding range in zeros 
\end{DoxyReturn}
\Hypertarget{namespaceigl_af63be3993b067600b578e85bf0fa186a}\label{namespaceigl_af63be3993b067600b578e85bf0fa186a} 
\index{igl@{igl}!normal\_derivative@{normal\_derivative}}
\index{normal\_derivative@{normal\_derivative}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{normal\_derivative()}{normal\_derivative()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+Ele , typename Scalar $>$ \\
void igl\+::normal\+\_\+derivative (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&}]{Ele,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{DD }\end{DoxyParamCaption})}



Computes the directional derivative {\bfseries{normal}} to {\bfseries{all}} (half-\/)edges of a triangle mesh (not just boundary edges). 

These are integrated along the edge\+: they\textquotesingle{}re the per-\/face constant gradient dot the rotated edge vector (unit rotated edge vector for direction then magnitude for integration).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3\texorpdfstring{$\vert$}{|}4 list of triangle\texorpdfstring{$\vert$}{|}tetrahedron indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em DD} & \#F\texorpdfstring{$\ast$}{*}3\texorpdfstring{$\vert$}{|}4 by \#V sparse matrix representing operator to compute directional derivative with respect to each facet of each element. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a01a8628fb6a1bef5682ad416cfcd0a5e}\label{namespaceigl_a01a8628fb6a1bef5682ad416cfcd0a5e} 
\index{igl@{igl}!normalize\_quat@{normalize\_quat}}
\index{normalize\_quat@{normalize\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{normalize\_quat()}{normalize\_quat()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
bool igl\+::normalize\+\_\+quat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{out }\end{DoxyParamCaption})}



Normalize a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & input quaternion \\
\hline
\mbox{\texttt{ out}}  & {\em out} & result of normalization, allowed to be same as q \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false if len(q) \texorpdfstring{$<$}{<} EPS 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a8799fd07216a41e98f6ccaa39aec488f}\label{namespaceigl_a8799fd07216a41e98f6ccaa39aec488f} 
\index{igl@{igl}!null@{null}}
\index{null@{null}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{null()}{null()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedN $>$ \\
void igl\+::null (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



Compute a basis for the null space for the given matrix A\+: the columns of the output N form a basis for the space orthogonal to that spanned by the rows of A. 

Like MATLAB\textquotesingle{}s null


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix \\
\hline
\mbox{\texttt{ out}}  & {\em N} & n by r matrix, where r is the row rank of A \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3ff69240d0614e6f4ab20ff15b2f21a4}\label{namespaceigl_a3ff69240d0614e6f4ab20ff15b2f21a4} 
\index{igl@{igl}!octree@{octree}}
\index{octree@{octree}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{octree()}{octree()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename Index\+Type , typename Derived\+CH , typename Derived\+CN , typename DerivedW $>$ \\
void igl\+::octree (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{point\+\_\+indices,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CH $>$ \&}]{CH,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&}]{CN,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Given a set of 3D points P, generate data structures for a pointerless octree. 

Each cell stores its points, children, center location and width. Our octree is not dense. We use the following rule\+: if the current cell has any number of points, it will have all 8 children. A leaf cell will have -\/1\textquotesingle{}s as its list of child indices.

We use a binary numbering of children. Treating the parent cell\textquotesingle{}s center as the origin, we number the octants in the following manner\+: The first bit is 1 iff the octant\textquotesingle{}s x coordinate is positive The second bit is 1 iff the octant\textquotesingle{}s y coordinate is positive The third bit is 1 iff the octant\textquotesingle{}s z coordinate is positive

For example, the octant with negative x, positive y, positive z is\+: 110 binary = 6 decimal


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of point locations \\
\hline
\mbox{\texttt{ out}}  & {\em point\+\_\+indices} & a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell\textquotesingle{}s points \\
\hline
\mbox{\texttt{ out}}  & {\em CH} & \#\+Octree\+Cells by 8, where the ith row is the indices of the ith octree cell\textquotesingle{}s children \\
\hline
\mbox{\texttt{ out}}  & {\em CN} & \#\+Octree\+Cells by 3, where the ith row is a 3d row vector representing the position of the ith cell\textquotesingle{}s center \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#\+Octree\+Cells, a vector where the ith entry is the width of the ith octree cell \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_afff5efd1454c4544da0680e4c410b7cf}\label{namespaceigl_afff5efd1454c4544da0680e4c410b7cf} 
\index{igl@{igl}!offset\_surface@{offset\_surface}}
\index{offset\_surface@{offset\_surface}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{offset\_surface()}{offset\_surface()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename isolevel\+Type , typename Derived\+SV , typename Derived\+SF , typename Derived\+GV , typename Derivedside , typename DerivedS $>$ \\
void igl\+::offset\+\_\+surface (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const isolevel\+Type}]{isolevel,  }\item[{const typename Derivedside\+::\+Scalar}]{s,  }\item[{const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}} \&}]{signed\+\_\+distance\+\_\+type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedside $>$ \&}]{side,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Compute a triangulated offset surface using matching cubes on a grid of signed distance values from the input triangle mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em isolevel} & iso level to extract (signed distance\+: negative inside) \\
\hline
\mbox{\texttt{ in}}  & {\em s} & number of grid cells along longest side (controls resolution) \\
\hline
\mbox{\texttt{ in}}  & {\em signed\+\_\+distance\+\_\+type} & type of signing to use (see ../signed\+\_\+distance.h) \\
\hline
\mbox{\texttt{ out}}  & {\em SV} & \#\+SV by 3 list of output surface mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em SF} & \#\+SF by 3 list of output mesh triangle indices into SV \\
\hline
\mbox{\texttt{ out}}  & {\em GV} & \#\+GV=side(0)\texorpdfstring{$\ast$}{*}side(1)\texorpdfstring{$\ast$}{*}side(2) by 3 list of grid cell centers \\
\hline
\mbox{\texttt{ out}}  & {\em side} & list of number of grid cells in x, y, and z directions \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#\+GV by 3 list of signed distance values {\itshape near} {\ttfamily isolevel} ("{}far"{} from {\ttfamily isolevel} these values are incorrect) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9f19762456ef8396dfc4096f34c841e6}\label{namespaceigl_a9f19762456ef8396dfc4096f34c841e6} 
\index{igl@{igl}!on\_boundary@{on\_boundary}}
\index{on\_boundary@{on\_boundary}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{on\_boundary()}{on\_boundary()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename IntegerT $>$ \\
void igl\+::on\+\_\+boundary (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ IntegerT $>$ $>$ \&}]{T,  }\item[{std\+::vector$<$ bool $>$ \&}]{I,  }\item[{std\+::vector$<$ std\+::vector$<$ bool $>$ $>$ \&}]{C }\end{DoxyParamCaption})}



Determine boundary facets of mesh elements stored in T. 


\begin{DoxyTemplParams}{Template Parameters}
{\em IntegerT} & integer-\/value\+: i.\+e. int \\
\hline
{\em IntegerF} & integer-\/value\+: i.\+e. int \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & triangle\texorpdfstring{$\vert$}{|}tetrahedron index list, m by 3\texorpdfstring{$\vert$}{|}4, where m is the number of elements \\
\hline
\mbox{\texttt{ out}}  & {\em I} & m long list of bools whether tet is on boundary \\
\hline
\mbox{\texttt{ out}}  & {\em C} & m by 3\texorpdfstring{$\vert$}{|}4 list of bools whether opposite facet is on boundary \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_acc0e9a973c6c86bc98645ef61f4d4b43}\label{namespaceigl_acc0e9a973c6c86bc98645ef61f4d4b43} 
\index{igl@{igl}!on\_boundary@{on\_boundary}}
\index{on\_boundary@{on\_boundary}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{on\_boundary()}{on\_boundary()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename DerivedI , typename DerivedC $>$ \\
void igl\+::on\+\_\+boundary (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ae76f879f4715d4a8596d28f12bc7161d}\label{namespaceigl_ae76f879f4715d4a8596d28f12bc7161d} 
\index{igl@{igl}!orient\_halfedges@{orient\_halfedges}}
\index{orient\_halfedges@{orient\_halfedges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{orient\_halfedges()}{orient\_halfedges()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename Derived\+OE $>$ \\
void igl\+::orient\+\_\+halfedges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&}]{oE }\end{DoxyParamCaption})}



Orients halfedges for a triangle mesh, assigning them to a unique edge. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 input mesh connectivity \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ out}}  & {\em oE} & \#E by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge compared to the orientation of the actual edge. Every edge appears positively oriented exactly once.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a23358af3f14021f32e9d30758f80a9a7}{unique\+\_\+simplices} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a13811b519cd4b97b94f6ef8f3fe90f30}\label{namespaceigl_a13811b519cd4b97b94f6ef8f3fe90f30} 
\index{igl@{igl}!orient\_outward@{orient\_outward}}
\index{orient\_outward@{orient\_outward}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{orient\_outward()}{orient\_outward()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC , typename Derived\+FF , typename DerivedI $>$ \\
void igl\+::orient\+\_\+outward (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Orient each component (identified by C) of a mesh (V,F) so the normals on average point away from the patch\textquotesingle{}s centroid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#F list of components (output of orientable\+\_\+patches) \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#F by 3 list of new triangle indices such that FF(\texorpdfstring{$\sim$}{\string~}I,\+:) = F(\texorpdfstring{$\sim$}{\string~}I,\+:) and FF(\+I,\+:) = fliplr(\+F(\+I,\+:)) (OK if \&FF = \&F) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & max(\+C)+1 list of whether face has been flipped\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_aa7ea97ba9a25206eb1ba9d7469b371d1}{orientable\+\_\+patches}, reorient\+\_\+facets\+\_\+raycast 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_aa7ea97ba9a25206eb1ba9d7469b371d1}\label{namespaceigl_aa7ea97ba9a25206eb1ba9d7469b371d1} 
\index{igl@{igl}!orientable\_patches@{orientable\_patches}}
\index{orientable\_patches@{orientable\_patches}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{orientable\_patches()}{orientable\_patches()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedC , typename AScalar $>$ \\
void igl\+::orientable\+\_\+patches (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ AScalar $>$ \&}]{A }\end{DoxyParamCaption})}



Compute connected components of facets connected by manifold edges. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of facets \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#F list of component ids \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#F by \#F adjacency matrix\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad5c31bf9a8576f1775affb93a5722e85}\label{namespaceigl_ad5c31bf9a8576f1775affb93a5722e85} 
\index{igl@{igl}!orientable\_patches@{orientable\_patches}}
\index{orientable\_patches@{orientable\_patches}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{orientable\_patches()}{orientable\_patches()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedC $>$ \\
void igl\+::orientable\+\_\+patches (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a3f9293ec84689fd8949325ccb22d55fb}\label{namespaceigl_a3f9293ec84689fd8949325ccb22d55fb} 
\index{igl@{igl}!oriented\_facets@{oriented\_facets}}
\index{oriented\_facets@{oriented\_facets}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{oriented\_facets()}{oriented\_facets()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE $>$ \\
void igl\+::oriented\+\_\+facets (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}



Determines all "{}directed \mbox{[}facets\mbox{]}(https\+://en.\+wikipedia.\+org/wiki/\+Simplex\#\+Elements)"{} of a given set of simplicial elements. 

For a manifold triangle mesh, this computes all half-\/edges. For a manifold tetrahedral mesh, this computes all half-\/faces.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of simplices \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by simplex\+\_\+size-\/1 list of facets, such that E.\+row(f+\#F\texorpdfstring{$\ast$}{*}c) is the facet opposite F(f,c)\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
this is not the same as \doxylink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{igl\+::edges} because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-\/manifold edges may appear more than once for each direction). 
\end{DoxyNote}
\Hypertarget{namespaceigl_a8010396f68fc2ad676aa1a713b6a7bc4}\label{namespaceigl_a8010396f68fc2ad676aa1a713b6a7bc4} 
\index{igl@{igl}!orth@{orth}}
\index{orth@{orth}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{orth()}{orth()}}
{\footnotesize\ttfamily void igl\+::orth (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{A,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{Q }\end{DoxyParamCaption})}



Orthogonalization of a matrix. 

ORTH(\+A,\+Q) produces Q as an orthonormal basis for the range of A. That is, Q\textquotesingle{}\texorpdfstring{$\ast$}{*}Q = I, the columns of Q span the same space as the columns of A, and the number of columns of Q is the rank of A.

The algorithm uses singular value decomposition, SVD, instead of orthogonal factorization, QR. This doubles the computation time, but provides more reliable and consistent rank determination. Closely follows MATLAB implementation in orth.\+m


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & m by n matrix with orthonormal columns spanning same column space as A\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
Implementation listed as "{}\+Broken"{} 
\end{DoxyWarning}
\Hypertarget{namespaceigl_a4aa53ae1b1d678353d4056c724b7df7c}\label{namespaceigl_a4aa53ae1b1d678353d4056c724b7df7c} 
\index{igl@{igl}!ortho@{ortho}}
\index{ortho@{ortho}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ortho()}{ortho()}}
{\footnotesize\ttfamily template$<$typename DerivedP $>$ \\
void igl\+::ortho (\begin{DoxyParamCaption}\item[{const typename Derived\+P\+::\+Scalar}]{left,  }\item[{const typename Derived\+P\+::\+Scalar}]{right,  }\item[{const typename Derived\+P\+::\+Scalar}]{bottom,  }\item[{const typename Derived\+P\+::\+Scalar}]{top,  }\item[{const typename Derived\+P\+::\+Scalar}]{near\+Val,  }\item[{const typename Derived\+P\+::\+Scalar}]{far\+Val,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Implementation of the deprecated gl\+Ortho function. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em left} & coordinate of left vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em right} & coordinate of right vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em bottom} & coordinate of bottom vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em top} & coordinate of top vertical clipping plane \\
\hline
\mbox{\texttt{ in}}  & {\em near\+Val} & distance to near plane \\
\hline
\mbox{\texttt{ in}}  & {\em far\+Val} & distance to far plane \\
\hline
\mbox{\texttt{ out}}  & {\em P} & 4x4 perspective matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_abf646b1d4c8ad6dd0d2660d0a5cae584}\label{namespaceigl_abf646b1d4c8ad6dd0d2660d0a5cae584} 
\index{igl@{igl}!outer\_vertex@{outer\_vertex}}
\index{outer\_vertex@{outer\_vertex}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{outer\_vertex()}{outer\_vertex()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ \\
void igl\+::outer\+\_\+vertex (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{v\+\_\+index,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Find a vertex that is reachable from infinite without crossing any faces. 

Such vertex is called "{}outer vertex."{}

Precondition\+: The input mesh must have all self-\/intersection resolved and no duplicated vertices. See cgal\+::remesh\+\_\+self\+\_\+intersections.\+h for how to obtain such input.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of facets to consider \\
\hline
\mbox{\texttt{ out}}  & {\em v\+\_\+index} & index of outer vertex \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#A list of facets incident to the outer vertex\\
\hline
\end{DoxyParams}
\doxylink{outer__element_8h}{include/igl/outer\+\_\+element.\+h} ~\newline
 \Hypertarget{namespaceigl_a8a1dbaf3fab3346a4956ef93313e488b}\label{namespaceigl_a8a1dbaf3fab3346a4956ef93313e488b} 
\index{igl@{igl}!outer\_edge@{outer\_edge}}
\index{outer\_edge@{outer\_edge}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{outer\_edge()}{outer\_edge()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedI , typename Index\+Type , typename DerivedA $>$ \\
void igl\+::outer\+\_\+edge (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{v1,  }\item[{Index\+Type \&}]{v2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A }\end{DoxyParamCaption})}



Find an edge that is reachable from infinity without crossing any faces. 

Such edge is called "{}outer edge."{}

Precondition\+: The input mesh must have all self-\/intersection resolved and no duplicated vertices. The correctness of the output depends on the fact that there is no edge overlap. See cgal\+::remesh\+\_\+self\+\_\+intersections.\+h for how to obtain such input.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of facets to consider \\
\hline
\mbox{\texttt{ out}}  & {\em v1} & index of the first end point of outer edge \\
\hline
\mbox{\texttt{ out}}  & {\em v2} & index of the second end point of outer edge \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#A list of facets incident to the outer edge\\
\hline
\end{DoxyParams}
\doxylink{outer__element_8h}{include/igl/outer\+\_\+element.\+h} ~\newline
 \Hypertarget{namespaceigl_ab8ea262d61548f3946263a5c00ed0192}\label{namespaceigl_ab8ea262d61548f3946263a5c00ed0192} 
\index{igl@{igl}!outer\_facet@{outer\_facet}}
\index{outer\_facet@{outer\_facet}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{outer\_facet()}{outer\_facet()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename Index\+Type $>$ \\
void igl\+::outer\+\_\+facet (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Index\+Type \&}]{f,  }\item[{bool \&}]{flipped }\end{DoxyParamCaption})}



Find a facet that is reachable from infinity without crossing any faces. 

Such facet is called "{}outer facet."{}

Precondition\+: The input mesh must have all self-\/intersection resolved. I.\+e there is no duplicated vertices, no overlapping edge and no intersecting faces (the only exception is there could be topologically duplicated faces). See cgal\+::remesh\+\_\+self\+\_\+intersections.\+h for how to obtain such input.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#N by 3 list of face normals \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I list of facets to consider \\
\hline
\mbox{\texttt{ out}}  & {\em f} & Index of the outer facet. \\
\hline
\mbox{\texttt{ out}}  & {\em flipped} & true iff the normal of f points inwards.\\
\hline
\end{DoxyParams}
\doxylink{outer__element_8h}{include/igl/outer\+\_\+element.\+h} \Hypertarget{namespaceigl_a48ba3dac8f2da11935cd7e566f27e69d}\label{namespaceigl_a48ba3dac8f2da11935cd7e566f27e69d} 
\index{igl@{igl}!parallel\_for@{parallel\_for}}
\index{parallel\_for@{parallel\_for}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parallel\_for()}{parallel\_for()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Index , typename Function\+Type $>$ \\
bool igl\+::parallel\+\_\+for (\begin{DoxyParamCaption}\item[{const Index}]{loop\+\_\+size,  }\item[{const Function\+Type \&}]{func,  }\item[{const size\+\_\+t}]{min\+\_\+parallel = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Functional implementation of a basic, open-\/mp style, parallel for loop. 

If the inner block of a for-\/loop can be rewritten/encapsulated in a single (anonymous/lambda) function call {\ttfamily func} so that the serial code looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i\ =\ 0;i<loop\_size;i++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ func(i);}
\DoxyCodeLine{\}}

\end{DoxyCode}


then {\ttfamily parallel\+\_\+for(loop\+\_\+size,func,min\+\_\+parallel)} will use as many threads as available on the current hardware to parallelize this for loop so long as loop\+\_\+size\texorpdfstring{$<$}{<}min\+\_\+parallel, otherwise it will just use a serial for loop.

Often if your code looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i\ =\ 0;i<loop\_size;i++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\}}

\end{DoxyCode}


Then you can make a minimal two-\/line change to parallelize it\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//for(int\ i\ =\ 0;i<loop\_size;i++)}}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a48ba3dac8f2da11935cd7e566f27e69d}{parallel\_for}}(loop\_size,[\&](\textcolor{keywordtype}{int}\ i)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ }
\DoxyCodeLine{\}}
\DoxyCodeLine{,1000);}

\end{DoxyCode}



\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em loop\+\_\+size} & number of iterations. I.\+e. for(int i = 0;i\texorpdfstring{$<$}{<}loop\+\_\+size;i++) ... \\
\hline
\mbox{\texttt{ in}}  & {\em func} & function handle taking iteration index as only argument to compute inner block of for loop I.\+e. for(int i ...)\{ func(i); \} \\
\hline
\mbox{\texttt{ in}}  & {\em min\+\_\+parallel} & min size of loop\+\_\+size such that parallel (non-\/serial) thread pooling should be attempted \{0\} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff thread pool was invoked 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a8e1804e24a4fefa3bbe3e6241bd00f75}\label{namespaceigl_a8e1804e24a4fefa3bbe3e6241bd00f75} 
\index{igl@{igl}!parallel\_for@{parallel\_for}}
\index{parallel\_for@{parallel\_for}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parallel\_for()}{parallel\_for()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Index , typename Prep\+Function\+Type , typename Function\+Type , typename Accum\+Function\+Type $>$ \\
bool igl\+::parallel\+\_\+for (\begin{DoxyParamCaption}\item[{const Index}]{loop\+\_\+size,  }\item[{const Prep\+Function\+Type \&}]{prep\+\_\+func,  }\item[{const Function\+Type \&}]{func,  }\item[{const Accum\+Function\+Type \&}]{accum\+\_\+func,  }\item[{const size\+\_\+t}]{min\+\_\+parallel = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Functional implementation of an open-\/mp style, parallel for loop with accumulation. 

For example, serial code separated into n chunks (each to be parallelized with a thread) might look like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXd\ S;}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \&\ prep\_func\ =\ [\&S](\textcolor{keywordtype}{int}\ n)\{\ S\ =\ Eigen:VectorXd::Zero(n);\ \};}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \&\ func\ =\ [\&X,\&S](\textcolor{keywordtype}{int}\ i,\ \textcolor{keywordtype}{int}\ t)\{\ S(t)\ +=\ X(i);\ \};}
\DoxyCodeLine{\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ \&\ accum\_func\ =\ [\&S,\&\mbox{\hyperlink{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}{sum}}](\textcolor{keywordtype}{int}\ t)\{\ \mbox{\hyperlink{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}{sum}}\ +=\ S(t);\ \};}
\DoxyCodeLine{prep\_func(n);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i\ =\ 0;i<loop\_size;i++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ func(i,i\%n);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ \mbox{\hyperlink{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}{sum}}\ =\ 0;}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ t\ =\ 0;t<n;t++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ accum\_func(t);}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em loop\+\_\+size} & number of iterations. I.\+e. for(int i = 0;i\texorpdfstring{$<$}{<}loop\+\_\+size;i++) ... \\
\hline
\mbox{\texttt{ in}}  & {\em prep\+\_\+func} & function handle taking n \texorpdfstring{$>$}{>}= number of threads as only argument \\
\hline
\mbox{\texttt{ in}}  & {\em func} & function handle taking iteration index i and thread id t as only arguments to compute inner block of for loop I.\+e. for(int i ...)\{ func(i,t); \} \\
\hline
\mbox{\texttt{ in}}  & {\em accum\+\_\+func} & function handle taking thread index as only argument, to be called after all calls of func, e.\+g., for serial accumulation across all n (potential) threads, see n in description of prep\+\_\+func. \\
\hline
\mbox{\texttt{ in}}  & {\em min\+\_\+parallel} & min size of loop\+\_\+size such that parallel (non-\/serial) thread pooling should be attempted \{0\} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff thread pool was invoked 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a842fd7e11ac0c43a81d15fa137337adb}\label{namespaceigl_a842fd7e11ac0c43a81d15fa137337adb} 
\index{igl@{igl}!parallel\_transport\_angles@{parallel\_transport\_angles}}
\index{parallel\_transport\_angles@{parallel\_transport\_angles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parallel\_transport\_angles()}{parallel\_transport\_angles()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedK $>$ \\
void igl\+::parallel\+\_\+transport\+\_\+angles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{FN,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{E2F,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F2E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedK $>$ \&}]{K }\end{DoxyParamCaption})}



Given the per-\/face local bases computed via \doxylink{namespaceigl_a108a662cae580e5c3459d81435f32e24}{igl\+::local\+\_\+basis}, this function computes the angle between the two reference frames across each edge. 

Any two vectors across the edge whose 2D representation only differs by this angle are considered to be parallel.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3 list of face normals \\
\hline
\mbox{\texttt{ in}}  & {\em E2F} & \#E by 2 list of the edge-\/to-\/face relation (e.\+g. computed via \doxylink{namespaceigl_a182268447e88dbae647fd2971598226a}{igl\+::edge\+\_\+topology}) \\
\hline
\mbox{\texttt{ in}}  & {\em F2E} & \#F by 3 list of the face-\/to-\/edge relation (e.\+g. computed \\
\hline
\mbox{\texttt{ out}}  & {\em K} & \#E by 1 list of the parallel transport angles (zero for all boundary edges) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af85fb6c92debf67385c27c8a06c2a1f9}\label{namespaceigl_af85fb6c92debf67385c27c8a06c2a1f9} 
\index{igl@{igl}!partition@{partition}}
\index{partition@{partition}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{partition()}{partition()}}
{\footnotesize\ttfamily void igl\+::partition (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{G,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{S,  }\item[{Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, 1 $>$ \&}]{D }\end{DoxyParamCaption})}



Partition vertices into groups based on each vertex\textquotesingle{}s vector\+: vertices with similar coordinates (close in space) will be put in the same group. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em W} & \#W by dim coordinate matrix \\
\hline
\mbox{\texttt{ in}}  & {\em k} & desired number of groups default is dim \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#W list of group indices (1 to k) for each vertex, such that vertex i is assigned to group G(i) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & k list of seed vertices \\
\hline
\mbox{\texttt{ out}}  & {\em D} & \#W list of squared distances for each vertex to it\textquotesingle{}s corresponding closest seed \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa9dfa8a07d0d391278ff5023da5ba1bf}\label{namespaceigl_aa9dfa8a07d0d391278ff5023da5ba1bf} 
\index{igl@{igl}!parula@{parula}}
\index{parula@{parula}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parula()}{parula()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::parula (\begin{DoxyParamCaption}\item[{const T}]{f,  }\item[{T \texorpdfstring{$\ast$}{*}}]{rgb }\end{DoxyParamCaption})}



Parula colormap like MATLAB\textquotesingle{}s parula. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & factor determining color value as if 0 was min and 1 was max \\
\hline
\mbox{\texttt{ out}}  & {\em rgb} & resulting rgb color
\begin{DoxyItemize}
\item r red value
\item g green value
\item b blue value 
\end{DoxyItemize}\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a79a5375852c84e549987ad3aedd7e80e}\label{namespaceigl_a79a5375852c84e549987ad3aedd7e80e} 
\index{igl@{igl}!parula@{parula}}
\index{parula@{parula}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parula()}{parula()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::parula (\begin{DoxyParamCaption}\item[{const T}]{f,  }\item[{T \&}]{r,  }\item[{T \&}]{g,  }\item[{T \&}]{b }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a36caf45296cda61ad8a61ee3772378e7}\label{namespaceigl_a36caf45296cda61ad8a61ee3772378e7} 
\index{igl@{igl}!parula@{parula}}
\index{parula@{parula}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parula()}{parula()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedZ , typename DerivedC $>$ \\
void igl\+::parula (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{const bool}]{normalize,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Z} & \#Z list of factors \\
\hline
\mbox{\texttt{ in}}  & {\em normalize} & whether to normalize Z to be tightly between \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C by 3 list of rgb colors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a70ff59da460d9fa5095c2cd9447fe9a4}\label{namespaceigl_a70ff59da460d9fa5095c2cd9447fe9a4} 
\index{igl@{igl}!parula@{parula}}
\index{parula@{parula}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{parula()}{parula()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedZ , typename DerivedC $>$ \\
void igl\+::parula (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{const double}]{min\+\_\+Z,  }\item[{const double}]{max\+\_\+Z,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em min\+\_\+z} & value at blue \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+z} & value at red \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad9dedb9d3d8f684abb92cef75cacdb69}\label{namespaceigl_ad9dedb9d3d8f684abb92cef75cacdb69} 
\index{igl@{igl}!path\_to\_edges@{path\_to\_edges}}
\index{path\_to\_edges@{path\_to\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{path\_to\_edges()}{path\_to\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedI , typename DerivedE $>$ \\
void igl\+::path\+\_\+to\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{bool}]{make\+\_\+loop = {\ttfamily false} }\end{DoxyParamCaption})}



Given a path as an ordered list of N\texorpdfstring{$>$}{>}=2 vertex indices I\mbox{[}0\mbox{]}, I\mbox{[}1\mbox{]}, ..., I\mbox{[}N-\/1\mbox{]} construct a list of edges \mbox{[}\mbox{[}I\mbox{[}0\mbox{]},I\mbox{[}1\mbox{]}\mbox{]}, \mbox{[}I\mbox{[}1\mbox{]},I\mbox{[}2\mbox{]}\mbox{]}, ..., \mbox{[}I\mbox{[}N-\/2\mbox{]}, I\mbox{[}N-\/1\mbox{]}\mbox{]}\mbox{]} connecting each sequential pair of vertices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em I} & \#I list of vertex indices \\
\hline
\mbox{\texttt{ in}}  & {\em make\+\_\+loop} & bool If true, include an edge connecting I\mbox{[}N-\/1\mbox{]} to I\mbox{[}0\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#I-\/1 by 2 list of edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_abc2ac47ac2adbe917283d5dd317dab36}\label{namespaceigl_abc2ac47ac2adbe917283d5dd317dab36} 
\index{igl@{igl}!path\_to\_edges@{path\_to\_edges}}
\index{path\_to\_edges@{path\_to\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{path\_to\_edges()}{path\_to\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Index , typename DerivedE $>$ \\
void igl\+::path\+\_\+to\+\_\+edges (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Index $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{bool}]{make\+\_\+loop = {\ttfamily false} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a35cb149bbe78233befd8a3fcbf0bf0f9}\label{namespaceigl_a35cb149bbe78233befd8a3fcbf0bf0f9} 
\index{igl@{igl}!path\_to\_executable@{path\_to\_executable}}
\index{path\_to\_executable@{path\_to\_executable}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{path\_to\_executable()}{path\_to\_executable()}}
{\footnotesize\ttfamily std\+::string igl\+::path\+\_\+to\+\_\+executable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Path to current executable. 

\begin{DoxyReturn}{Returns}
path as string 
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Tested for Mac OS X 
\end{DoxyNote}
\Hypertarget{namespaceigl_a541dccb34e02684e3d43966fca86bdaf}\label{namespaceigl_a541dccb34e02684e3d43966fca86bdaf} 
\index{igl@{igl}!pathinfo@{pathinfo}}
\index{pathinfo@{pathinfo}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pathinfo()}{pathinfo()}}
{\footnotesize\ttfamily void igl\+::pathinfo (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{path,  }\item[{std\+::string \&}]{dirname,  }\item[{std\+::string \&}]{basename,  }\item[{std\+::string \&}]{extension,  }\item[{std\+::string \&}]{filename }\end{DoxyParamCaption})}



Function like PHP\textquotesingle{}s pathinfo to return information about path. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em path} & string containing input path \\
\hline
\mbox{\texttt{ out}}  & {\em dirname} & string containing dirname (see \doxylink{dirname_8h}{dirname.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em basename} & string containing basename (see \doxylink{basename_8h}{basename.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em extension} & string containing extension (characters after last \textquotesingle{}.\textquotesingle{}) \\
\hline
\mbox{\texttt{ out}}  & {\em filename} & string containing filename (characters of basename before last \textquotesingle{}.\textquotesingle{})\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md18}{}\doxyparagraph{\texorpdfstring{Examples}{Examples}}\label{namespaceigl_autotoc_md18}
\begin{DoxyVerb} input                     | dirname        basename       ext    filename
 "/"                       | "/"            ""             ""     ""
 "//"                      | "/"            ""             ""     ""
 "/foo"                    | "/"            "foo"          ""     "foo"
 "/foo/"                   | "/"            "foo"          ""     "foo"
 "/foo//"                  | "/"            "foo"          ""     "foo"
 "/foo/./"                 | "/foo"         "."            ""     ""
 "/foo/bar"                | "/foo"         "bar"          ""     "bar"
 "/foo/bar."               | "/foo"         "bar."         ""     "bar"
 "/foo/bar.txt"            | "/foo"         "bar.txt"      "txt"  "bar"
 "/foo/bar.txt.zip"        | "/foo"         "bar.txt.zip"  "zip"  "bar.txt"
 "/foo/bar.dir/"           | "/foo"         "bar.dir"      "dir"  "bar"
 "/foo/bar.dir/file"       | "/foo/bar.dir" "file"         ""     "file"
 "/foo/bar.dir/file.txt"   | "/foo/bar.dir" "file.txt"     "txt"  "file"
\end{DoxyVerb}
 \begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_aa32f08d2b80c8d69515001b7d6347e82}{basename}, \doxylink{namespaceigl_aef1ff1d390be65861384b6ff764ebe09}{dirname} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a3a09c2edf78994c6f25f23a9212a3666}\label{namespaceigl_a3a09c2edf78994c6f25f23a9212a3666} 
\index{igl@{igl}!per\_corner\_normals@{per\_corner\_normals}}
\index{per\_corner\_normals@{per\_corner\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_corner\_normals()}{per\_corner\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+CN $>$ \\
void igl\+::per\+\_\+corner\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+V\+::\+Scalar}]{corner\+\_\+threshold\+\_\+degrees,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&}]{CN }\end{DoxyParamCaption})}



Compute per corner normals for a triangle mesh by computing the area-\/weighted average of normals at incident faces whose normals deviate less than the provided threshold. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em corner\+\_\+threshold\+\_\+degrees} & threshold in degrees on sharp angles \\
\hline
\mbox{\texttt{ out}}  & {\em CN} & \#F\texorpdfstring{$\ast$}{*}3 by 3 list of mesh vertex 3D normals, where the normal for corner F(i,j) is at CN.\+row(i\texorpdfstring{$\ast$}{*}3+j) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1038de65b964583d4ea533a631e6c1b8}\label{namespaceigl_a1038de65b964583d4ea533a631e6c1b8} 
\index{igl@{igl}!per\_corner\_normals@{per\_corner\_normals}}
\index{per\_corner\_normals@{per\_corner\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_corner\_normals()}{per\_corner\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VF , typename Derived\+NI , typename Derived\+CN $>$ \\
void igl\+::per\+\_\+corner\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+V\+::\+Scalar}]{corner\+\_\+threshold\+\_\+degrees,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VF $>$ \&}]{VF,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+NI $>$ \&}]{NI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&}]{CN }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em VF} & 3\texorpdfstring{$\ast$}{*}\#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. \\
\hline
\mbox{\texttt{ in}}  & {\em NI} & \#V+1 list cumulative sum of vertex-\/triangle degrees with a preceeding zero. "{}\+How many faces"{} have been seen before visiting this vertex and its incident faces.\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acabdf409439e0498066a620d30db6899}{vertex\+\_\+triangle\+\_\+adjacency} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a01b4e893d7a38a99124fb826f0f337c1}\label{namespaceigl_a01b4e893d7a38a99124fb826f0f337c1} 
\index{igl@{igl}!per\_corner\_normals@{per\_corner\_normals}}
\index{per\_corner\_normals@{per\_corner\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_corner\_normals()}{per\_corner\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+CI , typename Derived\+CC , typename Derived\+CN $>$ \\
void igl\+::per\+\_\+corner\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CI $>$ \&}]{CI,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CC $>$ \&}]{CC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&}]{CN }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em CI} & \#\+CI list of face neighbors as indices into rows of F \\
\hline
\mbox{\texttt{ in}}  & {\em CC} & 3\texorpdfstring{$\ast$}{*}\#F+1 list of cumulative sizes so that CC(i\texorpdfstring{$\ast$}{*}3+j+1) -\/ CC(i\texorpdfstring{$\ast$}{*}3+j) is the number of faces considered smoothly incident on corner at F(i,j)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_aef5e220e449787733ece4abbc94f419a}{smooth\+\_\+corner\+\_\+adjacency} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_aac0d1344faa3702f4c79dcdf54888c68}\label{namespaceigl_aac0d1344faa3702f4c79dcdf54888c68} 
\index{igl@{igl}!per\_corner\_normals@{per\_corner\_normals}}
\index{per\_corner\_normals@{per\_corner\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_corner\_normals()}{per\_corner\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$typename Derived\+NV , typename Derived\+NF , typename Derived\+CN $>$ \\
void igl\+::per\+\_\+corner\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+NV $>$ \&}]{NV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+NF $>$ \&}]{NF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&}]{CN }\end{DoxyParamCaption})}



Given indexed normals (e.\+g., read from a .obj file), explode into per-\/corner normals (e.\+g., as expected by \doxylink{classigl_1_1opengl_1_1ViewerData}{igl\+::opengl\+::\+Viewer\+Data}) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em NV} & \#\+NV by 3 list of index normal vectors \\
\hline
\mbox{\texttt{ in}}  & {\em NF} & \#F by nc list of indices into rows of NV \\
\hline
\mbox{\texttt{ out}}  & {\em CN} & \#F\texorpdfstring{$\ast$}{*}nc by 3 list of per-\/corner normals so that CN.\+row(i\texorpdfstring{$\ast$}{*}nc+c) = NV.\+row(\+NF(i,c)) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4353bfd8d4ca70d1ea3bdf98dbfb50f4}\label{namespaceigl_a4353bfd8d4ca70d1ea3bdf98dbfb50f4} 
\index{igl@{igl}!per\_corner\_normals@{per\_corner\_normals}}
\index{per\_corner\_normals@{per\_corner\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_corner\_normals()}{per\_corner\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename Derived\+VV , typename Derived\+FF , typename DerivedJ , typename Derived\+NN $>$ \\
void igl\+::per\+\_\+corner\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const typename Derived\+V\+::\+Scalar}]{corner\+\_\+threshold\+\_\+degrees,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&}]{VV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NN $>$ \&}]{NN }\end{DoxyParamCaption})}



Per-\/corner normals for a polygon mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#polygons+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\mbox{\texttt{ in}}  & {\em corner\+\_\+threshold} & threshold in degrees on sharp angles \\
\hline
\mbox{\texttt{ out}}  & {\em N} & \#I by 3 list of per corner normals \\
\hline
\mbox{\texttt{ out}}  & {\em VV} & \#I+\#polygons by 3 list of auxiliary triangle mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#I by 3 list of triangle indices into rows of VV \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#I list of indices into original polygons \\
\hline
\mbox{\texttt{ out}}  & {\em NN} & \#\+FF by 3 list of normals for each auxiliary triangle \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae0359520eb722b81b3460a2dc23178e2}\label{namespaceigl_ae0359520eb722b81b3460a2dc23178e2} 
\index{igl@{igl}!per\_edge\_normals@{per\_edge\_normals}}
\index{per\_edge\_normals@{per\_edge\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_edge\_normals()}{per\_edge\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename DerivedN , typename DerivedE , typename Derived\+EMAP $>$ \\
void igl\+::per\+\_\+edge\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55}{Per\+Edge\+Normals\+Weighting\+Type}}}]{weight,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



Compute face normals via vertex position list, face list. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ in}}  & {\em weight} & weighting type \\
\hline
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3 matrix of 3D face normals per face \\
\hline
\mbox{\texttt{ out}}  & {\em N} & \#2 by 3 matrix of mesh edge 3D normals per row \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#E by 2 matrix of edge indices per row \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#E by 1 matrix of indices from all edges to E \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_accd393d9be7212b4986f0e14328e4acc}\label{namespaceigl_accd393d9be7212b4986f0e14328e4acc} 
\index{igl@{igl}!per\_edge\_normals@{per\_edge\_normals}}
\index{per\_edge\_normals@{per\_edge\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_edge\_normals()}{per\_edge\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename Derived\+EMAP $>$ \\
void igl\+::per\+\_\+edge\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a347183daf701cad3537c990f8ce0cf55}{Per\+Edge\+Normals\+Weighting\+Type}}}]{weight,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_abe5c6976aa15d2689a00df1cbb695776}\label{namespaceigl_abe5c6976aa15d2689a00df1cbb695776} 
\index{igl@{igl}!per\_edge\_normals@{per\_edge\_normals}}
\index{per\_edge\_normals@{per\_edge\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_edge\_normals()}{per\_edge\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename Derived\+EMAP $>$ \\
void igl\+::per\+\_\+edge\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a3d793baadcefcf122deae556812b2406}\label{namespaceigl_a3d793baadcefcf122deae556812b2406} 
\index{igl@{igl}!per\_face\_normals@{per\_face\_normals}}
\index{per\_face\_normals@{per\_face\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_face\_normals()}{per\_face\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedZ , typename DerivedN $>$ \\
void igl\+::per\+\_\+face\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedZ $>$ \&}]{Z,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



Compute face normals via vertex position list, face list. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ in}}  & {\em Z} & 3 vector normal given to faces with degenerate normal. \\
\hline
\mbox{\texttt{ out}}  & {\em N} & \#F by 3 eigen Matrix of mesh face (triangle) 3D normals\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md19}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md19}
// Give degenerate faces (1/3,1/3,1/3)\texorpdfstring{$^\wedge$}{\string^}0.5 per\+\_\+face\+\_\+normals(V,F,Vector3d(1,1,1).normalized(),N); \Hypertarget{namespaceigl_aa5e240d2506aa22bb2a07edd7636d6cb}\label{namespaceigl_aa5e240d2506aa22bb2a07edd7636d6cb} 
\index{igl@{igl}!per\_face\_normals@{per\_face\_normals}}
\index{per\_face\_normals@{per\_face\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_face\_normals()}{per\_face\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
void igl\+::per\+\_\+face\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper with Z = (0,0,0). Note that this means that row norms will be zero (i.\+e. not 1) for degenerate normals. \Hypertarget{namespaceigl_a49d8e3459f18186d9cbfd36ba4c053bc}\label{namespaceigl_a49d8e3459f18186d9cbfd36ba4c053bc} 
\index{igl@{igl}!per\_face\_normals\_stable@{per\_face\_normals\_stable}}
\index{per\_face\_normals\_stable@{per\_face\_normals\_stable}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_face\_normals\_stable()}{per\_face\_normals\_stable()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
void igl\+::per\+\_\+face\+\_\+normals\+\_\+stable (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Special version where order of face indices is guaranteed not to effect output. \Hypertarget{namespaceigl_a95670a831d56f91f1afdd042cc8ae97b}\label{namespaceigl_a95670a831d56f91f1afdd042cc8ae97b} 
\index{igl@{igl}!per\_face\_normals@{per\_face\_normals}}
\index{per\_face\_normals@{per\_face\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_face\_normals()}{per\_face\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename Derived\+VV , typename Derived\+FF , typename DerivedJ $>$ \\
void igl\+::per\+\_\+face\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VV $>$ \&}]{VV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Per face normals for a general polygon mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#polygons+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\mbox{\texttt{ in}}  & {\em corner\+\_\+threshold} & threshold in degrees on sharp angles \\
\hline
\mbox{\texttt{ out}}  & {\em N} & \#polygons by 3 list of per face normals \\
\hline
\mbox{\texttt{ out}}  & {\em VV} & \#I+\#polygons by 3 list of auxiliary triangle mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#I by 3 list of triangle indices into rows of VV \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#I list of indices into original polygons \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a55694e78e07c4a2640cbfa122fa3deed}\label{namespaceigl_a55694e78e07c4a2640cbfa122fa3deed} 
\index{igl@{igl}!per\_vertex\_attribute\_smoothing@{per\_vertex\_attribute\_smoothing}}
\index{per\_vertex\_attribute\_smoothing@{per\_vertex\_attribute\_smoothing}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_vertex\_attribute\_smoothing()}{per\_vertex\_attribute\_smoothing()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::per\+\_\+vertex\+\_\+attribute\+\_\+smoothing (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{Ain,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{Aout }\end{DoxyParamCaption})}



Smooth vertex attributes using uniform Laplacian. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Ain} & \#V by \#A eigen Matrix of mesh vertex attributes (each vertex has \#A attributes) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigne Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ out}}  & {\em Aout} & \#V by \#A eigen Matrix of mesh vertex attributes \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7d913043c5590b413bc2ea64adae0c17}\label{namespaceigl_a7d913043c5590b413bc2ea64adae0c17} 
\index{igl@{igl}!per\_vertex\_normals@{per\_vertex\_normals}}
\index{per\_vertex\_normals@{per\_vertex\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_vertex\_normals()}{per\_vertex\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
void igl\+::per\+\_\+vertex\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}{igl\+::\+Per\+Vertex\+Normals\+Weighting\+Type}}}]{weighting,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



Compute vertex normals via vertex position list, face list. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ in}}  & {\em weighting} & Weighting type \\
\hline
\mbox{\texttt{ out}}  & {\em N} & \#V by 3 eigen Matrix of mesh vertex 3D normals \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3b0ea8f0fee8d96f0acbda506d40fe2d}\label{namespaceigl_a3b0ea8f0fee8d96f0acbda506d40fe2d} 
\index{igl@{igl}!per\_vertex\_normals@{per\_vertex\_normals}}
\index{per\_vertex\_normals@{per\_vertex\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_vertex\_normals()}{per\_vertex\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
void igl\+::per\+\_\+vertex\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa29a9edc300d4684a03a6d656d2d715c}\label{namespaceigl_aa29a9edc300d4684a03a6d656d2d715c} 
\index{igl@{igl}!per\_vertex\_normals@{per\_vertex\_normals}}
\index{per\_vertex\_normals@{per\_vertex\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_vertex\_normals()}{per\_vertex\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename DerivedN $>$ \\
void igl\+::per\+\_\+vertex\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a9bd1d9465ddaaed7691194b99b3b9f94}{Per\+Vertex\+Normals\+Weighting\+Type}}}]{weighting,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3 matrix of face (triangle) normals \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_addca97c5fd3aeb0c2ed9fb260b020092}\label{namespaceigl_addca97c5fd3aeb0c2ed9fb260b020092} 
\index{igl@{igl}!per\_vertex\_normals@{per\_vertex\_normals}}
\index{per\_vertex\_normals@{per\_vertex\_normals}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_vertex\_normals()}{per\_vertex\_normals()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename DerivedN $>$ \\
void igl\+::per\+\_\+vertex\+\_\+normals (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a3ac6a5f35466ea9216e1de32fecaf032}\label{namespaceigl_a3ac6a5f35466ea9216e1de32fecaf032} 
\index{igl@{igl}!per\_vertex\_point\_to\_plane\_quadrics@{per\_vertex\_point\_to\_plane\_quadrics}}
\index{per\_vertex\_point\_to\_plane\_quadrics@{per\_vertex\_point\_to\_plane\_quadrics}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{per\_vertex\_point\_to\_plane\_quadrics()}{per\_vertex\_point\_to\_plane\_quadrics()}}
{\footnotesize\ttfamily void igl\+::per\+\_\+vertex\+\_\+point\+\_\+to\+\_\+plane\+\_\+quadrics (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EF,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{EI,  }\item[{std\+::vector$<$ std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ $>$ \&}]{quadrics }\end{DoxyParamCaption})}



Compute quadrics per vertex of a "{}closed"{} triangle mesh (V,F). 

Rather than follow the qslim paper, this implements the lesser-\/known {\itshape follow up} "{}\+Simplifying Surfaces with Color and Texture using Quadric Error Metrics"{}. This allows V to be n-\/dimensional (where the extra coordiantes store texture UVs, color RGBs, etc.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by n list of vertex positions. Assumes that vertices with infinite coordinates are "{}points at infinity"{} being used to close up boundary edges with faces. This allows special subspace quadrice for boundary edges\+: There should never be more than one "{}point at     infinity"{} in a single triangle. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V. \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into E, mapping each directed edge to unique unique edge in E \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge flaps, EF(e,0)=f means e=(i-\/-\/\texorpdfstring{$>$}{>}j) is the edge of F(f,\+:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "{} e=(j-\/\texorpdfstring{$>$}{>}i) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge flap corners (see above). \\
\hline
\mbox{\texttt{ out}}  & {\em quadrics} & \#V list of quadrics, where a quadric is a tuple \{A,b,c\} such that the quadratic energy of moving this vertex to position x is given by x\textquotesingle{}Ax -\/ 2b + c \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9edfc37639a2817ac5ffde534ec7391a}\label{namespaceigl_a9edfc37639a2817ac5ffde534ec7391a} 
\index{igl@{igl}!piecewise\_constant\_winding\_number@{piecewise\_constant\_winding\_number}}
\index{piecewise\_constant\_winding\_number@{piecewise\_constant\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{piecewise\_constant\_winding\_number()}{piecewise\_constant\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DeriveduE , typename Derivedu\+EC , typename Derivedu\+EE $>$ \\
bool igl\+::piecewise\+\_\+constant\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE }\end{DoxyParamCaption})}



Determine if a given mesh induces a piecewise constant winding number field\+: Is this mesh valid input to solid set operations. 

{\bfseries{Assumes}} that {\ttfamily (V,F)} contains no self-\/intersections (including degeneracies and co-\/incidences). If there are co-\/planar and co-\/incident vertex placements, a mesh could {\itshape fail} this combinatorial test but still induce a piecewise-\/constant winding number {\itshape geometrically}. For example, consider a hemisphere with boundary and then pinch the boundary "{}shut"{} along a line segment. The \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\+\_\+bullet-\/proof\+\_\+\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} check is to first resolve all self-\/intersections in {\ttfamily (V,F) -\/\texorpdfstring{$>$}{>} (SV,SF)} (i.\+e. what the {\ttfamily \doxylink{namespaceigl_1_1copyleft_1_1cgal_a55276c7ddaadbfad9b0ddf0beeb756fe}{igl\+::copyleft\+::cgal\+::piecewise\+\_\+constant\+\_\+winding\+\_\+number}} overload does).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into some (abstract) list of vertices V \\
\hline
\mbox{\texttt{ in}}  & {\em uE} & \#uE by 2 list of unique edges indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumsums of directed edges sharing each unique edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#E list of indices into E (see {\ttfamily \doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{igl\+::unique\+\_\+edge\+\_\+map}}) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the mesh {\itshape combinatorially} induces a piecewise constant winding number field. 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a4321fc08252fa849e3fa6f47f3047fd9}\label{namespaceigl_a4321fc08252fa849e3fa6f47f3047fd9} 
\index{igl@{igl}!piecewise\_constant\_winding\_number@{piecewise\_constant\_winding\_number}}
\index{piecewise\_constant\_winding\_number@{piecewise\_constant\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{piecewise\_constant\_winding\_number()}{piecewise\_constant\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF $>$ \\
bool igl\+::piecewise\+\_\+constant\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad226f56507bf0f6f88843734531e04cb}\label{namespaceigl_ad226f56507bf0f6f88843734531e04cb} 
\index{igl@{igl}!pinv@{pinv}}
\index{pinv@{pinv}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pinv()}{pinv()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedX $>$ \\
void igl\+::pinv (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{typename Derived\+A\+::\+Scalar}]{tol,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X }\end{DoxyParamCaption})}



Compute the Moore-\/\+Penrose pseudoinverse. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em tol} & tolerance (if negative then default is used) \\
\hline
\mbox{\texttt{ out}}  & {\em X} & n by m matrix so that A\texorpdfstring{$\ast$}{*}\+X\texorpdfstring{$\ast$}{*}A = A and X\texorpdfstring{$\ast$}{*}\+A\texorpdfstring{$\ast$}{*}X = X and A\texorpdfstring{$\ast$}{*}X = (A\texorpdfstring{$\ast$}{*}X)\textquotesingle{} and (X\texorpdfstring{$\ast$}{*}A) = (X\texorpdfstring{$\ast$}{*}A)\textquotesingle{}\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a11e789f2ff1ea85406f3c41468c7f1b5}\label{namespaceigl_a11e789f2ff1ea85406f3c41468c7f1b5} 
\index{igl@{igl}!pinv@{pinv}}
\index{pinv@{pinv}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pinv()}{pinv()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedX $>$ \\
void igl\+::pinv (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a4a6123b286eebf1eb6e5ca4957ae2b89}\label{namespaceigl_a4a6123b286eebf1eb6e5ca4957ae2b89} 
\index{igl@{igl}!planarize\_quad\_mesh@{planarize\_quad\_mesh}}
\index{planarize\_quad\_mesh@{planarize\_quad\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{planarize\_quad\_mesh()}{planarize\_quad\_mesh()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::planarize\+\_\+quad\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{Vin,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{max\+Iter,  }\item[{const double \&}]{threshold,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{Vout }\end{DoxyParamCaption})}



Planarizes a given quad mesh using the algorithm described in the paper "{}\+Shape-\/\+Up\+: Shaping Discrete Geometry with Projections"{} by S. 

Bouaziz, M. Deuss, Y. Schwartzburg, T. Weise, M. Pauly, Computer Graphics Forum, Volume 31, Issue 5, August 2012, p. 1657-\/1667 (\href{http://dl.acm.org/citation.cfm?id=2346802}{\texttt{ http\+://dl.\+acm.\+org/citation.\+cfm?id=2346802}}). The algorithm iterates between projecting each quad to its closest planar counterpart and stitching those quads together via a least squares optimization. It stops whenever all quads\textquotesingle{} non-\/planarity is less than a given threshold (suggested value\+: 0.\+01), or a maximum number of iterations is reached.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Vin} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 4 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ in}}  & {\em max\+Iter} & maximum numbers of iterations \\
\hline
\mbox{\texttt{ in}}  & {\em threshold} & minimum allowed threshold for non-\/planarity \\
\hline
\mbox{\texttt{ out}}  & {\em Vout} & \#V by 3 eigen Matrix of planar mesh vertex 3D positions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0dad55e28df3f93b606cddb108b85e9d}\label{namespaceigl_a0dad55e28df3f93b606cddb108b85e9d} 
\index{igl@{igl}!point\_in\_circle@{point\_in\_circle}}
\index{point\_in\_circle@{point\_in\_circle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{point\_in\_circle()}{point\_in\_circle()}}
{\footnotesize\ttfamily bool igl\+::point\+\_\+in\+\_\+circle (\begin{DoxyParamCaption}\item[{const double}]{qx,  }\item[{const double}]{qy,  }\item[{const double}]{cx,  }\item[{const double}]{cy,  }\item[{const double}]{r }\end{DoxyParamCaption})}



Determine if 2d point is in a circle. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em qx} & x-\/coordinate of query point \\
\hline
\mbox{\texttt{ in}}  & {\em qy} & y-\/coordinate of query point \\
\hline
\mbox{\texttt{ in}}  & {\em cx} & x-\/coordinate of circle center \\
\hline
\mbox{\texttt{ in}}  & {\em cy} & y-\/coordinate of circle center \\
\hline
\mbox{\texttt{ in}}  & {\em r} & radius of circle \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if query point is in circle, false otherwise 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ae9616bb9fd33e6c00dcb4e8f91952091}\label{namespaceigl_ae9616bb9fd33e6c00dcb4e8f91952091} 
\index{igl@{igl}!point\_mesh\_squared\_distance@{point\_mesh\_squared\_distance}}
\index{point\_mesh\_squared\_distance@{point\_mesh\_squared\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{point\_mesh\_squared\_distance()}{point\_mesh\_squared\_distance()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedV , typename Derived\+Ele , typename DerivedsqrD , typename DerivedI , typename DerivedC $>$ \\
void igl\+::point\+\_\+mesh\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&}]{Ele,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&}]{sqrD,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute distances from a set of points P to a triangle mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em Ele} & \#\+Ele by (3\texorpdfstring{$\vert$}{|}2\texorpdfstring{$\vert$}{|}1) list of (triangle\texorpdfstring{$\vert$}{|}edge\texorpdfstring{$\vert$}{|}point) indices \\
\hline
\mbox{\texttt{ out}}  & {\em sqrD} & \#P list of smallest squared distances \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#P list of primitive indices corresponding to smallest distances \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#P by 3 list of closest points\\
\hline
\end{DoxyParams}


\label{namespaceigl_autotoc_md20}%
\Hypertarget{namespaceigl_autotoc_md20}%
 \doxysubparagraph*{Example\+:}


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::MatrixXd\ V;}
\DoxyCodeLine{Eigen::MatrixXi\ F;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a6bd18b073b51beb1500c10c4f2825aba}{igl::read\_triangle\_mesh}}(\textcolor{stringliteral}{"{}bunny.obj"{}},V,F);}
\DoxyCodeLine{\textcolor{comment}{//\ 100\ points\ in\ [-\/1,1]\ cube}}
\DoxyCodeLine{Eigen::MatrixXd\ P\ =\ Eigen::MatrixXd::Random(100,3);}
\DoxyCodeLine{Eigen::VectorXd\ sqrD;}
\DoxyCodeLine{Eigen::VectorXi\ I;}
\DoxyCodeLine{Eigen::MatrixXd\ C;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_ae9616bb9fd33e6c00dcb4e8f91952091}{igl::point\_mesh\_squared\_distance}}(P,V,F,sqrD,I,C);}
\DoxyCodeLine{\textcolor{comment}{//\ Now\ sqrD(i)\ =\ squared\ distance\ from\ P.row(i)\ to\ mesh}}
\DoxyCodeLine{\textcolor{comment}{//\ I(i)\ =\ closest\ primitive\ index}}
\DoxyCodeLine{\textcolor{comment}{//\ C.row(i)\ =\ closest\ point\ on\ mesh\ to\ P.row(i)}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a8c64da392edc068d98cf9c78ec8a6ee3}\label{namespaceigl_a8c64da392edc068d98cf9c78ec8a6ee3} 
\index{igl@{igl}!point\_simplex\_squared\_distance@{point\_simplex\_squared\_distance}}
\index{point\_simplex\_squared\_distance@{point\_simplex\_squared\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{point\_simplex\_squared\_distance()}{point\_simplex\_squared\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$int DIM, typename Derivedp , typename DerivedV , typename Derived\+Ele , typename Derivedsqr\+\_\+d , typename Derivedc $>$ \\
void igl\+::point\+\_\+simplex\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&}]{p,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&}]{Ele,  }\item[{const typename Derived\+Ele\+::\+Index}]{i,  }\item[{Derivedsqr\+\_\+d \&}]{sqr\+\_\+d,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c }\end{DoxyParamCaption})}



Determine squared distance from a point to linear simplex. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em p} & d-\/long query point \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by d list of vertices \\
\hline
\mbox{\texttt{ in}}  & {\em Ele} & \#\+Ele by ss\texorpdfstring{$<$}{<}=d+1 list of simplex indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em i} & index into Ele of simplex \\
\hline
\mbox{\texttt{ out}}  & {\em sqr\+\_\+d} & squared distance of Ele(i) to p \\
\hline
\mbox{\texttt{ out}}  & {\em c} & closest point on Ele(i) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a937e7f60501c5fa10d8ddf3aba6e3d2e}\label{namespaceigl_a937e7f60501c5fa10d8ddf3aba6e3d2e} 
\index{igl@{igl}!point\_simplex\_squared\_distance@{point\_simplex\_squared\_distance}}
\index{point\_simplex\_squared\_distance@{point\_simplex\_squared\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{point\_simplex\_squared\_distance()}{point\_simplex\_squared\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$int DIM, typename Derivedp , typename DerivedV , typename Derived\+Ele , typename Derivedsqr\+\_\+d , typename Derivedc , typename Derivedb $>$ \\
void igl\+::point\+\_\+simplex\+\_\+squared\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&}]{p,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Ele $>$ \&}]{Ele,  }\item[{const typename Derived\+Ele\+::\+Index}]{i,  }\item[{Derivedsqr\+\_\+d \&}]{sqr\+\_\+d,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedb $>$ \&}]{b }\end{DoxyParamCaption})}



Determine squared distance from a point to linear simplex. 

Also return barycentric coordinate of closest point.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em p} & d-\/long query point \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by d list of vertices \\
\hline
\mbox{\texttt{ in}}  & {\em Ele} & \#\+Ele by ss\texorpdfstring{$<$}{<}=d+1 list of simplex indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em i} & index into Ele of simplex \\
\hline
\mbox{\texttt{ out}}  & {\em sqr\+\_\+d} & squared distance of Ele(i) to p \\
\hline
\mbox{\texttt{ out}}  & {\em c} & closest point on Ele(i) \\
\hline
\mbox{\texttt{ out}}  & {\em b} & barycentric coordinates of closest point on Ele(i) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adef4fd6ebad61768a405ac601011aa83}\label{namespaceigl_adef4fd6ebad61768a405ac601011aa83} 
\index{igl@{igl}!polar\_dec@{polar\_dec}}
\index{polar\_dec@{polar\_dec}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_dec()}{polar\_dec()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ \\
void igl\+::polar\+\_\+dec (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{bool}]{include\+Reflections,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



Computes the polar decomposition (R,T) of a matrix A. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 3 by 3 matrix to be decomposed \\
\hline
\mbox{\texttt{ in}}  & {\em include\+Reflections} & Whether to force R to be a rotation, or allow it to be a reflection \\
\hline
\mbox{\texttt{ out}}  & {\em R} & 3 by 3 orthonormal matrix part of decomposition \\
\hline
\mbox{\texttt{ out}}  & {\em T} & 3 by 3 stretch matrix part of decomposition \\
\hline
\mbox{\texttt{ out}}  & {\em U} & 3 by 3 left-\/singular vectors \\
\hline
\mbox{\texttt{ out}}  & {\em S} & 3 by 1 singular values \\
\hline
\mbox{\texttt{ out}}  & {\em V} & 3 by 3 right-\/singular vectors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4542a1ce3e5fc92a58929332bf0d5afe}\label{namespaceigl_a4542a1ce3e5fc92a58929332bf0d5afe} 
\index{igl@{igl}!polar\_dec@{polar\_dec}}
\index{polar\_dec@{polar\_dec}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_dec()}{polar\_dec()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ \\
void igl\+::polar\+\_\+dec (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const bool}]{include\+Reflections,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af5cc516e97872405063d0bcf3005f99e}\label{namespaceigl_af5cc516e97872405063d0bcf3005f99e} 
\index{igl@{igl}!polar\_dec@{polar\_dec}}
\index{polar\_dec@{polar\_dec}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_dec()}{polar\_dec()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ \\
void igl\+::polar\+\_\+dec (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

For backward compatibility, these set include\+Reflections = false. \Hypertarget{namespaceigl_a32e10aea297c30b7daf1616d1eba2a4f}\label{namespaceigl_a32e10aea297c30b7daf1616d1eba2a4f} 
\index{igl@{igl}!polar\_dec@{polar\_dec}}
\index{polar\_dec@{polar\_dec}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_dec()}{polar\_dec()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ \\
void igl\+::polar\+\_\+dec (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aaa0b3fd9e1e8dbf5c6ddb9750f575b77}\label{namespaceigl_aaa0b3fd9e1e8dbf5c6ddb9750f575b77} 
\index{igl@{igl}!polar\_svd@{polar\_svd}}
\index{polar\_svd@{polar\_svd}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_svd()}{polar\_svd()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ \\
void igl\+::polar\+\_\+svd (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{bool}]{include\+Reflections,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



Computes the polar decomposition (R,T) of a matrix A using SVD singular value decomposition. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 3 by 3 matrix to be decomposed \\
\hline
\mbox{\texttt{ in}}  & {\em include\+Reflections} & Whether to force R to be a rotation, or allow it to be a reflection \\
\hline
\mbox{\texttt{ out}}  & {\em R} & 3 by 3 rotation matrix part of decomposition ({\bfseries{always rotataion}}) \\
\hline
\mbox{\texttt{ out}}  & {\em T} & 3 by 3 stretch matrix part of decomposition \\
\hline
\mbox{\texttt{ out}}  & {\em U} & 3 by 3 left-\/singular vectors \\
\hline
\mbox{\texttt{ out}}  & {\em S} & 3 by 1 singular values \\
\hline
\mbox{\texttt{ out}}  & {\em V} & 3 by 3 right-\/singular vectors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9357cd43402973e99dcba962cdc1c8f9}\label{namespaceigl_a9357cd43402973e99dcba962cdc1c8f9} 
\index{igl@{igl}!polar\_svd@{polar\_svd}}
\index{polar\_svd@{polar\_svd}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_svd()}{polar\_svd()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ \\
void igl\+::polar\+\_\+svd (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const bool}]{include\+Reflections,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5bf5509fee9fb84f1bce5173d27cb3e4}\label{namespaceigl_a5bf5509fee9fb84f1bce5173d27cb3e4} 
\index{igl@{igl}!polar\_svd@{polar\_svd}}
\index{polar\_svd@{polar\_svd}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_svd()}{polar\_svd()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV $>$ \\
void igl\+::polar\+\_\+svd (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

For backward compatibility, these set include\+Reflections = false. \Hypertarget{namespaceigl_a299b725f8b4d5586c64c2c5e22a242db}\label{namespaceigl_a299b725f8b4d5586c64c2c5e22a242db} 
\index{igl@{igl}!polar\_svd@{polar\_svd}}
\index{polar\_svd@{polar\_svd}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_svd()}{polar\_svd()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedR , typename DerivedT $>$ \\
void igl\+::polar\+\_\+svd (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a78fc94343abfa102d5a9b95e8faca581}\label{namespaceigl_a78fc94343abfa102d5a9b95e8faca581} 
\index{igl@{igl}!polar\_svd3x3@{polar\_svd3x3}}
\index{polar\_svd3x3@{polar\_svd3x3}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polar\_svd3x3()}{polar\_svd3x3()}}
{\footnotesize\ttfamily template$<$typename Mat $>$ \\
void igl\+::polar\+\_\+svd3x3 (\begin{DoxyParamCaption}\item[{const Mat \&}]{A,  }\item[{Mat \&}]{R }\end{DoxyParamCaption})}



Computes the closest rotation to input matrix A using specialized 3x3 SVD singular value decomposition (Wunder\+SVD3x3) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 3 by 3 matrix to be decomposed \\
\hline
\mbox{\texttt{ out}}  & {\em R} & 3 by 3 closest element in SO(3) (closeness in terms of Frobenius metric)\\
\hline
\end{DoxyParams}
This means that det(\+R) = 1. Technically it\textquotesingle{}s not polar decomposition which guarantees positive semidefinite stretch factor (at the cost of having det(\+R) = -\/1). "{} The orthogonal factors U and V will be true rotation matrices..."{} \mbox{[}Mc\+Adams, Selle, Tamstorf, Teran, Sefakis 2011\mbox{]} \Hypertarget{namespaceigl_ae45e0eb6f9263af4777dc45bc136e1fd}\label{namespaceigl_ae45e0eb6f9263af4777dc45bc136e1fd} 
\index{igl@{igl}!polygon\_corners@{polygon\_corners}}
\index{polygon\_corners@{polygon\_corners}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polygon\_corners()}{polygon\_corners()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename PType , typename DerivedI , typename DerivedC $>$ \\
void igl\+::polygon\+\_\+corners (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::vector$<$ PType $>$ $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Convert a list-\/of-\/lists polygon mesh faces representation to list of polygon corners and sizes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P list of lists of vertex indices into rows of some matrix V \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#P+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5393c55c226b5d9d116837047c016f14}\label{namespaceigl_a5393c55c226b5d9d116837047c016f14} 
\index{igl@{igl}!polygon\_corners@{polygon\_corners}}
\index{polygon\_corners@{polygon\_corners}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polygon\_corners()}{polygon\_corners()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedQ , typename DerivedI , typename DerivedC $>$ \\
void igl\+::polygon\+\_\+corners (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Convert a pure k-\/gon list of polygon mesh indices to list of polygon corners and sizes


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Q} & \#Q by k list of polygon indices (ith row is a k-\/gon, unless Q(i,j) = -\/1 then it\textquotesingle{}s a j-\/gon) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5c951f3fc9bfbbd0c78c007fd43c8337}\label{namespaceigl_a5c951f3fc9bfbbd0c78c007fd43c8337} 
\index{igl@{igl}!polygons\_to\_triangles@{polygons\_to\_triangles}}
\index{polygons\_to\_triangles@{polygons\_to\_triangles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{polygons\_to\_triangles()}{polygons\_to\_triangles()}}
{\footnotesize\ttfamily template$<$typename DerivedI , typename DerivedC , typename DerivedF , typename DerivedJ $>$ \\
void igl\+::polygons\+\_\+to\+\_\+triangles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Given a polygon mesh, trivially triangulate each polygon with a fan. 

This purely combinatorial triangulation will work well for convex/flat polygons and degrade otherwise.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#polygons+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of triangle indices into rows of V \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#F list of indices into 0\+:\#P-\/1 of corresponding polygon \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a381027e74d14b6e7adb31c0565a26027}\label{namespaceigl_a381027e74d14b6e7adb31c0565a26027} 
\index{igl@{igl}!principal\_curvature@{principal\_curvature}}
\index{principal\_curvature@{principal\_curvature}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{principal\_curvature()}{principal\_curvature()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+PD1 , typename Derived\+PD2 , typename Derived\+PV1 , typename Derived\+PV2 $>$ \\
void igl\+::principal\+\_\+curvature (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD1 $>$ \&}]{PD1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD2 $>$ \&}]{PD2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV1 $>$ \&}]{PV1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV2 $>$ \&}]{PV2,  }\item[{unsigned}]{radius = {\ttfamily 5},  }\item[{bool}]{use\+Kring = {\ttfamily true} }\end{DoxyParamCaption})}



Compute the principal curvature directions and magnitude of the given triangle mesh DerivedV derived from vertex positions matrix type\+: i.\+e. 

Matrix\+Xd DerivedF derived from face indices matrix type\+: i.\+e. Matrix\+Xi 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & eigen matrix \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em PD1} & \#V by 3 maximal curvature direction for each vertex. \\
\hline
\mbox{\texttt{ out}}  & {\em PD2} & \#V by 3 minimal curvature direction for each vertex. \\
\hline
\mbox{\texttt{ out}}  & {\em PV1} & \#V by 1 maximal curvature value for each vertex. \\
\hline
\mbox{\texttt{ out}}  & {\em PV2} & \#V by 1 minimal curvature value for each vertex. \\
\hline
\mbox{\texttt{ in}}  & {\em radius} & controls the size of the neighbourhood used, 1 = average edge length \\
\hline
\mbox{\texttt{ in}}  & {\em use\+Kring} & use Kring neighbourhood instead of ball neighbourhood \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
vector of indices of bad vertices if any.
\end{DoxyReturn}
This function has been developed by\+: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on\+: Efficient Multi-\/scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca Gra\+Vis\+Ma, 2010

\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ac457ea2c4e31fec1d7a3855fefb0260d}{average\+\_\+onto\+\_\+faces}, \doxylink{namespaceigl_ac14f50dc6ec911af71c62d6c187fe3c2}{average\+\_\+onto\+\_\+vertices} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a1521eb853db32a29fdb6eacbf3ad9fc2}\label{namespaceigl_a1521eb853db32a29fdb6eacbf3ad9fc2} 
\index{igl@{igl}!principal\_curvature@{principal\_curvature}}
\index{principal\_curvature@{principal\_curvature}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{principal\_curvature()}{principal\_curvature()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+PD1 , typename Derived\+PD2 , typename Derived\+PV1 , typename Derived\+PV2 , typename Index $>$ \\
void igl\+::principal\+\_\+curvature (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD1 $>$ \&}]{PD1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PD2 $>$ \&}]{PD2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV1 $>$ \&}]{PV1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+PV2 $>$ \&}]{PV2,  }\item[{std\+::vector$<$ Index $>$ \&}]{bad\+\_\+vertices,  }\item[{unsigned}]{radius = {\ttfamily 5},  }\item[{bool}]{use\+Kring = {\ttfamily true} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em bad\+\_\+vertices} & vector of indices of bad vertices if any. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0f935d00d75dd71d9b65d2f6a7fe4a19}\label{namespaceigl_a0f935d00d75dd71d9b65d2f6a7fe4a19} 
\index{igl@{igl}!print\_ijv@{print\_ijv}}
\index{print\_ijv@{print\_ijv}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{print\_ijv()}{print\_ijv()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::print\+\_\+ijv (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X,  }\item[{const int}]{offset = {\ttfamily 0} }\end{DoxyParamCaption})}



Prints a 3 column matrix representing \mbox{[}I,J,V\mbox{]} = find(\+X). 

That is, each row is the row index, column index and value for each non zero entry. Each row is printed on a new line


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix whose entries are to be sorted \\
\hline
\mbox{\texttt{ in}}  & {\em offset} & optional offset for I and J indices \{0\}\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a64d87355c9c3b734e7658eed10bdd764}{matlab\+\_\+format} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a5d05e9d7e5d74e1a763370ff141d3628}\label{namespaceigl_a5d05e9d7e5d74e1a763370ff141d3628} 
\index{igl@{igl}!print\_vector@{print\_vector}}
\index{print\_vector@{print\_vector}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{print\_vector()}{print\_vector()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::print\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{v }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a59761c584c133e800d3e0f34dfa717cc}\label{namespaceigl_a59761c584c133e800d3e0f34dfa717cc} 
\index{igl@{igl}!print\_vector@{print\_vector}}
\index{print\_vector@{print\_vector}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{print\_vector()}{print\_vector()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::print\+\_\+vector (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ T $>$ $>$ $>$ \&}]{v }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a6f43ea8a5c6f5622b8340b9d9d5d3936}\label{namespaceigl_a6f43ea8a5c6f5622b8340b9d9d5d3936} 
\index{igl@{igl}!procrustes@{procrustes}}
\index{procrustes@{procrustes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{procrustes()}{procrustes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Scalar , typename DerivedR , typename DerivedT $>$ \\
void igl\+::procrustes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const bool}]{include\+Scaling,  }\item[{const bool}]{include\+Reflections,  }\item[{Scalar \&}]{scale,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{t }\end{DoxyParamCaption})}



Solve Procrustes problem in d dimensions. 

Given two point sets X,Y in R\texorpdfstring{$^\wedge$}{\string^}d find best scale s, orthogonal R and translation t s.\+t. \texorpdfstring{$\vert$}{|}s\texorpdfstring{$\ast$}{*}\+X\texorpdfstring{$\ast$}{*}R + t -\/ Y\texorpdfstring{$\vert$}{|}\texorpdfstring{$^\wedge$}{\string^}2 is minimized.


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & point type \\
\hline
{\em Scalar} & scalar type \\
\hline
{\em DerivedR} & type of R \\
\hline
{\em DerivedT} & type of t \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & \#V by DIM first list of points \\
\hline
\mbox{\texttt{ in}}  & {\em Y} & \#V by DIM second list of points \\
\hline
\mbox{\texttt{ in}}  & {\em include\+Scaling} & if scaling should be allowed \\
\hline
\mbox{\texttt{ in}}  & {\em include\+Reflections} & if R is allowed to be a reflection \\
\hline
\mbox{\texttt{ out}}  & {\em scale} & scaling \\
\hline
\mbox{\texttt{ out}}  & {\em R} & orthogonal matrix \\
\hline
\mbox{\texttt{ out}}  & {\em t} & translation\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md21}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md21}

\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd\ X,\ Y;\ (containing\ 3d\ points\ as\ rows)}
\DoxyCodeLine{\textcolor{keywordtype}{double}\ scale;}
\DoxyCodeLine{MatrixXd\ R;}
\DoxyCodeLine{VectorXd\ t;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a6f43ea8a5c6f5622b8340b9d9d5d3936}{igl::procrustes}}(X,Y,\textcolor{keyword}{true},\textcolor{keyword}{false},scale,R,t);}
\DoxyCodeLine{R\ *=\ scale;}
\DoxyCodeLine{MatrixXd\ Xprime\ =\ (X\ *\ R).rowwise()\ +\ t.transpose();}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a71995610b0f5d6e170ea2748950c0138}\label{namespaceigl_a71995610b0f5d6e170ea2748950c0138} 
\index{igl@{igl}!procrustes@{procrustes}}
\index{procrustes@{procrustes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{procrustes()}{procrustes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Scalar , int DIM, int TType$>$ \\
void igl\+::procrustes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const bool}]{include\+Scaling,  }\item[{const bool}]{include\+Reflections,  }\item[{Eigen\+::\+Transform$<$ Scalar, DIM, TType $>$ \&}]{T }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Same as above but returns Eigen transformation object.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em T} & transformation that minimizes error ~\newline
\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md22}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md22}

\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd\ X,\ Y;\ (containing\ 3d\ points\ as\ rows)}
\DoxyCodeLine{AffineCompact3d\ T;}
\DoxyCodeLine{\mbox{\hyperlink{namespaceigl_a6f43ea8a5c6f5622b8340b9d9d5d3936}{igl::procrustes}}(X,Y,\textcolor{keyword}{true},\textcolor{keyword}{false},T);}
\DoxyCodeLine{MatrixXd\ Xprime\ =\ (X\ *\ T.linear()).rowwise()\ +\ T.translation().transpose();}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a2f02fa686c9416188ccb0b47bbb41985}\label{namespaceigl_a2f02fa686c9416188ccb0b47bbb41985} 
\index{igl@{igl}!procrustes@{procrustes}}
\index{procrustes@{procrustes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{procrustes()}{procrustes()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT $>$ \\
void igl\+::procrustes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{const bool}]{include\+Scaling,  }\item[{const bool}]{include\+Reflections,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{t }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em S} & S=scale\texorpdfstring{$\ast$}{*}R, instead of scale and R separately \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa5807bccc7e6795e024af55047f473e6}\label{namespaceigl_aa5807bccc7e6795e024af55047f473e6} 
\index{igl@{igl}!procrustes@{procrustes}}
\index{procrustes@{procrustes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{procrustes()}{procrustes()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT $>$ \\
void igl\+::procrustes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{t }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Convenient wrapper for rigid case (no scaling, no reflections) \Hypertarget{namespaceigl_ab2b1805a74d6529030a2eb932a6f2fa0}\label{namespaceigl_ab2b1805a74d6529030a2eb932a6f2fa0} 
\index{igl@{igl}!procrustes@{procrustes}}
\index{procrustes@{procrustes}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{procrustes()}{procrustes()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Scalar , typename DerivedT $>$ \\
void igl\+::procrustes (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Rotation2D$<$ Scalar $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{t }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Convenient wrapper for 2D case. \Hypertarget{namespaceigl_aea21608bab1115f54a773ade037824bd}\label{namespaceigl_aea21608bab1115f54a773ade037824bd} 
\index{igl@{igl}!project@{project}}
\index{project@{project}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project()}{project()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ igl\+::project (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ \&}]{obj,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 4, 1 $>$ \&}]{viewport }\end{DoxyParamCaption})}



Eigen reimplementation of glu\+Project. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj\texorpdfstring{$\ast$}{*}} & 3D objects\textquotesingle{} x, y, and z coordinates respectively \\
\hline
\mbox{\texttt{ in}}  & {\em model} & model matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & viewport vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
screen space x, y, and z coordinates respectively 
\end{DoxyReturn}
\Hypertarget{namespaceigl_af7eb3109db11f7024416cd77670e4bb6}\label{namespaceigl_af7eb3109db11f7024416cd77670e4bb6} 
\index{igl@{igl}!project@{project}}
\index{project@{project}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project()}{project()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP $>$ \\
void igl\+::project (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&}]{viewport,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of object points \\
\hline
\mbox{\texttt{ in}}  & {\em model} & model matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & viewport vector \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#V by 3 list of screen space points\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md23}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md23}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer}{igl::opengl::glfw::Viewer}}\ vr;}
\DoxyCodeLine{...}
\DoxyCodeLine{igl::project(V,vr.\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer_a4fc39cbf6a2d68d0eaf63bef3fd49464}{core}}().\mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore_a8ce15c9d27268543847a0d83c2010cb6}{view}},vr.\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer_a4fc39cbf6a2d68d0eaf63bef3fd49464}{core}}().\mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore_a50af5081883025581f00b0918b3d9d30}{proj}},vr.\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer_a4fc39cbf6a2d68d0eaf63bef3fd49464}{core}}().\mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore_ac5a0f15fc245747e1d83b8e718f2e74f}{viewport}},P);}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a33f14c3d07d3f875efa80645432c32b8}\label{namespaceigl_a33f14c3d07d3f875efa80645432c32b8} 
\index{igl@{igl}!project\_isometrically\_to\_plane@{project\_isometrically\_to\_plane}}
\index{project\_isometrically\_to\_plane@{project\_isometrically\_to\_plane}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project\_isometrically\_to\_plane()}{project\_isometrically\_to\_plane()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedU , typename Derived\+UF , typename Scalar $>$ \\
void igl\+::project\+\_\+isometrically\+\_\+to\+\_\+plane (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UF $>$ \&}]{UF,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{I }\end{DoxyParamCaption})}



Project each triangle to the plane. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh indices \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#F\texorpdfstring{$\ast$}{*}3 by 2 list of triangle positions \\
\hline
\mbox{\texttt{ out}}  & {\em UF} & \#F by 3 list of mesh indices into U \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#V by \#F\texorpdfstring{$\ast$}{*}3 such that I(i,j) = 1 implies U(j,\+:) corresponds to V(i,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a51a1c901184c35afeb294420a2cfe4f5}\label{namespaceigl_a51a1c901184c35afeb294420a2cfe4f5} 
\index{igl@{igl}!project\_to\_line@{project\_to\_line}}
\index{project\_to\_line@{project\_to\_line}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project\_to\_line()}{project\_to\_line()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD $>$ \\
void igl\+::project\+\_\+to\+\_\+line (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&}]{t,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&}]{sqrD }\end{DoxyParamCaption})}



Project points onto vectors, that is find the parameter t for a point p such that proj\+\_\+p = (y-\/x). 

\texorpdfstring{$\ast$}{*}t, additionally compute the squared distance from p to the line of the vector, such that \texorpdfstring{$\vert$}{|}p -\/ proj\+\_\+p\texorpdfstring{$\vert$}{|} = sqr\+\_\+d


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by dim list of points to be projected \\
\hline
\mbox{\texttt{ in}}  & {\em S} & size dim start position of line vector \\
\hline
\mbox{\texttt{ in}}  & {\em D} & size dim destination position of line vector \\
\hline
\mbox{\texttt{ out}}  & {\em T} & \#P by 1 list of parameters \\
\hline
\mbox{\texttt{ out}}  & {\em sqrD} & \#P by 1 list of squared distances \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa6f357976c09a2f618f23fa9710bbf5c}\label{namespaceigl_aa6f357976c09a2f618f23fa9710bbf5c} 
\index{igl@{igl}!project\_to\_line@{project\_to\_line}}
\index{project\_to\_line@{project\_to\_line}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project\_to\_line()}{project\_to\_line()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::project\+\_\+to\+\_\+line (\begin{DoxyParamCaption}\item[{const Scalar}]{px,  }\item[{const Scalar}]{py,  }\item[{const Scalar}]{pz,  }\item[{const Scalar}]{sx,  }\item[{const Scalar}]{sy,  }\item[{const Scalar}]{sz,  }\item[{const Scalar}]{dx,  }\item[{const Scalar}]{dy,  }\item[{const Scalar}]{dz,  }\item[{Scalar \&}]{projpx,  }\item[{Scalar \&}]{projpy,  }\item[{Scalar \&}]{projpz,  }\item[{Scalar \&}]{t,  }\item[{Scalar \&}]{sqrd }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Same as above but for a single query point \Hypertarget{namespaceigl_a3608b109e5112e5f70ff99cbdd56af0a}\label{namespaceigl_a3608b109e5112e5f70ff99cbdd56af0a} 
\index{igl@{igl}!project\_to\_line@{project\_to\_line}}
\index{project\_to\_line@{project\_to\_line}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project\_to\_line()}{project\_to\_line()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::project\+\_\+to\+\_\+line (\begin{DoxyParamCaption}\item[{const Scalar}]{px,  }\item[{const Scalar}]{py,  }\item[{const Scalar}]{pz,  }\item[{const Scalar}]{sx,  }\item[{const Scalar}]{sy,  }\item[{const Scalar}]{sz,  }\item[{const Scalar}]{dx,  }\item[{const Scalar}]{dy,  }\item[{const Scalar}]{dz,  }\item[{Scalar \&}]{t,  }\item[{Scalar \&}]{sqrd }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a1dc57864ef37d9b1d37f52bb65fccc07}\label{namespaceigl_a1dc57864ef37d9b1d37f52bb65fccc07} 
\index{igl@{igl}!project\_to\_line\_segment@{project\_to\_line\_segment}}
\index{project\_to\_line\_segment@{project\_to\_line\_segment}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{project\_to\_line\_segment()}{project\_to\_line\_segment()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD $>$ \\
void igl\+::project\+\_\+to\+\_\+line\+\_\+segment (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&}]{t,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedsqrD $>$ \&}]{sqrD }\end{DoxyParamCaption})}



Project points onto vectors, that is find the parameter t for a point p such that proj\+\_\+p = (y-\/x). 

\texorpdfstring{$\ast$}{*}t, additionally compute the squared distance from p to the line of the vector, such that \texorpdfstring{$\vert$}{|}p -\/ proj\+\_\+p\texorpdfstring{$\vert$}{|} = sqr\+\_\+d


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by dim list of points to be projected \\
\hline
\mbox{\texttt{ in}}  & {\em S} & size dim start position of line vector \\
\hline
\mbox{\texttt{ in}}  & {\em D} & size dim destination position of line vector \\
\hline
\mbox{\texttt{ out}}  & {\em T} & \#P by 1 list of parameters \\
\hline
\mbox{\texttt{ out}}  & {\em sqrD} & \#P by 1 list of squared distances \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6cc2bb56a9aea43d8fc3108544294915}\label{namespaceigl_a6cc2bb56a9aea43d8fc3108544294915} 
\index{igl@{igl}!projection\_constraint@{projection\_constraint}}
\index{projection\_constraint@{projection\_constraint}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{projection\_constraint()}{projection\_constraint()}}
{\footnotesize\ttfamily template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename DerivedA , typename DerivedB $>$ \\
void igl\+::projection\+\_\+constraint (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&}]{VP,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Construct two constraint equations for projecting a point to the screen. 

Of the form\+: \begin{DoxyVerb}A z = B
\end{DoxyVerb}
 with A 2x3 and B 2x1, where z is the 3d position of point in the scene, given the current projection matrix (e.\+g. gl\+\_\+proj \texorpdfstring{$\ast$}{*} gl\+\_\+modelview), viewport (corner u/v and width/height) and screen space point x,y. Satisfying this equation means that z projects to screen space point (x,y).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em UV} & 2-\/long uv-\/coordinates of screen space point \\
\hline
\mbox{\texttt{ in}}  & {\em M} & 4 by 4 projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em VP} & 4-\/long viewport\+: (corner\+\_\+u, corner\+\_\+v, width, height) \\
\hline
\mbox{\texttt{ out}}  & {\em A} & 2 by 3 system matrix \\
\hline
\mbox{\texttt{ out}}  & {\em B} & 2 by 1 right-\/hand side \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a55630c2a7977e397d8b8fbc562a05bc5}\label{namespaceigl_a55630c2a7977e397d8b8fbc562a05bc5} 
\index{igl@{igl}!pseudonormal\_test@{pseudonormal\_test}}
\index{pseudonormal\_test@{pseudonormal\_test}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pseudonormal\_test()}{pseudonormal\_test()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn $>$ \\
void igl\+::pseudonormal\+\_\+test (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&}]{VN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&}]{EN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{const int}]{f,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{Scalar \&}]{s,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&}]{n }\end{DoxyParamCaption})}



Given a mesh (V,F), a query point q, and a point on (V,F) c, determine whether q is inside (V,F) -\/-\/\texorpdfstring{$>$}{>} s=-\/1 or outside (V,F) s=1, based on the sign of the dot product between (q-\/c) and n, where n is the normal {\itshape at c}, carefully chosen according to \mbox{[}Brentzen \& Aans 2005\mbox{]}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3 list of triangle normals \\
\hline
\mbox{\texttt{ in}}  & {\em VN} & \#V by 3 list of vertex normals (ANGLE WEIGHTING) \\
\hline
\mbox{\texttt{ in}}  & {\em EN} & \#E by 3 list of edge normals (UNIFORM WEIGHTING) \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 mapping edges in F to E \\
\hline
\mbox{\texttt{ in}}  & {\em q} & Query point \\
\hline
\mbox{\texttt{ in}}  & {\em f} & index into F to face to which c belongs \\
\hline
\mbox{\texttt{ in}}  & {\em c} & Point on (V,F) \\
\hline
\mbox{\texttt{ out}}  & {\em s} & sign \\
\hline
\mbox{\texttt{ out}}  & {\em n} & normal \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a56d059b63286144db10a9dc08d5083d2}\label{namespaceigl_a56d059b63286144db10a9dc08d5083d2} 
\index{igl@{igl}!pseudonormal\_test@{pseudonormal\_test}}
\index{pseudonormal\_test@{pseudonormal\_test}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pseudonormal\_test()}{pseudonormal\_test()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+EN , typename Derived\+VN , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn $>$ \\
void igl\+::pseudonormal\+\_\+test (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&}]{EN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&}]{VN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{const int}]{e,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{Scalar \&}]{s,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&}]{n }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

2D version. \Hypertarget{namespaceigl_a011d3a109b2f48a5285cb49b1cf1f288}\label{namespaceigl_a011d3a109b2f48a5285cb49b1cf1f288} 
\index{igl@{igl}!pso@{pso}}
\index{pso@{pso}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pso()}{pso()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB $>$ \\
Scalar igl\+::pso (\begin{DoxyParamCaption}\item[{const std\+::function$<$ Scalar(DerivedX \&) $>$}]{f,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&}]{LB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&}]{UB,  }\item[{const int}]{max\+\_\+iters,  }\item[{const int}]{population,  }\item[{DerivedX \&}]{X }\end{DoxyParamCaption})}



Global optimization with the particle swarm algorithm. 

Solve the problem\+:

minimize f(x) subject to lb  x  ub

by particle swarm optimization (PSO).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & function that evaluates the objective for a given "{}particle"{} location \\
\hline
\mbox{\texttt{ in}}  & {\em LB} & \#X vector of lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em UB} & \#X vector of upper bounds \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+iters} & maximum number of iterations \\
\hline
\mbox{\texttt{ in}}  & {\em population} & number of particles in swarm \\
\hline
\mbox{\texttt{ out}}  & {\em X} & best particle seen so far \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
objective corresponding to best particle seen so far 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a1b1cad08724f66e0be85d15317bb5f11}\label{namespaceigl_a1b1cad08724f66e0be85d15317bb5f11} 
\index{igl@{igl}!pso@{pso}}
\index{pso@{pso}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{pso()}{pso()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB , typename DerivedP $>$ \\
Scalar igl\+::pso (\begin{DoxyParamCaption}\item[{const std\+::function$<$ Scalar(DerivedX \&) $>$}]{f,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&}]{LB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&}]{UB,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const int}]{max\+\_\+iters,  }\item[{const int}]{population,  }\item[{DerivedX \&}]{X }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em P} & whether each DOF is periodic\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad5a2ee54dd545ede9b79ee62905dfc4d}\label{namespaceigl_ad5a2ee54dd545ede9b79ee62905dfc4d} 
\index{igl@{igl}!qslim@{qslim}}
\index{qslim@{qslim}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{qslim()}{qslim()}}
{\footnotesize\ttfamily bool igl\+::qslim (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const size\+\_\+t}]{max\+\_\+m,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{U,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{G,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J,  }\item[{Eigen\+::\+Vector\+Xi \&}]{I }\end{DoxyParamCaption})}



Decimate (simplify) a triangle mesh in nD according to the paper "{}\+Simplifying Surfaces with Color and Texture using Quadric Error Metrics"{} by \mbox{[}Garland and Heckbert, 1987\mbox{]} (technically a followup to qslim). 

The mesh can have open boundaries but should be edge-\/manifold.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions. Assumes that vertices with infinite coordinates are "{}points at infinity"{} being used to close up boundary edges with faces. This allows special subspace quadrice for boundary edges\+: There should never be more than one "{}point at     infinity"{} in a single triangle. \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em max\+\_\+m} & desired number of output faces \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#U by dim list of output vertex posistions (can be same ref as V) \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of output face indices into U (can be same ref as F) \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#G list of indices into F of birth face \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#U list of indices into V of birth vertices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_acb165fc9bf550b7a4248ef3e4750c7b5}\label{namespaceigl_acb165fc9bf550b7a4248ef3e4750c7b5} 
\index{igl@{igl}!quad\_grid@{quad\_grid}}
\index{quad\_grid@{quad\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quad\_grid()}{quad\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedQ , typename DerivedE $>$ \\
void igl\+::quad\+\_\+grid (\begin{DoxyParamCaption}\item[{const int}]{nx,  }\item[{const int}]{ny,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_aa374c6a411a695fa5fec90e301b42daf}\label{namespaceigl_aa374c6a411a695fa5fec90e301b42daf} 
\index{igl@{igl}!quad\_grid@{quad\_grid}}
\index{quad\_grid@{quad\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quad\_grid()}{quad\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedQ , typename DerivedE $>$ \\
void igl\+::quad\+\_\+grid (\begin{DoxyParamCaption}\item[{const int}]{nx,  }\item[{const int}]{ny,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_addf84125e942c49f765c4d652f607cd2}\label{namespaceigl_addf84125e942c49f765c4d652f607cd2} 
\index{igl@{igl}!quad\_planarity@{quad\_planarity}}
\index{quad\_planarity@{quad\_planarity}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quad\_planarity()}{quad\_planarity()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP $>$ \\
void igl\+::quad\+\_\+planarity (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Compute planarity of the faces of a quad mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 4 eigen Matrix of face (quad) indices \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#F by 1 eigen Matrix of mesh face (quad) planarities \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af95394212815de2e493636449c262bfc}\label{namespaceigl_af95394212815de2e493636449c262bfc} 
\index{igl@{igl}!quadprog@{quadprog}}
\index{quadprog@{quadprog}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quadprog()}{quadprog()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Scalar , int n, int ni$>$ \\
Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ igl\+::quadprog (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&}]{H,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{f,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, ni, n $>$ \&}]{Ai,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, ni, 1 $>$ \&}]{lbi,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, ni, 1 $>$ \&}]{ubi,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{lb,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{ub }\end{DoxyParamCaption})}



Solve a convex quadratic program. 

Optimized for small dense problems. Still works for Eigen\+::\+Dynamic (and then everything needs to be Dynamic). \begin{DoxyVerb}min_x  x H x + xf
subject to:
  lbi  Ai x  ubi
  lb  x  u
\end{DoxyVerb}
 
\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & (e.\+g., double) \\
\hline
{\em n} & \#H or Eigen\+::\+Dynamic if not known at compile time \\
\hline
{\em ni} & \#\+Ai or Eigen\+::\+Dynamic if not known at compile time \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em H} & \#H by \#H quadratic coefficients (only lower triangle used) \\
\hline
\mbox{\texttt{ in}}  & {\em f} & \#H linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em Ai} & \#\+Ai by \#H list of linear equality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em lbi} & \#\+Ai list of linear equality lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em ubi} & \#\+Ai list of linear equality upper bounds \\
\hline
\mbox{\texttt{ in}}  & {\em lb} & \#H list of lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em ub} & \#H list of lower bounds \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#H-\/long solution x 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a552c079165c8e8dac0d633ddc36ad8f7}\label{namespaceigl_a552c079165c8e8dac0d633ddc36ad8f7} 
\index{igl@{igl}!quadprog@{quadprog}}
\index{quadprog@{quadprog}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quadprog()}{quadprog()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Scalar , int n, int m$>$ \\
Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ igl\+::quadprog (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&}]{H,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{f,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, m, n $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, m, 1 $>$ \&}]{b,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{lb,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{ub }\end{DoxyParamCaption})}



Solve a convex quadratic program. 

Optimized for small dense problems. All inequalities must be simple bounds. \begin{DoxyVerb} min_x  x H x + xf
 subject to:
   A x = b
   lb  x  u
\end{DoxyVerb}
 
\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & (e.\+g., double) \\
\hline
{\em n} & \#H or Eigen\+::\+Dynamic if not known at compile time \\
\hline
{\em m} & \#A or Eigen\+::\+Dynamic if not known at compile time \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em H} & \#H by \#H quadratic coefficients (only lower triangle used) \\
\hline
\mbox{\texttt{ in}}  & {\em f} & \#H linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#A by \#H list of linear equality constraint coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#A list of linear equality lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em lb} & \#H list of lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em ub} & \#H list of lower bounds \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#H-\/long solution x 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a4086d9d0f9c0d8f922776a698cbe2055}\label{namespaceigl_a4086d9d0f9c0d8f922776a698cbe2055} 
\index{igl@{igl}!quadprog@{quadprog}}
\index{quadprog@{quadprog}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quadprog()}{quadprog()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Scalar , int n$>$ \\
Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ igl\+::quadprog (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, n, n $>$ \&}]{H,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{f,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{lb,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, n, 1 $>$ \&}]{ub }\end{DoxyParamCaption})}



Solve a convex quadratic program. 

Optimized for small dense problems. All constraints must be simple bounds. \begin{DoxyVerb} min_x  x H x + xf
 subject to:
   lb  x  u
\end{DoxyVerb}
 
\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & (e.\+g., double) \\
\hline
{\em n} & \#H or Eigen\+::\+Dynamic if not known at compile time \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em H} & \#H by \#H quadratic coefficients (only lower triangle used) \\
\hline
\mbox{\texttt{ in}}  & {\em f} & \#H linear coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em lb} & \#H list of lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em ub} & \#H list of lower bounds \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#H-\/long solution x 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a0c609e4b0050f7ab7371dcde020c5566}\label{namespaceigl_a0c609e4b0050f7ab7371dcde020c5566} 
\index{igl@{igl}!operator+@{operator+}}
\index{operator+@{operator+}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{operator+()}{operator+()}}
{\footnotesize\ttfamily std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ igl\+::operator+ (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ \&}]{a,  }\item[{const std\+::tuple$<$ Eigen\+::\+Matrix\+Xd, Eigen\+::\+Row\+Vector\+Xd, double $>$ \&}]{b }\end{DoxyParamCaption})}



A binary addition operator for Quadric tuples compatible with qslim, computing c = a+b. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a} & QSlim quadric \\
\hline
\mbox{\texttt{ in}}  & {\em b} & QSlim quadric \\
\hline
\mbox{\texttt{ out}}  & {\em c} & QSlim quadric\\
\hline
\end{DoxyParams}
\doxylink{quadric__binary__plus__operator_8h}{include/igl/quadric\+\_\+binary\+\_\+plus\+\_\+operator.\+h} \Hypertarget{namespaceigl_ada511054bec3939ade8f2a9494ada31b}\label{namespaceigl_ada511054bec3939ade8f2a9494ada31b} 
\index{igl@{igl}!quat\_conjugate@{quat\_conjugate}}
\index{quat\_conjugate@{quat\_conjugate}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quat\_conjugate()}{quat\_conjugate()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::quat\+\_\+conjugate (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q1,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{out }\end{DoxyParamCaption})}



Compute conjugate of given quaternion \href{http://en.wikipedia.org/wiki/Quaternion\#Conjugation.2C_the_norm.2C_and_reciprocal}{\texttt{ http\+://en.\+wikipedia.\+org/wiki/\+Quaternion\#\+Conjugation.\+2\+C\+\_\+the\+\_\+norm.\+2\+C\+\_\+and\+\_\+reciprocal}} A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q1} & input quaternion \\
\hline
\mbox{\texttt{ out}}  & {\em out} & result of conjugation, allowed to be same as input \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac19bfa1b6952d8ab0687e3b33f445444}\label{namespaceigl_ac19bfa1b6952d8ab0687e3b33f445444} 
\index{igl@{igl}!quat\_mult@{quat\_mult}}
\index{quat\_mult@{quat\_mult}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quat\_mult()}{quat\_mult()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::quat\+\_\+mult (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q1,  }\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q2,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{out }\end{DoxyParamCaption})}



Computes out = q1 \texorpdfstring{$\ast$}{*} q2 with quaternion multiplication A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q1} & left quaternion \\
\hline
\mbox{\texttt{ in}}  & {\em q2} & right quaternion \\
\hline
\mbox{\texttt{ out}}  & {\em out} & result of multiplication \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0300d689abe2fb73dcf6b2c51821dada}\label{namespaceigl_a0300d689abe2fb73dcf6b2c51821dada} 
\index{igl@{igl}!quat\_to\_axis\_angle@{quat\_to\_axis\_angle}}
\index{quat\_to\_axis\_angle@{quat\_to\_axis\_angle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quat\_to\_axis\_angle()}{quat\_to\_axis\_angle()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::quat\+\_\+to\+\_\+axis\+\_\+angle (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{axis,  }\item[{Q\+\_\+type \&}]{angle }\end{DoxyParamCaption})}



Convert quat representation of a rotation to axis angle A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & quaternion \\
\hline
\mbox{\texttt{ out}}  & {\em axis} & 3d vector \\
\hline
\mbox{\texttt{ out}}  & {\em angle} & scalar in radians \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a279531123a14c37bbfeddb71253c50d9}\label{namespaceigl_a279531123a14c37bbfeddb71253c50d9} 
\index{igl@{igl}!quat\_to\_axis\_angle\_deg@{quat\_to\_axis\_angle\_deg}}
\index{quat\_to\_axis\_angle\_deg@{quat\_to\_axis\_angle\_deg}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quat\_to\_axis\_angle\_deg()}{quat\_to\_axis\_angle\_deg()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::quat\+\_\+to\+\_\+axis\+\_\+angle\+\_\+deg (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{axis,  }\item[{Q\+\_\+type \&}]{angle }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{quat__to__axis__angle_8h}{include/igl/quat\+\_\+to\+\_\+axis\+\_\+angle.\+h}. 

\Hypertarget{namespaceigl_aeb3f708cef51eb10e942ea1274a4fdc1}\label{namespaceigl_aeb3f708cef51eb10e942ea1274a4fdc1} 
\index{igl@{igl}!quat\_to\_mat@{quat\_to\_mat}}
\index{quat\_to\_mat@{quat\_to\_mat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quat\_to\_mat()}{quat\_to\_mat()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::quat\+\_\+to\+\_\+mat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{quat,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{mat }\end{DoxyParamCaption})}



Convert a quaternion to a 4x4 matrix A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em quat} & pointer to four elements of quaternion (x,y,z,w) ~\newline
 \\
\hline
\mbox{\texttt{ out}}  & {\em mat} & pointer to 16 elements of matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af1bd78c3679effe1e85e5049ddeba5f4}\label{namespaceigl_af1bd78c3679effe1e85e5049ddeba5f4} 
\index{igl@{igl}!quats\_to\_column@{quats\_to\_column}}
\index{quats\_to\_column@{quats\_to\_column}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quats\_to\_column()}{quats\_to\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::quats\+\_\+to\+\_\+column (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$}]{vQ,  }\item[{Eigen\+::\+Vector\+Xd \&}]{Q }\end{DoxyParamCaption})}



"{}\+Columnize"{} a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em vQ} & n-\/long list of quaternions \\
\hline
\mbox{\texttt{ out}}  & {\em Q} & n\texorpdfstring{$\ast$}{*}4-\/long list of coefficients \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a586f0e07552e1ed4293b6e627b2d21a9}\label{namespaceigl_a586f0e07552e1ed4293b6e627b2d21a9} 
\index{igl@{igl}!quats\_to\_column@{quats\_to\_column}}
\index{quats\_to\_column@{quats\_to\_column}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{quats\_to\_column()}{quats\_to\_column()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Eigen\+::\+Vector\+Xd igl\+::quats\+\_\+to\+\_\+column (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Eigen\+::\+Quaterniond, Eigen\+::aligned\+\_\+allocator$<$ Eigen\+::\+Quaterniond $>$ $>$}]{vQ }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0fe9e431751b9d9370672f22da915cea}\label{namespaceigl_a0fe9e431751b9d9370672f22da915cea} 
\index{igl@{igl}!ramer\_douglas\_peucker@{ramer\_douglas\_peucker}}
\index{ramer\_douglas\_peucker@{ramer\_douglas\_peucker}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ramer\_douglas\_peucker()}{ramer\_douglas\_peucker()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedS , typename DerivedJ $>$ \\
void igl\+::ramer\+\_\+douglas\+\_\+peucker (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const typename Derived\+P\+::\+Scalar}]{tol,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Ramer-\/\+Douglas-\/\+Peucker piecewise-\/linear curve simplification. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by dim ordered list of vertices along the curve \\
\hline
\mbox{\texttt{ in}}  & {\em tol} & tolerance (maximal euclidean distance allowed between the new line and a vertex) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#S by dim ordered list of points along the curve \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#S list of indices into P so that S = P(\+J,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aef4dc2b120bfd3e28f7e1731a3afe7d1}\label{namespaceigl_aef4dc2b120bfd3e28f7e1731a3afe7d1} 
\index{igl@{igl}!ramer\_douglas\_peucker@{ramer\_douglas\_peucker}}
\index{ramer\_douglas\_peucker@{ramer\_douglas\_peucker}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ramer\_douglas\_peucker()}{ramer\_douglas\_peucker()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedS , typename DerivedJ , typename DerivedQ $>$ \\
void igl\+::ramer\+\_\+douglas\+\_\+peucker (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const typename Derived\+P\+::\+Scalar}]{tol,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedQ $>$ \&}]{Q }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Run Ramer-\/\+Douglas-\/\+Peucker curve simplification but keep track of where every point on the original curve maps to on the simplified curve.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em Q} & \#P by dim list of points mapping along simplified curve \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae0064a7187fded546bbaf927301a9c7c}\label{namespaceigl_ae0064a7187fded546bbaf927301a9c7c} 
\index{igl@{igl}!random\_dir@{random\_dir}}
\index{random\_dir@{random\_dir}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_dir()}{random\_dir()}}
{\footnotesize\ttfamily Eigen\+::\+Vector3d igl\+::random\+\_\+dir (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Generate a uniformly random unit direction in 3D, return as vector. 

\begin{DoxyReturn}{Returns}
random direction 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a4782a4291e5724eb403de4686b8c786d}\label{namespaceigl_a4782a4291e5724eb403de4686b8c786d} 
\index{igl@{igl}!random\_dir\_stratified@{random\_dir\_stratified}}
\index{random\_dir\_stratified@{random\_dir\_stratified}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_dir\_stratified()}{random\_dir\_stratified()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd igl\+::random\+\_\+dir\+\_\+stratified (\begin{DoxyParamCaption}\item[{const int}]{n }\end{DoxyParamCaption})}



Generate n stratified uniformly random unit directions in 3d, return as rows of an n by 3 matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of directions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
n by 3 matrix of random directions 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a1fc88d96c492e3bf962501af8bea413e}\label{namespaceigl_a1fc88d96c492e3bf962501af8bea413e} 
\index{igl@{igl}!random\_points\_on\_mesh@{random\_points\_on\_mesh}}
\index{random\_points\_on\_mesh@{random\_points\_on\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_points\_on\_mesh()}{random\_points\_on\_mesh()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedB , typename Derived\+FI , typename DerivedX , typename URBG  = DEFAULT\+\_\+\+URBG$>$ \\
void igl\+::random\+\_\+points\+\_\+on\+\_\+mesh (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&}]{FI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{URBG \&\&}]{urbg = {\ttfamily \mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}()} }\end{DoxyParamCaption})}



Randomly sample a mesh (V,F) n times. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of samples \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em B} & n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) \\
\hline
\mbox{\texttt{ in}}  & {\em urbg} & An instance of Unform\+Random\+Bit\+Generator (e.\+g., {\ttfamily std\+::minstd\+\_\+rand(0)}) \\
\hline
\mbox{\texttt{ out}}  & {\em FI} & n list of indices into F \\
\hline
\mbox{\texttt{ in,out}}  & {\em urbg} & An instance of Unform\+Random\+Bit\+Generator. \\
\hline
\mbox{\texttt{ out}}  & {\em X} & n by dim list of sample positions. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a17abb32491125229903977390f4149b6}\label{namespaceigl_a17abb32491125229903977390f4149b6} 
\index{igl@{igl}!random\_points\_on\_mesh\_intrinsic@{random\_points\_on\_mesh\_intrinsic}}
\index{random\_points\_on\_mesh\_intrinsic@{random\_points\_on\_mesh\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_points\_on\_mesh\_intrinsic()}{random\_points\_on\_mesh\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DeriveddblA , typename DerivedB , typename Derived\+FI , typename URBG  = DEFAULT\+\_\+\+URBG$>$ \\
void igl\+::random\+\_\+points\+\_\+on\+\_\+mesh\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveddblA $>$ \&}]{dblA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&}]{FI,  }\item[{URBG \&\&}]{urbg = {\ttfamily \mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}()} }\end{DoxyParamCaption})}



Randomly sample a mesh (V,F) n times. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of samples \\
\hline
\mbox{\texttt{ in}}  & {\em dblA} & \#F list of double areas of triangles \\
\hline
\mbox{\texttt{ out}}  & {\em B} & n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) \\
\hline
\mbox{\texttt{ out}}  & {\em FI} & n list of indices into F \\
\hline
\mbox{\texttt{ in,out}}  & {\em urbg} & An instance of Unform\+Random\+Bit\+Generator. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a96aa82c3339685c664b22f768a8a6e0e}\label{namespaceigl_a96aa82c3339685c664b22f768a8a6e0e} 
\index{igl@{igl}!random\_points\_on\_mesh\_intrinsic@{random\_points\_on\_mesh\_intrinsic}}
\index{random\_points\_on\_mesh\_intrinsic@{random\_points\_on\_mesh\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_points\_on\_mesh\_intrinsic()}{random\_points\_on\_mesh\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DeriveddblA , typename DerivedF , typename ScalarB , typename Derived\+FI , typename URBG $>$ \\
void igl\+::random\+\_\+points\+\_\+on\+\_\+mesh\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveddblA $>$ \&}]{dblA,  }\item[{const int}]{num\+\_\+vertices,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FI $>$ \&}]{FI,  }\item[{URBG \&\&}]{urbg }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em num\+\_\+vertices} & number of vertices in mesh \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em B} & n by num\+\_\+vertices sparse matrix so that B\texorpdfstring{$\ast$}{*}V produces a list of sample points if dbl = doublearea(\+V,\+F) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_afce1200f20db3dc284cca380285517cf}\label{namespaceigl_afce1200f20db3dc284cca380285517cf} 
\index{igl@{igl}!random\_quaternion@{random\_quaternion}}
\index{random\_quaternion@{random\_quaternion}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_quaternion()}{random\_quaternion()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
Eigen\+::\+Quaternion$<$ Scalar $>$ igl\+::random\+\_\+quaternion (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Generate a random quaternion via uniform sampling of the 4-\/sphere. 

\begin{DoxyReturn}{Returns}
a random quaternion ~\newline
 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ad39042be3d7a469bc3519bc2a6ce7932}\label{namespaceigl_ad39042be3d7a469bc3519bc2a6ce7932} 
\index{igl@{igl}!random\_search@{random\_search}}
\index{random\_search@{random\_search}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{random\_search()}{random\_search()}}
{\footnotesize\ttfamily template$<$typename Scalar , typename DerivedX , typename Derived\+LB , typename Derived\+UB $>$ \\
Scalar igl\+::random\+\_\+search (\begin{DoxyParamCaption}\item[{const std\+::function$<$ Scalar(DerivedX \&) $>$}]{f,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+LB $>$ \&}]{LB,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UB $>$ \&}]{UB,  }\item[{const int}]{iters,  }\item[{DerivedX \&}]{X }\end{DoxyParamCaption})}



Global optimization via random search. 

Solve the problem\+:

minimize f(x) subject to lb  x  ub

by uniform random search.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em f} & function to minimize \\
\hline
\mbox{\texttt{ in}}  & {\em LB} & \#X vector of finite lower bounds \\
\hline
\mbox{\texttt{ in}}  & {\em UB} & \#X vector of finite upper bounds \\
\hline
\mbox{\texttt{ in}}  & {\em iters} & number of iterations \\
\hline
\mbox{\texttt{ out}}  & {\em X} & \#X optimal parameter vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
f(\+X) 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a7279a059983ae9a728c94ccc1983343d}\label{namespaceigl_a7279a059983ae9a728c94ccc1983343d} 
\index{igl@{igl}!randperm@{randperm}}
\index{randperm@{randperm}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{randperm()}{randperm()}}
{\footnotesize\ttfamily template$<$typename DerivedI , typename URBG  = DEFAULT\+\_\+\+URBG$>$ \\
void igl\+::randperm (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{URBG \&\&}]{urbg = {\ttfamily \mbox{\hyperlink{namespaceigl_a23d8ca74669cc6ed33b89020ee4f9b2e}{igl\+::generate\+\_\+default\+\_\+urbg}}()} }\end{DoxyParamCaption})}



Like matlab\textquotesingle{}s randperm(n) but minus 1. 

When urbg is not specified, randperm will use default random bit generator std\+::minstd\+\_\+rand initialized with random seed generated by std\+::rand()


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of elements \\
\hline
\mbox{\texttt{ out}}  & {\em I} & n list of rand permutation of 0\+:n-\/1 \\
\hline
\mbox{\texttt{ in,out}}  & {\em urbg} & An instance of Unform\+Random\+Bit\+Generator. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af41f8552f81764bc8793cb5f76a87553}\label{namespaceigl_af41f8552f81764bc8793cb5f76a87553} 
\index{igl@{igl}!ray\_box\_intersect@{ray\_box\_intersect}}
\index{ray\_box\_intersect@{ray\_box\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ray\_box\_intersect()}{ray\_box\_intersect()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derivedsource , typename Deriveddir , typename Scalar $>$ \\
bool igl\+::ray\+\_\+box\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&}]{source,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{dir,  }\item[{const Eigen\+::\+Aligned\+Box$<$ Scalar, 3 $>$ \&}]{box,  }\item[{const Scalar \&}]{t0,  }\item[{const Scalar \&}]{t1,  }\item[{Scalar \&}]{tmin,  }\item[{Scalar \&}]{tmax }\end{DoxyParamCaption})}



Determine whether a ray origin+t\texorpdfstring{$\ast$}{*}dir and box intersect within the ray\textquotesingle{}s parameterized range (t0,t1) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em source} & 3-\/vector origin of ray \\
\hline
\mbox{\texttt{ in}}  & {\em dir} & 3-\/vector direction of ray \\
\hline
\mbox{\texttt{ in}}  & {\em box} & axis aligned box \\
\hline
\mbox{\texttt{ in}}  & {\em t0} & hit only if hit.\+t less than t0 \\
\hline
\mbox{\texttt{ in}}  & {\em t1} & hit only if hit.\+t greater than t1 \\
\hline
\mbox{\texttt{ out}}  & {\em tmin} & minimum of interval of overlap within \mbox{[}t0,t1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em tmax} & maximum of interval of overlap within \mbox{[}t0,t1\mbox{]} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if hit 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a18af1e6cc596af264e3a02e02b823a01}\label{namespaceigl_a18af1e6cc596af264e3a02e02b823a01} 
\index{igl@{igl}!ray\_box\_intersect@{ray\_box\_intersect}}
\index{ray\_box\_intersect@{ray\_box\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ray\_box\_intersect()}{ray\_box\_intersect()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedsource , typename Deriveddir , typename Scalar $>$ \\
bool igl\+::ray\+\_\+box\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&}]{source,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{inv\+\_\+dir,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{inv\+\_\+dir\+\_\+pad,  }\item[{const Eigen\+::\+Aligned\+Box$<$ Scalar, 3 $>$ \&}]{box,  }\item[{const Scalar \&}]{t0,  }\item[{const Scalar \&}]{t1,  }\item[{Scalar \&}]{tmin,  }\item[{Scalar \&}]{tmax }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

same with direction inverse precomputed \Hypertarget{namespaceigl_adcb07bb96941cdba2a28b4239f88a246}\label{namespaceigl_adcb07bb96941cdba2a28b4239f88a246} 
\index{igl@{igl}!ray\_mesh\_intersect@{ray\_mesh\_intersect}}
\index{ray\_mesh\_intersect@{ray\_mesh\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ray\_mesh\_intersect()}{ray\_mesh\_intersect()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF $>$ \\
bool igl\+::ray\+\_\+mesh\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&}]{source,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{dir,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&}]{hits }\end{DoxyParamCaption})}



Shoot a ray against a mesh (V,F) and collect all hits. 

If you have many rays, consider using \doxylink{AABB_8h}{AABB.\+h}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em source} & 3-\/vector origin of ray \\
\hline
\mbox{\texttt{ in}}  & {\em dir} & 3-\/vector direction of ray \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em hits} & {\bfseries{sorted}} list of hits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if there were any hits (hits.\+size() \texorpdfstring{$>$}{>} 0)
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{classigl_1_1AABB}{AABB} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a6a827e72cc935817ec986e83ce56cc73}\label{namespaceigl_a6a827e72cc935817ec986e83ce56cc73} 
\index{igl@{igl}!ray\_mesh\_intersect@{ray\_mesh\_intersect}}
\index{ray\_mesh\_intersect@{ray\_mesh\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ray\_mesh\_intersect()}{ray\_mesh\_intersect()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF $>$ \\
bool igl\+::ray\+\_\+mesh\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&}]{source,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{dir,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{\mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} \&}]{hit }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em hit} & first hit, set only if it exists \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_afab2426f066fcd19c79646bcca3501b8}\label{namespaceigl_afab2426f066fcd19c79646bcca3501b8} 
\index{igl@{igl}!ray\_triangle\_intersect@{ray\_triangle\_intersect}}
\index{ray\_triangle\_intersect@{ray\_triangle\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ray\_triangle\_intersect()}{ray\_triangle\_intersect()}}
{\footnotesize\ttfamily template$<$typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF $>$ \\
bool igl\+::ray\+\_\+triangle\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedsource $>$ \&}]{source,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{dir,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{f,  }\item[{\mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} \&}]{hit }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a11b3c855b74e0beac5385f073686761e}\label{namespaceigl_a11b3c855b74e0beac5385f073686761e} 
\index{igl@{igl}!ray\_sphere\_intersect@{ray\_sphere\_intersect}}
\index{ray\_sphere\_intersect@{ray\_sphere\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{ray\_sphere\_intersect()}{ray\_sphere\_intersect()}}
{\footnotesize\ttfamily template$<$typename Derivedo , typename Derivedd , typename Derivedc , typename r\+\_\+type , typename t\+\_\+type $>$ \\
int igl\+::ray\+\_\+sphere\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedo $>$ \&}]{o,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedd $>$ \&}]{d,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{r\+\_\+type}]{r,  }\item[{t\+\_\+type \&}]{t0,  }\item[{t\+\_\+type \&}]{t1 }\end{DoxyParamCaption})}



Compute the intersection between a ray from O in direction D and a sphere centered at C with radius r. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em o} & origin of ray \\
\hline
\mbox{\texttt{ in}}  & {\em d} & direction of ray \\
\hline
\mbox{\texttt{ in}}  & {\em c} & center of sphere \\
\hline
\mbox{\texttt{ in}}  & {\em r} & radius of sphere \\
\hline
\mbox{\texttt{ out}}  & {\em t0} & parameterization of first hit (set only if exists) so that hit position = o + t0\texorpdfstring{$\ast$}{*}d \\
\hline
\mbox{\texttt{ out}}  & {\em t1} & parameterization of second hit (set only if exists) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of hits 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a28bb8198773c2124500fd5bc9a5f810b}\label{namespaceigl_a28bb8198773c2124500fd5bc9a5f810b} 
\index{igl@{igl}!read\_file\_binary@{read\_file\_binary}}
\index{read\_file\_binary@{read\_file\_binary}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{read\_file\_binary()}{read\_file\_binary()}}
{\footnotesize\ttfamily void igl\+::read\+\_\+file\+\_\+binary (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp,  }\item[{std\+::vector$<$ uint8\+\_\+t $>$ \&}]{file\+Buffer\+Bytes }\end{DoxyParamCaption})}



Read contents of file into a buffer of uint8\+\_\+t bytes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em fp} & pointer to open File \\
\hline
\mbox{\texttt{ out}}  & {\em file\+Buffer\+Bytes} & contents of file as vector of bytes\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md24}{}\doxyparagraph{\texorpdfstring{Side effects\+:}{Side effects:}}\label{namespaceigl_autotoc_md24}
closes fp 
\begin{DoxyExceptions}{Exceptions}
{\em runtime\+\_\+error} & on error \\
\hline
\end{DoxyExceptions}
\Hypertarget{namespaceigl_a6bd18b073b51beb1500c10c4f2825aba}\label{namespaceigl_a6bd18b073b51beb1500c10c4f2825aba} 
\index{igl@{igl}!read\_triangle\_mesh@{read\_triangle\_mesh}}
\index{read\_triangle\_mesh@{read\_triangle\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{read\_triangle\_mesh()}{read\_triangle\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+\_\+triangle\+\_\+mesh (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Read mesh from an ascii file with automatic detection of file format among\+: mesh, msh obj, off, ply, stl, wrl. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & eigen double matrix \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em F} & eigen int matrix \#F by 3 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff success 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ad787fca3bc0010177aa587a1ad0d8bc8}\label{namespaceigl_ad787fca3bc0010177aa587a1ad0d8bc8} 
\index{igl@{igl}!read\_triangle\_mesh@{read\_triangle\_mesh}}
\index{read\_triangle\_mesh@{read\_triangle\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{read\_triangle\_mesh()}{read\_triangle\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+\_\+triangle\+\_\+mesh (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

outputs to vectors, only .off and .obj supported. \Hypertarget{namespaceigl_ae6cf40d2ba95e3819ecc7d733a73d321}\label{namespaceigl_ae6cf40d2ba95e3819ecc7d733a73d321} 
\index{igl@{igl}!read\_triangle\_mesh@{read\_triangle\_mesh}}
\index{read\_triangle\_mesh@{read\_triangle\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{read\_triangle\_mesh()}{read\_triangle\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+\_\+triangle\+\_\+mesh (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::string \&}]{dir,  }\item[{std\+::string \&}]{base,  }\item[{std\+::string \&}]{ext,  }\item[{std\+::string \&}]{name }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em dir} & directory path (see \doxylink{pathinfo_8h}{pathinfo.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em base} & base name (see \doxylink{pathinfo_8h}{pathinfo.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em ext} & extension (see \doxylink{pathinfo_8h}{pathinfo.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em name} & filename (see \doxylink{pathinfo_8h}{pathinfo.\+h}) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8cfd07940eb9445554a8f64c84ea385c}\label{namespaceigl_a8cfd07940eb9445554a8f64c84ea385c} 
\index{igl@{igl}!read\_triangle\_mesh@{read\_triangle\_mesh}}
\index{read\_triangle\_mesh@{read\_triangle\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{read\_triangle\_mesh()}{read\_triangle\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+\_\+triangle\+\_\+mesh (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{ext,  }\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ext} & file extension \\
\hline
\mbox{\texttt{ in,out}}  & {\em fp} & pointer to already opened .ext file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4efbc110f683b253ef703142d1406f28}\label{namespaceigl_a4efbc110f683b253ef703142d1406f28} 
\index{igl@{igl}!readBF@{readBF}}
\index{readBF@{readBF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readBF()}{readBF()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+WI , typename DerivedP , typename DerivedO $>$ \\
bool igl\+::read\+BF (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WI $>$ \&}]{WI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{O }\end{DoxyParamCaption})}



Read a bones forest from a file, returns a list of bone roots. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+\_\+name} & path to .bf bones tree file \\
\hline
\mbox{\texttt{ out}}  & {\em WI} & \#B list of unique weight indices \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#B list of parent indices into B, -\/1 for roots \\
\hline
\mbox{\texttt{ out}}  & {\em O} & \#B by 3 list of tip offset vectors from parent (or position for roots) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a0ad78f74b0306e9a2775575579314170}\label{namespaceigl_a0ad78f74b0306e9a2775575579314170} 
\index{igl@{igl}!readBF@{readBF}}
\index{readBF@{readBF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readBF()}{readBF()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+WI , typename DerivedbfP , typename DerivedO , typename DerivedC , typename Derived\+BE , typename DerivedP $>$ \\
bool igl\+::read\+BF (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WI $>$ \&}]{WI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedbfP $>$ \&}]{bfP,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{O,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+BE $>$ \&}]{BE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Read bone forest into pure bone-\/skeleton format, expects only bones (no point handles), and that a root in the .bf \texorpdfstring{$<$}{<}---\texorpdfstring{$>$}{>} no weight attachment. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+\_\+name} & path to .bf bones tree file \\
\hline
\mbox{\texttt{ out}}  & {\em WI} & \#B list of unique weight indices \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#B list of parent indices into B, -\/1 for roots \\
\hline
\mbox{\texttt{ out}}  & {\em O} & \#B by 3 list of tip offset vectors from parent (or position for roots) \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C by 3 list of absolute joint locations \\
\hline
\mbox{\texttt{ out}}  & {\em BE} & \#\+BE by 3 list of bone indices into C, in order of weight index \\
\hline
\mbox{\texttt{ out}}  & {\em P} & \#\+BE list of parent bone indices into BE, -\/1 means root bone \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a0e2ff313a45b1882bc42711ef59518ea}{read\+TGF}, \doxylink{namespaceigl_af9bff7fe392542fa173e6665ddaf7a21}{bone\+\_\+parents}, \doxylink{namespaceigl_a583ee685a22b43577be16d088b6d3f29}{forward\+\_\+kinematics} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a5b133398a6e09068c97655f27de173a0}\label{namespaceigl_a5b133398a6e09068c97655f27de173a0} 
\index{igl@{igl}!readCSV@{readCSV}}
\index{readCSV@{readCSV}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readCSV()}{readCSV()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
bool igl\+::read\+CSV (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Matrix$<$ Scalar, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{M }\end{DoxyParamCaption})}



read a matrix from a csv file into a Eigen matrix 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for the matrix \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to .csv file \\
\hline
\mbox{\texttt{ out}}  & {\em M} & eigen matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a44a50547ab59bcb0705475875bb39a7d}\label{namespaceigl_a44a50547ab59bcb0705475875bb39a7d} 
\index{igl@{igl}!readDMAT@{readDMAT}}
\index{readDMAT@{readDMAT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readDMAT()}{readDMAT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedW $>$ \\
bool igl\+::read\+DMAT (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Read a matrix from an .dmat file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+\_\+name} & path to .dmat file \\
\hline
\mbox{\texttt{ out}}  & {\em W} & eigen matrix containing read-\/in coefficients \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a866564d1ac5b6f69fcee878f2ac2429d}\label{namespaceigl_a866564d1ac5b6f69fcee878f2ac2429d} 
\index{igl@{igl}!readDMAT@{readDMAT}}
\index{readDMAT@{readDMAT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readDMAT()}{readDMAT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
bool igl\+::read\+DMAT (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{W }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa40ef4e0517c71c597272824497377b2}\label{namespaceigl_aa40ef4e0517c71c597272824497377b2} 
\index{igl@{igl}!readMESH@{readMESH}}
\index{readMESH@{readMESH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMESH()}{readMESH()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedT $>$ \\
bool igl\+::read\+MESH (\begin{DoxyParamCaption}\item[{const std\+::string}]{mesh\+\_\+file\+\_\+name,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Load a tetrahedral volume mesh from a .mesh file. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mesh\+\_\+file\+\_\+name} & path of .mesh file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & double matrix of vertex positions \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em T} & \#T list of tet indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F list of face indices into vertex positions\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a078957e6e3c6a1f4cff7de4d0a28956d}\label{namespaceigl_a078957e6e3c6a1f4cff7de4d0a28956d} 
\index{igl@{igl}!readMESH@{readMESH}}
\index{readMESH@{readMESH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMESH()}{readMESH()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+MESH (\begin{DoxyParamCaption}\item[{const std\+::string}]{mesh\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{T,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a1471e99a81d4975918c69176594f4621}\label{namespaceigl_a1471e99a81d4975918c69176594f4621} 
\index{igl@{igl}!readMESH@{readMESH}}
\index{readMESH@{readMESH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMESH()}{readMESH()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedT $>$ \\
bool igl\+::read\+MESH (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{mesh\+\_\+file,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pointer} & to already opened .mesh file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2bcad51e218e111ff185566bea366cb3}\label{namespaceigl_a2bcad51e218e111ff185566bea366cb3} 
\index{igl@{igl}!readMESH@{readMESH}}
\index{readMESH@{readMESH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMESH()}{readMESH()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+MESH (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{mesh\+\_\+file,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{T,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a9364f18a5e9db3da7b923ab9ee054481}\label{namespaceigl_a9364f18a5e9db3da7b923ab9ee054481} 
\index{igl@{igl}!readMSH@{readMSH}}
\index{readMSH@{readMSH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMSH()}{readMSH()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$int Eigen\+Matrix\+Options$>$ \\
bool igl\+::read\+MSH (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msh,  }\item[{Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{X,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{Tri,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{Tet,  }\item[{Eigen\+::\+Vector\+Xi \&}]{Tri\+Tag,  }\item[{Eigen\+::\+Vector\+Xi \&}]{Tet\+Tag,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{XFields,  }\item[{std\+::vector$<$ Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ $>$ \&}]{XF,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{EFields,  }\item[{std\+::vector$<$ Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ $>$ \&}]{TriF,  }\item[{std\+::vector$<$ Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ $>$ \&}]{TetF }\end{DoxyParamCaption})}



read triangle surface mesh and tetrahedral volume mesh from .msh file 


\begin{DoxyTemplParams}{Template Parameters}
{\em Eigen\+Matrix\+Options} & matrix options of output matrices (e.\+g., Eigen\+::\+Col\+Major, Eigen\+::\+Row\+Major) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em msh} & -\/ file name \\
\hline
\mbox{\texttt{ out}}  & {\em X} & eigen double matrix of vertex positions \#X by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em Tri} & \#\+Tri eigen integer matrix of triangular faces indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em Tet} & \#\+Tet eigen integer matrix of tetrahedral indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em Tri\+Tag} & \#\+Tri eigen integer vector of tags associated with surface faces \\
\hline
\mbox{\texttt{ out}}  & {\em Tet\+Tag} & \#\+Tet eigen integer vector of tags associated with volume elements \\
\hline
\mbox{\texttt{ out}}  & {\em XFields} & \#\+XFields list of strings with field names associated with nodes \\
\hline
\mbox{\texttt{ out}}  & {\em XF} & \#\+XFields list of eigen double matrices, fields associated with nodes \\
\hline
\mbox{\texttt{ out}}  & {\em EFields} & \#\+EFields list of strings with field names associated with elements \\
\hline
\mbox{\texttt{ out}}  & {\em TriF} & \#\+EFields list of eigen double matrices, fields associated with surface elements \\
\hline
\mbox{\texttt{ out}}  & {\em TetF} & \#\+EFields list of eigen double matrices, fields associated with volume elements \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aadcaf1cbdf935ab8ae06264bc17a80b1}\label{namespaceigl_aadcaf1cbdf935ab8ae06264bc17a80b1} 
\index{igl@{igl}!readMSH@{readMSH}}
\index{readMSH@{readMSH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMSH()}{readMSH()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$int Eigen\+Matrix\+Options$>$ \\
bool igl\+::read\+MSH (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msh,  }\item[{Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{X,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{Tri,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{Tet,  }\item[{Eigen\+::\+Vector\+Xi \&}]{Tri\+Tag,  }\item[{Eigen\+::\+Vector\+Xi \&}]{Tet\+Tag }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad3928fbb4033580f092da0afb953cc7c}\label{namespaceigl_ad3928fbb4033580f092da0afb953cc7c} 
\index{igl@{igl}!readMSH@{readMSH}}
\index{readMSH@{readMSH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMSH()}{readMSH()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$int Eigen\+Matrix\+Options$>$ \\
bool igl\+::read\+MSH (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msh,  }\item[{Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{X,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{Tri,  }\item[{Eigen\+::\+Vector\+Xi \&}]{Tri\+Tag }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af2a21df0040f4d7799d33535261164ac}\label{namespaceigl_af2a21df0040f4d7799d33535261164ac} 
\index{igl@{igl}!readMSH@{readMSH}}
\index{readMSH@{readMSH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readMSH()}{readMSH()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$int Eigen\+Matrix\+Options$>$ \\
bool igl\+::read\+MSH (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msh,  }\item[{Eigen\+::\+Matrix$<$ double, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{X,  }\item[{Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic, Eigen\+Matrix\+Options $>$ \&}]{Tri }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0a5218e3a581f3ae7d3937db7cb6bafe}\label{namespaceigl_a0a5218e3a581f3ae7d3937db7cb6bafe} 
\index{igl@{igl}!readNODE@{readNODE}}
\index{readNODE@{readNODE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readNODE()}{readNODE()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedI $>$ \\
bool igl\+::read\+NODE (\begin{DoxyParamCaption}\item[{const std\+::string}]{node\+\_\+file\+\_\+name,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



load a list of points from a .node file 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em node\+\_\+file\+\_\+name} & path of .node file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & double matrix of vertex positions \#V by dim \\
\hline
\mbox{\texttt{ out}}  & {\em I} & list of indices (first tells whether 0 or 1 indexed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9897d432300521fe95987a223d3c834c}\label{namespaceigl_a9897d432300521fe95987a223d3c834c} 
\index{igl@{igl}!readNODE@{readNODE}}
\index{readNODE@{readNODE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readNODE()}{readNODE()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+NODE (\begin{DoxyParamCaption}\item[{const std\+::string}]{node\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad3d68499324615abfb462bf80130431b}\label{namespaceigl_ad3d68499324615abfb462bf80130431b} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{obj\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{TC,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{N,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{FTC,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{FN,  }\item[{std\+::vector$<$ std\+::tuple$<$ std\+::string, Index, Index $>$ $>$ \&}]{FM }\end{DoxyParamCaption})}



Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. 

Mesh may have faces of any number of degree


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to .obj file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & double matrix of vertex positions \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em TC} & double matrix of texture coordinats \#\+TC by 2 \\
\hline
\mbox{\texttt{ out}}  & {\em N} & double matrix of corner normals \#N by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F list of face indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em FTC} & \#F list of face indices into vertex texture coordinates \\
\hline
\mbox{\texttt{ out}}  & {\em FN} & \#F list of face indices into vertex normals \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8}\label{namespaceigl_aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{obj\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{TC,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{N,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{FTC,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{FN }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a86d39ea33fc7a17fb16a3e02a5065757}\label{namespaceigl_a86d39ea33fc7a17fb16a3e02a5065757} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{obj\+\_\+file,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{TC,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{N,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{FTC,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{FN,  }\item[{std\+::vector$<$ std\+::tuple$<$ std\+::string, Index, Index $>$ $>$ \&}]{FM }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em obj\+\_\+file} & pointer to already opened .obj file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6485914541d342f476f70e9ba97a00ff}\label{namespaceigl_a6485914541d342f476f70e9ba97a00ff} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{obj\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a2d8c28b2557217c00bb8e146d828cd35}\label{namespaceigl_a2d8c28b2557217c00bb8e146d828cd35} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+TC , typename Derived\+CN , typename DerivedF , typename Derived\+FTC , typename Derived\+FN $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TC $>$ \&}]{TC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+CN $>$ \&}]{CN,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FTC $>$ \&}]{FTC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FN $>$ \&}]{FN }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Eigen Wrappers. These will return true only if the data is perfectly "{}rectangular"{}\+: All faces are the same degree, all have the same number of textures/normals etc. \Hypertarget{namespaceigl_a3034889b938bdf0fa96f79ad62f47641}\label{namespaceigl_a3034889b938bdf0fa96f79ad62f47641} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a4c4849d6cdcfeffd1ed7b48c15d493ad}\label{namespaceigl_a4c4849d6cdcfeffd1ed7b48c15d493ad} 
\index{igl@{igl}!readOBJ@{readOBJ}}
\index{readOBJ@{readOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOBJ()}{readOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedI , typename DerivedC $>$ \\
bool igl\+::read\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Polygon mesh version. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em I} & \#I vectorized list of polygon corner indices into rows of some matrix V \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#P+1 list of cumulative polygon sizes so that C(i+1)-\/C(i) = size of the ith polygon, and so I(\+C(i)) through I(C(i+1)-\/1) are the indices of the ith polygon \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae0b3fbb305991ff009d5ef2bf7c2bb99}\label{namespaceigl_ae0b3fbb305991ff009d5ef2bf7c2bb99} 
\index{igl@{igl}!readOFF@{readOFF}}
\index{readOFF@{readOFF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOFF()}{readOFF()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+OFF (\begin{DoxyParamCaption}\item[{const std\+::string}]{off\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{N,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{C }\end{DoxyParamCaption})}



Read a mesh from an ascii OFF file, filling in vertex positions, normals and texture coordinates. 

Mesh may have faces of any number of degree


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to .obj file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & double matrix of vertex positions \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F list of face indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em N} & list of vertex normals \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em C} & list of rgb color values per vertex \#V by 3 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a80e987bbb9c21c44facf425147ce0c0e}\label{namespaceigl_a80e987bbb9c21c44facf425147ce0c0e} 
\index{igl@{igl}!readOFF@{readOFF}}
\index{readOFF@{readOFF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOFF()}{readOFF()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+OFF (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a53bb9e4bd7e6acfc8838f372351d7fd5}\label{namespaceigl_a53bb9e4bd7e6acfc8838f372351d7fd5} 
\index{igl@{igl}!readOFF@{readOFF}}
\index{readOFF@{readOFF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOFF()}{readOFF()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+OFF (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a805a632075fa2b99892f172b2063e8de}\label{namespaceigl_a805a632075fa2b99892f172b2063e8de} 
\index{igl@{igl}!readOFF@{readOFF}}
\index{readOFF@{readOFF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readOFF()}{readOFF()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+OFF (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{off\+\_\+file,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{N,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em off\+\_\+file} & pointer to already open .off file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a19dbe47791345f0dff905ae3515ffd21}\label{namespaceigl_a19dbe47791345f0dff905ae3515ffd21} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{ply\+\_\+stream,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VD $>$ \&}]{VD,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{Vheader,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FD $>$ \&}]{FD,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{Fheader,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ED $>$ \&}]{ED,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{Eheader,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{comments }\end{DoxyParamCaption})}



Read triangular mesh from ply file, filling in vertex positions, normals and texture coordinates, if available also read additional properties associated with vertex,faces and edges and file comments. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Derived\texorpdfstring{$\ast$}{*}} & from Eigen matrix parameters \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ply\+\_\+stream} & ply file input stream \\
\hline
\mbox{\texttt{ out}}  & {\em V} & (\#V,3) matrix of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & (\#F,3) list of face indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em E} & (\#E,2) list of edge indices into vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em N} & (\#V,3) list of normals \\
\hline
\mbox{\texttt{ out}}  & {\em UV} & (\#V,2) list of texture coordinates \\
\hline
\mbox{\texttt{ out}}  & {\em VD} & (\#V,\texorpdfstring{$\ast$}{*}) additional vertex data \\
\hline
\mbox{\texttt{ out}}  & {\em Vheader} & (\#V) list of vertex data headers \\
\hline
\mbox{\texttt{ out}}  & {\em FD} & (\#F,\texorpdfstring{$\ast$}{*}) additional face data \\
\hline
\mbox{\texttt{ out}}  & {\em Fheader} & (\#F) list of face data headers \\
\hline
\mbox{\texttt{ out}}  & {\em ED} & (\#E,\texorpdfstring{$\ast$}{*}) additional edge data \\
\hline
\mbox{\texttt{ out}}  & {\em Eheader} & (\#E) list of edge data headers \\
\hline
\mbox{\texttt{ out}}  & {\em comments} & (\texorpdfstring{$\ast$}{*}) file comments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Unlike previous versions, all matrices are left untouched if they are not read from the file. ~\newline
 
\end{DoxyNote}
\Hypertarget{namespaceigl_a2d9d95305b4c4ad23b0ae936bf8ebe28}\label{namespaceigl_a2d9d95305b4c4ad23b0ae936bf8ebe28} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{ply\+\_\+file,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VD $>$ \&}]{VD,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{VDheader,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FD $>$ \&}]{FD,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{FDheader,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+ED $>$ \&}]{ED,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{EDheader,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{comments }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ply\+\_\+file} & ply file name \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa82ecbf00ab1917446d26d4aaed0c79f}\label{namespaceigl_aa82ecbf00ab1917446d26d4aaed0c79f} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename Derived\+UV , typename Derived\+VD $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VD $>$ \&}]{VD,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{Vheader }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a500ef30b39ed4e46a12342238fddd1ea}\label{namespaceigl_a500ef30b39ed4e46a12342238fddd1ea} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UV $>$ \&}]{UV }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aab45ac576aa1e4ed7721b0a00e5d12c1}\label{namespaceigl_aab45ac576aa1e4ed7721b0a00e5d12c1} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a18adc6f5870ec2806992a65719834abd}\label{namespaceigl_a18adc6f5870ec2806992a65719834abd} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0c0ed58390b96d5981b908b62103c250}\label{namespaceigl_a0c0ed58390b96d5981b908b62103c250} 
\index{igl@{igl}!readPLY@{readPLY}}
\index{readPLY@{readPLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readPLY()}{readPLY()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::read\+PLY (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em fp} & pointer to ply file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa1e874916eb50201727b290cc48fbaac}\label{namespaceigl_aa1e874916eb50201727b290cc48fbaac} 
\index{igl@{igl}!readSTL@{readSTL}}
\index{readSTL@{readSTL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readSTL()}{readSTL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
bool igl\+::read\+STL (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{input,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



Read a mesh from an ascii/binary stl file. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & path to .stl file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & double matrix of vertex positions \#V\texorpdfstring{$\ast$}{*}3 by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em F} & index matrix of triangle indices \#F by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em N} & double matrix of surface normals \#F by 3 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md30}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md30}
\begin{DoxyVerb}bool success = readSTL(filename,temp_V,F,N);
remove_duplicate_vertices(temp_V,0,V,SVI,SVJ);
for_each(F.data(),F.data()+F.size(),[&SVJ](int & f){f=SVJ(f);});
writeOBJ("Downloads/cat.obj",V,F); 
\end{DoxyVerb}
 \Hypertarget{namespaceigl_a1b3c654bf8fde8ab6f7b55c515b11bea}\label{namespaceigl_a1b3c654bf8fde8ab6f7b55c515b11bea} 
\index{igl@{igl}!readSTL@{readSTL}}
\index{readSTL@{readSTL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readSTL()}{readSTL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename TypeV , typename TypeF , typename TypeN $>$ \\
bool igl\+::read\+STL (\begin{DoxyParamCaption}\item[{std\+::istream \&}]{input,  }\item[{std\+::vector$<$ std\+::array$<$ TypeV, 3 $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::array$<$ TypeF, 3 $>$ $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::array$<$ TypeN, 3 $>$ $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa7d360f2f2694afebd1e62cee1551de4}\label{namespaceigl_aa7d360f2f2694afebd1e62cee1551de4} 
\index{igl@{igl}!readSTL@{readSTL}}
\index{readSTL@{readSTL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readSTL()}{readSTL()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
bool igl\+::read\+STL (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em fp} & pointer to ply file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0e2ff313a45b1882bc42711ef59518ea}\label{namespaceigl_a0e2ff313a45b1882bc42711ef59518ea} 
\index{igl@{igl}!readTGF@{readTGF}}
\index{readTGF@{readTGF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readTGF()}{readTGF()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool igl\+::read\+TGF (\begin{DoxyParamCaption}\item[{const std\+::string}]{tgf\+\_\+filename,  }\item[{std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&}]{C,  }\item[{std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&}]{E,  }\item[{std\+::vector$<$ int $>$ \&}]{P,  }\item[{std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&}]{BE,  }\item[{std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&}]{CE,  }\item[{std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&}]{PE }\end{DoxyParamCaption})}



Read a graph from a .tgf file. 

Input\+: filename .tgf file name Output\+: V \# vertices by 3 list of vertex positions E \# edges by 2 list of edge indices P \# point-\/handles list of point handle indices BE \# bone-\/edges by 2 list of bone-\/edge indices CE \# cage-\/edges by 2 list of cage-\/edge indices PE \# pseudo-\/edges by 2 list of pseudo-\/edge indices

Assumes that graph vertices are 3 dimensional \Hypertarget{namespaceigl_a86a753ab8f368313c20aa9d6aa98841c}\label{namespaceigl_a86a753ab8f368313c20aa9d6aa98841c} 
\index{igl@{igl}!readTGF@{readTGF}}
\index{readTGF@{readTGF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readTGF()}{readTGF()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool igl\+::read\+TGF (\begin{DoxyParamCaption}\item[{const std\+::string}]{tgf\+\_\+filename,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{Eigen\+::\+Vector\+Xi \&}]{P,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{BE,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{CE,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{PE }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a2cfc64e83ab4d2cd4fb8a6e31d4403d6}\label{namespaceigl_a2cfc64e83ab4d2cd4fb8a6e31d4403d6} 
\index{igl@{igl}!readTGF@{readTGF}}
\index{readTGF@{readTGF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readTGF()}{readTGF()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool igl\+::read\+TGF (\begin{DoxyParamCaption}\item[{const std\+::string}]{tgf\+\_\+filename,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a480b2999b4d8ec50dcfa86d790f7b9d0}\label{namespaceigl_a480b2999b4d8ec50dcfa86d790f7b9d0} 
\index{igl@{igl}!readWRL@{readWRL}}
\index{readWRL@{readWRL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readWRL()}{readWRL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+WRL (\begin{DoxyParamCaption}\item[{const std\+::string}]{wrl\+\_\+file\+\_\+name,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



Read a mesh from an ascii wrl file, filling in vertex positions and face indices of the first model. 

Mesh may have faces of any number of degree


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to .wrl file \\
\hline
\mbox{\texttt{ out}}  & {\em V} & double matrix of vertex positions \#V by 3 \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F list of face indices into vertex positions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a90ea20362e20a0f75e389904a2957ed2}\label{namespaceigl_a90ea20362e20a0f75e389904a2957ed2} 
\index{igl@{igl}!readWRL@{readWRL}}
\index{readWRL@{readWRL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{readWRL()}{readWRL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::read\+WRL (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{wrl\+\_\+file,  }\item[{std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em wrl\+\_\+file} & pointer to already opened .wrl file (will be closed) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af757c8be2caaeaf804de6240cc6ffa7f}\label{namespaceigl_af757c8be2caaeaf804de6240cc6ffa7f} 
\index{igl@{igl}!redux@{redux}}
\index{redux@{redux}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{redux()}{redux()}}
{\footnotesize\ttfamily template$<$typename AType , typename Func , typename DerivedB $>$ \\
void igl\+::redux (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{const Func \&}]{func,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Perform reductions on the rows or columns of a Sparse\+Matrix. 

This is {\itshape similar} to Dense\+Base\+::redux, but different in two important ways\+:
\begin{DoxyEnumerate}
\item (unstored) Zeros are {\bfseries{not}} "{}visited"{}, however if the first element in the column/row does not appear in the first row/column then the reduction is assumed to start with zero. In this way, "{}any"{}, "{}all"{}, "{}count"{}(non-\/zeros) work as expected. This means it is {\bfseries{not}} possible to use this to count (implicit) zeros.
\item This redux is more powerful in the sense that A and B may have different types. This makes it possible to count the number of non-\/zeros in a Sparse\+Matrix$<$bool$>$ A into a Vector\+Xi B.
\end{DoxyEnumerate}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to sum (1 or 2) \\
\hline
\mbox{\texttt{ in}}  & {\em func} & function handle with the prototype {\ttfamily X(\+Y a, I i, J j, Z b)} where a is the running value, b is A(i,j) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & n-\/long sparse vector (if dim == 1) or m-\/long sparse vector (if dim == 2)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a09311547ed4f12bee75c2631d2d19bfd}{for\+\_\+each} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a492e4e2a6bc227fe67a79b0110d4c8de}\label{namespaceigl_a492e4e2a6bc227fe67a79b0110d4c8de} 
\index{igl@{igl}!remesh\_along\_isoline@{remesh\_along\_isoline}}
\index{remesh\_along\_isoline@{remesh\_along\_isoline}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remesh\_along\_isoline()}{remesh\_along\_isoline()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedU , typename DerivedG , typename DerivedJ , typename BCtype , typename Derived\+SU , typename DerivedL $>$ \\
void igl\+::remesh\+\_\+along\+\_\+isoline (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{val,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SU $>$ \&}]{SU,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ BCtype $>$ \&}]{BC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



Given a triangle mesh and a scalar field, remesh so that a given isovalue of the scalar field follows (new) edges of the output mesh. 

Effectively running "{}marching triangles"{} on mesh, but not in any coherent order. The output mesh should be as manifold as the input.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#V by 1 list of scalar field \\
\hline
\mbox{\texttt{ in}}  & {\em val} & value of S to remesh along \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#U by dim list of mesh vertex positions \#U\texorpdfstring{$>$}{>}=\#V \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#G by 3 list of mesh triangle indices into U, \#G\texorpdfstring{$>$}{>}=\#F \\
\hline
\mbox{\texttt{ out}}  & {\em SU} & \#U list of scalar field values over new mesh \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#G list of indices into F revealing birth triangles \\
\hline
\mbox{\texttt{ out}}  & {\em BC} & \#U by \#V sparse matrix of barycentric coordinates so that U = BC\texorpdfstring{$\ast$}{*}V \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#G list of bools whether scalar field in triangle below or above val \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7057971dd3f4cb240c6598b5ee52eaff}\label{namespaceigl_a7057971dd3f4cb240c6598b5ee52eaff} 
\index{igl@{igl}!remesh\_along\_isoline@{remesh\_along\_isoline}}
\index{remesh\_along\_isoline@{remesh\_along\_isoline}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remesh\_along\_isoline()}{remesh\_along\_isoline()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedS , typename DerivedG , typename DerivedJ , typename BCtype , typename Derived\+SU , typename DerivedL $>$ \\
void igl\+::remesh\+\_\+along\+\_\+isoline (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const typename Derived\+S\+::\+Scalar}]{val,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SU $>$ \&}]{SU,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ BCtype $>$ \&}]{BC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of vertices (\#V) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4684c8d485a5cd367751c6bb92e8b415}\label{namespaceigl_a4684c8d485a5cd367751c6bb92e8b415} 
\index{igl@{igl}!remove\_duplicate\_vertices@{remove\_duplicate\_vertices}}
\index{remove\_duplicate\_vertices@{remove\_duplicate\_vertices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remove\_duplicate\_vertices()}{remove\_duplicate\_vertices()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+SV , typename Derived\+SVI , typename Derived\+SVJ $>$ \\
void igl\+::remove\+\_\+duplicate\+\_\+vertices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const double}]{epsilon,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&}]{SVI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVJ $>$ \&}]{SVJ }\end{DoxyParamCaption})}



Remove duplicate vertices upto a uniqueness tolerance (epsilon) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em epsilon} & uniqueness tolerance used coordinate-\/wise\+: 1e0 -\/-\/\texorpdfstring{$>$}{>} integer match, 1e-\/1 -\/-\/\texorpdfstring{$>$}{>} match up to first decimal, ... , 0 -\/-\/\texorpdfstring{$>$}{>} exact match. \\
\hline
\mbox{\texttt{ out}}  & {\em SV} & \#\+SV by dim new list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em SVI} & \#\+SV by 1 list of indices so SV = V(\+SVI,\+:) \\
\hline
\mbox{\texttt{ out}}  & {\em SVJ} & \#V by 1 list of indices so V = SV(\+SVJ,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae2865c2682b8f7cda67db377ca026619}\label{namespaceigl_ae2865c2682b8f7cda67db377ca026619} 
\index{igl@{igl}!remove\_duplicate\_vertices@{remove\_duplicate\_vertices}}
\index{remove\_duplicate\_vertices@{remove\_duplicate\_vertices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remove\_duplicate\_vertices()}{remove\_duplicate\_vertices()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+SV , typename Derived\+SVI , typename Derived\+SVJ , typename Derived\+SF $>$ \\
void igl\+::remove\+\_\+duplicate\+\_\+vertices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const double}]{epsilon,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&}]{SVI,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVJ $>$ \&}]{SVJ,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper that also remaps given faces (F) -\/-\/\texorpdfstring{$>$}{>} (SF) so that SF index SV 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em SF} & \#F by dim list of face indices into SV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8d51bedab2b1bb46c40334e6d59035bc}\label{namespaceigl_a8d51bedab2b1bb46c40334e6d59035bc} 
\index{igl@{igl}!remove\_unreferenced@{remove\_unreferenced}}
\index{remove\_unreferenced@{remove\_unreferenced}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remove\_unreferenced()}{remove\_unreferenced()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF , typename DerivedI , typename DerivedJ $>$ \\
void igl\+::remove\+\_\+unreferenced (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&}]{NV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&}]{NF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Remove unreferenced vertices from V, updating F accordingly. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by ss list of simplices (Values of -\/1 are quitely skipped) \\
\hline
\mbox{\texttt{ out}}  & {\em NV} & \#\+NV by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em NF} & \#\+NF by ss list of simplices \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#V by 1 list of indices such that\+: NF = IM(\+F) and NT = IM(\+T) and V(find(IM\texorpdfstring{$<$}{<}=size(\+NV,1)),\+:) = NV \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+NV by 1 list, such that NV = V(\+J,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a84fd84522be8f2e70fa6ef154849f3c1}\label{namespaceigl_a84fd84522be8f2e70fa6ef154849f3c1} 
\index{igl@{igl}!remove\_unreferenced@{remove\_unreferenced}}
\index{remove\_unreferenced@{remove\_unreferenced}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remove\_unreferenced()}{remove\_unreferenced()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF , typename DerivedI $>$ \\
void igl\+::remove\+\_\+unreferenced (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&}]{NV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&}]{NF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6afd2f60ecc2994c7f37deecac94dc80}\label{namespaceigl_a6afd2f60ecc2994c7f37deecac94dc80} 
\index{igl@{igl}!remove\_unreferenced@{remove\_unreferenced}}
\index{remove\_unreferenced@{remove\_unreferenced}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{remove\_unreferenced()}{remove\_unreferenced()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedI , typename DerivedJ $>$ \\
void igl\+::remove\+\_\+unreferenced (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of vertices (possibly greater than F.\+max\+Coeff()+1) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad35357b4f4e8dbf29c3fad77850fb957}\label{namespaceigl_ad35357b4f4e8dbf29c3fad77850fb957} 
\index{igl@{igl}!repdiag@{repdiag}}
\index{repdiag@{repdiag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{repdiag()}{repdiag()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::repdiag (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{A,  }\item[{const int}]{d,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{B }\end{DoxyParamCaption})}



Repeat a matrix along the diagonal a certain number of times, so that if A is a m by n matrix and we want to repeat along the diagonal d times, we get a m\texorpdfstring{$\ast$}{*}d by n\texorpdfstring{$\ast$}{*}d matrix B such that\+: B( (k\texorpdfstring{$\ast$}{*}m+1)\+:(k\texorpdfstring{$\ast$}{*}m+1+m-\/1), (k\texorpdfstring{$\ast$}{*}n+1)\+:(k\texorpdfstring{$\ast$}{*}n+1+n-\/1)) = A for k from 0 to d-\/1. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix we are repeating along the diagonal. \\
\hline
\mbox{\texttt{ in}}  & {\em d} & number of times to repeat A along the diagonal \\
\hline
\mbox{\texttt{ out}}  & {\em B} & m\texorpdfstring{$\ast$}{*}d by n\texorpdfstring{$\ast$}{*}d matrix with A repeated d times along the diagonal, will be dense or sparse to match A \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4425112c9b09eccba5935d7390228b8f}\label{namespaceigl_a4425112c9b09eccba5935d7390228b8f} 
\index{igl@{igl}!repdiag@{repdiag}}
\index{repdiag@{repdiag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{repdiag()}{repdiag()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::repdiag (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{A,  }\item[{const int}]{d,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{B }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a8da20ed25cb6630b40cb666c4f0153fb}\label{namespaceigl_a8da20ed25cb6630b40cb666c4f0153fb} 
\index{igl@{igl}!repdiag@{repdiag}}
\index{repdiag@{repdiag}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{repdiag()}{repdiag()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$class Mat $>$ \\
Mat igl\+::repdiag (\begin{DoxyParamCaption}\item[{const Mat \&}]{A,  }\item[{const int}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38}\label{namespaceigl_af22441a0a5c291b8fd51ee68e5817c38} 
\index{igl@{igl}!repmat@{repmat}}
\index{repmat@{repmat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{repmat()}{repmat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB $>$ \\
void igl\+::repmat (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const int}]{r,  }\item[{const int}]{c,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



Replicate and tile a matrix. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n input matrix \\
\hline
\mbox{\texttt{ in}}  & {\em r} & number of row-\/direction copies \\
\hline
\mbox{\texttt{ in}}  & {\em c} & number of col-\/direction copies \\
\hline
\mbox{\texttt{ out}}  & {\em B} & r\texorpdfstring{$\ast$}{*}m by c\texorpdfstring{$\ast$}{*}n output matrix\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
At least for Dense matrices this is replaced by {\ttfamily replicate} e.\+g., dst = src.\+replicate(n,m); \href{http://forum.kde.org/viewtopic.php?f=74&t=90876\#p173517}{\texttt{ http\+://forum.\+kde.\+org/viewtopic.\+php?f=74\&t=90876\#p173517}} 
\end{DoxyNote}
\Hypertarget{namespaceigl_ab60f3cce9962403250a40b72d322e7c3}\label{namespaceigl_ab60f3cce9962403250a40b72d322e7c3} 
\index{igl@{igl}!repmat@{repmat}}
\index{repmat@{repmat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{repmat()}{repmat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T , int major\+Type$>$ \\
void igl\+::repmat (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T, major\+Type $>$ \&}]{A,  }\item[{const int}]{r,  }\item[{const int}]{c,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T, major\+Type $>$ \&}]{B }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aaadc5b485c5ab4b8719143b79e9458b2}\label{namespaceigl_aaadc5b485c5ab4b8719143b79e9458b2} 
\index{igl@{igl}!resolve\_duplicated\_faces@{resolve\_duplicated\_faces}}
\index{resolve\_duplicated\_faces@{resolve\_duplicated\_faces}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{resolve\_duplicated\_faces()}{resolve\_duplicated\_faces()}}
{\footnotesize\ttfamily template$<$typename Derived\+F1 , typename Derived\+F2 , typename DerivedJ $>$ \\
void igl\+::resolve\+\_\+duplicated\+\_\+faces (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+F1 $>$ \&}]{F1,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F2 $>$ \&}]{F2,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Resolve duplicated faces according to the following rules per unique face\+: 


\begin{DoxyEnumerate}
\item If the number of positively oriented faces equals the number of negatively oriented faces, remove all duplicated faces at this triangle.
\item If the number of positively oriented faces equals the number of negatively oriented faces plus 1, keeps one of the positively oriented face.
\item If the number of positively oriented faces equals the number of negatively oriented faces minus 1, keeps one of the negatively oriented face.
\item If the number of postively oriented faces differ with the number of negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown.
\end{DoxyEnumerate}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F1} & \#\+F1 by 3 array of input faces. \\
\hline
\mbox{\texttt{ out}}  & {\em F2} & \#\+F2 by 3 array of output faces without duplicated faces. \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#\+F2 list of indices into F1. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad9c02b0853de3739e4fcfe1a39591826}\label{namespaceigl_ad9c02b0853de3739e4fcfe1a39591826} 
\index{igl@{igl}!rgb\_to\_hsv@{rgb\_to\_hsv}}
\index{rgb\_to\_hsv@{rgb\_to\_hsv}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rgb\_to\_hsv()}{rgb\_to\_hsv()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename R , typename H $>$ \\
void igl\+::rgb\+\_\+to\+\_\+hsv (\begin{DoxyParamCaption}\item[{const R \texorpdfstring{$\ast$}{*}}]{rgb,  }\item[{H \texorpdfstring{$\ast$}{*}}]{hsv }\end{DoxyParamCaption})}



Convert RGB to HSV. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em rgb} & rgb triplet in (0,1) \\
\hline
\mbox{\texttt{ out}}  & {\em hsv} & hsv triplet in (0,360),(0,1),(0,1) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2ffa1e3139c0b53002dfc44fa70bb3de}\label{namespaceigl_a2ffa1e3139c0b53002dfc44fa70bb3de} 
\index{igl@{igl}!rgb\_to\_hsv@{rgb\_to\_hsv}}
\index{rgb\_to\_hsv@{rgb\_to\_hsv}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rgb\_to\_hsv()}{rgb\_to\_hsv()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedR , typename DerivedH $>$ \\
void igl\+::rgb\+\_\+to\+\_\+hsv (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedH $>$ \&}]{H }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em R} & \#R by 3 list of rgb triplets in (0,1) \\
\hline
\mbox{\texttt{ out}}  & {\em H} & \#R by 3 list of hsv triplets in \mbox{[}(0,360),(0,1),(0,1)\mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad9b76e4f79b4040f8b327696d8120ac6}\label{namespaceigl_ad9b76e4f79b4040f8b327696d8120ac6} 
\index{igl@{igl}!rigid\_alignment@{rigid\_alignment}}
\index{rigid\_alignment@{rigid\_alignment}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rigid\_alignment()}{rigid\_alignment()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedP , typename DerivedN , typename DerivedR , typename Derivedt $>$ \\
void igl\+::rigid\+\_\+alignment (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedt $>$ \&}]{t }\end{DoxyParamCaption})}



Find the rigid transformation that best aligns the 3D points X to their corresponding points P with associated normals N. 

\begin{DoxyVerb} min       (X*R+t-P)'N
 RSO(3)
 tR
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & \#X by 3 list of query points \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#X by 3 list of corresponding (e.\+g., closest) points \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#X by 3 list of unit normals for each row in P \\
\hline
\mbox{\texttt{ out}}  & {\em R} & 3 by 3 rotation matrix \\
\hline
\mbox{\texttt{ out}}  & {\em t} & 1 by 3 translation vector\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
icp 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ad3a4c70fcd75b8cb889db416e1412838}\label{namespaceigl_ad3a4c70fcd75b8cb889db416e1412838} 
\index{igl@{igl}!rotate\_by\_quat@{rotate\_by\_quat}}
\index{rotate\_by\_quat@{rotate\_by\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rotate\_by\_quat()}{rotate\_by\_quat()}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::rotate\+\_\+by\+\_\+quat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{v,  }\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{out }\end{DoxyParamCaption})}



Compute rotation of a given vector/point by a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x\texorpdfstring{$\ast$}{*}i + y\texorpdfstring{$\ast$}{*}j + z\texorpdfstring{$\ast$}{*}k + w. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em v} & input 3d point/vector \\
\hline
\mbox{\texttt{ in}}  & {\em q} & input quaternion \\
\hline
\mbox{\texttt{ out}}  & {\em out} & result of rotation, allowed to be same as v \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac6346e87eb125dbf3922a86b2430cd66}\label{namespaceigl_ac6346e87eb125dbf3922a86b2430cd66} 
\index{igl@{igl}!rotate\_vectors@{rotate\_vectors}}
\index{rotate\_vectors@{rotate\_vectors}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rotate\_vectors()}{rotate\_vectors()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd igl\+::rotate\+\_\+vectors (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{B1,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{B2 }\end{DoxyParamCaption})}



Rotate the vectors V by A radians on the tangent plane spanned by B1 and B2. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of vectors \\
\hline
\mbox{\texttt{ in}}  & {\em A} & \#V eigen vector of rotation angles or a single angle to be applied to all vectors \\
\hline
\mbox{\texttt{ in}}  & {\em B1} & \#V by 3 eigen Matrix of base vector 1 \\
\hline
\mbox{\texttt{ in}}  & {\em B2} & \#V by 3 eigen Matrix of base vector 2 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the rotated vectors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a9d8d4e651144f2c59335a8050526d3a2}\label{namespaceigl_a9d8d4e651144f2c59335a8050526d3a2} 
\index{igl@{igl}!rotation\_matrix\_from\_directions@{rotation\_matrix\_from\_directions}}
\index{rotation\_matrix\_from\_directions@{rotation\_matrix\_from\_directions}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rotation\_matrix\_from\_directions()}{rotation\_matrix\_from\_directions()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
Eigen\+::\+Matrix$<$ Scalar, 3, 3 $>$ igl\+::rotation\+\_\+matrix\+\_\+from\+\_\+directions (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$}]{v0,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$}]{v1 }\end{DoxyParamCaption})}



Given 2 vectors centered on origin calculate the rotation matrix from first to the second. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em v0} & 3D column vector \\
\hline
\mbox{\texttt{ in}}  & {\em v1} & 3D column vector \\
\hline
\mbox{\texttt{ out}}  & {\em 3} & by 3 rotation matrix that takes v0 to v1 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae02094b6dc03417864b855a494010674}\label{namespaceigl_ae02094b6dc03417864b855a494010674} 
\index{igl@{igl}!round@{round}}
\index{round@{round}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{round()}{round()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX $>$ \\
DerivedX igl\+::round (\begin{DoxyParamCaption}\item[{const DerivedX}]{r }\end{DoxyParamCaption})}



Round a scalar value. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em x} & number \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
x rounded to integer 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a97b570d716cfd4d32ff22a5ec6b1d14b}\label{namespaceigl_a97b570d716cfd4d32ff22a5ec6b1d14b} 
\index{igl@{igl}!round@{round}}
\index{round@{round}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{round()}{round()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::round (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



Round a given matrix to nearest integers. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix of scalars \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n matrix of rounded integers \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7fa793427dc212ca586bf37babf9459e}\label{namespaceigl_a7fa793427dc212ca586bf37babf9459e} 
\index{igl@{igl}!rows\_to\_matrix@{rows\_to\_matrix}}
\index{rows\_to\_matrix@{rows\_to\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{rows\_to\_matrix()}{rows\_to\_matrix()}}
{\footnotesize\ttfamily template$<$class Row , class Mat $>$ \\
bool igl\+::rows\+\_\+to\+\_\+matrix (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Row $>$ \&}]{V,  }\item[{Mat \&}]{M }\end{DoxyParamCaption})}



Convert a list (std\+::vector) of row vectors of the same length to a matrix. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Row} & row vector type, must implement\+: .size() \\
\hline
{\em Mat} & Matrix type, must implement\+: .resize(m,n) .row(i) = Row \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & a m-\/long list of vectors of size n \\
\hline
\mbox{\texttt{ out}}  & {\em M} & an m by n matrix \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a32d8c4634efb1346c13c78dc765a3550}\label{namespaceigl_a32d8c4634efb1346c13c78dc765a3550} 
\index{igl@{igl}!sample\_edges@{sample\_edges}}
\index{sample\_edges@{sample\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sample\_edges()}{sample\_edges()}}
{\footnotesize\ttfamily void igl\+::sample\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{const int}]{k,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{S }\end{DoxyParamCaption})}



Compute k extra points along each edge in E defined over vertices of V. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & vertices over which edges are defined, \# vertices by dim \\
\hline
\mbox{\texttt{ in}}  & {\em E} & edge list, \# edges by 2 \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of extra samples to be computed along edge not including start and end points \\
\hline
\mbox{\texttt{ out}}  & {\em S} & sampled vertices, size less than \# edges \texorpdfstring{$\ast$}{*} (2+k) by dim always begins with V so that E is also defined over S \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a037463f70cf735b53d1205d9f24f8bd3}\label{namespaceigl_a037463f70cf735b53d1205d9f24f8bd3} 
\index{igl@{igl}!scalar\_to\_cr\_vector\_gradient@{scalar\_to\_cr\_vector\_gradient}}
\index{scalar\_to\_cr\_vector\_gradient@{scalar\_to\_cr\_vector\_gradient}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{scalar\_to\_cr\_vector\_gradient()}{scalar\_to\_cr\_vector\_gradient()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ \\
void igl\+::scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&}]{G }\end{DoxyParamCaption})}



Computes the gradient matrix with hat functions on the right, and vector CR functions on the left. 

See Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "{}\+A Simple Discretization of the Vector Dirichlet \+Energy"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/4 list of triangle/tetrahedron indices \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ in}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge \\
\hline
\mbox{\texttt{ out}}  & {\em G} & 2\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+HE\texorpdfstring{$\vert$}{|} by \#V gradient matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adb08e6f491b4715eb69439e76a9d6829}\label{namespaceigl_adb08e6f491b4715eb69439e76a9d6829} 
\index{igl@{igl}!scalar\_to\_cr\_vector\_gradient@{scalar\_to\_cr\_vector\_gradient}}
\index{scalar\_to\_cr\_vector\_gradient@{scalar\_to\_cr\_vector\_gradient}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{scalar\_to\_cr\_vector\_gradient()}{scalar\_to\_cr\_vector\_gradient()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ \\
void igl\+::scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&}]{G }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em E} & \#F by 3 a mapping from each halfedge to each edge \\
\hline
\mbox{\texttt{ out}}  & {\em oE} & \#F by 3 the orientation (e.\+g., -\/1 or 1) of each halfedge \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a27653ad9aae1bdd251eeb2b990cb69be}\label{namespaceigl_a27653ad9aae1bdd251eeb2b990cb69be} 
\index{igl@{igl}!scalar\_to\_cr\_vector\_gradient\_intrinsic@{scalar\_to\_cr\_vector\_gradient\_intrinsic}}
\index{scalar\_to\_cr\_vector\_gradient\_intrinsic@{scalar\_to\_cr\_vector\_gradient\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{scalar\_to\_cr\_vector\_gradient\_intrinsic()}{scalar\_to\_cr\_vector\_gradient\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DeriveddA , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ \\
void igl\+::scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DeriveddA $>$ \&}]{dA,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&}]{G }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

intrinsic version.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em l\+\_\+sq} & \#F by 3 list of squared edge lengths of each halfedge \\
\hline
\mbox{\texttt{ in}}  & {\em dA} & \#F list of double areas\\
\hline
\end{DoxyParams}
\doxylink{scalar__to__cr__vector__gradient_8h}{include/igl/scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient.\+h} \Hypertarget{namespaceigl_a9e243eeab5d04120f9aa5670610e5961}\label{namespaceigl_a9e243eeab5d04120f9aa5670610e5961} 
\index{igl@{igl}!scalar\_to\_cr\_vector\_gradient\_intrinsic@{scalar\_to\_cr\_vector\_gradient\_intrinsic}}
\index{scalar\_to\_cr\_vector\_gradient\_intrinsic@{scalar\_to\_cr\_vector\_gradient\_intrinsic}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{scalar\_to\_cr\_vector\_gradient\_intrinsic()}{scalar\_to\_cr\_vector\_gradient\_intrinsic()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+L\+\_\+sq , typename DerivedE , typename Derived\+OE , typename ScalarG $>$ \\
void igl\+::scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient\+\_\+intrinsic (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+L\+\_\+sq $>$ \&}]{l\+\_\+sq,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+OE $>$ \&}]{oE,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ ScalarG $>$ \&}]{G }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \doxylink{scalar__to__cr__vector__gradient_8h}{include/igl/scalar\+\_\+to\+\_\+cr\+\_\+vector\+\_\+gradient.\+h}. 

\Hypertarget{namespaceigl_a0aea89901f87476263f8973c9ea065e4}\label{namespaceigl_a0aea89901f87476263f8973c9ea065e4} 
\index{igl@{igl}!screen\_space\_selection@{screen\_space\_selection}}
\index{screen\_space\_selection@{screen\_space\_selection}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{screen\_space\_selection()}{screen\_space\_selection()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW , typename Deriveda $>$ \\
void igl\+::screen\+\_\+space\+\_\+selection (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&}]{viewport,  }\item[{const std\+::vector$<$ Eigen\+::\+Matrix$<$ Ltype, 1, 2 $>$ $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Deriveda $>$ \&}]{and\+\_\+visible }\end{DoxyParamCaption})}



Given a mesh, a camera determine which points are inside of a given 2D screen space polygon {\bfseries{culling points based on self-\/occlusion. }}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em tree} & precomputed bounding volume heirarchy \\
\hline
\mbox{\texttt{ in}}  & {\em model} & 4 by 4 camera model-\/view matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & 4 by 4 camera projection matrix (perspective or orthoraphic) \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & 4-\/vector containing camera viewport \\
\hline
\mbox{\texttt{ in}}  & {\em L} & \#L by 2 list of 2D polygon vertices (in order) \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by 1 list of winding numbers (\texorpdfstring{$\vert$}{|}\+W\texorpdfstring{$\vert$}{|}\texorpdfstring{$>$}{>}0.\+5 indicates inside) \\
\hline
\mbox{\texttt{ out}}  & {\em and\+\_\+visible} & \#V by 1 list of visibility values (only correct for vertices with \texorpdfstring{$\vert$}{|}\+W\texorpdfstring{$\vert$}{|}\texorpdfstring{$>$}{>}0.\+5) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa76ba56f1ce1b064b681b9c9d1a258bf}\label{namespaceigl_aa76ba56f1ce1b064b681b9c9d1a258bf} 
\index{igl@{igl}!screen\_space\_selection@{screen\_space\_selection}}
\index{screen\_space\_selection@{screen\_space\_selection}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{screen\_space\_selection()}{screen\_space\_selection()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW $>$ \\
void igl\+::screen\+\_\+space\+\_\+selection (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&}]{viewport,  }\item[{const std\+::vector$<$ Eigen\+::\+Matrix$<$ Ltype, 1, 2 $>$ $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Given a mesh, a camera determine which points are inside of a given 2D screen space polygon. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em model} & 4 by 4 camera model-\/view matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & 4 by 4 camera projection matrix (perspective or orthoraphic) \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & 4-\/vector containing camera viewport \\
\hline
\mbox{\texttt{ in}}  & {\em L} & \#L by 2 list of 2D polygon vertices (in order) \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by 1 list of winding numbers (\texorpdfstring{$\vert$}{|}\+W\texorpdfstring{$\vert$}{|}\texorpdfstring{$>$}{>}0.\+5 indicates inside) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad310e7bb193a3ef3e6b0de1b5598799b}\label{namespaceigl_ad310e7bb193a3ef3e6b0de1b5598799b} 
\index{igl@{igl}!screen\_space\_selection@{screen\_space\_selection}}
\index{screen\_space\_selection@{screen\_space\_selection}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{screen\_space\_selection()}{screen\_space\_selection()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP , typename DerivedE , typename DerivedW $>$ \\
void igl\+::screen\+\_\+space\+\_\+selection (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&}]{viewport,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Given a mesh, a camera determine which points are inside of a given 2D screen space polygon. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em model} & 4 by 4 camera model-\/view matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & 4 by 4 camera projection matrix (perspective or orthoraphic) \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & 4-\/vector containing camera viewport \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 2 list of screen space polygon vertices \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of screen space edges as indices into rows of P \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#V by 1 list of winding numbers (\texorpdfstring{$\vert$}{|}\+W\texorpdfstring{$\vert$}{|}\texorpdfstring{$>$}{>}0.\+5 indicates inside) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac159f8e26c3ca48a403dd1f27d3fd645}\label{namespaceigl_ac159f8e26c3ca48a403dd1f27d3fd645} 
\index{igl@{igl}!seam\_edges@{seam\_edges}}
\index{seam\_edges@{seam\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{seam\_edges()}{seam\_edges()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+TC , typename DerivedF , typename Derived\+FTC , typename Derivedseams , typename Derivedboundaries , typename Derivedfoldovers $>$ \\
void igl\+::seam\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TC $>$ \&}]{TC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FTC $>$ \&}]{FTC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedseams $>$ \&}]{seams,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedboundaries $>$ \&}]{boundaries,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedfoldovers $>$ \&}]{foldovers }\end{DoxyParamCaption})}



Finds all UV-\/space boundaries of a mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of positions of the input mesh. \\
\hline
\mbox{\texttt{ in}}  & {\em TC} & \#\+TC by 2 list of 2D texture coordinates of the input mesh \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triange indices into V representing a manifold-\/with-\/boundary triangle mesh \\
\hline
\mbox{\texttt{ in}}  & {\em FTC} & \#F by 3 list of indices into TC for each corner \\
\hline
\mbox{\texttt{ out}}  & {\em seams} & Edges where the forwards and backwards directions have different texture coordinates, as a \#seams-\/by-\/4 matrix of indices. Each row is organized as \mbox{[} forward\+\_\+face\+\_\+index, forward\+\_\+face\+\_\+vertex\+\_\+index, backwards\+\_\+face\+\_\+index, backwards\+\_\+face\+\_\+vertex\+\_\+index \mbox{]} such that one side of the seam is the edge\+: F\mbox{[} seams( i, 0 ), seams( i, 1 ) \mbox{]}, F\mbox{[} seams( i, 0 ), (seams( i, 1 ) + 1) \% 3 \mbox{]} and the other side is the edge\+: F\mbox{[} seams( i, 2 ), seams( i, 3 ) \mbox{]}, F\mbox{[} seams( i, 2 ), (seams( i, 3 ) + 1) \% 3 \mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em boundaries} & Edges with only one incident triangle, as a \#boundaries-\/by-\/2 matrix of indices. Each row is organized as \mbox{[} face\+\_\+index, face\+\_\+vertex\+\_\+index \mbox{]} such that the edge is\+: F\mbox{[} boundaries( i, 0 ), boundaries( i, 1 ) \mbox{]}, F\mbox{[} boundaries( i, 0 ), (boundaries( i, 1 ) + 1) \% 3 \mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em foldovers} & Edges where the two incident triangles fold over each other in UV-\/space, as a \#foldovers-\/by-\/4 matrix of indices. Each row is organized as \mbox{[} forward\+\_\+face\+\_\+index, forward\+\_\+face\+\_\+vertex\+\_\+index, backwards\+\_\+face\+\_\+index, backwards\+\_\+face\+\_\+vertex\+\_\+index \mbox{]} such that one side of the foldover is the edge\+: F\mbox{[} foldovers( i, 0 ), foldovers( i, 1 ) \mbox{]}, F\mbox{[} foldovers( i, 0 ), (foldovers( i, 1 ) + 1) \% 3 \mbox{]} and the other side is the edge\+: F\mbox{[} foldovers( i, 2 ), foldovers( i, 3 ) \mbox{]}, F\mbox{[} foldovers( i, 2 ), (foldovers( i, 3 ) + 1) \% 3 \mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab4c9b0f32a7605d9de8575ba478e0817}\label{namespaceigl_ab4c9b0f32a7605d9de8575ba478e0817} 
\index{igl@{igl}!segment\_segment\_intersect@{segment\_segment\_intersect}}
\index{segment\_segment\_intersect@{segment\_segment\_intersect}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{segment\_segment\_intersect()}{segment\_segment\_intersect()}}
{\footnotesize\ttfamily template$<$typename Derived\+Source , typename Derived\+Dir $>$ \\
bool igl\+::segment\+\_\+segment\+\_\+intersect (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Source $>$ \&}]{p,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Dir $>$ \&}]{r,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Source $>$ \&}]{q,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Dir $>$ \&}]{s,  }\item[{double \&}]{t,  }\item[{double \&}]{u,  }\item[{double}]{eps = {\ttfamily 1e-\/6} }\end{DoxyParamCaption})}



Determine whether two line segments A,B intersect. 

A\+: p + t\texorpdfstring{$\ast$}{*}r \+: t \textbackslash{}in \mbox{[}0,1\mbox{]} B\+: q + u\texorpdfstring{$\ast$}{*}s \+: u \textbackslash{}in \mbox{[}0,1\mbox{]}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em p} & 3-\/vector origin of segment A \\
\hline
\mbox{\texttt{ in}}  & {\em r} & 3-\/vector direction of segment A \\
\hline
\mbox{\texttt{ in}}  & {\em q} & 3-\/vector origin of segment B \\
\hline
\mbox{\texttt{ in}}  & {\em s} & 3-\/vector direction of segment B \\
\hline
\mbox{\texttt{ out}}  & {\em t} & scalar point of intersection along segment A, t \textbackslash{}in \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ out}}  & {\em u} & scalar point of intersection along segment B, u \textbackslash{}in \mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em eps} & precision \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if intersection 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a212b29890b63152674a53444a2003677}\label{namespaceigl_a212b29890b63152674a53444a2003677} 
\index{igl@{igl}!serialize@{serialize}}
\index{serialize@{serialize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::serialize (\begin{DoxyParamCaption}\item[{const T \&}]{obj,  }\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_ab2bd82ed66c652d0930f6b460886010b}\label{namespaceigl_ab2bd82ed66c652d0930f6b460886010b} 
\index{igl@{igl}!serialize@{serialize}}
\index{serialize@{serialize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::serialize (\begin{DoxyParamCaption}\item[{const T \&}]{obj,  }\item[{const std\+::string \&}]{object\+Name,  }\item[{const std\+::string \&}]{filename,  }\item[{bool}]{overwrite = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_af1e1aa7b19e544f9f8d0e5d2872c1b21}\label{namespaceigl_af1e1aa7b19e544f9f8d0e5d2872c1b21} 
\index{igl@{igl}!serialize@{serialize}}
\index{serialize@{serialize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{serialize()}{serialize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::serialize (\begin{DoxyParamCaption}\item[{const T \&}]{obj,  }\item[{const std\+::string \&}]{object\+Name,  }\item[{std\+::vector$<$ char $>$ \&}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_a61617b81f6b89d6692a31f8d34c6d294}\label{namespaceigl_a61617b81f6b89d6692a31f8d34c6d294} 
\index{igl@{igl}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::deserialize (\begin{DoxyParamCaption}\item[{T \&}]{obj,  }\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_aa8dfda78a1c420b40f80b07d1c3f8b2e}\label{namespaceigl_aa8dfda78a1c420b40f80b07d1c3f8b2e} 
\index{igl@{igl}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::deserialize (\begin{DoxyParamCaption}\item[{T \&}]{obj,  }\item[{const std\+::string \&}]{object\+Name,  }\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_a5dd8043bf43851bafaa6e264162eefce}\label{namespaceigl_a5dd8043bf43851bafaa6e264162eefce} 
\index{igl@{igl}!deserialize@{deserialize}}
\index{deserialize@{deserialize}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{deserialize()}{deserialize()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::deserialize (\begin{DoxyParamCaption}\item[{T \&}]{obj,  }\item[{const std\+::string \&}]{object\+Name,  }\item[{const std\+::vector$<$ char $>$ \&}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_ad1b7a7a566f0d4a5553987d4d25aedec}\label{namespaceigl_ad1b7a7a566f0d4a5553987d4d25aedec} 
\index{igl@{igl}!serializer@{serializer}}
\index{serializer@{serializer}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{serializer()}{serializer()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::serializer (\begin{DoxyParamCaption}\item[{bool}]{serialize,  }\item[{T \&}]{obj,  }\item[{const std\+::string \&}]{filename }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_a8dba28198b48a2a0432d5c4e640484e4}\label{namespaceigl_a8dba28198b48a2a0432d5c4e640484e4} 
\index{igl@{igl}!serializer@{serializer}}
\index{serializer@{serializer}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{serializer()}{serializer()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::serializer (\begin{DoxyParamCaption}\item[{bool}]{serialize,  }\item[{T \&}]{obj,  }\item[{const std\+::string \&}]{object\+Name,  }\item[{const std\+::string \&}]{filename,  }\item[{bool}]{overwrite = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_af28b32c6f34213f61257beff8a2927ca}\label{namespaceigl_af28b32c6f34213f61257beff8a2927ca} 
\index{igl@{igl}!serializer@{serializer}}
\index{serializer@{serializer}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{serializer()}{serializer()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool igl\+::serializer (\begin{DoxyParamCaption}\item[{bool}]{serialize,  }\item[{T \&}]{obj,  }\item[{const std\+::string \&}]{object\+Name,  }\item[{std\+::vector$<$ char $>$ \&}]{buffer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{namespaceigl_ad9fa51487804e5c3f67e72d4ff8fceb1}\label{namespaceigl_ad9fa51487804e5c3f67e72d4ff8fceb1} 
\index{igl@{igl}!setdiff@{setdiff}}
\index{setdiff@{setdiff}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{setdiff()}{setdiff()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename Derived\+IA $>$ \\
void igl\+::setdiff (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA }\end{DoxyParamCaption})}



Set difference of elements of matrices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m-\/long vector of indices \\
\hline
\mbox{\texttt{ in}}  & {\em B} & n-\/long vector of indices \\
\hline
\mbox{\texttt{ out}}  & {\em C} & (k\texorpdfstring{$<$}{<}=m)-\/long vector of unique elements appearing in A but not in B \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & (k\texorpdfstring{$<$}{<}=m)-\/long list of indices into A so that C = A(\+IA) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a925a8ea3a2337a70f7cadc603e7e741e}\label{namespaceigl_a925a8ea3a2337a70f7cadc603e7e741e} 
\index{igl@{igl}!setunion@{setunion}}
\index{setunion@{setunion}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{setunion()}{setunion()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename Derived\+IA , typename Derived\+IB $>$ \\
void igl\+::setunion (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IB $>$ \&}]{IB }\end{DoxyParamCaption})}



Union of elements of matrices (like matlab\textquotesingle{}s {\ttfamily union}) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m-\/long vector of indices \\
\hline
\mbox{\texttt{ in}}  & {\em B} & n-\/long vector of indices \\
\hline
\mbox{\texttt{ out}}  & {\em C} & (k\texorpdfstring{$>$}{>}=m)-\/long vector of unique elements appearing in A and/or B \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & ($<$k$>$=m)-\/long list of indices into A so that C = sort(\mbox{[}A(\+IA);B(\+IB)\mbox{]}) \\
\hline
\mbox{\texttt{ out}}  & {\em IB} & ($<$k$>$=m)-\/long list of indices into B so that C = sort(\mbox{[}A(\+IA);B(\+IB)\mbox{]}) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9bbf23ea4d8a5f3ef6ce4117496fb037}\label{namespaceigl_a9bbf23ea4d8a5f3ef6ce4117496fb037} 
\index{igl@{igl}!setxor@{setxor}}
\index{setxor@{setxor}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{setxor()}{setxor()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename Derived\+IA , typename Derived\+IB $>$ \\
void igl\+::setxor (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IB $>$ \&}]{IB }\end{DoxyParamCaption})}



Set xor of elements of matrices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m-\/long vector of indices \\
\hline
\mbox{\texttt{ in}}  & {\em B} & n-\/long vector of indices \\
\hline
\mbox{\texttt{ out}}  & {\em C} & (k\texorpdfstring{$<$}{<}=m)-\/long vector of unique elements appearing in A but not in B or B but not in A \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & (\texorpdfstring{$<$}{<}k\texorpdfstring{$<$}{<}=m)-\/long list of indices into A so that C = sort(\mbox{[}A(\+IA);B(\+IB)\mbox{]}) \\
\hline
\mbox{\texttt{ out}}  & {\em IB} & (\texorpdfstring{$<$}{<}k\texorpdfstring{$<$}{<}=m)-\/long list of indices into B so that C = sort(\mbox{[}A(\+IA);B(\+IB)\mbox{]}) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3df5a621d40fe169f2138e39b8b81fec}\label{namespaceigl_a3df5a621d40fe169f2138e39b8b81fec} 
\index{igl@{igl}!shape\_diameter\_function@{shape\_diameter\_function}}
\index{shape\_diameter\_function@{shape\_diameter\_function}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shape\_diameter\_function()}{shape\_diameter\_function()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedN , typename DerivedS $>$ \\
void igl\+::shape\+\_\+diameter\+\_\+function (\begin{DoxyParamCaption}\item[{const std\+::function$<$ double(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&) $>$ \&}]{shoot\+\_\+ray,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Compute shape diamater function per given point. 

In the parlence of the paper "{}\+Consistent Mesh Partitioning and Skeletonisation using the Shape \+Diameter Function"{} \mbox{[}Shapiro et al. 2008\mbox{]}, this implementation uses a 180 cone and a {\itshape uniform} average ({\itshape not} a average weighted by inverse angles).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em shoot\+\_\+ray} & function handle that outputs hits of a given ray against a mesh (embedded in function handles as captured variable/data) \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of origin points \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#P by 3 list of origin normals \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of shape diamater function values between bounding box \\
\hline
\mbox{\texttt{ out}}  & {\em diagonal} & (perfect sphere) and 0 (perfect needle hook) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a982784dfbf6aae442c5e9b0bc3fdcb53}\label{namespaceigl_a982784dfbf6aae442c5e9b0bc3fdcb53} 
\index{igl@{igl}!shape\_diameter\_function@{shape\_diameter\_function}}
\index{shape\_diameter\_function@{shape\_diameter\_function}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shape\_diameter\_function()}{shape\_diameter\_function()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ \\
void igl\+::shape\+\_\+diameter\+\_\+function (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{igl\+::\+AABB}}$<$ DerivedV, DIM $>$ \&}]{aabb,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em \doxylink{classigl_1_1AABB}{AABB}} & axis-\/aligned bounding box hierarchy around (V,F) \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh face indices into V \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a46e0193f9523e75a450e14e3cf8179fd}\label{namespaceigl_a46e0193f9523e75a450e14e3cf8179fd} 
\index{igl@{igl}!shape\_diameter\_function@{shape\_diameter\_function}}
\index{shape\_diameter\_function@{shape\_diameter\_function}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shape\_diameter\_function()}{shape\_diameter\_function()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS $>$ \\
void igl\+::shape\+\_\+diameter\+\_\+function (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a725c756cdeba9b4dbc64ab4a50c50cfa}\label{namespaceigl_a725c756cdeba9b4dbc64ab4a50c50cfa} 
\index{igl@{igl}!shape\_diameter\_function@{shape\_diameter\_function}}
\index{shape\_diameter\_function@{shape\_diameter\_function}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shape\_diameter\_function()}{shape\_diameter\_function()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedS $>$ \\
void igl\+::shape\+\_\+diameter\+\_\+function (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const bool}]{per\+\_\+face,  }\item[{const int}]{num\+\_\+samples,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em per\+\_\+face} & whether to compute per face (S is \#F by 1) or per vertex (S is \#V by 1) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5df9db393a5b6b3865e7a10d9d02a31b}\label{namespaceigl_a5df9db393a5b6b3865e7a10d9d02a31b} 
\index{igl@{igl}!shapeup\_identity\_projection@{shapeup\_identity\_projection}}
\index{shapeup\_identity\_projection@{shapeup\_identity\_projection}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shapeup\_identity\_projection()}{shapeup\_identity\_projection()}}
{\footnotesize\ttfamily bool igl\+::shapeup\+\_\+identity\+\_\+projection (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Vector\+Xi $>$ \&}]{SC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xi $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{projP }\end{DoxyParamCaption})}



This projection does nothing but render points into projP. 

Mostly used for "{}echoing"{} the global step


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 set of points, either the initial solution, or from previous iteration. \\
\hline
\mbox{\texttt{ in}}  & {\em SC} & \#\+Set by 1 cardinalities of sets in S \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#\+Sets by max(\+SC) independent sets where the local projection applies. Values beyond column SC(i)-\/1 in row S(i,\+:) are "{}don\textquotesingle{}t care"{} \\
\hline
\mbox{\texttt{ out}}  & {\em projP} & \#S by 3\texorpdfstring{$\ast$}{*}max(SC) in format xyzxyzxyz, where the projected points correspond to each set in S in the same order. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return value appears to be ignored
\end{DoxyReturn}
\doxylink{shapeup_8h}{include/igl/shapeup.\+h} \Hypertarget{namespaceigl_aaced06a2a1f184dc5bfe8ff1b87d6d0d}\label{namespaceigl_aaced06a2a1f184dc5bfe8ff1b87d6d0d} 
\index{igl@{igl}!shapeup\_regular\_face\_projection@{shapeup\_regular\_face\_projection}}
\index{shapeup\_regular\_face\_projection@{shapeup\_regular\_face\_projection}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shapeup\_regular\_face\_projection()}{shapeup\_regular\_face\_projection()}}
{\footnotesize\ttfamily bool igl\+::shapeup\+\_\+regular\+\_\+face\+\_\+projection (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Vector\+Xi $>$ \&}]{SC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xi $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{projP }\end{DoxyParamCaption})}



the projection assumes that the sets are vertices of polygons in cyclic order 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 set of points, either the initial solution, or from previous iteration. \\
\hline
\mbox{\texttt{ in}}  & {\em SC} & \#\+Set by 1 cardinalities of sets in S \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#\+Sets by max(\+SC) independent sets where the local projection applies. Values beyond column SC(i)-\/1 in row S(i,\+:) are "{}don\textquotesingle{}t care"{} \\
\hline
\mbox{\texttt{ out}}  & {\em projP} & \#S by 3\texorpdfstring{$\ast$}{*}max(SC) in format xyzxyzxyz, where the projected points correspond to each set in S in the same order. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Return value appears to be ignored
\end{DoxyReturn}
\doxylink{shapeup_8h}{include/igl/shapeup.\+h} \Hypertarget{namespaceigl_ad94a2c7d2cbbaf046ff244daa6620895}\label{namespaceigl_ad94a2c7d2cbbaf046ff244daa6620895} 
\index{igl@{igl}!shapeup\_precomputation@{shapeup\_precomputation}}
\index{shapeup\_precomputation@{shapeup\_precomputation}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shapeup\_precomputation()}{shapeup\_precomputation()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename Derived\+SC , typename DerivedS , typename Derivedw $>$ \\
bool igl\+::shapeup\+\_\+precomputation (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SC $>$ \&}]{SC,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{E,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SC $>$ \&}]{b,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedw $>$ \&}]{w\+Shape,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derivedw $>$ \&}]{w\+Smooth,  }\item[{\mbox{\hyperlink{structigl_1_1ShapeupData}{Shapeup\+Data}} \&}]{sudata }\end{DoxyParamCaption})}



This function precomputation the necessary matrices for the Shape\+Up process, and prefactorizes them. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 point positions \\
\hline
\mbox{\texttt{ in}}  & {\em SC} & \#\+Set by 1 cardinalities of sets in S \\
\hline
\mbox{\texttt{ in}}  & {\em S} & \#\+Sets by max(\+SC) independent sets where the local projection applies. Values beyond column SC(i)-\/1 in row S(i,\+:) are "{}don\textquotesingle{}t care"{} \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 the "{}edges"{} of the set P; used for the smoothness energy. \\
\hline
\mbox{\texttt{ in}}  & {\em b} & \#b by 1 boundary (fixed) vertices from P. \\
\hline
\mbox{\texttt{ in}}  & {\em w\+Shape} & \#\+Set by 1 \\
\hline
\mbox{\texttt{ in}}  & {\em w\+Smooth} & \#b by 1 weights for constraints from S and positional constraints (used in the global step) \\
\hline
\mbox{\texttt{ out}}  & {\em sudata} & struct \doxylink{structigl_1_1ShapeupData}{Shapeup\+Data} the data necessary to solve the system in shapeup\+\_\+solve \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if precomputation was successful, false otherwise
\end{DoxyReturn}
\doxylink{shapeup_8h}{include/igl/shapeup.\+h} \Hypertarget{namespaceigl_a9b6baf02654fad9293e1560d71475185}\label{namespaceigl_a9b6baf02654fad9293e1560d71475185} 
\index{igl@{igl}!shapeup\_solve@{shapeup\_solve}}
\index{shapeup\_solve@{shapeup\_solve}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shapeup\_solve()}{shapeup\_solve()}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename Derived\+SC , typename DerivedS $>$ \\
bool igl\+::shapeup\+\_\+solve (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{bc,  }\item[{const std\+::function$<$ bool(const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&, const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SC $>$ \&, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&, Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&)$>$ \&}]{local\+\_\+projection,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P0,  }\item[{const \mbox{\hyperlink{structigl_1_1ShapeupData}{Shapeup\+Data}} \&}]{sudata,  }\item[{const bool}]{quiet\+Iterations,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



This function solve the shapeup project optimization. 

shapeup\+\_\+precompute must be called before with the same sudata, or results are unpredictable


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em bc} & \#b by 3 fixed point values corresonding to "{}b"{} in sudata \\
\hline
\mbox{\texttt{ in}}  & {\em local\+\_\+projection} & function pointer taking (P,SC,S,projP), where the first three parameters are as defined, and "{}proj\+P"{} is the output, as a \#S by 3\texorpdfstring{$\ast$}{*}max(SC) function in format xyzxyzxyz, and where it returns the projected points corresponding to each set in S in the same order. NOTE\+: the input values in P0 don\textquotesingle{}t need to correspond to prescribed values in bc; the iterations will project them automatically (by design). \\
\hline
\mbox{\texttt{ in}}  & {\em P0} & \#P by 3 initial solution (point positions) \\
\hline
\mbox{\texttt{ in}}  & {\em sudata} & the Shape\+Up\+Data structure computed in \doxylink{namespaceigl_ad94a2c7d2cbbaf046ff244daa6620895}{shapeup\+\_\+precomputation()} \\
\hline
\mbox{\texttt{ in}}  & {\em quiet\+Iterations} & flagging if to output iteration information. \\
\hline
\mbox{\texttt{ out}}  & {\em P} & the solution to the problem, indices corresponding to P0. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the solver converged, false otherwise.
\end{DoxyReturn}
\doxylink{shapeup_8h}{include/igl/shapeup.\+h} \Hypertarget{namespaceigl_a0b1cfc3d745b201faa8129b75d5a3b79}\label{namespaceigl_a0b1cfc3d745b201faa8129b75d5a3b79} 
\index{igl@{igl}!sharp\_edges@{sharp\_edges}}
\index{sharp\_edges@{sharp\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sharp\_edges()}{sharp\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+SE , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+Etype , typename sharptype $>$ \\
void igl\+::sharp\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+V\+::\+Scalar}]{angle,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SE $>$ \&}]{SE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+Etype $>$ $>$ \&}]{u\+E2E,  }\item[{std\+::vector$<$ sharptype $>$ \&}]{sharp }\end{DoxyParamCaption})}



Given a mesh, compute sharp edges. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle mesh indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em angle} & dihedral angle considered to sharp (e.\+g., \doxylink{namespaceigl_af3c65fcb2a063b19e572a9d982b5dcdc}{igl\+::\+PI} \texorpdfstring{$\ast$}{*} 0.\+11) \\
\hline
\mbox{\texttt{ out}}  & {\em SE} & \#\+SE by 2 list of edge indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em uE} & \#uE by 2 list of unique undirected edges \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+\#F\texorpdfstring{$\ast$}{*}c)) is the unique edge corresponding to E.\+row(f+\#F\texorpdfstring{$\ast$}{*}c) \\
\hline
\mbox{\texttt{ out}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges, so that E.\+row(u\+E2\+E\mbox{[}i\mbox{]}\mbox{[}j\mbox{]}) corresponds to u\+E.\+row(i) for all j in 0..u\+E2E\mbox{[}i\mbox{]}.size()-\/1. \\
\hline
\mbox{\texttt{ out}}  & {\em sharp} & \#\+SE list of indices into uE revealing sharp undirected edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a7002429ac13c0e1d678e1e9d9aea99d8}\label{namespaceigl_a7002429ac13c0e1d678e1e9d9aea99d8} 
\index{igl@{igl}!sharp\_edges@{sharp\_edges}}
\index{sharp\_edges@{sharp\_edges}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sharp\_edges()}{sharp\_edges()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+SE $>$ \\
void igl\+::sharp\+\_\+edges (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const typename Derived\+V\+::\+Scalar}]{angle,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SE $>$ \&}]{SE }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a571aed34e627db21360984824ccc7838}\label{namespaceigl_a571aed34e627db21360984824ccc7838} 
\index{igl@{igl}!shortest\_edge\_and\_midpoint@{shortest\_edge\_and\_midpoint}}
\index{shortest\_edge\_and\_midpoint@{shortest\_edge\_and\_midpoint}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{shortest\_edge\_and\_midpoint()}{shortest\_edge\_and\_midpoint()}}
{\footnotesize\ttfamily void igl\+::shortest\+\_\+edge\+\_\+and\+\_\+midpoint (\begin{DoxyParamCaption}\item[{const int}]{e,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{E,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{,  }\item[{double \&}]{cost,  }\item[{Eigen\+::\+Row\+Vector\+Xd \&}]{p }\end{DoxyParamCaption})}



Cost and placement function compatible with \doxylink{namespaceigl_a48e2a2c1ae537d160f7767a230be66b3}{igl\+::decimate}. 

The cost of collapsing an edge is its length (prefer to collapse short edges) and the placement strategy for the new vertex is the midpoint of the collapsed edge.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em e} & index into E of edge to be considered for collapse \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of faces (ignored) \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \#E by 2 list of edge indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of half-\/edges indices into E (ignored) \\
\hline
\mbox{\texttt{ in}}  & {\em EF} & \#E by 2 list of edge-\/face flaps into F (ignored) \\
\hline
\mbox{\texttt{ in}}  & {\em EI} & \#E by 2 list of edge-\/face opposite corners (ignored) \\
\hline
\mbox{\texttt{ out}}  & {\em cost} & set to edge length \\
\hline
\mbox{\texttt{ out}}  & {\em p} & placed point set to edge midpoint \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a78da3ad1832aa83542b3dc3a28e1a8e1}\label{namespaceigl_a78da3ad1832aa83542b3dc3a28e1a8e1} 
\index{igl@{igl}!signed\_angle@{signed\_angle}}
\index{signed\_angle@{signed\_angle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_angle()}{signed\_angle()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedP $>$ \\
Derived\+A\+::\+Scalar igl\+::signed\+\_\+angle (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Compute the signed angle subtended by the oriented 3d triangle (A,B,C) at some point P. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 2D position of corner \\
\hline
\mbox{\texttt{ in}}  & {\em B} & 2D position of corner \\
\hline
\mbox{\texttt{ in}}  & {\em P} & 2D position of query point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
signed angle 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a094f93a7b569504f70587f81f75fd879}\label{namespaceigl_a094f93a7b569504f70587f81f75fd879} 
\index{igl@{igl}!signed\_distance@{signed\_distance}}
\index{signed\_distance@{signed\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance()}{signed\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN $>$ \\
void igl\+::signed\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}}}]{sign\+\_\+type,  }\item[{const typename Derived\+V\+::\+Scalar}]{lower\+\_\+bound,  }\item[{const typename Derived\+V\+::\+Scalar}]{upper\+\_\+bound,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



Computes signed distance to a mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by (2\texorpdfstring{$\vert$}{|}3) list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by (2\texorpdfstring{$\vert$}{|}3) list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by ss list of triangle indices, ss should be 3 unless sign\+\_\+type == SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+UNSIGNED \texorpdfstring{$\vert$}{|} SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+WINDING\+\_\+\+NUMBER \\
\hline
\mbox{\texttt{ in}}  & {\em sign\+\_\+type} & method for computing distance {\itshape sign} S \\
\hline
\mbox{\texttt{ in}}  & {\em lower\+\_\+bound} & lower bound of distances needed \{std\+::numeric\+\_\+limits\+::min\} \\
\hline
\mbox{\texttt{ in}}  & {\em upper\+\_\+bound} & lower bound of distances needed \{std\+::numeric\+\_\+limits\+::max\} \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of smallest signed distances \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#P list of facet indices corresponding to smallest distances \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#P by (2\texorpdfstring{$\vert$}{|}3) list of closest points \\
\hline
\mbox{\texttt{ out}}  & {\em N} & \#P by (2\texorpdfstring{$\vert$}{|}3) list of closest normals (only set if sign\+\_\+type=SIGNED\+\_\+\+DISTANCE\+\_\+\+TYPE\+\_\+\+PSEUDONORMAL)\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a9379f935afc42d6fbad6340c07639c54}\label{namespaceigl_a9379f935afc42d6fbad6340c07639c54} 
\index{igl@{igl}!signed\_distance@{signed\_distance}}
\index{signed\_distance@{signed\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance()}{signed\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN $>$ \\
void igl\+::signed\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{namespaceigl_a92ae0e8cefa226a1e493b33684b0b02e}{Signed\+Distance\+Type}}}]{sign\+\_\+type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a102279423d1d1b649cdf6a74558883dc}\label{namespaceigl_a102279423d1d1b649cdf6a74558883dc} 
\index{igl@{igl}!signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}}
\index{signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_pseudonormal()}{signed\_distance\_pseudonormal()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename Derivedq $>$ \\
Derived\+V\+::\+Scalar igl\+::signed\+\_\+distance\+\_\+pseudonormal (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&}]{VN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&}]{EN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q }\end{DoxyParamCaption})}



Computes signed distance to mesh using pseudonormal with precomputed \doxylink{classigl_1_1AABB}{AABB} tree and edge/vertice normals. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tree} & \doxylink{classigl_1_1AABB}{AABB} acceleration tree (see \doxylink{AABB_8h}{AABB.\+h}) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3 list of triangle normals \\
\hline
\mbox{\texttt{ in}}  & {\em VN} & \#V by 3 list of vertex normals (ANGLE WEIGHTING) \\
\hline
\mbox{\texttt{ in}}  & {\em EN} & \#E by 3 list of edge normals (UNIFORM WEIGHTING) \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 mapping edges in F to E \\
\hline
\mbox{\texttt{ in}}  & {\em q} & Query point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
signed distance to mesh
\end{DoxyReturn}
\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h} \Hypertarget{namespaceigl_aead78bb0215bc26bdb1dafabc8366acd}\label{namespaceigl_aead78bb0215bc26bdb1dafabc8366acd} 
\index{igl@{igl}!signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}}
\index{signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_pseudonormal()}{signed\_distance\_pseudonormal()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN $>$ \\
void igl\+::signed\+\_\+distance\+\_\+pseudonormal (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&}]{VN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&}]{EN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedN $>$ \&}]{N }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h}. 

\Hypertarget{namespaceigl_a391b1e9f4f4bc678fac2b8c522ce4331}\label{namespaceigl_a391b1e9f4f4bc678fac2b8c522ce4331} 
\index{igl@{igl}!signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}}
\index{signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_pseudonormal()}{signed\_distance\_pseudonormal()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+FN , typename Derived\+VN , typename Derived\+EN , typename Derived\+EMAP , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn $>$ \\
void igl\+::signed\+\_\+distance\+\_\+pseudonormal (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&}]{VN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&}]{EN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{Scalar \&}]{s,  }\item[{Scalar \&}]{sqrd,  }\item[{int \&}]{i,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&}]{n }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em s} & sign \\
\hline
\mbox{\texttt{ out}}  & {\em sqrd} & squared distance \\
\hline
\mbox{\texttt{ out}}  & {\em i} & closest primitive \\
\hline
\mbox{\texttt{ out}}  & {\em c} & closest point \\
\hline
\mbox{\texttt{ out}}  & {\em n} & normal\\
\hline
\end{DoxyParams}
\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h} \Hypertarget{namespaceigl_a5011d0263ec9b3347530d3d807596671}\label{namespaceigl_a5011d0263ec9b3347530d3d807596671} 
\index{igl@{igl}!signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}}
\index{signed\_distance\_pseudonormal@{signed\_distance\_pseudonormal}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_pseudonormal()}{signed\_distance\_pseudonormal()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedE , typename Derived\+EN , typename Derived\+VN , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn $>$ \\
void igl\+::signed\+\_\+distance\+\_\+pseudonormal (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 2 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EN $>$ \&}]{EN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VN $>$ \&}]{VN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{Scalar \&}]{s,  }\item[{Scalar \&}]{sqrd,  }\item[{int \&}]{i,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedn $>$ \&}]{n }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a75576a9807c547b55f797639412650d6}\label{namespaceigl_a75576a9807c547b55f797639412650d6} 
\index{igl@{igl}!signed\_distance\_winding\_number@{signed\_distance\_winding\_number}}
\index{signed\_distance\_winding\_number@{signed\_distance\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_winding\_number()}{signed\_distance\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedq $>$ \\
Derived\+V\+::\+Scalar igl\+::signed\+\_\+distance\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{classigl_1_1WindingNumberAABB}{igl\+::\+Winding\+Number\+AABB}}$<$ Derivedq, DerivedV, DerivedF $>$ \&}]{hier,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q }\end{DoxyParamCaption})}



Computes signed distance to mesh using winding number with precomputed \doxylink{classigl_1_1AABB}{AABB}. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tree} & \doxylink{classigl_1_1AABB}{AABB} acceleration tree (see \doxylink{copyleft_2cgal_2point__mesh__squared__distance_8h}{cgal/point\+\_\+mesh\+\_\+squared\+\_\+distance.\+h}) \\
\hline
\mbox{\texttt{ in}}  & {\em hier} & Winding number evaluation hierarchy \\
\hline
\mbox{\texttt{ in}}  & {\em q} & Query point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
signed distance to mesh
\end{DoxyReturn}
\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h} \Hypertarget{namespaceigl_ad184a41c6d66cebef9a4714a2d59326f}\label{namespaceigl_ad184a41c6d66cebef9a4714a2d59326f} 
\index{igl@{igl}!signed\_distance\_winding\_number@{signed\_distance\_winding\_number}}
\index{signed\_distance\_winding\_number@{signed\_distance\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_winding\_number()}{signed\_distance\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc $>$ \\
void igl\+::signed\+\_\+distance\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{classigl_1_1WindingNumberAABB}{igl\+::\+Winding\+Number\+AABB}}$<$ Derivedq, DerivedV, DerivedF $>$ \&}]{hier,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{Scalar \&}]{s,  }\item[{Scalar \&}]{sqrd,  }\item[{int \&}]{i,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em s} & sign \\
\hline
\mbox{\texttt{ out}}  & {\em sqrd} & squared distance \\
\hline
\mbox{\texttt{ out}}  & {\em pp} & closest point and primitve \doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af25f0719d3f6108b4917e1511a4941f5}\label{namespaceigl_af25f0719d3f6108b4917e1511a4941f5} 
\index{igl@{igl}!signed\_distance\_winding\_number@{signed\_distance\_winding\_number}}
\index{signed\_distance\_winding\_number@{signed\_distance\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_winding\_number()}{signed\_distance\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc $>$ \\
void igl\+::signed\+\_\+distance\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 2 $>$ \&}]{tree,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{Scalar \&}]{s,  }\item[{Scalar \&}]{sqrd,  }\item[{int \&}]{i,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedc $>$ \&}]{c }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a88918723d512e80456d10a043fa25177}\label{namespaceigl_a88918723d512e80456d10a043fa25177} 
\index{igl@{igl}!signed\_distance\_fast\_winding\_number@{signed\_distance\_fast\_winding\_number}}
\index{signed\_distance\_fast\_winding\_number@{signed\_distance\_fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_fast\_winding\_number()}{signed\_distance\_fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS $>$ \\
void igl\+::signed\+\_\+distance\+\_\+fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const igl\+::\+Fast\+Winding\+Number\+BVH \&}]{fwn\+\_\+bvh,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{S }\end{DoxyParamCaption})}



Calculates signed distance at query points P, using fast winding number for sign. 

\hypertarget{namespaceigl_autotoc_md34}{}\doxyparagraph{\texorpdfstring{Usage\+:}{Usage:}}\label{namespaceigl_autotoc_md34}
Vector\+Xd S; ~\newline
 Vector\+Xd V, P; //where V is mesh vertices, P are query points Vector\+Xi F; ~\newline
 igl\+::\+Fast\+Winding\+Number\+BVH fwn\+\_\+bvh; \doxylink{namespaceigl_af9a50987fefc0df065fb3e2cde90c92e}{igl\+::fast\+\_\+winding\+\_\+number}(V.\+cast$<$float$>$(), F, 2, fwn\+\_\+bvh); igl\+::signed\+\_\+distance\+\_\+fast\+\_\+winding\+\_\+number(\+P,\+V,\+F,tree,fwn\+\_\+bvh,\+S);


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & \#P by 3 list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle normals \\
\hline
\mbox{\texttt{ in}}  & {\em tree} & \doxylink{classigl_1_1AABB}{AABB} acceleration tree (see \doxylink{AABB_8h}{AABB.\+h}) \\
\hline
\mbox{\texttt{ in}}  & {\em bvh} & fast winding precomputation (see Fast\+\_\+\+Winding\+\_\+\+Number.\+h) ~\newline
 \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of signed distances of each point in P\\
\hline
\end{DoxyParams}
\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h} \Hypertarget{namespaceigl_a0dabf308e8466b0ec192b798fc538eb4}\label{namespaceigl_a0dabf308e8466b0ec192b798fc538eb4} 
\index{igl@{igl}!signed\_distance\_fast\_winding\_number@{signed\_distance\_fast\_winding\_number}}
\index{signed\_distance\_fast\_winding\_number@{signed\_distance\_fast\_winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{signed\_distance\_fast\_winding\_number()}{signed\_distance\_fast\_winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedq , typename DerivedV , typename DerivedF $>$ \\
Derived\+V\+::\+Scalar igl\+::signed\+\_\+distance\+\_\+fast\+\_\+winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedq $>$ \&}]{q,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const \mbox{\hyperlink{classigl_1_1AABB}{AABB}}$<$ DerivedV, 3 $>$ \&}]{tree,  }\item[{const igl\+::\+Fast\+Winding\+Number\+BVH \&}]{fwn\+\_\+bvh }\end{DoxyParamCaption})}



Calculates signed distance at query point q, using fast winding number for sign. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tree} & \doxylink{classigl_1_1AABB}{AABB} acceleration tree (see \doxylink{AABB_8h}{AABB.\+h}) \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle normals \\
\hline
\mbox{\texttt{ in}}  & {\em bvh} & fast winding precomputation (see Fast\+\_\+\+Winding\+\_\+\+Number.\+h) ~\newline
 \\
\hline
\mbox{\texttt{ in}}  & {\em q} & 1 by 3 list of query point positions \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#P list of signed distances of each point in P\\
\hline
\end{DoxyParams}
\doxylink{signed__distance_8h}{include/igl/signed\+\_\+distance.\+h} \Hypertarget{namespaceigl_a4d3b37a4f86172d30f35d330aed1e7fe}\label{namespaceigl_a4d3b37a4f86172d30f35d330aed1e7fe} 
\index{igl@{igl}!simplify\_polyhedron@{simplify\_polyhedron}}
\index{simplify\_polyhedron@{simplify\_polyhedron}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{simplify\_polyhedron()}{simplify\_polyhedron()}}
{\footnotesize\ttfamily void igl\+::simplify\+\_\+polyhedron (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{OV,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{OF,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{Eigen\+::\+Vector\+Xi \&}]{J }\end{DoxyParamCaption})}



Simplify a polyhedron represented as a triangle mesh (OV,OF) by collapsing any edge that doesn\textquotesingle{}t contribute to defining surface\textquotesingle{}s pointset. 

\begin{DoxyPrecond}{Precondition}
This {\itshape would} also make sense for open and non-\/manifold meshes, but the current implementation only works with closed manifold surfaces with well defined triangle normals.
\end{DoxyPrecond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em OV} & \#\+OV by 3 list of input mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em OF} & \#\+OF by 3 list of input mesh triangle indices into OV \\
\hline
\mbox{\texttt{ out}}  & {\em V} & \#V by 3 list of output mesh vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#F by 3 list of input mesh triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#F list of indices into OF of birth parents \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a547a8704200d3af48fe92105c15a32ad}\label{namespaceigl_a547a8704200d3af48fe92105c15a32ad} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename TX , typename TY , typename DerivedR , typename DerivedC $>$ \\
void igl\+::slice (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&}]{Y }\end{DoxyParamCaption})}



Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em R} & list of row indices \\
\hline
\mbox{\texttt{ in}}  & {\em C} & list of column indices \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & \#R by \#C matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_acb30d6061d773254628256682b88b427}{slice\+\_\+mask}, \doxylink{namespaceigl_ab893d0a94d4eb6a1c5422e7cfe368daf}{slice\+\_\+into}
\end{DoxySeeAlso}
\begin{DoxyNote}{Note}
See also Eigen\textquotesingle{}s unary\+Expr \href{https://stackoverflow.com/a/49411587/148668}{\texttt{ https\+://stackoverflow.\+com/a/49411587/148668}} 
\end{DoxyNote}
\Hypertarget{namespaceigl_ae747d042c40e074264e161b49906216d}\label{namespaceigl_ae747d042c40e074264e161b49906216d} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename MatX , typename DerivedR , typename MatY $>$ \\
void igl\+::slice (\begin{DoxyParamCaption}\item[{const MatX \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const int}]{dim,  }\item[{MatY \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper to only slice in one direction


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em dim} & dimension to slice in 1 or 2, dim=1 -\/-\/\texorpdfstring{$>$}{>} X(\+R,\+:), dim=2 -\/-\/\texorpdfstring{$>$}{>} X(\+:,\+R)\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
For now this is just a cheap wrapper. 
\end{DoxyNote}
\Hypertarget{namespaceigl_aa05264f934b9cecbac042ef69735b74b}\label{namespaceigl_aa05264f934b9cecbac042ef69735b74b} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void igl\+::slice (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{X,  }\item[{std\+::vector$<$ size\+\_\+t $>$ const \&}]{R,  }\item[{std\+::vector$<$ T $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aae8c4cf15b6f5f8cc16da9405b96be59}\label{namespaceigl_aae8c4cf15b6f5f8cc16da9405b96be59} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedR $>$ \\
void igl\+::slice (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Vector version  \Hypertarget{namespaceigl_a90268d9fb8c64692427036793191a8b7}\label{namespaceigl_a90268d9fb8c64692427036793191a8b7} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedR , typename DerivedC , typename DerivedY $>$ \\
void igl\+::slice (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

See \doxylink{slice_8h}{slice.\+h} for more details \Hypertarget{namespaceigl_a86abeffa3ef136e9e35057e526618dc8}\label{namespaceigl_a86abeffa3ef136e9e35057e526618dc8} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedR $>$ \\
DerivedX igl\+::slice (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Vector\+Xi Y = slice(\+X,\+R); This templating is bad because the return type might not have the same size as {\ttfamily DerivedX}. This will probably only work if DerivedX has Dynamic as it\textquotesingle{}s non-\/trivial sizes or if the number of rows in R happens to equal the number of rows in {\ttfamily DerivedX}. \Hypertarget{namespaceigl_aa5271870d0385781c2236145ee9c3897}\label{namespaceigl_aa5271870d0385781c2236145ee9c3897} 
\index{igl@{igl}!slice@{slice}}
\index{slice@{slice}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedR $>$ \\
DerivedX igl\+::slice (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const int}]{dim }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a473da3d5636834fa6b0510d7a2f97628}\label{namespaceigl_a473da3d5636834fa6b0510d7a2f97628} 
\index{igl@{igl}!slice\_cached\_precompute@{slice\_cached\_precompute}}
\index{slice\_cached\_precompute@{slice\_cached\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_cached\_precompute()}{slice\_cached\_precompute()}}
{\footnotesize\ttfamily template$<$typename TX , typename TY , typename DerivedI $>$ \\
void igl\+::slice\+\_\+cached\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const Eigen\+::\+Matrix$<$ int, Eigen\+::\+Dynamic, 1 $>$ \&}]{C,  }\item[{Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&}]{Y }\end{DoxyParamCaption})}



Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. 

This is a fast version of \doxylink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{igl\+::slice} that can analyze and store the sparsity structure. It is slower at the irst evaluation (slice\+\_\+cached\+\_\+precompute), but faster on the subsequent ones.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em R} & list of row indices \\
\hline
\mbox{\texttt{ in}}  & {\em C} & list of column indices \\
\hline
\mbox{\texttt{ out}}  & {\em data} & Temporary data used by slice\+\_\+cached to repeat this operation \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & \#R by \#C matrix\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md35}{}\doxyparagraph{\texorpdfstring{Example}{Example}}\label{namespaceigl_autotoc_md35}
\begin{DoxyVerb}// Construct and slice up Laplacian
SparseMatrix<double> L,L_sliced;
igl::cotmatrix(V,F,L);
// Normal igl::slice call
igl::slice(L,in,in,L_in_in);

// Fast version
static VectorXi data; // static or saved in a global state
if (data.size() == 0)
  igl::slice_cached_precompute(L,in,in,data,L_sliced);
else
  igl::slice_cached(L,data,L_sliced);
\end{DoxyVerb}
 \doxylink{slice__cached_8h}{include/igl/slice\+\_\+cached.\+h} \Hypertarget{namespaceigl_a192c36479a5f74cfc02aaddd3afa4fea}\label{namespaceigl_a192c36479a5f74cfc02aaddd3afa4fea} 
\index{igl@{igl}!slice\_cached@{slice\_cached}}
\index{slice\_cached@{slice\_cached}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_cached()}{slice\_cached()}}
{\footnotesize\ttfamily template$<$typename TX , typename TY , typename DerivedI $>$ \\
void igl\+::slice\+\_\+cached (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&}]{Y }\end{DoxyParamCaption})}



Slice X by cached C,R indices into Y. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em data} & Temporary data used by slice\+\_\+cached to repeat this operation \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & \#R by \#C matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab893d0a94d4eb6a1c5422e7cfe368daf}\label{namespaceigl_ab893d0a94d4eb6a1c5422e7cfe368daf} 
\index{igl@{igl}!slice\_into@{slice\_into}}
\index{slice\_into@{slice\_into}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_into()}{slice\_into()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , typename DerivedR , typename DerivedC $>$ \\
void igl\+::slice\+\_\+into (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{Y }\end{DoxyParamCaption})}



Act like the matlab Y(row\+\_\+indices,col\+\_\+indices) = X. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & xm by xn rhs matrix \\
\hline
\mbox{\texttt{ in}}  & {\em R} & list of row indices \\
\hline
\mbox{\texttt{ in}}  & {\em C} & list of column indices \\
\hline
\mbox{\texttt{ in}}  & {\em Y} & ym by yn lhs matrix \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & ym by yn lhs matrix, same as input but Y(\+R,\+C) = X\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{slice} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a185ee703c7cf8760af368bcb0861d37f}\label{namespaceigl_a185ee703c7cf8760af368bcb0861d37f} 
\index{igl@{igl}!slice\_into@{slice\_into}}
\index{slice\_into@{slice\_into}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_into()}{slice\_into()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename MatX , typename MatY , typename DerivedR $>$ \\
void igl\+::slice\+\_\+into (\begin{DoxyParamCaption}\item[{const MatX \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const int}]{dim,  }\item[{MatY \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper to only slice in one direction


\begin{DoxyParams}{Parameters}
{\em \mbox{[}int\mbox{]}} & dim dimension to slice in 1 or 2, dim=1 -\/-\/\texorpdfstring{$>$}{>} X(\+R,\+:), dim=2 -\/-\/\texorpdfstring{$>$}{>} X(\+:,\+R)\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
For now this is just a cheap wrapper. 
\end{DoxyNote}
\Hypertarget{namespaceigl_afce428bb768059c8d6f9563873f8e730}\label{namespaceigl_afce428bb768059c8d6f9563873f8e730} 
\index{igl@{igl}!slice\_into@{slice\_into}}
\index{slice\_into@{slice\_into}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_into()}{slice\_into()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedC $>$ \\
void igl\+::slice\+\_\+into (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

See \doxylink{slice_8h}{slice.\+h} for more details \Hypertarget{namespaceigl_aa29b762b3094e33fd5167ca196de49ce}\label{namespaceigl_aa29b762b3094e33fd5167ca196de49ce} 
\index{igl@{igl}!slice\_into@{slice\_into}}
\index{slice\_into@{slice\_into}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_into()}{slice\_into()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedR , typename DerivedY $>$ \\
void igl\+::slice\+\_\+into (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Vector version \Hypertarget{namespaceigl_acb30d6061d773254628256682b88b427}\label{namespaceigl_acb30d6061d773254628256682b88b427} 
\index{igl@{igl}!slice\_mask@{slice\_mask}}
\index{slice\_mask@{slice\_mask}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_mask()}{slice\_mask()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$typename XType , typename YType $>$ \\
void igl\+::slice\+\_\+mask (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&}]{X,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ YType $>$ \&}]{Y }\end{DoxyParamCaption})}



Act like the matlab X(row\+\_\+mask,col\+\_\+mask) operator, where row\+\_\+mask, col\+\_\+mask are non-\/negative integer indices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em R} & m list of row bools \\
\hline
\mbox{\texttt{ in}}  & {\em C} & n list of column bools \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & \#trues-\/in-\/R by \#trues-\/in-\/C matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{slice} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a6770877236349590d6b4bbc2a6f616ad}\label{namespaceigl_a6770877236349590d6b4bbc2a6f616ad} 
\index{igl@{igl}!slice\_mask@{slice\_mask}}
\index{slice\_mask@{slice\_mask}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_mask()}{slice\_mask()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$typename XType , typename YType $>$ \\
void igl\+::slice\+\_\+mask (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ XType $>$ \&}]{X,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ YType $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper to only slice in one direction


\begin{DoxyParams}{Parameters}
{\em \mbox{[}int\mbox{]}} & dim dimension to slice in 1 or 2, dim=1 -\/-\/\texorpdfstring{$>$}{>} X(\+R,\+:), dim=2 -\/-\/\texorpdfstring{$>$}{>} X(\+:,\+R) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aef569f1ee0e9cd71c2cfabd1e27e2f40}\label{namespaceigl_aef569f1ee0e9cd71c2cfabd1e27e2f40} 
\index{igl@{igl}!slice\_mask@{slice\_mask}}
\index{slice\_mask@{slice\_mask}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_mask()}{slice\_mask()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::slice\+\_\+mask (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

See \doxylink{slice_8h}{slice.\+h} for more details \Hypertarget{namespaceigl_ab448e84d310f37a2cffd09d50faad326}\label{namespaceigl_ab448e84d310f37a2cffd09d50faad326} 
\index{igl@{igl}!slice\_mask@{slice\_mask}}
\index{slice\_mask@{slice\_mask}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_mask()}{slice\_mask()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::slice\+\_\+mask (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_afe884ab3e3a80bcea135959a5b9aa831}\label{namespaceigl_afe884ab3e3a80bcea135959a5b9aa831} 
\index{igl@{igl}!slice\_mask@{slice\_mask}}
\index{slice\_mask@{slice\_mask}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_mask()}{slice\_mask()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename DerivedX $>$ \\
DerivedX igl\+::slice\+\_\+mask (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\begin{DoxyNote}{Note}
This templating is bad because the return type might not have the same size as {\ttfamily DerivedX}. This will probably only work if DerivedX has Dynamic as it\textquotesingle{}s non-\/trivial sizes or if the number of rows in R happens to equal the number of rows in {\ttfamily DerivedX}. 
\end{DoxyNote}
\Hypertarget{namespaceigl_ae4dd189219e52c3496a80f36b82cbbce}\label{namespaceigl_ae4dd189219e52c3496a80f36b82cbbce} 
\index{igl@{igl}!slice\_mask@{slice\_mask}}
\index{slice\_mask@{slice\_mask}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_mask()}{slice\_mask()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename DerivedX $>$ \\
DerivedX igl\+::slice\+\_\+mask (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const Eigen\+::\+Array$<$ bool, Eigen\+::\+Dynamic, 1 $>$ \&}]{R,  }\item[{const int}]{dim }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af8a1c0b05598d819b78e57f2525f5497}\label{namespaceigl_af8a1c0b05598d819b78e57f2525f5497} 
\index{igl@{igl}!slice\_sorted@{slice\_sorted}}
\index{slice\_sorted@{slice\_sorted}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slice\_sorted()}{slice\_sorted()}}
{\footnotesize\ttfamily template$<$typename TX , typename TY , typename DerivedR , typename DerivedC $>$ \\
void igl\+::slice\+\_\+sorted (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&}]{X,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&}]{R,  }\item[{const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&}]{Y }\end{DoxyParamCaption})}



Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. 

This version is about 2x faster than \doxylink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{igl\+::slice}, but it assumes that the indices to slice with are already sorted.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix \\
\hline
\mbox{\texttt{ in}}  & {\em R} & list of row indices \\
\hline
\mbox{\texttt{ in}}  & {\em C} & list of column indices \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & \#R by \#C matrix\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{slice} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a4b29382a965c510055a154aac6ecde4e}\label{namespaceigl_a4b29382a965c510055a154aac6ecde4e} 
\index{igl@{igl}!slim\_precompute@{slim\_precompute}}
\index{slim\_precompute@{slim\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slim\_precompute()}{slim\_precompute()}}
{\footnotesize\ttfamily void igl\+::slim\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{V\+\_\+init,  }\item[{\mbox{\hyperlink{structigl_1_1SLIMData}{SLIMData}} \&}]{data,  }\item[{\mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{Mapping\+Energy\+Type}}}]{slim\+\_\+energy,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{b,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{bc,  }\item[{double}]{soft\+\_\+p }\end{DoxyParamCaption})}



Compute necessary information to start using SLIM. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3/3 list of mesh faces (triangles/tets) \\
\hline
\mbox{\texttt{ in}}  & {\em V\+\_\+init} & \#V by 3 list of initial mesh vertex positions \\
\hline
\mbox{\texttt{ in,out}}  & {\em data} & Precomputation data structure \\
\hline
\mbox{\texttt{ in}}  & {\em slim\+\_\+energy} & Energy to minimize \\
\hline
\mbox{\texttt{ in}}  & {\em b} & list of boundary indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em bc} & \#b by dim list of boundary conditions \\
\hline
\mbox{\texttt{ in}}  & {\em soft\+\_\+p} & Soft penalty factor (can be zero)\\
\hline
\end{DoxyParams}
\doxylink{slim_8h}{include/igl/slim.\+h} \Hypertarget{namespaceigl_a5651f5d9a88f7dc131b6dd3b99f31fdf}\label{namespaceigl_a5651f5d9a88f7dc131b6dd3b99f31fdf} 
\index{igl@{igl}!slim\_solve@{slim\_solve}}
\index{slim\_solve@{slim\_solve}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slim\_solve()}{slim\_solve()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xd igl\+::slim\+\_\+solve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structigl_1_1SLIMData}{SLIMData}} \&}]{data,  }\item[{int}]{iter\+\_\+num }\end{DoxyParamCaption})}



Run iter\+\_\+num iterations of SLIM. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in,out}}  & {\em data} & Precomputation data structure \\
\hline
\mbox{\texttt{ in}}  & {\em iter\+\_\+num} & Number of iterations to run \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\#V by dim list of mesh vertex positions
\end{DoxyReturn}
\doxylink{slim_8h}{include/igl/slim.\+h} \Hypertarget{namespaceigl_a02c86d444aaf4ab498a1466a59775059}\label{namespaceigl_a02c86d444aaf4ab498a1466a59775059} 
\index{igl@{igl}!slim\_update\_weights\_and\_closest\_rotations\_with\_jacobians@{slim\_update\_weights\_and\_closest\_rotations\_with\_jacobians}}
\index{slim\_update\_weights\_and\_closest\_rotations\_with\_jacobians@{slim\_update\_weights\_and\_closest\_rotations\_with\_jacobians}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slim\_update\_weights\_and\_closest\_rotations\_with\_jacobians()}{slim\_update\_weights\_and\_closest\_rotations\_with\_jacobians()}}
{\footnotesize\ttfamily void igl\+::slim\+\_\+update\+\_\+weights\+\_\+and\+\_\+closest\+\_\+rotations\+\_\+with\+\_\+jacobians (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{Ji,  }\item[{\mbox{\hyperlink{namespaceigl_a79904ddf7fe8d79169b339cf43f9e739}{igl\+::\+Mapping\+Energy\+Type}}}]{slim\+\_\+energy,  }\item[{double}]{exp\+\_\+factor,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{Ri }\end{DoxyParamCaption})}



Internal Routine. 

Exposed for Integration with SCAF


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Ji} & ?? by ?? list of Jacobians?? \\
\hline
\mbox{\texttt{ in}}  & {\em slim\+\_\+energy} & Energy to minimize \\
\hline
\mbox{\texttt{ in}}  & {\em exp\+\_\+factor} & ??? used for exponential energies, ignored otherwise \\
\hline
\mbox{\texttt{ out}}  & {\em W} & ?? by ?? list of weights?? \\
\hline
\mbox{\texttt{ out}}  & {\em Ri} & ?? by ?? list of rotations??\\
\hline
\end{DoxyParams}
\doxylink{slim_8h}{include/igl/slim.\+h} \Hypertarget{namespaceigl_ac1a2368c134ab7daeb5cfb40b5a0e639}\label{namespaceigl_ac1a2368c134ab7daeb5cfb40b5a0e639} 
\index{igl@{igl}!slim\_buildA@{slim\_buildA}}
\index{slim\_buildA@{slim\_buildA}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{slim\_buildA()}{slim\_buildA()}}
{\footnotesize\ttfamily void igl\+::slim\+\_\+buildA (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{Dx,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{Dy,  }\item[{const Eigen\+::\+Sparse\+Matrix$<$ double $>$ \&}]{Dz,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{std\+::vector$<$ Eigen\+::\+Triplet$<$ double $>$ $>$ \&}]{IJV }\end{DoxyParamCaption})}



Undocumented function related to SLIM optimization. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em Dx} & ?? by ?? matrix to compute of x derivatives? \\
\hline
\mbox{\texttt{ in}}  & {\em Dy} & ?? by ?? matrix to compute of y derivatives? \\
\hline
\mbox{\texttt{ in}}  & {\em Dz} & ?? bz ?? matrix to compute of z derivatives? \\
\hline
\mbox{\texttt{ in}}  & {\em W} & ?? by ?? list of weights?? \\
\hline
\mbox{\texttt{ out}}  & {\em IJV} & ?? by ?? list of triplets to some A matrix?? \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aef5e220e449787733ece4abbc94f419a}\label{namespaceigl_aef5e220e449787733ece4abbc94f419a} 
\index{igl@{igl}!smooth\_corner\_adjacency@{smooth\_corner\_adjacency}}
\index{smooth\_corner\_adjacency@{smooth\_corner\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{smooth\_corner\_adjacency()}{smooth\_corner\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::smooth\+\_\+corner\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const double}]{corner\+\_\+threshold\+\_\+radians,  }\item[{Eigen\+::\+Vector\+Xi \&}]{CI,  }\item[{Eigen\+::\+Vector\+Xi \&}]{CC }\end{DoxyParamCaption})}



Determine the corner-\/to-\/face adjacency relationship that can be used for computing crease-\/aware per-\/corner normals. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle mesh indices into rows of V \\
\hline
\mbox{\texttt{ in}}  & {\em corner\+\_\+threshold\+\_\+radians} & dihedral angle considered non-\/smooth (in radians) \\
\hline
\mbox{\texttt{ out}}  & {\em CI} & \#\+CI list of face neighbors as indices into rows of F \\
\hline
\mbox{\texttt{ out}}  & {\em CC} & 3\texorpdfstring{$\ast$}{*}\#F+1 list of cumulative sizes so that CC(i\texorpdfstring{$\ast$}{*}3+j+1) -\/ CC(i\texorpdfstring{$\ast$}{*}3+j) is the number of faces considered smoothly incident on corner at F(i,j) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6eedd51ba703a9667e0bc21d6de863d8}\label{namespaceigl_a6eedd51ba703a9667e0bc21d6de863d8} 
\index{igl@{igl}!smooth\_corner\_adjacency@{smooth\_corner\_adjacency}}
\index{smooth\_corner\_adjacency@{smooth\_corner\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{smooth\_corner\_adjacency()}{smooth\_corner\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void igl\+::smooth\+\_\+corner\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{FV,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{FN,  }\item[{Eigen\+::\+Vector\+Xi \&}]{CI,  }\item[{Eigen\+::\+Vector\+Xi \&}]{CC }\end{DoxyParamCaption})}



Determine the effective corner-\/to-\/face adjacency relationship implied by a set of indexed vertex positions (FV) and normals (FV) (e.\+g., those read in from a .obj file). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em FV} & \#F by 3 list of triangle mesh indices into rows of some V \\
\hline
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3 list of triangle mesh indices into rows of some N \\
\hline
\mbox{\texttt{ out}}  & {\em CI} & \#\+CI list of face neighbors as indices into rows of F \\
\hline
\mbox{\texttt{ out}}  & {\em CC} & 3\texorpdfstring{$\ast$}{*}\#F+1 list of cumulative sizes so that CC(i\texorpdfstring{$\ast$}{*}3+j+1) -\/ CC(i\texorpdfstring{$\ast$}{*}3+j) is the number of faces considered smoothly incident on corner at F(i,j) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3c65a87d0656aad1a67568ce7fe62505}\label{namespaceigl_a3c65a87d0656aad1a67568ce7fe62505} 
\index{igl@{igl}!snap\_points@{snap\_points}}
\index{snap\_points@{snap\_points}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{snap\_points()}{snap\_points()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD , typename Derived\+VI $>$ \\
void igl\+::snap\+\_\+points (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedminD $>$ \&}]{minD,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VI $>$ \&}]{VI }\end{DoxyParamCaption})}



Snap list of points C to closest of another list of points V. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em C} & \#C by dim list of query point positions \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of data point positions \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#C list of indices into V of closest points to C \\
\hline
\mbox{\texttt{ out}}  & {\em minD} & \#C list of squared (\texorpdfstring{$^\wedge$}{\string^}p) distances to closest points \\
\hline
\mbox{\texttt{ out}}  & {\em VI} & \#C by dim list of new point positions, VI = V(\+I,\+:) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0456e1ef831df9943ee2f062e8119655}\label{namespaceigl_a0456e1ef831df9943ee2f062e8119655} 
\index{igl@{igl}!snap\_points@{snap\_points}}
\index{snap\_points@{snap\_points}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{snap\_points()}{snap\_points()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD $>$ \\
void igl\+::snap\+\_\+points (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedminD $>$ \&}]{minD }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa76c38e927f8da17319f7809593f78b0}\label{namespaceigl_aa76c38e927f8da17319f7809593f78b0} 
\index{igl@{igl}!snap\_points@{snap\_points}}
\index{snap\_points@{snap\_points}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{snap\_points()}{snap\_points()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedC , typename DerivedV , typename DerivedI $>$ \\
void igl\+::snap\+\_\+points (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a2773ac49873440379d546be16bf756e8}\label{namespaceigl_a2773ac49873440379d546be16bf756e8} 
\index{igl@{igl}!snap\_to\_canonical\_view\_quat@{snap\_to\_canonical\_view\_quat}}
\index{snap\_to\_canonical\_view\_quat@{snap\_to\_canonical\_view\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{snap\_to\_canonical\_view\_quat()}{snap\_to\_canonical\_view\_quat()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalarq , typename Scalars $>$ \\
bool igl\+::snap\+\_\+to\+\_\+canonical\+\_\+view\+\_\+quat (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Quaternion$<$ Scalarq $>$ \&}]{q,  }\item[{const double}]{threshold,  }\item[{Eigen\+::\+Quaternion$<$ Scalars $>$ \&}]{s }\end{DoxyParamCaption})}



Snap the quaternion q to the nearest canonical view quaternion. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & quaternion to be snapped (also see Outputs) \\
\hline
\mbox{\texttt{ in}}  & {\em threshold} & (optional) threshold\+: 1.\+0 -\/-\/\texorpdfstring{$>$}{>} snap any input 0.\+5 -\/-\/\texorpdfstring{$>$}{>} snap inputs somewhat close to canonical views 0.\+0 -\/-\/\texorpdfstring{$>$}{>} snap no input \\
\hline
\mbox{\texttt{ out}}  & {\em q} & quaternion possibly set to nearest canonical view \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only if q was snapped to the nearest canonical view 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a972274b2ed4c85251899428421619ad5}\label{namespaceigl_a972274b2ed4c85251899428421619ad5} 
\index{igl@{igl}!snap\_to\_canonical\_view\_quat@{snap\_to\_canonical\_view\_quat}}
\index{snap\_to\_canonical\_view\_quat@{snap\_to\_canonical\_view\_quat}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{snap\_to\_canonical\_view\_quat()}{snap\_to\_canonical\_view\_quat()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
bool igl\+::snap\+\_\+to\+\_\+canonical\+\_\+view\+\_\+quat (\begin{DoxyParamCaption}\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{q,  }\item[{const Q\+\_\+type}]{threshold,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{s }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af6de4ebdb7f531d96fb57a566e0d121c}\label{namespaceigl_af6de4ebdb7f531d96fb57a566e0d121c} 
\index{igl@{igl}!snap\_to\_fixed\_up@{snap\_to\_fixed\_up}}
\index{snap\_to\_fixed\_up@{snap\_to\_fixed\_up}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{snap\_to\_fixed\_up()}{snap\_to\_fixed\_up()}}
{\footnotesize\ttfamily template$<$typename Qtype $>$ \\
void igl\+::snap\+\_\+to\+\_\+fixed\+\_\+up (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Quaternion$<$ Qtype $>$ \&}]{q,  }\item[{Eigen\+::\+Quaternion$<$ Qtype $>$ \&}]{s }\end{DoxyParamCaption})}



Snap an arbitrary rotation to a rotation resulting from a rotation about the y-\/axis then the x-\/axis (maintaining fixed up like two\+\_\+axis\+\_\+valuator\+\_\+fixed\+\_\+up.) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em q} & General rotation as quaternion \\
\hline
\mbox{\texttt{ out}}  & {\em s} & the resulting rotation (as quaternion)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_aaef42c6f3251414c7485b4d1433a54e4}{two\+\_\+axis\+\_\+valuator\+\_\+fixed\+\_\+up} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ac42833fb0899d755feb35dbf0db24410}\label{namespaceigl_ac42833fb0899d755feb35dbf0db24410} 
\index{igl@{igl}!solid\_angle@{solid\_angle}}
\index{solid\_angle@{solid\_angle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{solid\_angle()}{solid\_angle()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedP $>$ \\
Derived\+A\+::\+Scalar igl\+::solid\+\_\+angle (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P }\end{DoxyParamCaption})}



Compute the signed solid angle subtended by the oriented 3d triangle (A,B,C) at some point P. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 3D position of corner \\
\hline
\mbox{\texttt{ in}}  & {\em B} & 3D position of corner \\
\hline
\mbox{\texttt{ in}}  & {\em C} & 3D position of corner \\
\hline
\mbox{\texttt{ in}}  & {\em P} & 3D position of query point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
signed solid angle 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aea54a5804527aa194785e403870ba7db}\label{namespaceigl_aea54a5804527aa194785e403870ba7db} 
\index{igl@{igl}!sort@{sort}}
\index{sort@{sort}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ \\
void igl\+::sort (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&}]{IX }\end{DoxyParamCaption})}



Sort the elements of a matrix X along a given dimension like matlabs sort function. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedX} & derived scalar type, e.\+g. Matrix\+Xi or Matrix\+Xd \\
\hline
{\em Derived\+IX} & derived integer type, e.\+g. Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix whose entries are to be sorted \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimensional along which to sort\+: 1 sort each column (matlab default) 2 sort each row \\
\hline
\mbox{\texttt{ in}}  & {\em ascending} & sort ascending (true, matlab default) or descending (false) \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n matrix whose entries are sorted \\
\hline
\mbox{\texttt{ out}}  & {\em IX} & m by n matrix of indices so that if dim = 1, then in matlab notation for j = 1\+:n, Y(\+:,j) = X(\+I(\+:,j),j); end \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1b8c55dff1cae23221b5570ad7f9c194}\label{namespaceigl_a1b8c55dff1cae23221b5570ad7f9c194} 
\index{igl@{igl}!sort@{sort}}
\index{sort@{sort}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::sort (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a4dd6daca2b874edaf27301a111ed2401}\label{namespaceigl_a4dd6daca2b874edaf27301a111ed2401} 
\index{igl@{igl}!sort\_new@{sort\_new}}
\index{sort\_new@{sort\_new}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_new()}{sort\_new()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ \\
void igl\+::sort\+\_\+new (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&}]{IX }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\begin{DoxyNote}{Note}
This should be renamed to something like sort\+\_\+small because it is only faster if size(\+X,dim) is small. 
\end{DoxyNote}
\Hypertarget{namespaceigl_a61ad3bd047a94be9c5ad7bf8890dd798}\label{namespaceigl_a61ad3bd047a94be9c5ad7bf8890dd798} 
\index{igl@{igl}!sort2@{sort2}}
\index{sort2@{sort2}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort2()}{sort2()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ \\
void igl\+::sort2 (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&}]{IX }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Special case if size(\+X,dim) == 2 \Hypertarget{namespaceigl_a6bfeee50844cf4deac8ad3b473407428}\label{namespaceigl_a6bfeee50844cf4deac8ad3b473407428} 
\index{igl@{igl}!sort3@{sort3}}
\index{sort3@{sort3}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort3()}{sort3()}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename Derived\+IX $>$ \\
void igl\+::sort3 (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IX $>$ \&}]{IX }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Special case if size(\+X,dim) == 3 \Hypertarget{namespaceigl_a5ee021e4c406d792e624a3ddbdc5145d}\label{namespaceigl_a5ee021e4c406d792e624a3ddbdc5145d} 
\index{igl@{igl}!sort@{sort}}
\index{sort@{sort}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort()}{sort()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void igl\+::sort (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{unsorted,  }\item[{const bool}]{ascending,  }\item[{std\+::vector$<$ T $>$ \&}]{sorted,  }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index\+\_\+map }\end{DoxyParamCaption})}



Act like matlab\textquotesingle{}s \mbox{[}Y,I\mbox{]} = SORT(\+X) for std library vectors. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a class that implements the \textquotesingle{}\texorpdfstring{$<$}{<}\textquotesingle{} comparator operator \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em unsorted} & unsorted vector \\
\hline
\mbox{\texttt{ in}}  & {\em ascending} & sort ascending (true, matlab default) or descending (false) \\
\hline
\mbox{\texttt{ out}}  & {\em sorted} & sorted vector, allowed to be same as unsorted \\
\hline
\mbox{\texttt{ out}}  & {\em index\+\_\+map} & an index map such that sorted\mbox{[}i\mbox{]} = unsorted\mbox{[}index\+\_\+map\mbox{[}i\mbox{]}\mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af203a35e46d72618e788c9c02e5f2e0c}\label{namespaceigl_af203a35e46d72618e788c9c02e5f2e0c} 
\index{igl@{igl}!sort\_angles@{sort\_angles}}
\index{sort\_angles@{sort\_angles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_angles()}{sort\_angles()}}
{\footnotesize\ttfamily template$<$typename DerivedM , typename DerivedR $>$ \\
void igl\+::sort\+\_\+angles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedR $>$ \&}]{R }\end{DoxyParamCaption})}



Sort angles in ascending order in a numerically robust way. 

Instead of computing angles using atan2(y, x), sort directly on (y, x).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em M} & m by n matrix of scalars. (n \texorpdfstring{$>$}{>}= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-\/breaker. \\
\hline
\mbox{\texttt{ in}}  & {\em R} & an array of m indices. M.\+row(\+R\mbox{[}i\mbox{]}) contains the i-\/th smallest angle. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1c0a98c41282a4c612da5ad971a4a676}\label{namespaceigl_a1c0a98c41282a4c612da5ad971a4a676} 
\index{igl@{igl}!sort\_triangles@{sort\_triangles}}
\index{sort\_triangles@{sort\_triangles}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_triangles()}{sort\_triangles()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+MV , typename DerivedP , typename Derived\+FF , typename DerivedI $>$ \\
void igl\+::sort\+\_\+triangles (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+MV $>$ \&}]{MV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Sort triangles by depth (from back to front) using a painter\textquotesingle{}s algorithm. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by {\bfseries{4}} list of homogeneous vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em MV} & 4 by 4 model view matrix \\
\hline
\mbox{\texttt{ in}}  & {\em P} & 4 by 4 projection matrix \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#F by 3 list of sorted triangles indices \\
\hline
\mbox{\texttt{ out}}  & {\em I} & \#F list of sorted indices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab6d31a3df6fc3ab3d769b240cc8ca2f5}\label{namespaceigl_ab6d31a3df6fc3ab3d769b240cc8ca2f5} 
\index{igl@{igl}!sort\_vectors\_ccw@{sort\_vectors\_ccw}}
\index{sort\_vectors\_ccw@{sort\_vectors\_ccw}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_vectors\_ccw()}{sort\_vectors\_ccw()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedI $>$ \\
void igl\+::sort\+\_\+vectors\+\_\+ccw (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{order,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{sorted,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{inv\+\_\+order }\end{DoxyParamCaption})}



Sorts a set of N coplanar vectors in a ccw order, and returns their order. 

Optionally it also returns a copy of the ordered vector set, or the indices, in the original unordered set, of the vectors in the ordered set (called here the "{}inverse"{} set of indices).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em P} & 1 by 3N row vector of the vectors to be sorted, stacked horizontally \\
\hline
\mbox{\texttt{ in}}  & {\em N} & \#1 by 3 normal of the plane where the vectors lie \\
\hline
\mbox{\texttt{ out}}  & {\em order} & N by 1 order of the vectors (indices of the unordered vectors into the ordered vector set) \\
\hline
\mbox{\texttt{ out}}  & {\em sorted} & 1 by 3N row vector of the ordered vectors, stacked horizontally \\
\hline
\mbox{\texttt{ out}}  & {\em inv\+\_\+order} & N by 1 "{}inverse"{} order of the vectors (the indices of the ordered vectors into the unordered vector set) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ad12fb37ec629691009ae42d926adcb02}\label{namespaceigl_ad12fb37ec629691009ae42d926adcb02} 
\index{igl@{igl}!sort\_vectors\_ccw@{sort\_vectors\_ccw}}
\index{sort\_vectors\_ccw@{sort\_vectors\_ccw}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_vectors\_ccw()}{sort\_vectors\_ccw()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedI $>$ \\
void igl\+::sort\+\_\+vectors\+\_\+ccw (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{order,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{sorted }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a9b4fdcbef0f11737a037711a7ebf833c}\label{namespaceigl_a9b4fdcbef0f11737a037711a7ebf833c} 
\index{igl@{igl}!sort\_vectors\_ccw@{sort\_vectors\_ccw}}
\index{sort\_vectors\_ccw@{sort\_vectors\_ccw}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_vectors\_ccw()}{sort\_vectors\_ccw()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedI $>$ \\
void igl\+::sort\+\_\+vectors\+\_\+ccw (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{order,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{inv\+\_\+order }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a08c139732fd7bcd7379c91befbb35775}\label{namespaceigl_a08c139732fd7bcd7379c91befbb35775} 
\index{igl@{igl}!sort\_vectors\_ccw@{sort\_vectors\_ccw}}
\index{sort\_vectors\_ccw@{sort\_vectors\_ccw}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sort\_vectors\_ccw()}{sort\_vectors\_ccw()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedI $>$ \\
void igl\+::sort\+\_\+vectors\+\_\+ccw (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{N,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{order }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_af8ac99e9c2a051fdbc1b1c132e8102f8}\label{namespaceigl_af8ac99e9c2a051fdbc1b1c132e8102f8} 
\index{igl@{igl}!sortrows@{sortrows}}
\index{sortrows@{sortrows}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sortrows()}{sortrows()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY , typename DerivedI $>$ \\
void igl\+::sortrows (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{I }\end{DoxyParamCaption})}



Act like matlab\textquotesingle{}s \mbox{[}Y,I\mbox{]} = sortrows(\+X) 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedX} & derived scalar type, e.\+g. Matrix\+Xi or Matrix\+Xd \\
\hline
{\em DerivedI} & derived integer type, e.\+g. Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n matrix whose entries are to be sorted \\
\hline
\mbox{\texttt{ in}}  & {\em ascending} & sort ascending (true, matlab default) or descending (false) \\
\hline
\mbox{\texttt{ out}}  & {\em Y} & m by n matrix whose entries are sorted ({\bfseries{should not}} be same reference as X) \\
\hline
\mbox{\texttt{ out}}  & {\em I} & m list of indices so that Y = X(\+I,\+:); \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4f276cc65a7f7d0a0929e983028a3169}\label{namespaceigl_a4f276cc65a7f7d0a0929e983028a3169} 
\index{igl@{igl}!sortrows@{sortrows}}
\index{sortrows@{sortrows}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sortrows()}{sortrows()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedX , typename DerivedY $>$ \\
void igl\+::sortrows (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&}]{X,  }\item[{const bool}]{ascending,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&}]{Y }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aa0031015feb34d6398264ceac841bc0c}\label{namespaceigl_aa0031015feb34d6398264ceac841bc0c} 
\index{igl@{igl}!sparse@{sparse}}
\index{sparse@{sparse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse()}{sparse()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$class Index\+VectorI , class Index\+VectorJ , class Value\+Vector , typename T $>$ \\
void igl\+::sparse (\begin{DoxyParamCaption}\item[{const Index\+VectorI \&}]{I,  }\item[{const Index\+VectorJ \&}]{J,  }\item[{const Value\+Vector \&}]{V,  }\item[{const size\+\_\+t}]{m,  }\item[{const size\+\_\+t}]{n,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X }\end{DoxyParamCaption})}



Build a sparse matrix from list of indices and values (I,J,V), functions like the sparse function in matlab. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Index\+Vector} & list of indices, value should be non-\/negative and should expect to be cast to an index. Must implement operator(i) to retrieve ith element \\
\hline
{\em Value\+Vector} & list of values, value should be expect to be cast to type T. Must implement operator(i) to retrieve ith element \\
\hline
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em I} & nnz vector of row indices of non zeros entries in X \\
\hline
\mbox{\texttt{ in}}  & {\em J} & nnz vector of column indices of non zeros entries in X \\
\hline
\mbox{\texttt{ in}}  & {\em V} & nnz vector of non-\/zeros entries in X \\
\hline
\mbox{\texttt{ in}}  & {\em m} & number of rows \\
\hline
\mbox{\texttt{ in}}  & {\em n} & number of cols \\
\hline
\mbox{\texttt{ out}}  & {\em X} & m by n matrix of type T whose entries are to be found\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a55e6cc04971d8a30de15d18272221aa9}\label{namespaceigl_a55e6cc04971d8a30de15d18272221aa9} 
\index{igl@{igl}!sparse@{sparse}}
\index{sparse@{sparse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse()}{sparse()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$class Index\+Vector , class Value\+Vector , typename T $>$ \\
void igl\+::sparse (\begin{DoxyParamCaption}\item[{const Index\+Vector \&}]{I,  }\item[{const Index\+Vector \&}]{J,  }\item[{const Value\+Vector \&}]{V,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a1af79e7e819b442592de8d5db2e5829c}\label{namespaceigl_a1af79e7e819b442592de8d5db2e5829c} 
\index{igl@{igl}!sparse@{sparse}}
\index{sparse@{sparse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse()}{sparse()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedD , typename T $>$ \\
void igl\+::sparse (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X }\end{DoxyParamCaption})}



Convert a full, dense matrix to a sparse one. 

\begin{DoxyNote}{Note}
Just use .sparse\+View()
\end{DoxyNote}

\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em D} & m by n full, dense matrix \\
\hline
\mbox{\texttt{ out}}  & {\em X} & m by n sparse matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aee96f9beefd8dd12066e82a32b314855}\label{namespaceigl_aee96f9beefd8dd12066e82a32b314855} 
\index{igl@{igl}!sparse@{sparse}}
\index{sparse@{sparse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse()}{sparse()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedD $>$ \\
Eigen\+::\+Sparse\+Matrix$<$ typename Derived\+D\+::\+Scalar $>$ igl\+::sparse (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedD $>$ \&}]{D }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ac623ce43ac510a2b3374c791984d819c}\label{namespaceigl_ac623ce43ac510a2b3374c791984d819c} 
\index{igl@{igl}!sparse\_cached\_precompute@{sparse\_cached\_precompute}}
\index{sparse\_cached\_precompute@{sparse\_cached\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse\_cached\_precompute()}{sparse\_cached\_precompute()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedI , typename Scalar $>$ \\
void igl\+::sparse\+\_\+cached\+\_\+precompute (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{I,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedI $>$ \&}]{J,  }\item[{Eigen\+::\+Vector\+Xi \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{X }\end{DoxyParamCaption})}



Build a sparse matrix from list of indices and values (I,J,V), similarly to the sparse function in matlab. 

Divides the construction in two phases, one for fixing the sparsity pattern, and one to populate it with values. Compared to \doxylink{namespaceigl_aa0031015feb34d6398264ceac841bc0c}{igl\+::sparse}, this version is slower for the first time (since it requires a precomputation), but faster to the subsequent evaluations.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em I} & nnz vector of row indices of non zeros entries in X \\
\hline
\mbox{\texttt{ in}}  & {\em J} & nnz vector of column indices of non zeros entries in X \\
\hline
\mbox{\texttt{ out}}  & {\em data} & ?? vector of ?? \\
\hline
\mbox{\texttt{ out}}  & {\em X} & m by n matrix of type T whose entries are to be found\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md36}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md36}
\begin{DoxyVerb}  Eigen::SparseMatrix<double> A;
  std::vector<Eigen::Triplet<double> > IJV;
  slim_buildA(IJV);
  if (A.rows() == 0)
  {
    A = Eigen::SparseMatrix<double>(rows,cols);
    igl::sparse_cached_precompute(IJV,A_data,A);
  }
  else
    igl::sparse_cached(IJV,A_data,A);
\end{DoxyVerb}
 \Hypertarget{namespaceigl_a652603bae4d621913f8679441ac6d771}\label{namespaceigl_a652603bae4d621913f8679441ac6d771} 
\index{igl@{igl}!sparse\_cached\_precompute@{sparse\_cached\_precompute}}
\index{sparse\_cached\_precompute@{sparse\_cached\_precompute}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse\_cached\_precompute()}{sparse\_cached\_precompute()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::sparse\+\_\+cached\+\_\+precompute (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Eigen\+::\+Triplet$<$ Scalar $>$ $>$ \&}]{triplets,  }\item[{Eigen\+::\+Vector\+Xi \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{X }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em triplets} & nnz vector of triplets of non zeros entries in X \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_abff00fedf6ea99985f251a964eb2fe21}\label{namespaceigl_abff00fedf6ea99985f251a964eb2fe21} 
\index{igl@{igl}!sparse\_cached@{sparse\_cached}}
\index{sparse\_cached@{sparse\_cached}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse\_cached()}{sparse\_cached()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
void igl\+::sparse\+\_\+cached (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ Eigen\+::\+Triplet$<$ Scalar $>$ $>$ \&}]{triplets,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{X }\end{DoxyParamCaption})}



Build a sparse matrix from cached list of data and values. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em triplets} & nnz vector of triplets of non zeros entries in X \\
\hline
\mbox{\texttt{ in}}  & {\em data} & ?? vector of ?? \\
\hline
\mbox{\texttt{ in,out}}  & {\em X} & m by n matrix of type T whose entries are to be found ~\newline
 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adb2f3d6b20dcda22b4415935b0b4a250}\label{namespaceigl_adb2f3d6b20dcda22b4415935b0b4a250} 
\index{igl@{igl}!sparse\_cached@{sparse\_cached}}
\index{sparse\_cached@{sparse\_cached}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse\_cached()}{sparse\_cached()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Scalar $>$ \\
void igl\+::sparse\+\_\+cached (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Vector\+Xi \&}]{data,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{X }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V list of values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae4c369ebc42c4e76553730c636d7967d}\label{namespaceigl_ae4c369ebc42c4e76553730c636d7967d} 
\index{igl@{igl}!sparse\_voxel\_grid@{sparse\_voxel\_grid}}
\index{sparse\_voxel\_grid@{sparse\_voxel\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sparse\_voxel\_grid()}{sparse\_voxel\_grid()}}
{\footnotesize\ttfamily template$<$typename Derived\+P0 , typename Func , typename DerivedS , typename DerivedV , typename DerivedI $>$ \\
void igl\+::sparse\+\_\+voxel\+\_\+grid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P0 $>$ \&}]{p0,  }\item[{const Func \&}]{scalar\+Func,  }\item[{const double}]{eps,  }\item[{const int}]{expected\+\_\+number\+\_\+of\+\_\+cubes,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedS $>$ \&}]{CS,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{CV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedI $>$ \&}]{CI }\end{DoxyParamCaption})}



Given a point, p0, on an isosurface, construct a shell of epsilon sized cubes surrounding the surface. 

These cubes can be used as the input to marching cubes.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em p0} & A 3D point on the isosurface surface defined by scalar\+Func(x) = 0 \\
\hline
\mbox{\texttt{ in}}  & {\em scalar\+Func} & A scalar function from R\texorpdfstring{$^\wedge$}{\string^}3 to R -- points which map to 0 lie on the surface, points which are negative lie inside the surface, and points which are positive lie outside the surface \\
\hline
\mbox{\texttt{ in}}  & {\em eps} & The edge length of the cubes surrounding the surface \\
\hline
\mbox{\texttt{ in}}  & {\em expected\+\_\+number\+\_\+of\+\_\+cubes} & This pre-\/allocates internal data structures to speed things up \\
\hline
\mbox{\texttt{ out}}  & {\em CS} & \#\+CV by 1 list of scalar values at the cube vertices \\
\hline
\mbox{\texttt{ out}}  & {\em CV} & \#\+CV by 3 list of cube vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em CI} & \#\+CI by 8 list of cube indices into rows of CS and CV. Each row represents 8 corners of cube in y-\/x-\/z binary counting order. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab7bca403061433327f7ae13005e190a6}\label{namespaceigl_ab7bca403061433327f7ae13005e190a6} 
\index{igl@{igl}!speye@{speye}}
\index{speye@{speye}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{speye()}{speye()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::speye (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{const int}]{m,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{I }\end{DoxyParamCaption})}



Builds an m by n sparse identity matrix like matlab\textquotesingle{}s speye function. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em m} & number of rows \\
\hline
\mbox{\texttt{ in}}  & {\em n} & number of cols \\
\hline
\mbox{\texttt{ out}}  & {\em I} & m by n sparse matrix with 1\textquotesingle{}s on the main diagonal \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a99a506e0e604f1618c56560c1c3238a7}\label{namespaceigl_a99a506e0e604f1618c56560c1c3238a7} 
\index{igl@{igl}!speye@{speye}}
\index{speye@{speye}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{speye()}{speye()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::speye (\begin{DoxyParamCaption}\item[{const int}]{n,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{I }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

m = n \Hypertarget{namespaceigl_ad087e73516c7afa1370f7b24c1132a36}\label{namespaceigl_ad087e73516c7afa1370f7b24c1132a36} 
\index{igl@{igl}!split\_nonmanifold@{split\_nonmanifold}}
\index{split\_nonmanifold@{split\_nonmanifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{split\_nonmanifold()}{split\_nonmanifold()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+SF , typename Derived\+SVI $>$ \\
void igl\+::split\+\_\+nonmanifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&}]{SVI }\end{DoxyParamCaption})}



Split a non-\/manifold (or non-\/orientable) mesh into a orientable manifold mesh possibly with more connected components and geometrically duplicate vertices. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into rows of some V \\
\hline
\mbox{\texttt{ out}}  & {\em SF} & \#F by 3 list of mesh triangle indices into rows of a new vertex list SV = V(\+SVI,\+:) \\
\hline
\mbox{\texttt{ out}}  & {\em SVI} & \#\+SV list of indices into V identifying vertex positions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_af6330810b20e78a8af65cb151d537d6d}\label{namespaceigl_af6330810b20e78a8af65cb151d537d6d} 
\index{igl@{igl}!split\_nonmanifold@{split\_nonmanifold}}
\index{split\_nonmanifold@{split\_nonmanifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{split\_nonmanifold()}{split\_nonmanifold()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+SV , typename Derived\+SF , typename Derived\+SVI $>$ \\
void igl\+::split\+\_\+nonmanifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SV $>$ \&}]{SV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SF $>$ \&}]{SF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+SVI $>$ \&}]{SVI }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim explicit list of vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em SV} & \#\+SV by dim explicit list of vertex positions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a45669ed07ec4ce3c9d9af3c976246bda}\label{namespaceigl_a45669ed07ec4ce3c9d9af3c976246bda} 
\index{igl@{igl}!squared\_edge\_lengths@{squared\_edge\_lengths}}
\index{squared\_edge\_lengths@{squared\_edge\_lengths}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{squared\_edge\_lengths()}{squared\_edge\_lengths()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedL $>$ \\
void igl\+::squared\+\_\+edge\+\_\+lengths (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedL $>$ \&}]{L }\end{DoxyParamCaption})}



Constructs a list of squared lengths of edges opposite each index in a face (triangle/tet) list. 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived from vertex positions matrix type\+: i.\+e. Matrix\+Xd \\
\hline
{\em DerivedF} & derived from face indices matrix type\+: i.\+e. Matrix\+Xi \\
\hline
{\em DerivedL} & derived from edge lengths matrix type\+: i.\+e. Matrix\+Xd \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & eigen matrix \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by (2\texorpdfstring{$\vert$}{|}3\texorpdfstring{$\vert$}{|}4) list of mesh edges, triangles or tets \\
\hline
\mbox{\texttt{ out}}  & {\em L} & \#F by \{1\texorpdfstring{$\vert$}{|}3\texorpdfstring{$\vert$}{|}6\} list of edge lengths squared for edges, column of lengths for triangles, columns correspond to edges \mbox{[}1,2\mbox{]},\mbox{[}2,0\mbox{]},\mbox{[}0,1\mbox{]} for tets, columns correspond to edges \mbox{[}3 0\mbox{]},\mbox{[}3 1\mbox{]},\mbox{[}3 2\mbox{]},\mbox{[}1 2\mbox{]},\mbox{[}2 0\mbox{]},\mbox{[}0 1\mbox{]} \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a8f4750b8f143bb05a426374c4c65b92a}\label{namespaceigl_a8f4750b8f143bb05a426374c4c65b92a} 
\index{igl@{igl}!stdin\_to\_temp@{stdin\_to\_temp}}
\index{stdin\_to\_temp@{stdin\_to\_temp}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{stdin\_to\_temp()}{stdin\_to\_temp()}}
{\footnotesize\ttfamily bool igl\+::stdin\+\_\+to\+\_\+temp (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{temp\+\_\+file }\end{DoxyParamCaption})}



Write stdin/piped input to a temporary file which can than be preprocessed as it is (a normal file). 

This is often useful if you want to process stdin/piped with library functions that expect to be able to fseek(), rewind() etc..

If your application is not using fseek(), rewind(), etc. but just reading from stdin then this will likely cause a bottle neck as it defeats the whole purpose of piping.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em temp\+\_\+file} & pointer to temp file pointer, rewound to beginning of file so its ready to be read \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true only if no errors were found
\end{DoxyReturn}
\begin{DoxyNote}{Note}
caller is responsible for closing the file (tmpfile() automatically unlinks the file so there is no need to remove/delete/unlink the file) 
\end{DoxyNote}
\Hypertarget{namespaceigl_a43464482f2fd9b2c4b7e2beac12fc522}\label{namespaceigl_a43464482f2fd9b2c4b7e2beac12fc522} 
\index{igl@{igl}!straighten\_seams@{straighten\_seams}}
\index{straighten\_seams@{straighten\_seams}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{straighten\_seams()}{straighten\_seams()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+VT , typename Derived\+FT , typename Scalar , typename Derived\+UE , typename Derived\+UT , typename Derived\+OT $>$ \\
void igl\+::straighten\+\_\+seams (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VT $>$ \&}]{VT,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FT $>$ \&}]{FT,  }\item[{const Scalar}]{tol,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UE $>$ \&}]{UE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+UT $>$ \&}]{UT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+OT $>$ \&}]{OT }\end{DoxyParamCaption})}



Given a obj-\/style mesh with (V,F) defining the geometric surface of the mesh and (VT,FT) defining the parameterization/texture-\/mapping of the mesh in the uv-\/domain, find all seams and boundaries in the texture-\/mapping and "{}straighten"{} them, remapping vertices along the boundary and in the interior. 

This will be careful to consistently straighten multiple seams in the texture-\/mesh corresponding to the same edge chains in the surface-\/mesh.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ in}}  & {\em VT} & \#\+VT by 2 list of texture coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em FT} & \#F by 3 list of triangle texture coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em tol} & followed by Ramer-\/\+Douglas-\/\+Peucker tolerance as a fraction of the curves bounding box diagonal (see dpsimplify) \\
\hline
\mbox{\texttt{ out}}  & {\em UE} & \#\+UE by 2 list of indices into VT of coarse output polygon edges \\
\hline
\mbox{\texttt{ out}}  & {\em UT} & \#\+VT by 3 list of new texture coordinates \\
\hline
\mbox{\texttt{ out}}  & {\em OT} & \#\+OT by 2 list of indices into VT of boundary edges\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a0fe9e431751b9d9370672f22da915cea}{ramer\+\_\+douglas\+\_\+peucker} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ac4a359f88733a83493b68b6f605a5161}\label{namespaceigl_ac4a359f88733a83493b68b6f605a5161} 
\index{igl@{igl}!starts\_with@{starts\_with}}
\index{starts\_with@{starts\_with}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{starts\_with()}{starts\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::starts\+\_\+with (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{const std\+::string \&}]{prefix }\end{DoxyParamCaption})}



Check if a string starts with a given prefix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & string to check \\
\hline
\mbox{\texttt{ in}}  & {\em prefix} & prefix to check \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str starts with prefix, false otherwise
\end{DoxyReturn}
\doxylink{string__utils_8h}{include/igl/string\+\_\+utils.\+h} \Hypertarget{namespaceigl_ad5e02163e30570e181965fba3609c8b4}\label{namespaceigl_ad5e02163e30570e181965fba3609c8b4} 
\index{igl@{igl}!starts\_with@{starts\_with}}
\index{starts\_with@{starts\_with}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{starts\_with()}{starts\_with()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::starts\+\_\+with (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{str,  }\item[{const char \texorpdfstring{$\ast$}{*}}]{prefix }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{string__utils_8h}{include/igl/string\+\_\+utils.\+h}. 

\Hypertarget{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734}\label{namespaceigl_adf21bb95cf3e8474259c54e4a55ed734} 
\index{igl@{igl}!sum@{sum}}
\index{sum@{sum}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sum()}{sum()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::sum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ T $>$ \&}]{X,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Sparse\+Vector$<$ T $>$ \&}]{S }\end{DoxyParamCaption})}



Sum the columns or rows of a sparse matrix. 


\begin{DoxyTemplParams}{Template Parameters}
{\em should} & be a eigen sparse matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em X} & m by n sparse matrix \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension along which to sum (1 or 2) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & n-\/long sparse vector (if dim == 1) or m-\/long sparse vector (if dim == 2)\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
If your looking for dense matrix matlab like sum for eigen matrics just use\+: \begin{DoxyVerb} M.colwise().sum() or M.rowwise().sum()
\end{DoxyVerb}
 
\end{DoxyNote}
\Hypertarget{namespaceigl_a5bcbac428755ce31717db4079956840b}\label{namespaceigl_a5bcbac428755ce31717db4079956840b} 
\index{igl@{igl}!sum@{sum}}
\index{sum@{sum}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{sum()}{sum()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename AType , typename DerivedB $>$ \\
void igl\+::sum (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Matrix$<$ AType $>$ \&}]{A,  }\item[{const int}]{dim,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedB $>$ \&}]{B }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Sum is "{}conducted"{} in the type of Derived\+B\+::\+Scalar 
\begin{DoxyTemplParams}{Template Parameters}
{\em AType} & should be a eigen sparse matrix primitive type like int or double \\
\hline
{\em DerivedB} & should be a eigen dense matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}
\Hypertarget{namespaceigl_a3b7376c37ca3ec7bb7dc4cf7fdecfe36}\label{namespaceigl_a3b7376c37ca3ec7bb7dc4cf7fdecfe36} 
\index{igl@{igl}!svd3x3@{svd3x3}}
\index{svd3x3@{svd3x3}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{svd3x3()}{svd3x3()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::svd3x3 (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, 3, 3 $>$ \&}]{A,  }\item[{Eigen\+::\+Matrix$<$ T, 3, 3 $>$ \&}]{U,  }\item[{Eigen\+::\+Matrix$<$ T, 3, 1 $>$ \&}]{S,  }\item[{Eigen\+::\+Matrix$<$ T, 3, 3 $>$ \&}]{V }\end{DoxyParamCaption})}



Super fast 3x3 SVD according to \href{http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/\texorpdfstring{$\sim$}{\string~}sifakis/project\+\_\+pages/svd.\+html}} The resulting decomposition is A = U \texorpdfstring{$\ast$}{*} diag(\+S\mbox{[}0\mbox{]}, S\mbox{[}1\mbox{]}, S\mbox{[}2\mbox{]}) \texorpdfstring{$\ast$}{*} V\textquotesingle{}. 

\begin{DoxyNote}{Note}
this SVD algorithm guarantees that det(\+U) = det(\+V) = 1, but this comes at the cost that \textquotesingle{}sigma3\textquotesingle{} can be negative for computing polar decomposition it\textquotesingle{}s great because all we need to do is U\texorpdfstring{$\ast$}{*}V\textquotesingle{} and the result will automatically have positive determinant
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 3x3 matrix \\
\hline
\mbox{\texttt{ out}}  & {\em U} & 3x3 left singular vectors \\
\hline
\mbox{\texttt{ out}}  & {\em S} & 3x1 singular values \\
\hline
\mbox{\texttt{ out}}  & {\em V} & 3x3 right singular vectors\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4153817f124410a202847cbf878d271b}\label{namespaceigl_a4153817f124410a202847cbf878d271b} 
\index{igl@{igl}!svd3x3\_avx@{svd3x3\_avx}}
\index{svd3x3\_avx@{svd3x3\_avx}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{svd3x3\_avx()}{svd3x3\_avx()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::svd3x3\+\_\+avx (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 3 $>$ \&}]{A,  }\item[{Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 3 $>$ \&}]{U,  }\item[{Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 1 $>$ \&}]{S,  }\item[{Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}8, 3 $>$ \&}]{V }\end{DoxyParamCaption})}



Super fast 3x3 SVD according to \href{http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/\texorpdfstring{$\sim$}{\string~}sifakis/project\+\_\+pages/svd.\+html}} This is AVX version of svd3x3 (see \doxylink{svd3x3_8h}{svd3x3.\+h}) which works on 8 matrices at a time These eight matrices are simply stacked in columns, the rest is the same as for svd3x3. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 12 by 3 stack of 3x3 matrices \\
\hline
\mbox{\texttt{ out}}  & {\em U} & 12x3 left singular vectors stacked \\
\hline
\mbox{\texttt{ out}}  & {\em S} & 12x1 singular values stacked \\
\hline
\mbox{\texttt{ out}}  & {\em V} & 12x3 right singular vectors stacked\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae67ee73993135205bd97cfc9c8453d68}\label{namespaceigl_ae67ee73993135205bd97cfc9c8453d68} 
\index{igl@{igl}!svd3x3\_sse@{svd3x3\_sse}}
\index{svd3x3\_sse@{svd3x3\_sse}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{svd3x3\_sse()}{svd3x3\_sse()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::svd3x3\+\_\+sse (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 3 $>$ \&}]{A,  }\item[{Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 3 $>$ \&}]{U,  }\item[{Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 1 $>$ \&}]{S,  }\item[{Eigen\+::\+Matrix$<$ T, 3 \texorpdfstring{$\ast$}{*}4, 3 $>$ \&}]{V }\end{DoxyParamCaption})}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & 12 by 3 stack of 3x3 matrices \\
\hline
\mbox{\texttt{ out}}  & {\em U} & 12x3 left singular vectors stacked \\
\hline
\mbox{\texttt{ out}}  & {\em S} & 12x1 singular values stacked \\
\hline
\mbox{\texttt{ out}}  & {\em V} & 12x3 right singular vectors stacked\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a525f425d4315f9547a6e82782d7d672b}\label{namespaceigl_a525f425d4315f9547a6e82782d7d672b} 
\index{igl@{igl}!swept\_volume@{swept\_volume}}
\index{swept\_volume@{swept\_volume}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{swept\_volume()}{swept\_volume()}}
{\footnotesize\ttfamily void igl\+::swept\+\_\+volume (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const std\+::function$<$ Eigen\+::\+Affine3d(const double t)$>$ \&}]{transform,  }\item[{const size\+\_\+t}]{steps,  }\item[{const size\+\_\+t}]{grid\+\_\+res,  }\item[{const size\+\_\+t}]{isolevel,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{SV,  }\item[{Eigen\+::\+Matrix\+Xi \&}]{SF }\end{DoxyParamCaption})}



Compute the surface of the swept volume of a solid object with surface (V,F) mesh under going rigid motion. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh positions in reference pose \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em transform} & function handle so that transform(t) returns the rigid transformation at time t\mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em steps} & number of time steps\+: steps=3 -\/-\/\texorpdfstring{$>$}{>} t\{0,0.\+5,1\} \\
\hline
\mbox{\texttt{ in}}  & {\em grid\+\_\+res} & number of grid cells on the longest side containing the motion (isolevel+1 cells will also be added on each side as padding) \\
\hline
\mbox{\texttt{ in}}  & {\em isolevel} & distance level to be contoured as swept volume \\
\hline
\mbox{\texttt{ out}}  & {\em SV} & \#\+SV by 3 list of mesh positions of the swept surface \\
\hline
\mbox{\texttt{ out}}  & {\em SF} & \#\+SF by 3 list of mesh faces into SV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0739e2c6e91f7aa950aca9580a90e612}\label{namespaceigl_a0739e2c6e91f7aa950aca9580a90e612} 
\index{igl@{igl}!swept\_volume\_bounding\_box@{swept\_volume\_bounding\_box}}
\index{swept\_volume\_bounding\_box@{swept\_volume\_bounding\_box}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{swept\_volume\_bounding\_box()}{swept\_volume\_bounding\_box()}}
{\footnotesize\ttfamily void igl\+::swept\+\_\+volume\+\_\+bounding\+\_\+box (\begin{DoxyParamCaption}\item[{const size\+\_\+t \&}]{n,  }\item[{const std\+::function$<$ Eigen\+::\+Row\+Vector3d(const size\+\_\+t vi, const double t)$>$ \&}]{V,  }\item[{const size\+\_\+t \&}]{steps,  }\item[{Eigen\+::\+Aligned\+Box3d \&}]{box }\end{DoxyParamCaption})}



Construct an axis-\/aligned bounding box containing a shape undergoing a motion sampled at {\ttfamily steps} discrete momements. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of mesh vertices \\
\hline
\mbox{\texttt{ in}}  & {\em V} & function handle so that V(i,t) returns the 3d position of vertex i at time t, for t\mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em steps} & number of time steps\+: steps=3 -\/-\/\texorpdfstring{$>$}{>} t\{0,0.\+5,1\} \\
\hline
\mbox{\texttt{ out}}  & {\em box} & box containing mesh under motion \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a2df37d639d7915a6623d3dd0deecaf8a}\label{namespaceigl_a2df37d639d7915a6623d3dd0deecaf8a} 
\index{igl@{igl}!swept\_volume\_signed\_distance@{swept\_volume\_signed\_distance}}
\index{swept\_volume\_signed\_distance@{swept\_volume\_signed\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{swept\_volume\_signed\_distance()}{swept\_volume\_signed\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::swept\+\_\+volume\+\_\+signed\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const std\+::function$<$ Eigen\+::\+Affine3d(const double t)$>$ \&}]{transform,  }\item[{const size\+\_\+t \&}]{steps,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{GV,  }\item[{const Eigen\+::\+Row\+Vector3i \&}]{res,  }\item[{const double}]{h,  }\item[{const double}]{isolevel,  }\item[{const Eigen\+::\+Vector\+Xd \&}]{S0,  }\item[{Eigen\+::\+Vector\+Xd \&}]{S }\end{DoxyParamCaption})}



Compute the signed distance to a sweep surface of a mesh under-\/going an arbitrary motion V(t) discretely sampled at {\ttfamily steps}-\/many moments in time at a grid. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh positions in reference pose \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \mbox{[}0,n) \\
\hline
\mbox{\texttt{ in}}  & {\em transform} & function handle so that transform(t) returns the rigid transformation at time t\mbox{[}0,1\mbox{]} \\
\hline
\mbox{\texttt{ in}}  & {\em steps} & number of time steps\+: steps=3 -\/-\/\texorpdfstring{$>$}{>} t\{0,0.\+5,1\} \\
\hline
\mbox{\texttt{ in}}  & {\em GV} & \#\+GV by 3 list of evaluation point grid positions \\
\hline
\mbox{\texttt{ in}}  & {\em res} & 3-\/long resolution of GV grid \\
\hline
\mbox{\texttt{ in}}  & {\em h} & edge-\/length of grid \\
\hline
\mbox{\texttt{ in}}  & {\em isolevel} & isolevel to "{}focus"{} on; grid positions far enough away from isolevel (based on h) will get approximate values). Set isolevel=infinity to get good values everywhere (slow and unnecessary if just trying to extract isolevel-\/level set). \\
\hline
\mbox{\texttt{ in}}  & {\em S0} & \#\+GV initial values (will take minimum with these), can be same as S) \\
\hline
\mbox{\texttt{ out}}  & {\em S} & \#\+GV list of signed distances \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a030deb66b915a2f498701588640ee3a4}\label{namespaceigl_a030deb66b915a2f498701588640ee3a4} 
\index{igl@{igl}!swept\_volume\_signed\_distance@{swept\_volume\_signed\_distance}}
\index{swept\_volume\_signed\_distance@{swept\_volume\_signed\_distance}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{swept\_volume\_signed\_distance()}{swept\_volume\_signed\_distance()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void igl\+::swept\+\_\+volume\+\_\+signed\+\_\+distance (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const std\+::function$<$ Eigen\+::\+Affine3d(const double t)$>$ \&}]{transform,  }\item[{const size\+\_\+t \&}]{steps,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{GV,  }\item[{const Eigen\+::\+Row\+Vector3i \&}]{res,  }\item[{const double}]{h,  }\item[{const double}]{isolevel,  }\item[{Eigen\+::\+Vector\+Xd \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aca626f9c0a1f205b884fc1c6787c6a59}\label{namespaceigl_aca626f9c0a1f205b884fc1c6787c6a59} 
\index{igl@{igl}!tan\_half\_angle@{tan\_half\_angle}}
\index{tan\_half\_angle@{tan\_half\_angle}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tan\_half\_angle()}{tan\_half\_angle()}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
Scalar igl\+::tan\+\_\+half\+\_\+angle (\begin{DoxyParamCaption}\item[{const Scalar \&}]{a,  }\item[{const Scalar \&}]{b,  }\item[{const Scalar \&}]{c }\end{DoxyParamCaption})}



Compute the tangent of half of the angle opposite the side with length a, in a triangle with side lengths (a,b,c). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em a} & scalar edge length of first side of triangle \\
\hline
\mbox{\texttt{ in}}  & {\em b} & scalar edge length of second side of triangle \\
\hline
\mbox{\texttt{ in}}  & {\em c} & scalar edge length of third side of triangle \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
tangent of half of the angle opposite side with length a

is\+\_\+intrinsic\+\_\+delaunay 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ab9fcd72a6173a2c6d4e4651a706b2911}\label{namespaceigl_ab9fcd72a6173a2c6d4e4651a706b2911} 
\index{igl@{igl}!tet\_tet\_adjacency@{tet\_tet\_adjacency}}
\index{tet\_tet\_adjacency@{tet\_tet\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tet\_tet\_adjacency()}{tet\_tet\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename Derived\+TT , typename Derived\+TTi $>$ \\
void igl\+::tet\+\_\+tet\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TTi $>$ \&}]{TTi }\end{DoxyParamCaption})}



Constructs the tet\+\_\+tet adjacency matrix for a given tet mesh with tets T. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em T} & \#T by 4 list of tets \\
\hline
\mbox{\texttt{ out}}  & {\em TT} & \#T by \#4 adjacency matrix, the element i,j is the id of the tet adjacent to the j face of tet i \\
\hline
\mbox{\texttt{ out}}  & {\em TTi} & \#T by \#4 adjacency matrix, the element i,j is the id of face of the tet TT(i,j) that is adjacent to tet i\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
the first face of a tet is \mbox{[}0,1,2\mbox{]}, the second \mbox{[}0,1,3\mbox{]}, the third \mbox{[}1,2,3\mbox{]}, and the fourth \mbox{[}2,0,3\mbox{]}. 
\end{DoxyNote}
\Hypertarget{namespaceigl_ada72de8eeac466f8cb2a52016a1bd1cf}\label{namespaceigl_ada72de8eeac466f8cb2a52016a1bd1cf} 
\index{igl@{igl}!tet\_tet\_adjacency@{tet\_tet\_adjacency}}
\index{tet\_tet\_adjacency@{tet\_tet\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tet\_tet\_adjacency()}{tet\_tet\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedT , typename Derived\+TT $>$ \\
void igl\+::tet\+\_\+tet\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&}]{TT }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a09d82782b314ba8729b05712387f7ec4}\label{namespaceigl_a09d82782b314ba8729b05712387f7ec4} 
\index{igl@{igl}!tetrahedralized\_grid@{tetrahedralized\_grid}}
\index{tetrahedralized\_grid@{tetrahedralized\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tetrahedralized\_grid()}{tetrahedralized\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+GV , typename Derived\+GT $>$ \\
void igl\+::tetrahedralized\+\_\+grid (\begin{DoxyParamCaption}\item[{const int}]{nx,  }\item[{const int}]{ny,  }\item[{const int}]{nz,  }\item[{const \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}{Tetrahedralized\+Grip\+Type}}}]{type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GT $>$ \&}]{GT }\end{DoxyParamCaption})}



Construct vertices of a regular grid, suitable for input to {\ttfamily \doxylink{namespaceigl_a5512306a29939c7ac8d4ebcef2cd032a}{igl\+::marching\+\_\+tets}} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em nx} & number of grid vertices in x direction \\
\hline
\mbox{\texttt{ in}}  & {\em ny} & number of grid vertices in y direction \\
\hline
\mbox{\texttt{ in}}  & {\em nz} & number of grid vertices in z direction \\
\hline
\mbox{\texttt{ in}}  & {\em type} & type of tetrahedralization of cube to use \\
\hline
\mbox{\texttt{ out}}  & {\em GV} & nx\texorpdfstring{$\ast$}{*}ny\texorpdfstring{$\ast$}{*}nz by 3 list of grid vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em GT} & (nx-\/1)\texorpdfstring{$\ast$}{*}(ny-\/1)\texorpdfstring{$\ast$}{*}(nz-\/1)\texorpdfstring{$\ast$}{*}k by 4 list of tetrahedron indices into rows of V, where k is the number of tets per cube (dependent on type)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a3be3b842294c1e29d654ace1e4f735ca}{triangulated\+\_\+grid}, \doxylink{namespaceigl_acb165fc9bf550b7a4248ef3e4750c7b5}{quad\+\_\+grid} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ae86a7e69f97c1ca839467731e3944441}\label{namespaceigl_ae86a7e69f97c1ca839467731e3944441} 
\index{igl@{igl}!tetrahedralized\_grid@{tetrahedralized\_grid}}
\index{tetrahedralized\_grid@{tetrahedralized\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tetrahedralized\_grid()}{tetrahedralized\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedside , typename Derived\+GT $>$ \\
void igl\+::tetrahedralized\+\_\+grid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedside $>$ \&}]{side,  }\item[{const \mbox{\hyperlink{namespaceigl_ac3bae8c76c2714f3cce8b651ae93fae2}{Tetrahedralized\+Grip\+Type}}}]{type,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GT $>$ \&}]{GT }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em side} & 3-\/long list \{nx,ny,nz\} see above \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6f1fa0516e3b6395846621d6a79507e8}\label{namespaceigl_a6f1fa0516e3b6395846621d6a79507e8} 
\index{igl@{igl}!topological\_hole\_fill@{topological\_hole\_fill}}
\index{topological\_hole\_fill@{topological\_hole\_fill}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{topological\_hole\_fill()}{topological\_hole\_fill()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Vector\+Index , typename Derived\+F\+\_\+filled $>$ \\
void igl\+::topological\+\_\+hole\+\_\+fill (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const std\+::vector$<$ Vector\+Index $>$ \&}]{holes,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+F\+\_\+filled $>$ \&}]{F\+\_\+filled }\end{DoxyParamCaption})}



Topological fill hole on a mesh, with one additional vertex each hole Index of new abstract vertices will be F.\+max\+Coeff() + (index of hole) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of element indices \\
\hline
\mbox{\texttt{ in}}  & {\em holes} & vector of hole loops to fill \\
\hline
\mbox{\texttt{ out}}  & {\em F\+\_\+filled} & input F stacked with filled triangles.\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a4c72a7f89ae16b8e5196c4cd37fb2689}\label{namespaceigl_a4c72a7f89ae16b8e5196c4cd37fb2689} 
\index{igl@{igl}!trackball@{trackball}}
\index{trackball@{trackball}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{trackball()}{trackball()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::trackball (\begin{DoxyParamCaption}\item[{const double}]{w,  }\item[{const double}]{h,  }\item[{const Q\+\_\+type}]{speed\+\_\+factor,  }\item[{const double}]{down\+\_\+mouse\+\_\+x,  }\item[{const double}]{down\+\_\+mouse\+\_\+y,  }\item[{const double}]{mouse\+\_\+x,  }\item[{const double}]{mouse\+\_\+y,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{quat }\end{DoxyParamCaption})}



Applies a trackball drag to identity. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em w} & width of the trackball context \\
\hline
\mbox{\texttt{ in}}  & {\em h} & height of the trackball context \\
\hline
\mbox{\texttt{ in}}  & {\em speed\+\_\+factor} & controls how fast the trackball feels, 1 is normal \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+mouse\+\_\+x} & x position of mouse down \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+mouse\+\_\+y} & y position of mouse down \\
\hline
\mbox{\texttt{ in}}  & {\em mouse\+\_\+x} & current x position of mouse \\
\hline
\mbox{\texttt{ in}}  & {\em mouse\+\_\+y} & current y position of mouse \\
\hline
\mbox{\texttt{ out}}  & {\em quat} & the resulting rotation (as quaternion) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a46c31d9f94cfdba0d5da1b69f4f4d968}\label{namespaceigl_a46c31d9f94cfdba0d5da1b69f4f4d968} 
\index{igl@{igl}!trackball@{trackball}}
\index{trackball@{trackball}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{trackball()}{trackball()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Q\+\_\+type $>$ \\
void igl\+::trackball (\begin{DoxyParamCaption}\item[{const double}]{w,  }\item[{const double}]{h,  }\item[{const Q\+\_\+type}]{speed\+\_\+factor,  }\item[{const Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{down\+\_\+quat,  }\item[{const double}]{down\+\_\+mouse\+\_\+x,  }\item[{const double}]{down\+\_\+mouse\+\_\+y,  }\item[{const double}]{mouse\+\_\+x,  }\item[{const double}]{mouse\+\_\+y,  }\item[{Q\+\_\+type \texorpdfstring{$\ast$}{*}}]{quat }\end{DoxyParamCaption})}



Applies a trackball drag to a given rotation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em w} & width of the trackball context \\
\hline
\mbox{\texttt{ in}}  & {\em h} & height of the trackball context \\
\hline
\mbox{\texttt{ in}}  & {\em speed\+\_\+factor} & controls how fast the trackball feels, 1 is normal \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+quat} & rotation at mouse down, i.\+e. the rotation we\textquotesingle{}re applying the trackball motion to (as quaternion) \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+mouse\+\_\+x} & x position of mouse down \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+mouse\+\_\+y} & y position of mouse down \\
\hline
\mbox{\texttt{ in}}  & {\em mouse\+\_\+x} & current x position of mouse \\
\hline
\mbox{\texttt{ in}}  & {\em mouse\+\_\+y} & current y position of mouse \\
\hline
\mbox{\texttt{ out}}  & {\em quat} & the resulting rotation (as quaternion) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aaf9d8f7f6bbca5f24365f3ce5f401f9a}\label{namespaceigl_aaf9d8f7f6bbca5f24365f3ce5f401f9a} 
\index{igl@{igl}!trackball@{trackball}}
\index{trackball@{trackball}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{trackball()}{trackball()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Scalardown\+\_\+quat , typename Scalarquat $>$ \\
void igl\+::trackball (\begin{DoxyParamCaption}\item[{const double}]{w,  }\item[{const double}]{h,  }\item[{const double}]{speed\+\_\+factor,  }\item[{const Eigen\+::\+Quaternion$<$ Scalardown\+\_\+quat $>$ \&}]{down\+\_\+quat,  }\item[{const double}]{down\+\_\+mouse\+\_\+x,  }\item[{const double}]{down\+\_\+mouse\+\_\+y,  }\item[{const double}]{mouse\+\_\+x,  }\item[{const double}]{mouse\+\_\+y,  }\item[{Eigen\+::\+Quaternion$<$ Scalarquat $>$ \&}]{quat }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5fa327db1af41a1e29e474981b963409}\label{namespaceigl_a5fa327db1af41a1e29e474981b963409} 
\index{igl@{igl}!transpose\_blocks@{transpose\_blocks}}
\index{transpose\_blocks@{transpose\_blocks}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{transpose\_blocks()}{transpose\_blocks()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::transpose\+\_\+blocks (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{A,  }\item[{const size\+\_\+t}]{k,  }\item[{const size\+\_\+t}]{dim,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{B }\end{DoxyParamCaption})}



Transpose blocks of a matrix. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m\texorpdfstring{$\ast$}{*}k by n (dim\+: 1) or m by n\texorpdfstring{$\ast$}{*}k (dim\+: 2) eigen Matrix of type T values \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of blocks \\
\hline
\mbox{\texttt{ in}}  & {\em dim} & dimension in which to transpose \\
\hline
\mbox{\texttt{ out}}  & {\em B} & n\texorpdfstring{$\ast$}{*}k by m (dim\+: 1) or n by m\texorpdfstring{$\ast$}{*}k (dim\+: 2) eigen Matrix of type T values, NOT allowed to be the same as A\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md37}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md37}
A = \mbox{[} 1 2 3 4 5 6 7 8 101 102 103 104 105 106 107 108 201 202 203 204 205 206 207 208\mbox{]}; transpose\+\_\+blocks(\+A,1,3,\+B); B -\/\texorpdfstring{$>$}{>} \mbox{[} 1 5 2 6 3 7 4 8 101 105 102 106 103 107 104 108 201 205 202 206 203 207 204 208\mbox{]}; \Hypertarget{namespaceigl_a62161fdfef57c22542b38d735550b635}\label{namespaceigl_a62161fdfef57c22542b38d735550b635} 
\index{igl@{igl}!tri\_tri\_overlap\_test\_3d@{tri\_tri\_overlap\_test\_3d}}
\index{tri\_tri\_overlap\_test\_3d@{tri\_tri\_overlap\_test\_3d}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tri\_tri\_overlap\_test\_3d()}{tri\_tri\_overlap\_test\_3d()}}
{\footnotesize\ttfamily template$<$typename Derived\+P1 , typename Derived\+Q1 , typename Derived\+R1 , typename Derived\+P2 , typename Derived\+Q2 , typename Derived\+R2 $>$ \\
bool igl\+::tri\+\_\+tri\+\_\+overlap\+\_\+test\+\_\+3d (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P1 $>$ \&}]{p1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Q1 $>$ \&}]{q1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+R1 $>$ \&}]{r1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P2 $>$ \&}]{p2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Q2 $>$ \&}]{q2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+R2 $>$ \&}]{r2 }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a56ff893a73c2642eeec2692d37aad4d0}\label{namespaceigl_a56ff893a73c2642eeec2692d37aad4d0} 
\index{igl@{igl}!tri\_tri\_intersection\_test\_3d@{tri\_tri\_intersection\_test\_3d}}
\index{tri\_tri\_intersection\_test\_3d@{tri\_tri\_intersection\_test\_3d}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tri\_tri\_intersection\_test\_3d()}{tri\_tri\_intersection\_test\_3d()}}
{\footnotesize\ttfamily template$<$typename Derived\+P1 , typename Derived\+Q1 , typename Derived\+R1 , typename Derived\+P2 , typename Derived\+Q2 , typename Derived\+R2 , typename DerivedS , typename DerivedT $>$ \\
bool igl\+::tri\+\_\+tri\+\_\+intersection\+\_\+test\+\_\+3d (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P1 $>$ \&}]{p1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Q1 $>$ \&}]{q1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+R1 $>$ \&}]{r1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P2 $>$ \&}]{p2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Q2 $>$ \&}]{q2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+R2 $>$ \&}]{r2,  }\item[{bool \&}]{coplanar,  }\item[{Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{source,  }\item[{Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{target }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_ac4e80369c0a74cc009ec973dd70fd752}\label{namespaceigl_ac4e80369c0a74cc009ec973dd70fd752} 
\index{igl@{igl}!tri\_tri\_overlap\_test\_2d@{tri\_tri\_overlap\_test\_2d}}
\index{tri\_tri\_overlap\_test\_2d@{tri\_tri\_overlap\_test\_2d}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{tri\_tri\_overlap\_test\_2d()}{tri\_tri\_overlap\_test\_2d()}}
{\footnotesize\ttfamily template$<$typename Derived\+P1 , typename Derived\+Q1 , typename Derived\+R1 , typename Derived\+P2 , typename Derived\+Q2 , typename Derived\+R2 $>$ \\
bool igl\+::tri\+\_\+tri\+\_\+overlap\+\_\+test\+\_\+2d (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P1 $>$ \&}]{p1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Q1 $>$ \&}]{q1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+R1 $>$ \&}]{r1,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+P2 $>$ \&}]{p2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+Q2 $>$ \&}]{q2,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+R2 $>$ \&}]{r2 }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a9ce1a2b984f20466ffc7732ab29501ba}\label{namespaceigl_a9ce1a2b984f20466ffc7732ab29501ba} 
\index{igl@{igl}!triangle\_fan@{triangle\_fan}}
\index{triangle\_fan@{triangle\_fan}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_fan()}{triangle\_fan()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedE , typename Derivedcap $>$ \\
void igl\+::triangle\+\_\+fan (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedcap $>$ \&}]{cap }\end{DoxyParamCaption})}



Given a list of faces tessellate all of the "{}exterior"{} edges forming another list of. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em E} & \#E by simplex\+\_\+size-\/1 list of exterior edges (see \doxylink{exterior__edges_8h}{exterior\+\_\+edges.\+h}) \\
\hline
\mbox{\texttt{ out}}  & {\em cap} & \#cap by simplex\+\_\+size list of "{}faces"{} tessellating the boundary edges \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a6b17a92c69587c651fe1b4d549235a9d}\label{namespaceigl_a6b17a92c69587c651fe1b4d549235a9d} 
\index{igl@{igl}!triangle\_fan@{triangle\_fan}}
\index{triangle\_fan@{triangle\_fan}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_fan()}{triangle\_fan()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Eigen\+::\+Matrix\+Xi igl\+::triangle\+\_\+fan (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ae07b1e4d35569138ffa0d8a874f0e24f}\label{namespaceigl_ae07b1e4d35569138ffa0d8a874f0e24f} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+TT , typename Derived\+TTi $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&}]{TT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TTi $>$ \&}]{TTi }\end{DoxyParamCaption})}



Constructs the triangle-\/triangle adjacency matrix for a given mesh (V,F). 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em TT} & \#F by \#3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i \\
\hline
\mbox{\texttt{ out}}  & {\em TTi} & \#F by \#3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
the first edge of a triangle is \mbox{[}0,1\mbox{]} the second \mbox{[}1,2\mbox{]} and the third \mbox{[}2,3\mbox{]}. This convention is DIFFERENT from \doxylink{cotmatrix__entries_8h}{cotmatrix\+\_\+entries.\+h}/edge\+\_\+lengths.h/etc. To fix this you could use\+:
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Fix\ mis-\/match\ convention}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ Eigen::PermutationMatrix<3,3>\ perm(3);}
\DoxyCodeLine{\ \ perm.indices()\ =\ Eigen::Vector3i(1,2,0);}
\DoxyCodeLine{\ \ TT\ =\ (TT*perm).eval();}
\DoxyCodeLine{\ \ TTi\ =\ (TTi*perm).eval();}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i=0;i<TTi.rows();i++)}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ j=0;j<TTi.cols();j++)}
\DoxyCodeLine{\ \ \ \ \ \ TTi(i,j)=TTi(i,j)==-\/1?-\/1:(TTi(i,j)+3-\/1)\%3;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_a7210f2492117b1c482907e6a47dbed75}\label{namespaceigl_a7210f2492117b1c482907e6a47dbed75} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+TT $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&}]{TT }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_add74393b2dabd37b8efd0a7c2145372a}\label{namespaceigl_add74393b2dabd37b8efd0a7c2145372a} 
\index{igl@{igl}!triangle\_triangle\_adjacency\_preprocess@{triangle\_triangle\_adjacency\_preprocess}}
\index{triangle\_triangle\_adjacency\_preprocess@{triangle\_triangle\_adjacency\_preprocess}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency\_preprocess()}{triangle\_triangle\_adjacency\_preprocess()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename TTT\+\_\+type $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency\+\_\+preprocess (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ TTT\+\_\+type $>$ $>$ \&}]{TTT }\end{DoxyParamCaption})}



Preprocessing for triangle\+\_\+triangle\+\_\+adjacency. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em TT} & \#F by \#3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i\\
\hline
\end{DoxyParams}
\doxylink{triangle__triangle__adjacency_8h}{include/igl/triangle\+\_\+triangle\+\_\+adjacency.\+h} \Hypertarget{namespaceigl_a45cd01351200f4312c4fa5abef9c63a1}\label{namespaceigl_a45cd01351200f4312c4fa5abef9c63a1} 
\index{igl@{igl}!triangle\_triangle\_adjacency\_extractTT@{triangle\_triangle\_adjacency\_extractTT}}
\index{triangle\_triangle\_adjacency\_extractTT@{triangle\_triangle\_adjacency\_extractTT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency\_extractTT()}{triangle\_triangle\_adjacency\_extractTT()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename TTT\+\_\+type , typename Derived\+TT $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency\+\_\+extract\+TT (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ TTT\+\_\+type $>$ $>$ \&}]{TTT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TT $>$ \&}]{TT }\end{DoxyParamCaption})}



Extract the face adjacencies for triangle\+\_\+triangle\+\_\+adjacency. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em TTT} & \#F list of lists adjacent triangles \\
\hline
\mbox{\texttt{ in}}  & {\em TT} & \#F by \#3 adjacentmatrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i\\
\hline
\end{DoxyParams}
\doxylink{triangle__triangle__adjacency_8h}{include/igl/triangle\+\_\+triangle\+\_\+adjacency.\+h} \Hypertarget{namespaceigl_a81887c23c0079fb92f46a517cd42f752}\label{namespaceigl_a81887c23c0079fb92f46a517cd42f752} 
\index{igl@{igl}!triangle\_triangle\_adjacency\_extractTTi@{triangle\_triangle\_adjacency\_extractTTi}}
\index{triangle\_triangle\_adjacency\_extractTTi@{triangle\_triangle\_adjacency\_extractTTi}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency\_extractTTi()}{triangle\_triangle\_adjacency\_extractTTi()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename TTT\+\_\+type , typename Derived\+TTi $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency\+\_\+extract\+TTi (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ TTT\+\_\+type $>$ $>$ \&}]{TTT,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+TTi $>$ \&}]{TTi }\end{DoxyParamCaption})}



Extract the face adjacencies indices for triangle\+\_\+triangle\+\_\+adjacency. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex\+\_\+size list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ in}}  & {\em TTT} & \#F list of lists adjacent triangles \\
\hline
\mbox{\texttt{ out}}  & {\em TTi} & \#F by \#3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i\\
\hline
\end{DoxyParams}
\doxylink{triangle__triangle__adjacency_8h}{include/igl/triangle\+\_\+triangle\+\_\+adjacency.\+h} \Hypertarget{namespaceigl_a99e6fd086c1507cb6b02df0b458566cd}\label{namespaceigl_a99e6fd086c1507cb6b02df0b458566cd} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename TTIndex , typename TTi\+Index $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&}]{TT,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&}]{TTi }\end{DoxyParamCaption})}



Adjacency list version, which works with non-\/manifold meshes. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em TT} & \#F by 3 list of lists so that TT\mbox{[}i\mbox{]}\mbox{[}c\mbox{]} -\/-\/\texorpdfstring{$>$}{>} \{j,k,...\} means that faces j and k etc. are edge-\/neighbors of face i on face i\textquotesingle{}s edge opposite corner c \\
\hline
\mbox{\texttt{ out}}  & {\em TTj} & \#F list of lists so that TTj\mbox{[}i\mbox{]}\mbox{[}c\mbox{]} -\/-\/\texorpdfstring{$>$}{>} \{j,k,...\} means that face TT\mbox{[}i\mbox{]}\mbox{[}c\mbox{]}\mbox{[}0\mbox{]} is an edge-\/neighbor of face i incident on the edge of face TT\mbox{[}i\mbox{]}\mbox{[}c\mbox{]}\mbox{[}0\mbox{]} opposite corner j, and TT\mbox{[}i\mbox{]}\mbox{[}c\mbox{]}\mbox{[}1\mbox{]} "{} corner k, etc. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a5ea1a1ba3c8bee980c00db518fb9f443}\label{namespaceigl_a5ea1a1ba3c8bee980c00db518fb9f443} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename TTIndex $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&}]{TT }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad091a40b270aa5030a3dd0909e6402e6}\label{namespaceigl_ad091a40b270aa5030a3dd0909e6402e6} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename TTIndex , typename TTi\+Index $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const bool}]{construct\+\_\+\+TTi,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&}]{TT,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&}]{TTi }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_ab979438c0daba73490363a56fc67f54a}\label{namespaceigl_ab979438c0daba73490363a56fc67f54a} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename DerivedE , typename Derived\+EMAP , typename u\+E2\+EType , typename TTIndex , typename TTi\+Index $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E,  }\item[{const bool}]{construct\+\_\+\+TTi,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&}]{TT,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&}]{TTi }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em E} & \#F\texorpdfstring{$\ast$}{*}3 by 2 list of all of directed edges in order (see {\ttfamily oriented\+\_\+facets}) \\
\hline
\mbox{\texttt{ in}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique undirected edge \\
\hline
\mbox{\texttt{ in}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges \\
\hline
\mbox{\texttt{ in}}  & {\em construct\+\_\+\+TTi} & whether to compute TTi\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}{unique\+\_\+edge\+\_\+map}, \doxylink{namespaceigl_a3f9293ec84689fd8949325ccb22d55fb}{oriented\+\_\+facets} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_afc80c379b811624a97c1ed29ba4df0fb}\label{namespaceigl_afc80c379b811624a97c1ed29ba4df0fb} 
\index{igl@{igl}!triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}}
\index{triangle\_triangle\_adjacency@{triangle\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangle\_triangle\_adjacency()}{triangle\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE , typename TTIndex , typename TTi\+Index $>$ \\
void igl\+::triangle\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE,  }\item[{const bool}]{construct\+\_\+\+TTi,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTIndex $>$ $>$ $>$ \&}]{TT,  }\item[{std\+::vector$<$ std\+::vector$<$ std\+::vector$<$ TTi\+Index $>$ $>$ $>$ \&}]{TTi }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em u\+EC} & \#uE+1 list of cumulative counts of directed edges sharing each unique edge so the u\+EC(i+1)-\/u\+EC(i) is the number of directed edges sharing the ith unique edge. \\
\hline
\mbox{\texttt{ in}}  & {\em u\+EE} & \#E list of indices into E, so that the consecutive segment of indices u\+EE.\+segment(u\+EC(i),u\+EC(i+1)-\/u\+EC(i)) lists all directed edges sharing the ith unique edge. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae67465786e131443ebdb6bdae0aa701f}\label{namespaceigl_ae67465786e131443ebdb6bdae0aa701f} 
\index{igl@{igl}!triangles\_from\_strip@{triangles\_from\_strip}}
\index{triangles\_from\_strip@{triangles\_from\_strip}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangles\_from\_strip()}{triangles\_from\_strip()}}
{\footnotesize\ttfamily template$<$typename DerivedS , typename DerivedF $>$ \\
void igl\+::triangles\+\_\+from\+\_\+strip (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedS $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Create a list of triangles from a stream of indices along a strip. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em S} & \#S list of indices \\
\hline
\mbox{\texttt{ out}}  & {\em F} & \#S-\/2 by 3 list of triangle indices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a3be3b842294c1e29d654ace1e4f735ca}\label{namespaceigl_a3be3b842294c1e29d654ace1e4f735ca} 
\index{igl@{igl}!triangulated\_grid@{triangulated\_grid}}
\index{triangulated\_grid@{triangulated\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangulated\_grid()}{triangulated\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename XType , typename YType , typename Derived\+GV , typename Derived\+GF $>$ \\
void igl\+::triangulated\+\_\+grid (\begin{DoxyParamCaption}\item[{const XType \&}]{nx,  }\item[{const YType \&}]{ny,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GF $>$ \&}]{GF }\end{DoxyParamCaption})}



Create a regular grid of elements (only 2D supported, currently) Vertex position order is compatible with {\ttfamily \doxylink{namespaceigl_adfb4bab2b437369dce2059e85836bd9a}{igl\+::grid}} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em nx} & number of vertices in the x direction \\
\hline
\mbox{\texttt{ in}}  & {\em ny} & number of vertices in the y direction \\
\hline
\mbox{\texttt{ out}}  & {\em GV} & nx\texorpdfstring{$\ast$}{*}ny by 2 list of mesh vertex positions. \\
\hline
\mbox{\texttt{ out}}  & {\em GF} & 2\texorpdfstring{$\ast$}{*}(nx-\/1)\texorpdfstring{$\ast$}{*}(ny-\/1) by 3 list of triangle indices\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_adfb4bab2b437369dce2059e85836bd9a}{grid}, \doxylink{namespaceigl_acb165fc9bf550b7a4248ef3e4750c7b5}{quad\+\_\+grid} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a82c16be739961936bc5159688a4c7683}\label{namespaceigl_a82c16be739961936bc5159688a4c7683} 
\index{igl@{igl}!triangulated\_grid@{triangulated\_grid}}
\index{triangulated\_grid@{triangulated\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{triangulated\_grid()}{triangulated\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename XType , typename YType , typename Derived\+GF $>$ \\
void igl\+::triangulated\+\_\+grid (\begin{DoxyParamCaption}\item[{const XType \&}]{nx,  }\item[{const YType \&}]{ny,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GF $>$ \&}]{GF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a38fd083e49162fe9dfe2e1de54948c89}\label{namespaceigl_a38fd083e49162fe9dfe2e1de54948c89} 
\index{igl@{igl}!turning\_number@{turning\_number}}
\index{turning\_number@{turning\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{turning\_number()}{turning\_number()}}
{\footnotesize\ttfamily template$<$typename DerivedV $>$ \\
Derived\+V\+::\+Scalar igl\+::turning\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V }\end{DoxyParamCaption})}



Compute the turning number of a closed curve in the plane. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 2 list of vertex positions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
tn turning number 
\end{DoxyReturn}
\Hypertarget{namespaceigl_aaef42c6f3251414c7485b4d1433a54e4}\label{namespaceigl_aaef42c6f3251414c7485b4d1433a54e4} 
\index{igl@{igl}!two\_axis\_valuator\_fixed\_up@{two\_axis\_valuator\_fixed\_up}}
\index{two\_axis\_valuator\_fixed\_up@{two\_axis\_valuator\_fixed\_up}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{two\_axis\_valuator\_fixed\_up()}{two\_axis\_valuator\_fixed\_up()}}
{\footnotesize\ttfamily template$<$typename Scalardown\+\_\+quat , typename Scalarquat $>$ \\
void igl\+::two\+\_\+axis\+\_\+valuator\+\_\+fixed\+\_\+up (\begin{DoxyParamCaption}\item[{const int}]{w,  }\item[{const int}]{h,  }\item[{const double}]{speed,  }\item[{const Eigen\+::\+Quaternion$<$ Scalardown\+\_\+quat $>$ \&}]{down\+\_\+quat,  }\item[{const int}]{down\+\_\+x,  }\item[{const int}]{down\+\_\+y,  }\item[{const int}]{mouse\+\_\+x,  }\item[{const int}]{mouse\+\_\+y,  }\item[{Eigen\+::\+Quaternion$<$ Scalarquat $>$ \&}]{quat }\end{DoxyParamCaption})}



Applies a two-\/axis valuator drag rotation (as seen in Maya/\+Studio max) to a given rotation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em w} & width of the trackball context \\
\hline
\mbox{\texttt{ in}}  & {\em h} & height of the trackball context \\
\hline
\mbox{\texttt{ in}}  & {\em speed} & controls how fast the trackball feels, 1 is normal \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+quat} & rotation at mouse down, i.\+e. the rotation we\textquotesingle{}re applying the trackball motion to (as quaternion). {\bfseries{Note\+:}} Up-\/vector that is fixed is with respect to this rotation. \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+x} & position of mouse down \\
\hline
\mbox{\texttt{ in}}  & {\em down\+\_\+y} & position of mouse down \\
\hline
\mbox{\texttt{ in}}  & {\em mouse\+\_\+x} & current x position of mouse \\
\hline
\mbox{\texttt{ in}}  & {\em mouse\+\_\+y} & current y position of mouse \\
\hline
\mbox{\texttt{ out}}  & {\em quat} & the resulting rotation (as quaternion)\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_af6de4ebdb7f531d96fb57a566e0d121c}{snap\+\_\+to\+\_\+fixed\+\_\+up} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a653da1c359295934ee69235ad8d43db4}\label{namespaceigl_a653da1c359295934ee69235ad8d43db4} 
\index{igl@{igl}!uniformly\_sample\_two\_manifold@{uniformly\_sample\_two\_manifold}}
\index{uniformly\_sample\_two\_manifold@{uniformly\_sample\_two\_manifold}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{uniformly\_sample\_two\_manifold()}{uniformly\_sample\_two\_manifold()}}
{\footnotesize\ttfamily void igl\+::uniformly\+\_\+sample\+\_\+two\+\_\+manifold (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const int}]{k,  }\item[{const double}]{push,  }\item[{Eigen\+::\+Matrix\+Xd \&}]{WS }\end{DoxyParamCaption})}



Attempt to sample a mesh uniformly with k-\/points by furthest point relaxation as described in "{}\+Fast Automatic Skinning Transformations"{} \mbox{[}Jacobson et al. 

12\mbox{]} Section 3.\+3. The input is not expected to be a typical 3D triangle mesh (e.\+g., \mbox{[}V,F\mbox{]}), instead each vertex is embedded in a high dimensional unit-\/hypercude ("{}weight space"{}) defined by W, with triangles given by F. This algorithm will first conduct furthest point sampling from the set of vertices and then attempt to relax the sampled points along the surface of the high-\/dimensional triangle mesh (i.\+e., the output points may be in the middle of triangles, not just at vertices). An additional "{}push"{} factor will repel samples away from the corners of the hypercube.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em W} & \#W by dim positions of mesh in weight space \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 indices of triangles \\
\hline
\mbox{\texttt{ in}}  & {\em k} & number of samples \\
\hline
\mbox{\texttt{ in}}  & {\em push} & factor by which corners should be pushed away \\
\hline
\mbox{\texttt{ out}}  & {\em WS} & k by dim locations in weight space\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a1fc88d96c492e3bf962501af8bea413e}{random\+\_\+points\+\_\+on\+\_\+mesh} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ad17a2faf487e7a4ee375842967d6b285}\label{namespaceigl_ad17a2faf487e7a4ee375842967d6b285} 
\index{igl@{igl}!uniformly\_sample\_two\_manifold\_at\_vertices@{uniformly\_sample\_two\_manifold\_at\_vertices}}
\index{uniformly\_sample\_two\_manifold\_at\_vertices@{uniformly\_sample\_two\_manifold\_at\_vertices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{uniformly\_sample\_two\_manifold\_at\_vertices()}{uniformly\_sample\_two\_manifold\_at\_vertices()}}
{\footnotesize\ttfamily void igl\+::uniformly\+\_\+sample\+\_\+two\+\_\+manifold\+\_\+at\+\_\+vertices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{W,  }\item[{const int}]{k,  }\item[{const double}]{push,  }\item[{Eigen\+::\+Vector\+Xi \&}]{S }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.

\doxylink{uniformly__sample__two__manifold_8h}{include/igl/uniformly\+\_\+sample\+\_\+two\+\_\+manifold.\+h}. 

\Hypertarget{namespaceigl_a45aa8c440aeb5e9aab5fb79156197153}\label{namespaceigl_a45aa8c440aeb5e9aab5fb79156197153} 
\index{igl@{igl}!unique@{unique}}
\index{unique@{unique}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::unique (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{A,  }\item[{std\+::vector$<$ T $>$ \&}]{C,  }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{IA,  }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{IC }\end{DoxyParamCaption})}



Act like matlab\textquotesingle{}s \mbox{[}C,IA,IC\mbox{]} = unique(\+X) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & comparable type T \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#A vector of type T \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C vector of unique entries in A \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & \#C index vector so that C = A(\+IA); \\
\hline
\mbox{\texttt{ out}}  & {\em IC} & \#A index vector so that A = C(\+IC); \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ae97cc0b7a30e7285c6375d63fca2946c}\label{namespaceigl_ae97cc0b7a30e7285c6375d63fca2946c} 
\index{igl@{igl}!unique@{unique}}
\index{unique@{unique}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::unique (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{A,  }\item[{std\+::vector$<$ T $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a715dcc29e1a1beb8b358ebd275765fbb}\label{namespaceigl_a715dcc29e1a1beb8b358ebd275765fbb} 
\index{igl@{igl}!unique@{unique}}
\index{unique@{unique}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedC , typename Derived\+IA , typename Derived\+IC $>$ \\
void igl\+::unique (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IC $>$ \&}]{IC }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a03a554daf5ff87c8e4661b250e0078ce}\label{namespaceigl_a03a554daf5ff87c8e4661b250e0078ce} 
\index{igl@{igl}!unique@{unique}}
\index{unique@{unique}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique()}{unique()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedC $>$ \\
void igl\+::unique (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2}\label{namespaceigl_a5ec9f63d03451613c1a56df8308fe4b2} 
\index{igl@{igl}!unique\_edge\_map@{unique\_edge\_map}}
\index{unique\_edge\_map@{unique\_edge\_map}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique\_edge\_map()}{unique\_edge\_map()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename u\+E2\+EType $>$ \\
void igl\+::unique\+\_\+edge\+\_\+map (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{std\+::vector$<$ std\+::vector$<$ u\+E2\+EType $>$ $>$ \&}]{u\+E2E }\end{DoxyParamCaption})}



Construct relationships between facet "{}half"{}-\/(or rather "{}viewed"{})-\/edges E to unique edges of the mesh seen as a graph. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of simplices \\
\hline
\mbox{\texttt{ out}}  & {\em E} & \#F\texorpdfstring{$\ast$}{*}3 by 2 list of all directed edges, such that E.\+row(f+\#F\texorpdfstring{$\ast$}{*}c) is the edge opposite F(f,c) \\
\hline
\mbox{\texttt{ out}}  & {\em uE} & \#uE by 2 list of unique undirected edges \\
\hline
\mbox{\texttt{ out}}  & {\em EMAP} & \#F\texorpdfstring{$\ast$}{*}3 list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+\#F\texorpdfstring{$\ast$}{*}c)) is the unique edge corresponding to E.\+row(f+\#F\texorpdfstring{$\ast$}{*}c) \\
\hline
\mbox{\texttt{ out}}  & {\em u\+E2E} & \#uE list of lists of indices into E of coexisting edges, so that E.\+row(u\+E2\+E\mbox{[}i\mbox{]}\mbox{[}j\mbox{]}) corresponds to u\+E.\+row(i) for all j in 0..u\+E2E\mbox{[}i\mbox{]}.size()-\/1. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a386a94bc8aaf45b2eb84b355d2bff311}\label{namespaceigl_a386a94bc8aaf45b2eb84b355d2bff311} 
\index{igl@{igl}!unique\_edge\_map@{unique\_edge\_map}}
\index{unique\_edge\_map@{unique\_edge\_map}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique\_edge\_map()}{unique\_edge\_map()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP $>$ \\
void igl\+::unique\+\_\+edge\+\_\+map (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a50a5bc29088ffa37e630cf9fd0d92c66}\label{namespaceigl_a50a5bc29088ffa37e630cf9fd0d92c66} 
\index{igl@{igl}!unique\_edge\_map@{unique\_edge\_map}}
\index{unique\_edge\_map@{unique\_edge\_map}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique\_edge\_map()}{unique\_edge\_map()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedE , typename DeriveduE , typename Derived\+EMAP , typename Derivedu\+EC , typename Derivedu\+EE $>$ \\
void igl\+::unique\+\_\+edge\+\_\+map (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DeriveduE $>$ \&}]{uE,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+EMAP $>$ \&}]{EMAP,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EC $>$ \&}]{u\+EC,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedu\+EE $>$ \&}]{u\+EE }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

It is usual much faster if your algorithm can be written in terms of (u\+EC,u\+EE) rather than (u\+E2E).


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em u\+EC} & \#uE+1 list of cumulative counts of directed edges sharing each unique edge so the u\+EC(i+1)-\/u\+EC(i) is the number of directed edges sharing the ith unique edge. \\
\hline
\mbox{\texttt{ out}}  & {\em u\+EE} & \#E list of indices into E, so that the consecutive segment of indices u\+EE.\+segment(u\+EC(i),u\+EC(i+1)-\/u\+EC(i)) lists all directed edges sharing the ith unique edge.\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md38}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md38}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Using\ uE2E}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ u\ =\ 0;u<uE2E.size();u++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ i\ =\ 0;i<uE2E[u].size();i++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ eth\ directed-\/edge\ is\ ith\ edge\ equivalent\ to\ uth\ undirected\ edge}}
\DoxyCodeLine{\ \ \ \ e\ =\ uE2E[u][i];\ }
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Using\ uEC,uEE}}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ u\ =\ 0;u<uE.size();u++)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ j\ =\ uEC(u);j<uEC(u+1);j++)}
\DoxyCodeLine{\ \ \{}
\DoxyCodeLine{\ \ \ \ e\ =\ uEE(j);\ \textcolor{comment}{//\ i\ =\ j-\/uEC(u);}}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 \Hypertarget{namespaceigl_adc1388186f7f12be43df64d7ad45a136}\label{namespaceigl_adc1388186f7f12be43df64d7ad45a136} 
\index{igl@{igl}!unique\_rows@{unique\_rows}}
\index{unique\_rows@{unique\_rows}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique\_rows()}{unique\_rows()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedC , typename Derived\+IA , typename Derived\+IC $>$ \\
void igl\+::unique\+\_\+rows (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Dense\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IC $>$ \&}]{IC }\end{DoxyParamCaption})}



Act like matlab\textquotesingle{}s \mbox{[}C,IA,IC\mbox{]} = unique(X,\textquotesingle{}rows\textquotesingle{}) 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedA} & derived scalar type, e.\+g. Matrix\+Xi or Matrix\+Xd \\
\hline
{\em Derived\+IA} & derived integer type, e.\+g. Matrix\+Xi \\
\hline
{\em Derived\+IC} & derived integer type, e.\+g. Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & m by n matrix whose entries are to unique\textquotesingle{}d according to rows \\
\hline
\mbox{\texttt{ out}}  & {\em C} & \#C vector of unique rows in A \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & \#C index vector so that C = A(\+IA,\+:); \\
\hline
\mbox{\texttt{ out}}  & {\em IC} & \#A index vector so that A = C(\+IC,\+:); \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a23358af3f14021f32e9d30758f80a9a7}\label{namespaceigl_a23358af3f14021f32e9d30758f80a9a7} 
\index{igl@{igl}!unique\_simplices@{unique\_simplices}}
\index{unique\_simplices@{unique\_simplices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique\_simplices()}{unique\_simplices()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+FF , typename Derived\+IA , typename Derived\+IC $>$ \\
void igl\+::unique\+\_\+simplices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IA $>$ \&}]{IA,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+IC $>$ \&}]{IC }\end{DoxyParamCaption})}



Find {\itshape combinatorially} unique simplices in F. 

{\bfseries{Order independent}}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by simplex-\/size list of simplices \\
\hline
\mbox{\texttt{ out}}  & {\em FF} & \#\+FF by simplex-\/size list of unique simplices in F \\
\hline
\mbox{\texttt{ out}}  & {\em IA} & \#\+FF index vector so that FF == sort(\+F(\+IA,\+:),2); \\
\hline
\mbox{\texttt{ out}}  & {\em IC} & \#F index vector so that sort(\+F,2) == FF(\+IC,\+:); \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a20ecb806162f1bbe1260c630e8bb941d}\label{namespaceigl_a20ecb806162f1bbe1260c630e8bb941d} 
\index{igl@{igl}!unique\_simplices@{unique\_simplices}}
\index{unique\_simplices@{unique\_simplices}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unique\_simplices()}{unique\_simplices()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+FF $>$ \\
void igl\+::unique\+\_\+simplices (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+FF $>$ \&}]{FF }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a04b29a2138c5fa4268400e42b8df04a9}\label{namespaceigl_a04b29a2138c5fa4268400e42b8df04a9} 
\index{igl@{igl}!unproject@{unproject}}
\index{unproject@{unproject}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject()}{unproject()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derivedwin , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Derivedscene $>$ \\
void igl\+::unproject (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedwin $>$ \&}]{win,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedmodel $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedproj $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedviewport $>$ \&}]{viewport,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedscene $>$ \&}]{scene }\end{DoxyParamCaption})}



Eigen reimplementation of glu\+Unproject. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em win} & \#P by 3 or 3-\/vector (\#P=1) of screen space x, y, and z coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em model} & 4x4 model-\/view matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & 4x4 projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & 4-\/long viewport vector \\
\hline
\mbox{\texttt{ out}}  & {\em scene} & \#P by 3 or 3-\/vector (\#P=1) the unprojected x, y, and z coordinates\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ac545f7c2b0b725169a3785ba8e5bdbc2}\label{namespaceigl_ac545f7c2b0b725169a3785ba8e5bdbc2} 
\index{igl@{igl}!unproject@{unproject}}
\index{unproject@{unproject}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject()}{unproject()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ igl\+::unproject (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ Scalar, 3, 1 $>$ \&}]{win,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 4, 4 $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, 4, 1 $>$ \&}]{viewport }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_adec5b69e885a84437436bde2e86bb09a}\label{namespaceigl_adec5b69e885a84437436bde2e86bb09a} 
\index{igl@{igl}!unproject\_in\_mesh@{unproject\_in\_mesh}}
\index{unproject\_in\_mesh@{unproject\_in\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_in\_mesh()}{unproject\_in\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedobj $>$ \\
int igl\+::unproject\+\_\+in\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector2f \&}]{pos,  }\item[{const Eigen\+::\+Matrix4f \&}]{model,  }\item[{const Eigen\+::\+Matrix4f \&}]{proj,  }\item[{const Eigen\+::\+Vector4f \&}]{viewport,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedobj $>$ \&}]{obj,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&}]{hits }\end{DoxyParamCaption})}



Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position {\itshape inside} a given mesh. 

If the ray through the given screen location (x,y) {\itshape hits} the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pos} & screen space coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em model} & model matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & vieweport vector \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em obj} & 3d unprojected mouse point in mesh \\
\hline
\mbox{\texttt{ out}}  & {\em hits} & vector of hits \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of hits 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a25fc2d8b2c9e58a5006fe7f8ea6308ec}\label{namespaceigl_a25fc2d8b2c9e58a5006fe7f8ea6308ec} 
\index{igl@{igl}!unproject\_in\_mesh@{unproject\_in\_mesh}}
\index{unproject\_in\_mesh@{unproject\_in\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_in\_mesh()}{unproject\_in\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedobj $>$ \\
int igl\+::unproject\+\_\+in\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector2f \&}]{pos,  }\item[{const Eigen\+::\+Matrix4f \&}]{model,  }\item[{const Eigen\+::\+Matrix4f \&}]{proj,  }\item[{const Eigen\+::\+Vector4f \&}]{viewport,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedobj $>$ \&}]{obj }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a86f5bf3b46d4f04f8189b0a5b489e4bb}\label{namespaceigl_a86f5bf3b46d4f04f8189b0a5b489e4bb} 
\index{igl@{igl}!unproject\_in\_mesh@{unproject\_in\_mesh}}
\index{unproject\_in\_mesh@{unproject\_in\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_in\_mesh()}{unproject\_in\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Derivedobj $>$ \\
int igl\+::unproject\+\_\+in\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector2f \&}]{pos,  }\item[{const Eigen\+::\+Matrix4f \&}]{model,  }\item[{const Eigen\+::\+Matrix4f \&}]{proj,  }\item[{const Eigen\+::\+Vector4f \&}]{viewport,  }\item[{const std\+::function$<$ void(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&, std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&) $>$ \&}]{shoot\+\_\+ray,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedobj $>$ \&}]{obj,  }\item[{std\+::vector$<$ \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} $>$ \&}]{hits }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em shoot\+\_\+ray} & function handle that outputs first hit of a given ray against a mesh (embedded in function handles as captured variable/data) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a28d4df676266aad88e2fad4b43a0777c}\label{namespaceigl_a28d4df676266aad88e2fad4b43a0777c} 
\index{igl@{igl}!unproject\_on\_line@{unproject\_on\_line}}
\index{unproject\_on\_line@{unproject\_on\_line}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_on\_line()}{unproject\_on\_line()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename Derivedorigin , typename Deriveddir $>$ \\
void igl\+::unproject\+\_\+on\+\_\+line (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&}]{VP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedorigin $>$ \&}]{origin,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{dir,  }\item[{typename Derived\+UV\+::\+Scalar \&}]{t }\end{DoxyParamCaption})}



Given a screen space point (u,v) and the current projection matrix (e.\+g. 

gl\+\_\+proj \texorpdfstring{$\ast$}{*} gl\+\_\+modelview) and viewport, {\itshape unproject} the point into the scene so that it lies on given line (origin and dir) and projects as closely as possible to the given screen space point.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em UV} & 2-\/long uv-\/coordinates of screen space point \\
\hline
\mbox{\texttt{ in}}  & {\em M} & 4 by 4 projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em VP} & 4-\/long viewport\+: (corner\+\_\+u, corner\+\_\+v, width, height) \\
\hline
\mbox{\texttt{ in}}  & {\em origin} & point on line \\
\hline
\mbox{\texttt{ in}}  & {\em dir} & vector parallel to line \\
\hline
\mbox{\texttt{ out}}  & {\em t} & line parameter so that closest poin on line to viewer ray through UV lies at origin+t\texorpdfstring{$\ast$}{*}dir \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_addb8ea814628c47819f95f70ed6ff5d8}\label{namespaceigl_addb8ea814628c47819f95f70ed6ff5d8} 
\index{igl@{igl}!unproject\_on\_line@{unproject\_on\_line}}
\index{unproject\_on\_line@{unproject\_on\_line}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_on\_line()}{unproject\_on\_line()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename Derivedorigin , typename Deriveddir , typename DerivedZ $>$ \\
void igl\+::unproject\+\_\+on\+\_\+line (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&}]{VP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedorigin $>$ \&}]{origin,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Deriveddir $>$ \&}]{dir,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&}]{Z }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ out}}  & {\em Z} & 3d position of closest point on line to viewing ray through UV \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a0cf2e9896877756fbe8f09c0b051e76d}\label{namespaceigl_a0cf2e9896877756fbe8f09c0b051e76d} 
\index{igl@{igl}!unproject\_on\_plane@{unproject\_on\_plane}}
\index{unproject\_on\_plane@{unproject\_on\_plane}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_on\_plane()}{unproject\_on\_plane()}}
{\footnotesize\ttfamily template$<$typename Derived\+UV , typename DerivedM , typename Derived\+VP , typename DerivedP , typename DerivedZ $>$ \\
void igl\+::unproject\+\_\+on\+\_\+plane (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedM $>$ \&}]{M,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VP $>$ \&}]{VP,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedZ $>$ \&}]{Z }\end{DoxyParamCaption})}



Given a screen space point (u,v) and the current projection matrix (e.\+g. 

gl\+\_\+proj \texorpdfstring{$\ast$}{*} gl\+\_\+modelview) and viewport, {\itshape unproject} the point into the scene so that it lies on given plane.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em UV} & 2-\/long uv-\/coordinates of screen space point \\
\hline
\mbox{\texttt{ in}}  & {\em M} & 4 by 4 projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em VP} & 4-\/long viewport\+: (corner\+\_\+u, corner\+\_\+v, width, height) \\
\hline
\mbox{\texttt{ in}}  & {\em P} & 4-\/long plane equation coefficients\+: P\texorpdfstring{$\ast$}{*}(X 1) = 0 \\
\hline
\mbox{\texttt{ out}}  & {\em Z} & 3-\/long world coordinate \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_abbefb4e32e184a299b36f663b23b7b9c}\label{namespaceigl_abbefb4e32e184a299b36f663b23b7b9c} 
\index{igl@{igl}!unproject\_onto\_mesh@{unproject\_onto\_mesh}}
\index{unproject\_onto\_mesh@{unproject\_onto\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_onto\_mesh()}{unproject\_onto\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedbc $>$ \\
bool igl\+::unproject\+\_\+onto\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector2f \&}]{pos,  }\item[{const Eigen\+::\+Matrix4f \&}]{model,  }\item[{const Eigen\+::\+Matrix4f \&}]{proj,  }\item[{const Eigen\+::\+Vector4f \&}]{viewport,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{int \&}]{fid,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedbc $>$ \&}]{bc }\end{DoxyParamCaption})}



Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position {\itshape onto} a given mesh, if the ray through the given screen location (x,y) {\itshape hits} the mesh. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pos} & screen space coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em model} & model matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & vieweport vector \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em fid} & id of the first face hit \\
\hline
\mbox{\texttt{ out}}  & {\em bc} & barycentric coordinates of hit \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if there\textquotesingle{}s a hit
\end{DoxyReturn}
\hypertarget{namespaceigl_autotoc_md39}{}\doxyparagraph{\texorpdfstring{Example\+:}{Example:}}\label{namespaceigl_autotoc_md39}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer}{igl::opengl::glfw::Viewer}}\ vr;}
\DoxyCodeLine{...}
\DoxyCodeLine{igl::unproject\_onto\_mesh(}
\DoxyCodeLine{\ \ pos,vr.\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer_a4fc39cbf6a2d68d0eaf63bef3fd49464}{core}}().\mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore_a8ce15c9d27268543847a0d83c2010cb6}{view}},vr.\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer_a4fc39cbf6a2d68d0eaf63bef3fd49464}{core}}().\mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore_a50af5081883025581f00b0918b3d9d30}{proj}},vr.\mbox{\hyperlink{classigl_1_1opengl_1_1glfw_1_1Viewer_a4fc39cbf6a2d68d0eaf63bef3fd49464}{core}}().\mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore_ac5a0f15fc245747e1d83b8e718f2e74f}{viewport}},V,F,fid,bc);}

\end{DoxyCode}
 \Hypertarget{namespaceigl_af4d029fbc6f770b7dec469f743858d8f}\label{namespaceigl_af4d029fbc6f770b7dec469f743858d8f} 
\index{igl@{igl}!unproject\_onto\_mesh@{unproject\_onto\_mesh}}
\index{unproject\_onto\_mesh@{unproject\_onto\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_onto\_mesh()}{unproject\_onto\_mesh()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Derivedbc $>$ \\
bool igl\+::unproject\+\_\+onto\+\_\+mesh (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Vector2f \&}]{pos,  }\item[{const Eigen\+::\+Matrix4f \&}]{model,  }\item[{const Eigen\+::\+Matrix4f \&}]{proj,  }\item[{const Eigen\+::\+Vector4f \&}]{viewport,  }\item[{const std\+::function$<$ bool(const Eigen\+::\+Vector3f \&, const Eigen\+::\+Vector3f \&, \mbox{\hyperlink{structigl_1_1Hit}{igl\+::\+Hit}} \&) $>$ \&}]{shoot\+\_\+ray,  }\item[{int \&}]{fid,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedbc $>$ \&}]{bc }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em shoot\+\_\+ray} & function handle that outputs hits of a given ray against a mesh (embedded in function handles as captured variable/data) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a171d8ab81ed0ba003408f162c80a5505}\label{namespaceigl_a171d8ab81ed0ba003408f162c80a5505} 
\index{igl@{igl}!unproject\_ray@{unproject\_ray}}
\index{unproject\_ray@{unproject\_ray}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unproject\_ray()}{unproject\_ray()}}
{\footnotesize\ttfamily template$<$typename Derivedpos , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Deriveds , typename Deriveddir $>$ \\
void igl\+::unproject\+\_\+ray (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedpos $>$ \&}]{pos,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedmodel $>$ \&}]{model,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedproj $>$ \&}]{proj,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedviewport $>$ \&}]{viewport,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Deriveds $>$ \&}]{s,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Deriveddir $>$ \&}]{dir }\end{DoxyParamCaption})}



Construct a ray (source point + direction vector) given a screen space positions (e.\+g. 

mouse) and a model-\/view projection constellation.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em pos} & 2d screen-\/space position (x,y) \\
\hline
\mbox{\texttt{ in}}  & {\em model} & 4x4 model-\/view matrix \\
\hline
\mbox{\texttt{ in}}  & {\em proj} & 4x4 projection matrix \\
\hline
\mbox{\texttt{ in}}  & {\em viewport} & 4-\/long viewport vector \\
\hline
\mbox{\texttt{ out}}  & {\em s} & source of ray (pos unprojected with z=0) \\
\hline
\mbox{\texttt{ out}}  & {\em dir} & direction of ray (d -\/ s) where d is pos unprojected with z=1 \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a681d80aaa80e594a1983b10aaf6006fd}\label{namespaceigl_a681d80aaa80e594a1983b10aaf6006fd} 
\index{igl@{igl}!unzip\_corners@{unzip\_corners}}
\index{unzip\_corners@{unzip\_corners}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{unzip\_corners()}{unzip\_corners()}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedU , typename DerivedG , typename DerivedJ $>$ \\
void igl\+::unzip\+\_\+corners (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ std\+::reference\+\_\+wrapper$<$ DerivedA $>$ $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedU $>$ \&}]{U,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedG $>$ \&}]{G,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedJ $>$ \&}]{J }\end{DoxyParamCaption})}



Given a triangle mesh where corners of each triangle index different matrices of attributes (e.\+g. 

read from an OBJ file), unzip the corners into unique efficiently\+: attributes become properly vertex valued (usually creating greater than \#V but less than \#F\texorpdfstring{$\ast$}{*}3 vertices).

To pass a list of attributes this function takes an std\+::vector of std\+::reference\+\_\+wrapper of an Eigen\+:\+:... type. This allows you to use list initializers {\bfseries{without}} incurring a copy, but means you\textquotesingle{}ll need to provide the derived type of A as an explicit template parameter\+: \begin{DoxyVerb} unzip_corners<Eigen::MatrixXi>({F,FTC,FN},U,G,J);
\end{DoxyVerb}
 
\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#A list of \#F by 3 attribute indices, typically \{F,FTC,FN\} \\
\hline
\mbox{\texttt{ out}}  & {\em U} & \#U by \#A list of indices into each attribute for each unique mesh vertex\+: U(v,a) is the attribute index of vertex v in attribute a. \\
\hline
\mbox{\texttt{ out}}  & {\em G} & \#F by 3 list of triangle indices into U \\
\hline
\mbox{\texttt{ out}}  & {\em J} & \#F\texorpdfstring{$\ast$}{*}3 by 1 list of indices so that A\mbox{[}\mbox{]}(i,j) = U.\+row(i+j\texorpdfstring{$\ast$}{*}\#F)\\
\hline
\end{DoxyParams}
\hypertarget{namespaceigl_autotoc_md40}{}\doxyparagraph{\texorpdfstring{Matlibberish Example}{Matlibberish Example}}\label{namespaceigl_autotoc_md40}
\mbox{[}V,F,TC,FTC\mbox{]} = read\+OBJ(\textquotesingle{}\texorpdfstring{$\sim$}{\string~}/\+Downloads/kiwis/kiwi.obj\textquotesingle{}); \mbox{[}U,G\mbox{]} = unzip\+\_\+corners(cat(3,\+F,\+FTC)); \% display mesh tsurf(G,V(\+U(\+:,1),\+:)); \% display texture coordinates tsurf(G,TC(\+U(\+:,2),\+:)); \Hypertarget{namespaceigl_a7897e133babd19415648e5aaef9cc63a}\label{namespaceigl_a7897e133babd19415648e5aaef9cc63a} 
\index{igl@{igl}!upsample@{upsample}}
\index{upsample@{upsample}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{upsample()}{upsample()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename SType , typename Derived\+NF $>$ \\
void igl\+::upsample (\begin{DoxyParamCaption}\item[{const int}]{n\+\_\+verts,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ SType $>$ \&}]{S,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&}]{NF }\end{DoxyParamCaption})}



Subdivide without moving vertices\+: Given the triangle mesh \mbox{[}V, F\mbox{]}, where n\+\_\+verts = V.\+rows(), computes newV and a sparse matrix S s.\+t. 

\mbox{[}newV, newF\mbox{]} is the subdivided mesh where newV = S\texorpdfstring{$\ast$}{*}V.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n\+\_\+verts} & an integer (number of mesh vertices) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & an m by 3 matrix of integers of triangle faces \\
\hline
\mbox{\texttt{ out}}  & {\em S} & a sparse matrix (will become the subdivision matrix) \\
\hline
\mbox{\texttt{ out}}  & {\em newF} & a matrix containing the new faces \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a22564028c3ea860f1dcfb72d48872602}\label{namespaceigl_a22564028c3ea860f1dcfb72d48872602} 
\index{igl@{igl}!upsample@{upsample}}
\index{upsample@{upsample}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{upsample()}{upsample()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+NV , typename Derived\+NF $>$ \\
void igl\+::upsample (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NV $>$ \&}]{NV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NF $>$ \&}]{NF,  }\item[{const int}]{number\+\_\+of\+\_\+subdivs = {\ttfamily 1} }\end{DoxyParamCaption})}



Subdivide a mesh without moving vertices\+: loop subdivision but odd vertices stay put and even vertices are just edge midpoints. 


\begin{DoxyTemplParams}{Template Parameters}
{\em MatV} & matrix for vertex positions, e.\+g. Matrix\+Xd \\
\hline
{\em MatF} & matrix for vertex positions, e.\+g. Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim mesh vertices \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 mesh triangles \\
\hline
\mbox{\texttt{ out}}  & {\em NV} & new vertex positions, V is guaranteed to be at top \\
\hline
\mbox{\texttt{ out}}  & {\em NF} & new list of face indices\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
V should not be the same as NV, 

F should not be the same as NF, use other proto
\end{DoxyNote}
\begin{DoxyPrecond}{Precondition}
assumes (V,F) is edge-\/manifold. 
\end{DoxyPrecond}
\Hypertarget{namespaceigl_a9347f30f3803c2aa656a3b73ed9c02f5}\label{namespaceigl_a9347f30f3803c2aa656a3b73ed9c02f5} 
\index{igl@{igl}!upsample@{upsample}}
\index{upsample@{upsample}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{upsample()}{upsample()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename MatV , typename MatF $>$ \\
void igl\+::upsample (\begin{DoxyParamCaption}\item[{MatV \&}]{V,  }\item[{MatF \&}]{F,  }\item[{const int}]{number\+\_\+of\+\_\+subdivs = {\ttfamily 1} }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_a4a3e7408bbfe1e7f478d79af1ab05dc0}\label{namespaceigl_a4a3e7408bbfe1e7f478d79af1ab05dc0} 
\index{igl@{igl}!vector\_area\_matrix@{vector\_area\_matrix}}
\index{vector\_area\_matrix@{vector\_area\_matrix}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vector\_area\_matrix()}{vector\_area\_matrix()}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Scalar $>$ \\
void igl\+::vector\+\_\+area\+\_\+matrix (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Sparse\+Matrix$<$ Scalar $>$ \&}]{A }\end{DoxyParamCaption})}



Constructs the symmetric area matrix A, s.\+t. 

\mbox{[}V.\+col(0)\textquotesingle{} V.\+col(1)\textquotesingle{}\mbox{]} \texorpdfstring{$\ast$}{*} A \texorpdfstring{$\ast$}{*} \mbox{[}V.\+col(0); V.\+col(1)\mbox{]} is the {\bfseries{vector area}} of the mesh (V,F).


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & derived type of eigen matrix for V (e.\+g. derived from Matrix\+Xd) \\
\hline
{\em DerivedF} & derived type of eigen matrix for F (e.\+g. derived from Matrix\+Xi) \\
\hline
{\em Scalar} & scalar type for eigen sparse matrix (e.\+g. double) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em A} & \#\+Vx2 by \#\+Vx2 area matrix \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1052b6f357eb1bcc4258d45490d866ad}\label{namespaceigl_a1052b6f357eb1bcc4258d45490d866ad} 
\index{igl@{igl}!verbose@{verbose}}
\index{verbose@{verbose}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{verbose()}{verbose()}}
{\footnotesize\ttfamily int igl\+::verbose (\begin{DoxyParamCaption}\item[{const char \texorpdfstring{$\ast$}{*}}]{msg,  }\item[{}]{... }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Provide a wrapper for printf, called verbose that functions exactly like printf if VERBOSE is defined and does exactly nothing if VERBOSE is undefined. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em msg} & printf style format string \\
\hline
\mbox{\texttt{ in}}  & {\em ...} & printf style arguments \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of characters printed 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ab8159118b103ccc116d788259917acdb}\label{namespaceigl_ab8159118b103ccc116d788259917acdb} 
\index{igl@{igl}!vertex\_components@{vertex\_components}}
\index{vertex\_components@{vertex\_components}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vertex\_components()}{vertex\_components()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedC , typename Derivedcounts $>$ \\
void igl\+::vertex\+\_\+components (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedcounts $>$ \&}]{counts }\end{DoxyParamCaption})}



Compute connected components of a graph represented by an adjacency matrix. 

Outputs a component ID per vertex of the graph where connectivity is established by edges.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & n by n adjacency matrix \\
\hline
\mbox{\texttt{ out}}  & {\em C} & n list of component ids (starting with 0) \\
\hline
\mbox{\texttt{ out}}  & {\em counts} & \#components list of counts for each component \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a669ae9814690f3c0f466cfae73890263}\label{namespaceigl_a669ae9814690f3c0f466cfae73890263} 
\index{igl@{igl}!vertex\_components@{vertex\_components}}
\index{vertex\_components@{vertex\_components}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vertex\_components()}{vertex\_components()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedC $>$ \\
void igl\+::vertex\+\_\+components (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Sparse\+Compressed\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a1cfebfe524e61fecdadf7d789ddb9ec9}\label{namespaceigl_a1cfebfe524e61fecdadf7d789ddb9ec9} 
\index{igl@{igl}!vertex\_components@{vertex\_components}}
\index{vertex\_components@{vertex\_components}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vertex\_components()}{vertex\_components()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename DerivedC $>$ \\
void igl\+::vertex\+\_\+components (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Compute the connected components for a mesh given its faces. 

Returns a component ID per vertex of the mesh where connectivity is established by edges.

For computing connected components per face see \doxylink{namespaceigl_a7823f08d518cb237ee3cb47bb03cdb6d}{igl\+::facet\+\_\+components}


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & n by 3 list of triangle indices \\
\hline
\mbox{\texttt{ out}}  & {\em C} & max(\+F) list of component ids \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_acabdf409439e0498066a620d30db6899}\label{namespaceigl_acabdf409439e0498066a620d30db6899} 
\index{igl@{igl}!vertex\_triangle\_adjacency@{vertex\_triangle\_adjacency}}
\index{vertex\_triangle\_adjacency@{vertex\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vertex\_triangle\_adjacency()}{vertex\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename VFType , typename VFi\+Type $>$ \\
void igl\+::vertex\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const typename Derived\+F\+::\+Scalar}]{n,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ VFType $>$ $>$ \&}]{VF,  }\item[{std\+::vector$<$ std\+::vector$<$ VFi\+Type $>$ $>$ \&}]{VFi }\end{DoxyParamCaption})}



vertex\+\_\+face\+\_\+adjacency constructs the vertex-\/face topology of a given mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em n} & number of vertices \#V (e.\+g. {\ttfamily F.\+max\+Coeff()+1} or {\ttfamily V.\+rows()}) \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh faces (must be triangles) \\
\hline
\mbox{\texttt{ out}}  & {\em VF} & \#V list of lists of incident faces (adjacency list) \\
\hline
\mbox{\texttt{ out}}  & {\em VI} & \#V list of lists of index of incidence within incident faces listed in VF\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a0efd6c6b371a55178d53cf0afacf34ee}{edges}, \doxylink{namespaceigl_acbfe6ae19ab6f94e36b3d92be1159fe9}{cotmatrix}, diag, vv
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a44c886a9ced7765ce3e2f03332bbcf91}\label{namespaceigl_a44c886a9ced7765ce3e2f03332bbcf91} 
\index{igl@{igl}!vertex\_triangle\_adjacency@{vertex\_triangle\_adjacency}}
\index{vertex\_triangle\_adjacency@{vertex\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vertex\_triangle\_adjacency()}{vertex\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Index\+Type $>$ \\
void igl\+::vertex\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{VF,  }\item[{std\+::vector$<$ std\+::vector$<$ Index\+Type $>$ $>$ \&}]{VFi }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6e4082714e403404167543bddf89ba53}\label{namespaceigl_a6e4082714e403404167543bddf89ba53} 
\index{igl@{igl}!vertex\_triangle\_adjacency@{vertex\_triangle\_adjacency}}
\index{vertex\_triangle\_adjacency@{vertex\_triangle\_adjacency}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{vertex\_triangle\_adjacency()}{vertex\_triangle\_adjacency()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedF , typename Derived\+VF , typename Derived\+NI $>$ \\
void igl\+::vertex\+\_\+triangle\+\_\+adjacency (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const int}]{n,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+VF $>$ \&}]{VF,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+NI $>$ \&}]{NI }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices into some vertex list V \\
\hline
\mbox{\texttt{ in}}  & {\em n} & number of vertices, \#V (e.\+g., F.\+max\+Coeff()+1) \\
\hline
\mbox{\texttt{ out}}  & {\em VF} & 3\texorpdfstring{$\ast$}{*}\#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. \\
\hline
\mbox{\texttt{ out}}  & {\em NI} & \#V+1 list cumulative sum of vertex-\/triangle degrees with a preceeding zero. "{}\+How many faces"{} have been seen before visiting this vertex and its incident faces. \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a289cc75429d0c045af9eca70642b8f8a}\label{namespaceigl_a289cc75429d0c045af9eca70642b8f8a} 
\index{igl@{igl}!volume@{volume}}
\index{volume@{volume}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{volume()}{volume()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename Derivedvol $>$ \\
void igl\+::volume (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedvol $>$ \&}]{vol }\end{DoxyParamCaption})}



Compute volume for all tets of a given tet mesh (V,T) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T by 4 list of tet indices \\
\hline
\mbox{\texttt{ out}}  & {\em vol} & \#T list of tetrahedron volumes \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_ab25567c5af213643fd332e32003e63b4}\label{namespaceigl_ab25567c5af213643fd332e32003e63b4} 
\index{igl@{igl}!volume@{volume}}
\index{volume@{volume}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{volume()}{volume()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename Derivedvol $>$ \\
void igl\+::volume (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedA $>$ \&}]{A,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedB $>$ \&}]{B,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedD $>$ \&}]{D,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedvol $>$ \&}]{vol }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em A} & \#V by dim list of first corner position \\
\hline
\mbox{\texttt{ in}}  & {\em B} & \#V by dim list of second corner position \\
\hline
\mbox{\texttt{ in}}  & {\em C} & \#V by dim list of third corner position \\
\hline
\mbox{\texttt{ in}}  & {\em D} & \#V by dim list of fourth corner position \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a89ebffa70b6797c8fd0404da673aaf3c}\label{namespaceigl_a89ebffa70b6797c8fd0404da673aaf3c} 
\index{igl@{igl}!volume\_single@{volume\_single}}
\index{volume\_single@{volume\_single}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{volume\_single()}{volume\_single()}}
{\footnotesize\ttfamily template$<$typename VecA , typename VecB , typename VecC , typename VecD $>$ \\
Vec\+A\+::\+Scalar igl\+::volume\+\_\+single (\begin{DoxyParamCaption}\item[{const VecA \&}]{a,  }\item[{const VecB \&}]{b,  }\item[{const VecC \&}]{c,  }\item[{const VecD \&}]{d }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Single tet \Hypertarget{namespaceigl_a0da5bd53ebc802822b96aebabbfddfa1}\label{namespaceigl_a0da5bd53ebc802822b96aebabbfddfa1} 
\index{igl@{igl}!volume@{volume}}
\index{volume@{volume}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{volume()}{volume()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedL , typename Derivedvol $>$ \\
void igl\+::volume (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedL $>$ \&}]{L,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedvol $>$ \&}]{vol }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Intrinsic version\+:


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em L} & \#V by 6 list of edge lengths (see edge\+\_\+lengths) \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_adbd087fd838f29b3d9e50ef45403f2ce}\label{namespaceigl_adbd087fd838f29b3d9e50ef45403f2ce} 
\index{igl@{igl}!voxel\_grid@{voxel\_grid}}
\index{voxel\_grid@{voxel\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{voxel\_grid()}{voxel\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Derived\+GV , typename Derivedside $>$ \\
void igl\+::voxel\+\_\+grid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Aligned\+Box$<$ Scalar, 3 $>$ \&}]{box,  }\item[{const int}]{s,  }\item[{const int}]{pad\+\_\+count,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedside $>$ \&}]{side }\end{DoxyParamCaption})}



Construct the cell center positions of a regular voxel grid (lattice) made of perfectly square voxels. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em box} & bounding box to enclose by grid \\
\hline
\mbox{\texttt{ in}}  & {\em s} & number of cell centers on largest side (including 2\texorpdfstring{$\ast$}{*}pad\+\_\+count) \\
\hline
\mbox{\texttt{ in}}  & {\em pad\+\_\+count} & number of cells beyond box \\
\hline
\mbox{\texttt{ out}}  & {\em GV} & side(0)\texorpdfstring{$\ast$}{*}side(1)\texorpdfstring{$\ast$}{*}side(2) by 3 list of cell center positions \\
\hline
\mbox{\texttt{ out}}  & {\em side} & 1 by 3 list of dimension of voxel grid \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a467c3ec21d8d152e2e6aaf04ef8ab1da}\label{namespaceigl_a467c3ec21d8d152e2e6aaf04ef8ab1da} 
\index{igl@{igl}!voxel\_grid@{voxel\_grid}}
\index{voxel\_grid@{voxel\_grid}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{voxel\_grid()}{voxel\_grid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename Derived\+GV , typename Derivedside $>$ \\
void igl\+::voxel\+\_\+grid (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const typename Derived\+V\+::\+Scalar}]{offset,  }\item[{const int}]{s,  }\item[{const int}]{pad\+\_\+count,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derived\+GV $>$ \&}]{GV,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ Derivedside $>$ \&}]{side }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em offset} & offset to add to each cell center \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a468f01ca961ac9ea78d02b3ecac25bee}\label{namespaceigl_a468f01ca961ac9ea78d02b3ecac25bee} 
\index{igl@{igl}!winding\_number@{winding\_number}}
\index{winding\_number@{winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{winding\_number()}{winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedO , typename DerivedW $>$ \\
void igl\+::winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedO $>$ \&}]{O,  }\item[{Eigen\+::\+Plain\+Object\+Base$<$ DerivedW $>$ \&}]{W }\end{DoxyParamCaption})}



Computes the generalized winding number at each dim-\/dimensional query point in O with respect to the oriented one-\/codimensional mesh (V,F). 

This is equivalent to summing the subtended signed angles/solid angles of each element in (V,F). See, "{}\+Robust \+Inside-\/\+Outside Segmentation using Generalized Winding Numbers"{} \mbox{[}Jacobson et al. 2013\mbox{]}.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of mesh facets as indices into rows of V. If dim==2, then (V,F) describes a set of edges in the plane. If dim==3, then (V,F) describes a triangle mesh/soup. \\
\hline
\mbox{\texttt{ in}}  & {\em O} & \#O by dim list of query points \\
\hline
\mbox{\texttt{ out}}  & {\em W} & \#O by 1 list of winding numbers\\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_af9a50987fefc0df065fb3e2cde90c92e}{fast\+\_\+winding\+\_\+number} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a6aab3f308b50dd0cafa361fed13ee213}\label{namespaceigl_a6aab3f308b50dd0cafa361fed13ee213} 
\index{igl@{igl}!winding\_number@{winding\_number}}
\index{winding\_number@{winding\_number}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{winding\_number()}{winding\_number()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derivedp $>$ \\
Derived\+V\+::\+Scalar igl\+::winding\+\_\+number (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derivedp $>$ \&}]{p }\end{DoxyParamCaption})}



Compute winding number of a single point. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & n by dim list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by dim list of triangle indices, minimum index is 0 \\
\hline
\mbox{\texttt{ in}}  & {\em p} & single origin position \\
\hline
\mbox{\texttt{ out}}  & {\em w} & winding number of this point \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_aa10e48891b5b843708fd73f095a5f96c}\label{namespaceigl_aa10e48891b5b843708fd73f095a5f96c} 
\index{igl@{igl}!write\_triangle\_mesh@{write\_triangle\_mesh}}
\index{write\_triangle\_mesh@{write\_triangle\_mesh}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{write\_triangle\_mesh()}{write\_triangle\_mesh()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+\_\+triangle\+\_\+mesh (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding = {\ttfamily \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{File\+Encoding\+::\+Ascii}}} }\end{DoxyParamCaption})}



write mesh to a file with automatic detection of file format. 

supported\+: obj, off, stl, wrl, ply, mesh).


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to file \\
\hline
\mbox{\texttt{ in}}  & {\em V} & eigen double matrix \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & eigen int matrix \#F by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em encoding} & set file encoding (ascii or binary) when both are available \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff success 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a95b5e18062898bc13278debb80127424}\label{namespaceigl_a95b5e18062898bc13278debb80127424} 
\index{igl@{igl}!writeBF@{writeBF}}
\index{writeBF@{writeBF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeBF()}{writeBF()}}
{\footnotesize\ttfamily template$<$typename Derived\+WI , typename DerivedP , typename DerivedO $>$ \\
bool igl\+::write\+BF (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ Derived\+WI $>$ \&}]{WI,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedP $>$ \&}]{P,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedO $>$ \&}]{O }\end{DoxyParamCaption})}



Write a bones forest to a file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+\_\+name} & path to .bf bones tree file \\
\hline
\mbox{\texttt{ in}}  & {\em WI} & \#B list of unique weight indices \\
\hline
\mbox{\texttt{ in}}  & {\em P} & \#B list of parent indices into B, -\/1 for roots \\
\hline
\mbox{\texttt{ in}}  & {\em O} & \#B list of tip offsets \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a4efbc110f683b253ef703142d1406f28}{read\+BF} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a8159d2953cb18953457a90976885ff57}\label{namespaceigl_a8159d2953cb18953457a90976885ff57} 
\index{igl@{igl}!writeDMAT@{writeDMAT}}
\index{writeDMAT@{writeDMAT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeDMAT()}{writeDMAT()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedW $>$ \\
bool igl\+::write\+DMAT (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedW $>$ \&}]{W,  }\item[{const bool}]{ascii = {\ttfamily true} }\end{DoxyParamCaption})}



Write a matrix using ascii dmat file type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat} & matrix type that supports .rows(), .cols(), operator(i,j) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em file\+\_\+name} & path to .dmat file \\
\hline
\mbox{\texttt{ in}}  & {\em W} & eigen matrix containing to-\/be-\/written coefficients \\
\hline
\mbox{\texttt{ in}}  & {\em ascii} & write ascii file \{true\} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a44a50547ab59bcb0705475875bb39a7d}{read\+DMAT} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a24f57ac9b3108c7e4e62890786a69337}\label{namespaceigl_a24f57ac9b3108c7e4e62890786a69337} 
\index{igl@{igl}!writeDMAT@{writeDMAT}}
\index{writeDMAT@{writeDMAT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeDMAT()}{writeDMAT()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
bool igl\+::write\+DMAT (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{const std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{W,  }\item[{const bool}]{ascii = {\ttfamily true} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ace5cabc9f902b654e3a9169855250e7c}\label{namespaceigl_ace5cabc9f902b654e3a9169855250e7c} 
\index{igl@{igl}!writeDMAT@{writeDMAT}}
\index{writeDMAT@{writeDMAT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeDMAT()}{writeDMAT()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename Scalar $>$ \\
bool igl\+::write\+DMAT (\begin{DoxyParamCaption}\item[{const std\+::string}]{file\+\_\+name,  }\item[{const std\+::vector$<$ Scalar $>$ \&}]{W,  }\item[{const bool}]{ascii = {\ttfamily true} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a6a6b14a1061d9ce7d0ef20880e604186}\label{namespaceigl_a6a6b14a1061d9ce7d0ef20880e604186} 
\index{igl@{igl}!writeMESH@{writeMESH}}
\index{writeMESH@{writeMESH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeMESH()}{writeMESH()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , typename Index $>$ \\
bool igl\+::write\+MESH (\begin{DoxyParamCaption}\item[{const std\+::string}]{mesh\+\_\+file\+\_\+name,  }\item[{const std\+::vector$<$ std\+::vector$<$ Scalar $>$ $>$ \&}]{V,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{T,  }\item[{const std\+::vector$<$ std\+::vector$<$ Index $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



save a tetrahedral volume mesh to a .mesh file 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be cast as double) \\
\hline
{\em Index} & type for indices (will be cast to int) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mesh\+\_\+file\+\_\+name} & path of .mesh file \\
\hline
\mbox{\texttt{ in}}  & {\em V} & double matrix of vertex positions \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em T} & \#T list of tet indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F list of face indices into vertex positions \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors
\end{DoxyReturn}
\Hypertarget{namespaceigl_ac173c671f0c9f633abe3daa005455507}\label{namespaceigl_ac173c671f0c9f633abe3daa005455507} 
\index{igl@{igl}!writeMESH@{writeMESH}}
\index{writeMESH@{writeMESH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeMESH()}{writeMESH()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedT , typename DerivedF $>$ \\
bool igl\+::write\+MESH (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedT $>$ \&}]{T,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



save a tetrahedral volume mesh to a .mesh file 


\begin{DoxyTemplParams}{Template Parameters}
{\em DerivedV} & real-\/value\+: i.\+e. from Matrix\+Xd \\
\hline
{\em DerivedT} & integer-\/value\+: i.\+e. from Matrix\+Xi \\
\hline
{\em DerivedF} & integer-\/value\+: i.\+e. from Matrix\+Xi \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em mesh\+\_\+file\+\_\+name} & path of .mesh file \\
\hline
\mbox{\texttt{ in}}  & {\em V} & eigen double matrix \#V by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em T} & eigen int matrix \#T by 4 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & eigen int matrix \#F by 3 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a2df694c52f937d065a10d20c184ddfc4}\label{namespaceigl_a2df694c52f937d065a10d20c184ddfc4} 
\index{igl@{igl}!writeMSH@{writeMSH}}
\index{writeMSH@{writeMSH}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeMSH()}{writeMSH()}}
{\footnotesize\ttfamily bool igl\+::write\+MSH (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{msh,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{X,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Tri,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Tet,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Tri\+Tag,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{Tet\+Tag,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{XFields,  }\item[{const std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{XF,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{EFields,  }\item[{const std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{TriF,  }\item[{const std\+::vector$<$ Eigen\+::\+Matrix\+Xd $>$ \&}]{TetF }\end{DoxyParamCaption})}



write triangle surface mesh and tetrahedral volume mesh to .msh file 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em msh} & -\/ file name \\
\hline
\mbox{\texttt{ in}}  & {\em X} & eigen double matrix of vertex positions \#X by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em Tri} & \#\+Tri eigen integer matrix of triangular faces indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em Tet} & \#\+Tet eigen integer matrix of tetrahedral indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em Tri\+Tag} & \#\+Tri eigen integer vector of tags associated with surface faces \\
\hline
\mbox{\texttt{ in}}  & {\em Tet\+Tag} & \#\+Tet eigen integer vector of tags associated with volume elements \\
\hline
\mbox{\texttt{ in}}  & {\em XFields} & \#\+XFields list of strings with field names associated with nodes \\
\hline
\mbox{\texttt{ in}}  & {\em XF} & \#\+XFields list of eigen double matrices, fields associated with nodes \\
\hline
\mbox{\texttt{ in}}  & {\em EFields} & \#\+EFields list of strings with field names associated with elements \\
\hline
\mbox{\texttt{ in}}  & {\em TriF} & \#\+EFields list of eigen double matrices, fields associated with surface elements \\
\hline
\mbox{\texttt{ in}}  & {\em TetF} & \#\+EFields list of eigen double matrices, fields associated with volume elements\\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a1a1761a85ec5cdef44ce8104d0ccdc3f}\label{namespaceigl_a1a1761a85ec5cdef44ce8104d0ccdc3f} 
\index{igl@{igl}!writeOBJ@{writeOBJ}}
\index{writeOBJ@{writeOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeOBJ()}{writeOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename Derived\+CN , typename Derived\+FN , typename Derived\+TC , typename Derived\+FTC $>$ \\
bool igl\+::write\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+CN $>$ \&}]{CN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FN $>$ \&}]{FN,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+TC $>$ \&}]{TC,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FTC $>$ \&}]{FTC }\end{DoxyParamCaption})}



Write a mesh in an ascii obj file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to outputfile \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3\texorpdfstring{$\vert$}{|}4 mesh indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em CN} & \#\+CN by 3 normal vectors \\
\hline
\mbox{\texttt{ in}}  & {\em FN} & \#F by 3\texorpdfstring{$\vert$}{|}4 corner normal indices into CN \\
\hline
\mbox{\texttt{ in}}  & {\em TC} & \#\+TC by 2\texorpdfstring{$\vert$}{|}3 texture coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em FTC} & \#F by 3\texorpdfstring{$\vert$}{|}4 corner texture coord indices into TC \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}


\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_ad3d68499324615abfb462bf80130431b}{read\+OBJ} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_ad361555ef88be9751c1940298028a4a3}\label{namespaceigl_ad361555ef88be9751c1940298028a4a3} 
\index{igl@{igl}!writeOBJ@{writeOBJ}}
\index{writeOBJ@{writeOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeOBJ()}{writeOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a5acdf796fe0c739fd37989deb859f564}\label{namespaceigl_a5acdf796fe0c739fd37989deb859f564} 
\index{igl@{igl}!writeOBJ@{writeOBJ}}
\index{writeOBJ@{writeOBJ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeOBJ()}{writeOBJ()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename T $>$ \\
bool igl\+::write\+OBJ (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{F }\end{DoxyParamCaption})}



Write a mesh of mixed tris and quads to an ascii obj file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to outputfile \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F std\+::vector of std\+::vector$<$\+Index$>$ of size 3 or 4 mesh indices into V \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a3c26424f96cf3b86305b18dd91dd0c83}\label{namespaceigl_a3c26424f96cf3b86305b18dd91dd0c83} 
\index{igl@{igl}!writeOFF@{writeOFF}}
\index{writeOFF@{writeOFF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeOFF()}{writeOFF()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ \\
bool igl\+::write\+OFF (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



Export geometry and colors-\/by-\/vertex to an ascii OFF file. 

Only triangle meshes are supported


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
{\em Index} & type for indices (will be read as int and cast to Index) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to .off output file \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 mesh indices into V \\
\hline
\mbox{\texttt{ in}}  & {\em C} & double matrix of rgb values per vertex \#V by 3 \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ab9d5937707edc99d534ccab39d14429c}\label{namespaceigl_ab9d5937707edc99d534ccab39d14429c} 
\index{igl@{igl}!writeOFF@{writeOFF}}
\index{writeOFF@{writeOFF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeOFF()}{writeOFF()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+OFF (\begin{DoxyParamCaption}\item[{const std\+::string}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ad75b8abd010b0cc4ce47469b3f855e42}\label{namespaceigl_ad75b8abd010b0cc4ce47469b3f855e42} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [1/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{std\+::ostream \&}]{ply\+\_\+stream,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&}]{VD,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{VDheader,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FD $>$ \&}]{FD,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{FDheader,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+ED $>$ \&}]{ED,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{EDheader,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{comments,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding }\end{DoxyParamCaption})}



write triangular mesh to ply file 


\begin{DoxyTemplParams}{Template Parameters}
{\em Derived} & from Eigen matrix parameters \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em ply\+\_\+stream} & ply file output stream \\
\hline
\mbox{\texttt{ in}}  & {\em V} & (\#V,3) matrix of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & (\#F,3) list of face indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & (\#E,2) list of edge indices into vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em N} & (\#V,3) list of normals \\
\hline
\mbox{\texttt{ in}}  & {\em UV} & (\#V,2) list of texture coordinates \\
\hline
\mbox{\texttt{ in}}  & {\em VD} & (\#V,\texorpdfstring{$\ast$}{*}) additional vertex data \\
\hline
\mbox{\texttt{ in}}  & {\em Vheader} & (\#V) list of vertex data headers \\
\hline
\mbox{\texttt{ in}}  & {\em FD} & (\#F,\texorpdfstring{$\ast$}{*}) additional face data \\
\hline
\mbox{\texttt{ in}}  & {\em Fheader} & (\#F) list of face data headers \\
\hline
\mbox{\texttt{ in}}  & {\em ED} & (\#E,\texorpdfstring{$\ast$}{*}) additional edge data \\
\hline
\mbox{\texttt{ in}}  & {\em Eheader} & (\#E) list of edge data headers \\
\hline
\mbox{\texttt{ in}}  & {\em comments} & (\texorpdfstring{$\ast$}{*}) file comments \\
\hline
\mbox{\texttt{ in}}  & {\em encoding} & -\/ enum, to set binary or ascii file format \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_ab97df6737c8ab9d4d1c9093491d41c2a}\label{namespaceigl_ab97df6737c8ab9d4d1c9093491d41c2a} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [2/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD , typename Derived\+FD , typename Derived\+ED $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&}]{VD,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{VDheader,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+FD $>$ \&}]{FD,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{FDheader,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+ED $>$ \&}]{ED,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{EDheader,  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{comments,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & path to .ply file \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_a089a8c3e1a12d0ad0be24eb7b9b35f47}\label{namespaceigl_a089a8c3e1a12d0ad0be24eb7b9b35f47} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [3/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0f47de9a532d3a6d2ccc94267d3806f2}\label{namespaceigl_a0f47de9a532d3a6d2ccc94267d3806f2} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [4/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a21c501124b7b44b6adf81a2a11a1fea2}\label{namespaceigl_a21c501124b7b44b6adf81a2a11a1fea2} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [5/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename Derived\+UV $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a263e6503e126ed829c6a3e3e9c188110}\label{namespaceigl_a263e6503e126ed829c6a3e3e9c188110} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [6/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_abe192d7895221e908003d65ab544d24f}\label{namespaceigl_abe192d7895221e908003d65ab544d24f} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [7/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a689ca1568cfbecb2d29a1c37d6f38e7b}\label{namespaceigl_a689ca1568cfbecb2d29a1c37d6f38e7b} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [8/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0c7f6c3884f0355670c8fcdb36923671}\label{namespaceigl_a0c7f6c3884f0355670c8fcdb36923671} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [9/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN , typename Derived\+UV , typename Derived\+VD $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&}]{VD = {\ttfamily Eigen\+:\+:MatrixXd(0,~0)},  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{VDheader = {\ttfamily \{\}},  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{comments = {\ttfamily \{\}} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_aedef9e44fe11f235719d619185e404b7}\label{namespaceigl_aedef9e44fe11f235719d619185e404b7} 
\index{igl@{igl}!writePLY@{writePLY}}
\index{writePLY@{writePLY}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writePLY()}{writePLY()}\hspace{0.1cm}{\footnotesize\ttfamily [10/10]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename Derived\+UV , typename Derived\+VD $>$ \\
bool igl\+::write\+PLY (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedE $>$ \&}]{E,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+UV $>$ \&}]{UV,  }\item[{const Eigen\+::\+Matrix\+Base$<$ Derived\+VD $>$ \&}]{VD = {\ttfamily Eigen\+:\+:MatrixXd(0,~0)},  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{VDheader = {\ttfamily \{\}},  }\item[{const std\+::vector$<$ std\+::string $>$ \&}]{comments = {\ttfamily \{\}} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a07adddd7239a8b049f1383c09d78d245}\label{namespaceigl_a07adddd7239a8b049f1383c09d78d245} 
\index{igl@{igl}!writeSTL@{writeSTL}}
\index{writeSTL@{writeSTL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeSTL()}{writeSTL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedN $>$ \\
bool igl\+::write\+STL (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedN $>$ \&}]{N,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding = {\ttfamily \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{File\+Encoding\+::\+Ascii}}} }\end{DoxyParamCaption})}



Write a mesh to an stl file. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar} & type for positions and vectors (will be read as double and cast to Scalar) \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & path to .obj file \\
\hline
\mbox{\texttt{ in}}  & {\em V} & double matrix of vertex positions \#F\texorpdfstring{$\ast$}{*}3 by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em F} & index matrix of triangle indices \#F by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em N} & double matrix of vertex positions \#F by 3 \\
\hline
\mbox{\texttt{ in}}  & {\em encoding} & enum to set file encoding (ascii by default) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on errors 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a13c6477f242f1c28b713fc41205f21db}\label{namespaceigl_a13c6477f242f1c28b713fc41205f21db} 
\index{igl@{igl}!writeSTL@{writeSTL}}
\index{writeSTL@{writeSTL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeSTL()}{writeSTL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+STL (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{\mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbf}{File\+Encoding}}}]{encoding = {\ttfamily \mbox{\hyperlink{namespaceigl_a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31}{File\+Encoding\+::\+Ascii}}} }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_ae98f5c58b4e2db831a37794d14e68190}\label{namespaceigl_ae98f5c58b4e2db831a37794d14e68190} 
\index{igl@{igl}!writeTGF@{writeTGF}}
\index{writeTGF@{writeTGF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeTGF()}{writeTGF()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool igl\+::write\+TGF (\begin{DoxyParamCaption}\item[{const std\+::string}]{tgf\+\_\+filename,  }\item[{const std\+::vector$<$ std\+::vector$<$ double $>$ $>$ \&}]{C,  }\item[{const std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \&}]{E }\end{DoxyParamCaption})}



Write a graph to a .tgf file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em filename} & .tgf file name \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \# vertices by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em E} & \# edges by 2 list of edge indices\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
Assumes that graph vertices are 3 dimensional
\end{DoxyPrecond}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_a0e2ff313a45b1882bc42711ef59518ea}{read\+TGF} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_a217cf16c6a0be84701d89c49b3337ff4}\label{namespaceigl_a217cf16c6a0be84701d89c49b3337ff4} 
\index{igl@{igl}!writeTGF@{writeTGF}}
\index{writeTGF@{writeTGF}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeTGF()}{writeTGF()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool igl\+::write\+TGF (\begin{DoxyParamCaption}\item[{const std\+::string}]{tgf\+\_\+filename,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{C,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{E }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_a0cfecc2999b584fe90aa57e9e6538ddd}\label{namespaceigl_a0cfecc2999b584fe90aa57e9e6538ddd} 
\index{igl@{igl}!writeWRL@{writeWRL}}
\index{writeWRL@{writeWRL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeWRL()}{writeWRL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
bool igl\+::write\+WRL (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F }\end{DoxyParamCaption})}



Write mesh to a .wrl file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em str} & path to .wrl file \\
\hline
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 list of vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of triangle indices \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true iff succes 
\end{DoxyReturn}
\Hypertarget{namespaceigl_a315f62cc42f483bf2651f05eb1fd6d71}\label{namespaceigl_a315f62cc42f483bf2651f05eb1fd6d71} 
\index{igl@{igl}!writeWRL@{writeWRL}}
\index{writeWRL@{writeWRL}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{writeWRL()}{writeWRL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF , typename DerivedC $>$ \\
bool igl\+::write\+WRL (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Base$<$ DerivedC $>$ \&}]{C }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em C} & double matrix of rgb values per vertex \#V by 3 \\
\hline
\end{DoxyParams}


\doxysubsection{Variable Documentation}
\Hypertarget{namespaceigl_a4132693fc82720d3e947c09aad236d96}\label{namespaceigl_a4132693fc82720d3e947c09aad236d96} 
\index{igl@{igl}!IDENTITY\_QUAT\_F@{IDENTITY\_QUAT\_F}}
\index{IDENTITY\_QUAT\_F@{IDENTITY\_QUAT\_F}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{IDENTITY\_QUAT\_F}{IDENTITY\_QUAT\_F}}
{\footnotesize\ttfamily const float igl\+::\+IDENTITY\+\_\+\+QUAT\+\_\+F\mbox{[}4\mbox{]} = \{0,0,0,1\}}

\Hypertarget{namespaceigl_afc1c639c804d4e91dc1ffb424c5caf37}\label{namespaceigl_afc1c639c804d4e91dc1ffb424c5caf37} 
\index{igl@{igl}!XY\_PLANE\_QUAT\_F@{XY\_PLANE\_QUAT\_F}}
\index{XY\_PLANE\_QUAT\_F@{XY\_PLANE\_QUAT\_F}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{XY\_PLANE\_QUAT\_F}{XY\_PLANE\_QUAT\_F}}
{\footnotesize\ttfamily const float igl\+::\+XY\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+F\mbox{[}4\mbox{]} = \{0,0,0,1\}}

\Hypertarget{namespaceigl_adf4ae9044c47ccad908df3775523d731}\label{namespaceigl_adf4ae9044c47ccad908df3775523d731} 
\index{igl@{igl}!XZ\_PLANE\_QUAT\_F@{XZ\_PLANE\_QUAT\_F}}
\index{XZ\_PLANE\_QUAT\_F@{XZ\_PLANE\_QUAT\_F}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{XZ\_PLANE\_QUAT\_F}{XZ\_PLANE\_QUAT\_F}}
{\footnotesize\ttfamily const float igl\+::\+XZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+F\mbox{[}4\mbox{]} = \{-\/\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}},0,0,\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}}\}}

\Hypertarget{namespaceigl_abd154ccb32e580426fe71c29fccf45e8}\label{namespaceigl_abd154ccb32e580426fe71c29fccf45e8} 
\index{igl@{igl}!YZ\_PLANE\_QUAT\_F@{YZ\_PLANE\_QUAT\_F}}
\index{YZ\_PLANE\_QUAT\_F@{YZ\_PLANE\_QUAT\_F}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{YZ\_PLANE\_QUAT\_F}{YZ\_PLANE\_QUAT\_F}}
{\footnotesize\ttfamily const float igl\+::\+YZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+F\mbox{[}4\mbox{]} = \{-\/0.\+5,-\/0.\+5,-\/0.\+5,0.\+5\}}

\Hypertarget{namespaceigl_ab16914177d382aa61d647d2bdac2f61a}\label{namespaceigl_ab16914177d382aa61d647d2bdac2f61a} 
\index{igl@{igl}!CANONICAL\_VIEW\_QUAT\_F@{CANONICAL\_VIEW\_QUAT\_F}}
\index{CANONICAL\_VIEW\_QUAT\_F@{CANONICAL\_VIEW\_QUAT\_F}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CANONICAL\_VIEW\_QUAT\_F}{CANONICAL\_VIEW\_QUAT\_F}}
{\footnotesize\ttfamily const float igl\+::\+CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT\+\_\+F\mbox{[}$\,$\mbox{]}\mbox{[}4\mbox{]}}

\Hypertarget{namespaceigl_a4d25a0a671a74bdb8bea35d6dc482d66}\label{namespaceigl_a4d25a0a671a74bdb8bea35d6dc482d66} 
\index{igl@{igl}!IDENTITY\_QUAT\_D@{IDENTITY\_QUAT\_D}}
\index{IDENTITY\_QUAT\_D@{IDENTITY\_QUAT\_D}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{IDENTITY\_QUAT\_D}{IDENTITY\_QUAT\_D}}
{\footnotesize\ttfamily const double igl\+::\+IDENTITY\+\_\+\+QUAT\+\_\+D\mbox{[}4\mbox{]} = \{0,0,0,1\}}

\Hypertarget{namespaceigl_a1e0bd2386fb8512b5fccf9abaab47952}\label{namespaceigl_a1e0bd2386fb8512b5fccf9abaab47952} 
\index{igl@{igl}!XY\_PLANE\_QUAT\_D@{XY\_PLANE\_QUAT\_D}}
\index{XY\_PLANE\_QUAT\_D@{XY\_PLANE\_QUAT\_D}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{XY\_PLANE\_QUAT\_D}{XY\_PLANE\_QUAT\_D}}
{\footnotesize\ttfamily const double igl\+::\+XY\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+D\mbox{[}4\mbox{]} = \{0,0,0,1\}}

\Hypertarget{namespaceigl_a83519a14c0cfc4eb50105894232e10a4}\label{namespaceigl_a83519a14c0cfc4eb50105894232e10a4} 
\index{igl@{igl}!XZ\_PLANE\_QUAT\_D@{XZ\_PLANE\_QUAT\_D}}
\index{XZ\_PLANE\_QUAT\_D@{XZ\_PLANE\_QUAT\_D}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{XZ\_PLANE\_QUAT\_D}{XZ\_PLANE\_QUAT\_D}}
{\footnotesize\ttfamily const double igl\+::\+XZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+D\mbox{[}4\mbox{]} = \{-\/\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}},0,0,\mbox{\hyperlink{canonical__quaternions_8h_aeffaebb2528081eee665b34e5654a535}{SQRT\+\_\+2\+\_\+\+OVER\+\_\+2}}\}}

\Hypertarget{namespaceigl_aec963f40812a8ab05b4b6b370fce4cfd}\label{namespaceigl_aec963f40812a8ab05b4b6b370fce4cfd} 
\index{igl@{igl}!YZ\_PLANE\_QUAT\_D@{YZ\_PLANE\_QUAT\_D}}
\index{YZ\_PLANE\_QUAT\_D@{YZ\_PLANE\_QUAT\_D}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{YZ\_PLANE\_QUAT\_D}{YZ\_PLANE\_QUAT\_D}}
{\footnotesize\ttfamily const double igl\+::\+YZ\+\_\+\+PLANE\+\_\+\+QUAT\+\_\+D\mbox{[}4\mbox{]} = \{-\/0.\+5,-\/0.\+5,-\/0.\+5,0.\+5\}}

\Hypertarget{namespaceigl_abbe2a3410b25f28096dcde690d7df743}\label{namespaceigl_abbe2a3410b25f28096dcde690d7df743} 
\index{igl@{igl}!CANONICAL\_VIEW\_QUAT\_D@{CANONICAL\_VIEW\_QUAT\_D}}
\index{CANONICAL\_VIEW\_QUAT\_D@{CANONICAL\_VIEW\_QUAT\_D}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CANONICAL\_VIEW\_QUAT\_D}{CANONICAL\_VIEW\_QUAT\_D}}
{\footnotesize\ttfamily const double igl\+::\+CANONICAL\+\_\+\+VIEW\+\_\+\+QUAT\+\_\+D\mbox{[}$\,$\mbox{]}\mbox{[}4\mbox{]}}

\Hypertarget{namespaceigl_a959bd85cf0ed1b59e3a9ad857c953604}\label{namespaceigl_a959bd85cf0ed1b59e3a9ad857c953604} 
\index{igl@{igl}!DOUBLE\_EPS@{DOUBLE\_EPS}}
\index{DOUBLE\_EPS@{DOUBLE\_EPS}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{DOUBLE\_EPS}{DOUBLE\_EPS}}
{\footnotesize\ttfamily const double igl\+::\+DOUBLE\+\_\+\+EPS = 1.\+0e-\/14}



Standard value for double epsilon. 

\Hypertarget{namespaceigl_ab4c4eb25dcc0beddf9732c13704a07b7}\label{namespaceigl_ab4c4eb25dcc0beddf9732c13704a07b7} 
\index{igl@{igl}!DOUBLE\_EPS\_SQ@{DOUBLE\_EPS\_SQ}}
\index{DOUBLE\_EPS\_SQ@{DOUBLE\_EPS\_SQ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{DOUBLE\_EPS\_SQ}{DOUBLE\_EPS\_SQ}}
{\footnotesize\ttfamily const double igl\+::\+DOUBLE\+\_\+\+EPS\+\_\+\+SQ = 1.\+0e-\/28}



Standard value for double epsilon 

\Hypertarget{namespaceigl_a7184cb6e2f319e3c31a0e1f5bc90354d}\label{namespaceigl_a7184cb6e2f319e3c31a0e1f5bc90354d} 
\index{igl@{igl}!FLOAT\_EPS@{FLOAT\_EPS}}
\index{FLOAT\_EPS@{FLOAT\_EPS}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FLOAT\_EPS}{FLOAT\_EPS}}
{\footnotesize\ttfamily const float igl\+::\+FLOAT\+\_\+\+EPS = 1.\+0e-\/7f}



Standard value for single epsilon. 

\Hypertarget{namespaceigl_a529be4dc6f96c94adc21d8480d9d9bbf}\label{namespaceigl_a529be4dc6f96c94adc21d8480d9d9bbf} 
\index{igl@{igl}!FLOAT\_EPS\_SQ@{FLOAT\_EPS\_SQ}}
\index{FLOAT\_EPS\_SQ@{FLOAT\_EPS\_SQ}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FLOAT\_EPS\_SQ}{FLOAT\_EPS\_SQ}}
{\footnotesize\ttfamily const float igl\+::\+FLOAT\+\_\+\+EPS\+\_\+\+SQ = 1.\+0e-\/14f}



Standard value for single epsilon 

\Hypertarget{namespaceigl_a2719a5fd20a68136038b7132136e74bf}\label{namespaceigl_a2719a5fd20a68136038b7132136e74bf} 
\index{igl@{igl}!GOLD\_AMBIENT@{GOLD\_AMBIENT}}
\index{GOLD\_AMBIENT@{GOLD\_AMBIENT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{GOLD\_AMBIENT}{GOLD\_AMBIENT}}
{\footnotesize\ttfamily const float igl\+::\+GOLD\+\_\+\+AMBIENT\mbox{[}4\mbox{]} = \{ 51.\+0/255.\+0, 43.\+0/255.\+0,33.\+3/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a8589d6f0c07c7387258e004cfade2567}\label{namespaceigl_a8589d6f0c07c7387258e004cfade2567} 
\index{igl@{igl}!GOLD\_DIFFUSE@{GOLD\_DIFFUSE}}
\index{GOLD\_DIFFUSE@{GOLD\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{GOLD\_DIFFUSE}{GOLD\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+GOLD\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,228.\+0/255.\+0,58.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a63110eff6fbd6ded60fc3c4a004c1ac3}\label{namespaceigl_a63110eff6fbd6ded60fc3c4a004c1ac3} 
\index{igl@{igl}!GOLD\_SPECULAR@{GOLD\_SPECULAR}}
\index{GOLD\_SPECULAR@{GOLD\_SPECULAR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{GOLD\_SPECULAR}{GOLD\_SPECULAR}}
{\footnotesize\ttfamily const float igl\+::\+GOLD\+\_\+\+SPECULAR\mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,235.\+0/255.\+0,80.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a2cea9492c40178a4255d810a81b27abb}\label{namespaceigl_a2cea9492c40178a4255d810a81b27abb} 
\index{igl@{igl}!SILVER\_AMBIENT@{SILVER\_AMBIENT}}
\index{SILVER\_AMBIENT@{SILVER\_AMBIENT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{SILVER\_AMBIENT}{SILVER\_AMBIENT}}
{\footnotesize\ttfamily const float igl\+::\+SILVER\+\_\+\+AMBIENT\mbox{[}4\mbox{]} = \{ 0.\+2f, 0.\+2f, 0.\+2f, 1.\+0f \}}

\Hypertarget{namespaceigl_a285eccdcab39b99b34da071d0e811328}\label{namespaceigl_a285eccdcab39b99b34da071d0e811328} 
\index{igl@{igl}!SILVER\_DIFFUSE@{SILVER\_DIFFUSE}}
\index{SILVER\_DIFFUSE@{SILVER\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{SILVER\_DIFFUSE}{SILVER\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+SILVER\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 1.\+0f, 1.\+0f, 1.\+0f, 1.\+0f \}}

\Hypertarget{namespaceigl_adde55f12f19663cc168932e3cbaa1033}\label{namespaceigl_adde55f12f19663cc168932e3cbaa1033} 
\index{igl@{igl}!SILVER\_SPECULAR@{SILVER\_SPECULAR}}
\index{SILVER\_SPECULAR@{SILVER\_SPECULAR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{SILVER\_SPECULAR}{SILVER\_SPECULAR}}
{\footnotesize\ttfamily const float igl\+::\+SILVER\+\_\+\+SPECULAR\mbox{[}4\mbox{]} = \{ 1.\+0f, 1.\+0f, 1.\+0f, 1.\+0f \}}

\Hypertarget{namespaceigl_a41f327ea1271a24126e5b54b58137207}\label{namespaceigl_a41f327ea1271a24126e5b54b58137207} 
\index{igl@{igl}!CYAN\_AMBIENT@{CYAN\_AMBIENT}}
\index{CYAN\_AMBIENT@{CYAN\_AMBIENT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CYAN\_AMBIENT}{CYAN\_AMBIENT}}
{\footnotesize\ttfamily const float igl\+::\+CYAN\+\_\+\+AMBIENT\mbox{[}4\mbox{]} = \{ 59.\+0/255.\+0, 68.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_aa91b40d8001ba8a6732b57ea544e3cff}\label{namespaceigl_aa91b40d8001ba8a6732b57ea544e3cff} 
\index{igl@{igl}!CYAN\_DIFFUSE@{CYAN\_DIFFUSE}}
\index{CYAN\_DIFFUSE@{CYAN\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CYAN\_DIFFUSE}{CYAN\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+CYAN\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 94.\+0/255.\+0,185.\+0/255.\+0,238.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a2aa44781d95faf982b844c0aa39b3138}\label{namespaceigl_a2aa44781d95faf982b844c0aa39b3138} 
\index{igl@{igl}!CYAN\_SPECULAR@{CYAN\_SPECULAR}}
\index{CYAN\_SPECULAR@{CYAN\_SPECULAR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CYAN\_SPECULAR}{CYAN\_SPECULAR}}
{\footnotesize\ttfamily const float igl\+::\+CYAN\+\_\+\+SPECULAR\mbox{[}4\mbox{]} = \{ 163.\+0/255.\+0,221.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a35121926b4786e30ae17f9f96c2657c6}\label{namespaceigl_a35121926b4786e30ae17f9f96c2657c6} 
\index{igl@{igl}!DENIS\_PURPLE\_DIFFUSE@{DENIS\_PURPLE\_DIFFUSE}}
\index{DENIS\_PURPLE\_DIFFUSE@{DENIS\_PURPLE\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{DENIS\_PURPLE\_DIFFUSE}{DENIS\_PURPLE\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+DENIS\+\_\+\+PURPLE\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 80.\+0/255.\+0,64.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a31d9148951bd2c269433253e37bdb5fa}\label{namespaceigl_a31d9148951bd2c269433253e37bdb5fa} 
\index{igl@{igl}!LADISLAV\_ORANGE\_DIFFUSE@{LADISLAV\_ORANGE\_DIFFUSE}}
\index{LADISLAV\_ORANGE\_DIFFUSE@{LADISLAV\_ORANGE\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{LADISLAV\_ORANGE\_DIFFUSE}{LADISLAV\_ORANGE\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+LADISLAV\+\_\+\+ORANGE\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{1.\+0f, 125.\+0f / 255.\+0f, 19.\+0f / 255.\+0f, 0.\+0f\}}

\Hypertarget{namespaceigl_a3ef7cc70cc21ec016debd929ca40cb25}\label{namespaceigl_a3ef7cc70cc21ec016debd929ca40cb25} 
\index{igl@{igl}!FAST\_GREEN\_DIFFUSE@{FAST\_GREEN\_DIFFUSE}}
\index{FAST\_GREEN\_DIFFUSE@{FAST\_GREEN\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FAST\_GREEN\_DIFFUSE}{FAST\_GREEN\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+FAST\+\_\+\+GREEN\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 113.\+0f/255.\+0f, 239.\+0f/255.\+0f, 46.\+0f/255.\+0f, 1.\+0f\}}

\Hypertarget{namespaceigl_af6d07e97190e3d6eb57c438d929fd9f7}\label{namespaceigl_af6d07e97190e3d6eb57c438d929fd9f7} 
\index{igl@{igl}!FAST\_RED\_DIFFUSE@{FAST\_RED\_DIFFUSE}}
\index{FAST\_RED\_DIFFUSE@{FAST\_RED\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FAST\_RED\_DIFFUSE}{FAST\_RED\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+FAST\+\_\+\+RED\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 255.\+0f/255.\+0f, 65.\+0f/255.\+0f, 46.\+0f/255.\+0f, 1.\+0f\}}

\Hypertarget{namespaceigl_a81c3adfdf58bb4b9041258ed528419d8}\label{namespaceigl_a81c3adfdf58bb4b9041258ed528419d8} 
\index{igl@{igl}!FAST\_BLUE\_DIFFUSE@{FAST\_BLUE\_DIFFUSE}}
\index{FAST\_BLUE\_DIFFUSE@{FAST\_BLUE\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FAST\_BLUE\_DIFFUSE}{FAST\_BLUE\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+FAST\+\_\+\+BLUE\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 106.\+0f/255.\+0f, 106.\+0f/255.\+0f, 255.\+0f/255.\+0f, 1.\+0f\}}

\Hypertarget{namespaceigl_a1a8c0ec0db4f21074319658ec9cda122}\label{namespaceigl_a1a8c0ec0db4f21074319658ec9cda122} 
\index{igl@{igl}!FAST\_GRAY\_DIFFUSE@{FAST\_GRAY\_DIFFUSE}}
\index{FAST\_GRAY\_DIFFUSE@{FAST\_GRAY\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FAST\_GRAY\_DIFFUSE}{FAST\_GRAY\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+FAST\+\_\+\+GRAY\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 150.\+0f/255.\+0f, 150.\+0f/255.\+0f, 150.\+0f/255.\+0f, 1.\+0f\}}

\Hypertarget{namespaceigl_a42bdfa6acbe2c64f29cbd31426c86bfb}\label{namespaceigl_a42bdfa6acbe2c64f29cbd31426c86bfb} 
\index{igl@{igl}!WHITE@{WHITE}}
\index{WHITE@{WHITE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WHITE}{WHITE}}
{\footnotesize\ttfamily const float igl\+::\+WHITE\mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_aba9827caee2da38a16d2578ad87c18b8}\label{namespaceigl_aba9827caee2da38a16d2578ad87c18b8} 
\index{igl@{igl}!BLACK@{BLACK}}
\index{BLACK@{BLACK}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{BLACK}{BLACK}}
{\footnotesize\ttfamily const float igl\+::\+BLACK\mbox{[}4\mbox{]} = \{ 0.\+0/255.\+0,0.\+0/255.\+0,0.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a4ace1077f98e7c25d1b590afc21001d4}\label{namespaceigl_a4ace1077f98e7c25d1b590afc21001d4} 
\index{igl@{igl}!WHITE\_AMBIENT@{WHITE\_AMBIENT}}
\index{WHITE\_AMBIENT@{WHITE\_AMBIENT}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WHITE\_AMBIENT}{WHITE\_AMBIENT}}
{\footnotesize\ttfamily const float igl\+::\+WHITE\+\_\+\+AMBIENT\mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_af258223de150eac4510266bce6c15adc}\label{namespaceigl_af258223de150eac4510266bce6c15adc} 
\index{igl@{igl}!WHITE\_DIFFUSE@{WHITE\_DIFFUSE}}
\index{WHITE\_DIFFUSE@{WHITE\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WHITE\_DIFFUSE}{WHITE\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+WHITE\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_aa83f669c0c7352ed86d6991e28616eed}\label{namespaceigl_aa83f669c0c7352ed86d6991e28616eed} 
\index{igl@{igl}!WHITE\_SPECULAR@{WHITE\_SPECULAR}}
\index{WHITE\_SPECULAR@{WHITE\_SPECULAR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WHITE\_SPECULAR}{WHITE\_SPECULAR}}
{\footnotesize\ttfamily const float igl\+::\+WHITE\+\_\+\+SPECULAR\mbox{[}4\mbox{]} = \{ 255.\+0/255.\+0,255.\+0/255.\+0,255.\+0/255.\+0,1.\+0f \}}

\Hypertarget{namespaceigl_a8d653f310491c5eeea8199df41a8506b}\label{namespaceigl_a8d653f310491c5eeea8199df41a8506b} 
\index{igl@{igl}!BBW\_POINT\_COLOR@{BBW\_POINT\_COLOR}}
\index{BBW\_POINT\_COLOR@{BBW\_POINT\_COLOR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{BBW\_POINT\_COLOR}{BBW\_POINT\_COLOR}}
{\footnotesize\ttfamily const float igl\+::\+BBW\+\_\+\+POINT\+\_\+\+COLOR\mbox{[}4\mbox{]} = \{239./255.,213./255.,46./255.,255.\+0/255.\+0\}}

\Hypertarget{namespaceigl_a2a441cf01da7bb4f7455fa87831cc862}\label{namespaceigl_a2a441cf01da7bb4f7455fa87831cc862} 
\index{igl@{igl}!BBW\_LINE\_COLOR@{BBW\_LINE\_COLOR}}
\index{BBW\_LINE\_COLOR@{BBW\_LINE\_COLOR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{BBW\_LINE\_COLOR}{BBW\_LINE\_COLOR}}
{\footnotesize\ttfamily const float igl\+::\+BBW\+\_\+\+LINE\+\_\+\+COLOR\mbox{[}4\mbox{]} = \{106./255.,106./255.,255./255.,255./255.\}}

\Hypertarget{namespaceigl_a3443568d1ef02dea80982a3df4bbfec1}\label{namespaceigl_a3443568d1ef02dea80982a3df4bbfec1} 
\index{igl@{igl}!MIDNIGHT\_BLUE\_DIFFUSE@{MIDNIGHT\_BLUE\_DIFFUSE}}
\index{MIDNIGHT\_BLUE\_DIFFUSE@{MIDNIGHT\_BLUE\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{MIDNIGHT\_BLUE\_DIFFUSE}{MIDNIGHT\_BLUE\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+MIDNIGHT\+\_\+\+BLUE\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{ 21.\+0f/255.\+0f, 27.\+0f/255.\+0f, 84.\+0f/255.\+0f, 1.\+0f\}}

\Hypertarget{namespaceigl_aa9c277b6c43132159685619ae7e56d38}\label{namespaceigl_aa9c277b6c43132159685619ae7e56d38} 
\index{igl@{igl}!EASTER\_RED\_DIFFUSE@{EASTER\_RED\_DIFFUSE}}
\index{EASTER\_RED\_DIFFUSE@{EASTER\_RED\_DIFFUSE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{EASTER\_RED\_DIFFUSE}{EASTER\_RED\_DIFFUSE}}
{\footnotesize\ttfamily const float igl\+::\+EASTER\+\_\+\+RED\+\_\+\+DIFFUSE\mbox{[}4\mbox{]} = \{0.\+603922,0.\+494118f,0.\+603922f,1.\+0f\}}

\Hypertarget{namespaceigl_af16c584a27f3dcfaa597e5864861931f}\label{namespaceigl_af16c584a27f3dcfaa597e5864861931f} 
\index{igl@{igl}!WN\_OPEN\_BOUNDARY\_COLOR@{WN\_OPEN\_BOUNDARY\_COLOR}}
\index{WN\_OPEN\_BOUNDARY\_COLOR@{WN\_OPEN\_BOUNDARY\_COLOR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WN\_OPEN\_BOUNDARY\_COLOR}{WN\_OPEN\_BOUNDARY\_COLOR}}
{\footnotesize\ttfamily const float igl\+::\+WN\+\_\+\+OPEN\+\_\+\+BOUNDARY\+\_\+\+COLOR\mbox{[}4\mbox{]} = \{154./255.,0./255.,0./255.,1.\+0f\}}

\Hypertarget{namespaceigl_a147760067e19822d9de2d3386c607b6e}\label{namespaceigl_a147760067e19822d9de2d3386c607b6e} 
\index{igl@{igl}!WN\_NON\_MANIFOLD\_EDGE\_COLOR@{WN\_NON\_MANIFOLD\_EDGE\_COLOR}}
\index{WN\_NON\_MANIFOLD\_EDGE\_COLOR@{WN\_NON\_MANIFOLD\_EDGE\_COLOR}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{WN\_NON\_MANIFOLD\_EDGE\_COLOR}{WN\_NON\_MANIFOLD\_EDGE\_COLOR}}
{\footnotesize\ttfamily const float igl\+::\+WN\+\_\+\+NON\+\_\+\+MANIFOLD\+\_\+\+EDGE\+\_\+\+COLOR\mbox{[}4\mbox{]} = \{201./255., 51./255.,255./255.,1.\+0f\}}

\Hypertarget{namespaceigl_a417e9fcd5135f9dfc60524331328b9d8}\label{namespaceigl_a417e9fcd5135f9dfc60524331328b9d8} 
\index{igl@{igl}!CHAR\_ONE@{CHAR\_ONE}}
\index{CHAR\_ONE@{CHAR\_ONE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CHAR\_ONE}{CHAR\_ONE}}
{\footnotesize\ttfamily const char igl\+::\+CHAR\+\_\+\+ONE = 1}



Often one needs a reference to a dummy variable containing one as its value, for example when using Ant\+Tweak\+Bar\textquotesingle{}s Tw\+Set\+Param( "{}3\+D View"{}, "{}opened"{}, TW\+\_\+\+PARAM\+\_\+\+INT32, 1, \&INT\+\_\+\+ONE);. 

\Hypertarget{namespaceigl_a13bf1ec6ed30256c1043772e67394b33}\label{namespaceigl_a13bf1ec6ed30256c1043772e67394b33} 
\index{igl@{igl}!INT\_ONE@{INT\_ONE}}
\index{INT\_ONE@{INT\_ONE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{INT\_ONE}{INT\_ONE}}
{\footnotesize\ttfamily const int igl\+::\+INT\+\_\+\+ONE = 1}

\Hypertarget{namespaceigl_a57884543ce9ab8f3b3b1f9ffbef9a977}\label{namespaceigl_a57884543ce9ab8f3b3b1f9ffbef9a977} 
\index{igl@{igl}!UNSIGNED\_INT\_ONE@{UNSIGNED\_INT\_ONE}}
\index{UNSIGNED\_INT\_ONE@{UNSIGNED\_INT\_ONE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{UNSIGNED\_INT\_ONE}{UNSIGNED\_INT\_ONE}}
{\footnotesize\ttfamily const unsigned int igl\+::\+UNSIGNED\+\_\+\+INT\+\_\+\+ONE = 1}

\Hypertarget{namespaceigl_ad63b4ffb0ea045dc3cd8a516ba072090}\label{namespaceigl_ad63b4ffb0ea045dc3cd8a516ba072090} 
\index{igl@{igl}!DOUBLE\_ONE@{DOUBLE\_ONE}}
\index{DOUBLE\_ONE@{DOUBLE\_ONE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{DOUBLE\_ONE}{DOUBLE\_ONE}}
{\footnotesize\ttfamily const double igl\+::\+DOUBLE\+\_\+\+ONE = 1}

\Hypertarget{namespaceigl_af7ed44be1be4ade1ba7a4e7b382085db}\label{namespaceigl_af7ed44be1be4ade1ba7a4e7b382085db} 
\index{igl@{igl}!FLOAT\_ONE@{FLOAT\_ONE}}
\index{FLOAT\_ONE@{FLOAT\_ONE}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FLOAT\_ONE}{FLOAT\_ONE}}
{\footnotesize\ttfamily const float igl\+::\+FLOAT\+\_\+\+ONE = 1}

\Hypertarget{namespaceigl_af3c65fcb2a063b19e572a9d982b5dcdc}\label{namespaceigl_af3c65fcb2a063b19e572a9d982b5dcdc} 
\index{igl@{igl}!PI@{PI}}
\index{PI@{PI}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{PI}{PI}}
{\footnotesize\ttfamily constexpr double igl\+::\+PI = 3.\+1415926535897932384626433832795\hspace{0.3cm}{\ttfamily [constexpr]}}



 

\Hypertarget{namespaceigl_a89d712ab3a824b8712b6f228dc8242cf}\label{namespaceigl_a89d712ab3a824b8712b6f228dc8242cf} 
\index{igl@{igl}!CHAR\_ZERO@{CHAR\_ZERO}}
\index{CHAR\_ZERO@{CHAR\_ZERO}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{CHAR\_ZERO}{CHAR\_ZERO}}
{\footnotesize\ttfamily const char igl\+::\+CHAR\+\_\+\+ZERO = 0}

\Hypertarget{namespaceigl_ad26002c6ec8c14b1b4a7acc5db59b1e4}\label{namespaceigl_ad26002c6ec8c14b1b4a7acc5db59b1e4} 
\index{igl@{igl}!INT\_ZERO@{INT\_ZERO}}
\index{INT\_ZERO@{INT\_ZERO}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{INT\_ZERO}{INT\_ZERO}}
{\footnotesize\ttfamily const int igl\+::\+INT\+\_\+\+ZERO = 0}

\Hypertarget{namespaceigl_a3d956292d4f64a8ce6b1e1d92a9f9d24}\label{namespaceigl_a3d956292d4f64a8ce6b1e1d92a9f9d24} 
\index{igl@{igl}!UNSIGNED\_INT\_ZERO@{UNSIGNED\_INT\_ZERO}}
\index{UNSIGNED\_INT\_ZERO@{UNSIGNED\_INT\_ZERO}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{UNSIGNED\_INT\_ZERO}{UNSIGNED\_INT\_ZERO}}
{\footnotesize\ttfamily const unsigned int igl\+::\+UNSIGNED\+\_\+\+INT\+\_\+\+ZERO = 0}

\Hypertarget{namespaceigl_af1cef568dc365b5b596341a5b7f06867}\label{namespaceigl_af1cef568dc365b5b596341a5b7f06867} 
\index{igl@{igl}!DOUBLE\_ZERO@{DOUBLE\_ZERO}}
\index{DOUBLE\_ZERO@{DOUBLE\_ZERO}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{DOUBLE\_ZERO}{DOUBLE\_ZERO}}
{\footnotesize\ttfamily const double igl\+::\+DOUBLE\+\_\+\+ZERO = 0}

\Hypertarget{namespaceigl_aec3a0ea947dabbe9fc09e7e8da909613}\label{namespaceigl_aec3a0ea947dabbe9fc09e7e8da909613} 
\index{igl@{igl}!FLOAT\_ZERO@{FLOAT\_ZERO}}
\index{FLOAT\_ZERO@{FLOAT\_ZERO}!igl@{igl}}
\doxysubsubsection{\texorpdfstring{FLOAT\_ZERO}{FLOAT\_ZERO}}
{\footnotesize\ttfamily const float igl\+::\+FLOAT\+\_\+\+ZERO = 0}

