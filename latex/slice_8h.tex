\doxysection{include/igl/slice.h File Reference}
\hypertarget{slice_8h}{}\label{slice_8h}\index{include/igl/slice.h@{include/igl/slice.h}}
{\ttfamily \#include "{}igl\+\_\+inline.\+h"{}}\newline
{\ttfamily \#include $<$Eigen/\+Sparse$>$}\newline
{\ttfamily \#include $<$vector$>$}\newline
{\ttfamily \#include "{}slice.\+cpp"{}}\newline
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceigl}{igl}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename TX , typename TY , typename DerivedR , typename DerivedC $>$ }\\void \mbox{\hyperlink{namespaceigl_a547a8704200d3af48fe92105c15a32ad}{igl\+::slice}} (const Eigen\+::\+Sparse\+Matrix$<$ TX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Sparse\+Matrix$<$ TY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em Act like the matlab X(row\+\_\+indices,col\+\_\+indices) operator, where row\+\_\+indices, col\+\_\+indices are non-\/negative integer indices. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename MatX , typename DerivedR , typename MatY $>$ }\\void \mbox{\hyperlink{namespaceigl_ae747d042c40e074264e161b49906216d}{igl\+::slice}} (const MatX \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const int dim, MatY \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespaceigl_aa05264f934b9cecbac042ef69735b74b}{igl\+::slice}} (const std\+::vector$<$ T $>$ \&X, std\+::vector$<$ size\+\_\+t $>$ const \&R, std\+::vector$<$ T $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedY , typename DerivedR $>$ }\\void \mbox{\hyperlink{namespaceigl_aae8c4cf15b6f5f8cc16da9405b96be59}{igl\+::slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR , typename DerivedC , typename DerivedY $>$ }\\void \mbox{\hyperlink{namespaceigl_a90268d9fb8c64692427036793191a8b7}{igl\+::slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const Eigen\+::\+Dense\+Base$<$ DerivedC $>$ \&C, Eigen\+::\+Plain\+Object\+Base$<$ DerivedY $>$ \&Y)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_a86abeffa3ef136e9e35057e526618dc8}{igl\+::slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedX , typename DerivedR $>$ }\\DerivedX \mbox{\hyperlink{namespaceigl_aa5271870d0385781c2236145ee9c3897}{igl\+::slice}} (const Eigen\+::\+Dense\+Base$<$ DerivedX $>$ \&X, const Eigen\+::\+Dense\+Base$<$ DerivedR $>$ \&R, const int dim)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\texorpdfstring{$\vert$}{|} igl \texorpdfstring{$\vert$}{|} Eigen v3.\+4 \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---0-\/-\/-\/-\/-\/---\texorpdfstring{$\vert$}{|}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/---\texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice(\+X,\+I,\+J,\+Y)} \texorpdfstring{$\vert$}{|} {\ttfamily Y = X(\+I,\+J)} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice(\+X,\+I,1,\+Y)} \texorpdfstring{$\vert$}{|} {\ttfamily Y = X(\+I,\+Eigen\+::all)} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice(\+X,\+J,2,\+Y)} \texorpdfstring{$\vert$}{|} {\ttfamily Y = X(\+Eigen\+::all,\+J)} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice\+\_\+into(\+Z,\+I,\+J,\+X)} \texorpdfstring{$\vert$}{|} {\ttfamily X(\+I,\+J) = Z} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice\+\_\+into(\+Z,\+I,1,\+X)} \texorpdfstring{$\vert$}{|} {\ttfamily X(\+I,\+Eigen\+::all) = Z} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice\+\_\+into(\+Z,\+J,2,\+X)} \texorpdfstring{$\vert$}{|} {\ttfamily X(\+Eigen\+::all,\+J) = Z} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\ttfamily igl\+::slice\+\_\+mask(\+X,\+M,\+N,\+Y)} \texorpdfstring{$\vert$}{|} {\ttfamily Y = X(igl\+::find(\+M),igl\+::find(\+N))} \texorpdfstring{$\vert$}{|} \texorpdfstring{$\vert$}{|} {\itshape not available} \texorpdfstring{$\vert$}{|} {\ttfamily X(igl\+::find(\+M),igl\+::find(\+N)) = Z} \texorpdfstring{$\vert$}{|}

Eigen\textquotesingle{}s slicing supports much more than arrays of indices as input, as well.

Unfortunately, Eigen v3.\+4 does not support slicing on sparse matrices. 