\doxysection{igl\+::opengl Namespace Reference}
\hypertarget{namespaceigl_1_1opengl}{}\label{namespaceigl_1_1opengl}\index{igl::opengl@{igl::opengl}}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1opengl_1_1glfw}{glfw}}
\item 
namespace \mbox{\hyperlink{namespaceigl_1_1opengl_1_1stb}{stb}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structigl_1_1opengl_1_1gliGenericImage}{gli\+Generic\+Image}}
\item 
class \mbox{\hyperlink{classigl_1_1opengl_1_1MeshGL}{Mesh\+GL}}
\begin{DoxyCompactList}\small\item\em Coverts mesh data inside a igl\+::\+Viewer\+Data class in an Open\+GL compatible format The class includes a shader and the opengl calls to plot the data. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{structigl_1_1opengl_1_1TgaFooter}{Tga\+Footer}}
\item 
struct \mbox{\hyperlink{structigl_1_1opengl_1_1TgaHeader}{Tga\+Header}}
\item 
class \mbox{\hyperlink{classigl_1_1opengl_1_1ViewerCore}{Viewer\+Core}}
\begin{DoxyCompactList}\small\item\em Basic class of the 3D mesh viewer. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{classigl_1_1opengl_1_1ViewerData}{Viewer\+Data}}
\begin{DoxyCompactList}\small\item\em Object being drawn (i.\+e., mesh and its accessories) by the \doxylink{classigl_1_1opengl_1_1ViewerCore}{Viewer\+Core}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{namespaceigl_1_1opengl_a967f6e5284d63e98cbd501388672bff9}{render\+\_\+to\+\_\+tga}} (const std\+::string tga\+\_\+file, const int width, const int height, const bool alpha)
\begin{DoxyCompactList}\small\item\em alpha whether to include alpha channel \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1opengl_a276e885ccdcfd9e60b772c3c4bb2f866}{texture\+\_\+from\+\_\+tga}} (const std\+::string tga\+\_\+file, GLuint \&id)
\begin{DoxyCompactList}\small\item\em Read an image from a .tga file and use it as a texture. \end{DoxyCompactList}\item 
\mbox{\hyperlink{structigl_1_1opengl_1_1gliGenericImage}{gli\+Generic\+Image}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{namespaceigl_1_1opengl_a73e1f94f7c5006844213837713652e0f}{gli\+Read\+TGA}} (FILE \texorpdfstring{$\ast$}{*}fp, char \texorpdfstring{$\ast$}{*}name, int hflip, int vflip)
\item 
int \mbox{\hyperlink{namespaceigl_1_1opengl_a1581cf9fab6f2f7dbc495dc8c601bd9b}{gli\+\_\+verbose}} (int new\+\_\+verbose)
\item 
int \mbox{\hyperlink{namespaceigl_1_1opengl_ab7b723fc81098ef1841429fb1e127d76}{gli\+Verbose}} (int new\+Verbose)
\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_a0ee614bf7fc62ec302b276934bc9a8cc}{write\+TGA}} (\mbox{\hyperlink{structigl_1_1opengl_1_1gliGenericImage}{gli\+Generic\+Image}} \texorpdfstring{$\ast$}{*}image, FILE \texorpdfstring{$\ast$}{*}fp)
\item 
{\footnotesize template$<$typename Scalar , int Rows\+At\+Compile\+Time, int Cols\+At\+Compile\+Time$>$ }\\GLint \mbox{\hyperlink{namespaceigl_1_1opengl_aeec995e7405f0abc5605089526f4ed91}{bind\+\_\+vertex\+\_\+attrib\+\_\+array}} (const GLuint program\+\_\+shader, const std\+::string \&name, GLuint buffer\+ID, const Eigen\+::\+Matrix$<$ Scalar, Rows\+At\+Compile\+Time, Cols\+At\+Compile\+Time, Eigen\+::\+Row\+Major $>$ \&M, const bool refresh)
\begin{DoxyCompactList}\small\item\em Bind a per-\/vertex array attribute and refresh its contents from an Eigen matrix. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_afb53eea84ee235ebd173c8c150ce4759}{create\+\_\+index\+\_\+vbo}} (const Eigen\+::\+Matrix\+Xi \&F, GLuint \&F\+\_\+vbo\+\_\+id)
\begin{DoxyCompactList}\small\item\em Create a VBO (Vertex Buffer Object) for a list of indices\+: GL\+\_\+\+ELEMENT\+\_\+\+ARRAY\+\_\+\+BUFFER\+\_\+\+ARB for the triangle indices (F) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_a09b4597fbcc534310ba6cd68ad18e41f}{create\+\_\+mesh\+\_\+vbo}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, GLuint \&V\+\_\+vbo\+\_\+id, GLuint \&F\+\_\+vbo\+\_\+id)
\begin{DoxyCompactList}\small\item\em Create a VBO (Vertex Buffer Object) for a mesh. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_a33dff64f122b8ae53a54fb2c9b71445b}{create\+\_\+mesh\+\_\+vbo}} (const Eigen\+::\+Matrix\+Xd \&V, const Eigen\+::\+Matrix\+Xi \&F, const Eigen\+::\+Matrix\+Xd \&N, GLuint \&V\+\_\+vbo\+\_\+id, GLuint \&F\+\_\+vbo\+\_\+id, GLuint \&N\+\_\+vbo\+\_\+id)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1opengl_a387615839bfa5d4d521532cd18e96b23}{create\+\_\+shader\+\_\+program}} (const std\+::string \&geom\+\_\+source, const std\+::string \&vert\+\_\+source, const std\+::string \&frag\+\_\+source, const std\+::map$<$ std\+::string, GLuint $>$ \&attrib, GLuint \&id)
\begin{DoxyCompactList}\small\item\em Create a shader program with a vertex and fragments shader loading from source strings and vertex attributes assigned from a map before linking the shaders to the program, making it ready to use with gl\+Use\+Program(id) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1opengl_acb61cde775b172998ae6e6f9dffd5d96}{create\+\_\+shader\+\_\+program}} (const std\+::string \&vert\+\_\+source, const std\+::string \&frag\+\_\+source, const std\+::map$<$ std\+::string, GLuint $>$ \&attrib, GLuint \&id)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
GLuint \mbox{\hyperlink{namespaceigl_1_1opengl_a8804baac0135e31d5b9f585a1adb5cb5}{create\+\_\+shader\+\_\+program}} (const std\+::string \&geom\+\_\+source, const std\+::string \&vert\+\_\+source, const std\+::string \&frag\+\_\+source, const std\+::map$<$ std\+::string, GLuint $>$ \&attrib)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
GLuint \mbox{\hyperlink{namespaceigl_1_1opengl_a69e00ecaf2b3546583b44f5876a9f32c}{create\+\_\+shader\+\_\+program}} (const std\+::string \&vert\+\_\+source, const std\+::string \&frag\+\_\+source, const std\+::map$<$ std\+::string, GLuint $>$ \&attrib)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1opengl_a4d8948cd3db199a58744bcb5ecb8e010}{create\+\_\+vector\+\_\+vbo}} (const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&V, GLuint \&V\+\_\+vbo\+\_\+id)
\begin{DoxyCompactList}\small\item\em Create a VBO (Vertex Buffer Object) for a list of vectors\+: GL\+\_\+\+ARRAY\+\_\+\+BUFFER for the vectors (V) \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespaceigl_1_1opengl_a04d4be929fb0aefff3d0bee345e159c5}{destroy\+\_\+shader\+\_\+program}} (const GLuint id)
\begin{DoxyCompactList}\small\item\em Properly destroy a shader program. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespaceigl_1_1opengl_ab44717ffa90f441c2b8597a3809e516a}{gl\+\_\+type\+\_\+size}} (const GLenum type)
\begin{DoxyCompactList}\small\item\em Return the number of bytes for a given Open\+GL type. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_ac2d55d2b5f33e5c392361023b7c49c8f}{init\+\_\+render\+\_\+to\+\_\+texture}} (const size\+\_\+t width, const size\+\_\+t height, const bool depth\+\_\+texture, GLuint \&tex\+\_\+id, GLuint \&fbo\+\_\+id, GLuint \&d\+\_\+id)
\begin{DoxyCompactList}\small\item\em Create a frame buffer that renders color to a RGBA texture a depth to a "{}render buffer"{}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_ab6b653878f685eeea5feff5bc55d65b0}{init\+\_\+render\+\_\+to\+\_\+texture}} (const size\+\_\+t width, const size\+\_\+t height, GLuint \&tex\+\_\+id, GLuint \&fbo\+\_\+id, GLuint \&dfbo\+\_\+id)
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
GLuint \mbox{\hyperlink{namespaceigl_1_1opengl_a7d28d636421f0c47d69d4dc2b73fbe39}{load\+\_\+shader}} (const std\+::string \&src, const GLenum type)
\begin{DoxyCompactList}\small\item\em Creates and compiles a shader from a given string. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_ad53ec95dc32499a84b78cc753c0be4b4}{print\+\_\+program\+\_\+info\+\_\+log}} (const GLuint obj)
\begin{DoxyCompactList}\small\item\em Print the information log for a program object. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_ad2c5575db902618e488ef49d8ab34358}{print\+\_\+shader\+\_\+info\+\_\+log}} (const GLuint obj)
\begin{DoxyCompactList}\small\item\em Print the info log for a shader object. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1opengl_ad678bcaf9e800de821aab97429b0ceee}{read\+\_\+pixels}} (const GLuint width, const GLuint height, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&R, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&G, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&B, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&A, Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&D)
\begin{DoxyCompactList}\small\item\em Read full viewport into color, alpha and depth arrays suitable for igl\+::png\+::write\+PNG. \end{DoxyCompactList}\item 
GLenum \mbox{\hyperlink{namespaceigl_1_1opengl_aeb894bef3132fc177a66d54235c66133}{report\+\_\+gl\+\_\+error}} (const std\+::string id)
\begin{DoxyCompactList}\small\item\em Print last Open\+GL error to stderr prefixed by specified id string. \end{DoxyCompactList}\item 
GLenum \mbox{\hyperlink{namespaceigl_1_1opengl_a94637f36af5a94bbe26eaaecf41bf8ba}{report\+\_\+gl\+\_\+error}} ()
\begin{DoxyCompactList}\small\item\em This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. \end{DoxyCompactList}\item 
std\+::string \mbox{\hyperlink{namespaceigl_1_1opengl_aefa41e1672680581a7f43a0633d85776}{uniform\+\_\+type\+\_\+to\+\_\+string}} (const GLenum type)
\begin{DoxyCompactList}\small\item\em Convert a GL uniform variable type (say, returned from gl\+Get\+Active\+Uniform) and output a string naming that type. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespaceigl_1_1opengl_a35c6b235682036b135e9a0cb32b6d3cf}{decompress\+\_\+verasansmono\+\_\+atlas}} (unsigned char \texorpdfstring{$\ast$}{*}\+\_\+fontatlas)
\begin{DoxyCompactList}\small\item\em Decompress the vera sans mono font atlas. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename DerivedV , typename DerivedF $>$ }\\void \mbox{\hyperlink{namespaceigl_1_1opengl_a87b82a5ef0d8e4ba0e84f940804ac380}{vertex\+\_\+array}} (const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&V, const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&F, GLuint \&va\+\_\+id, GLuint \&ab\+\_\+id, GLuint \&eab\+\_\+id)
\begin{DoxyCompactList}\small\item\em Create a GL\+\_\+\+VERTEX\+\_\+\+ARRAY for a given mesh (V,F) \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{namespaceigl_1_1opengl_a967f6e5284d63e98cbd501388672bff9}\label{namespaceigl_1_1opengl_a967f6e5284d63e98cbd501388672bff9} 
\index{igl::opengl@{igl::opengl}!render\_to\_tga@{render\_to\_tga}}
\index{render\_to\_tga@{render\_to\_tga}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{render\_to\_tga()}{render\_to\_tga()}}
{\footnotesize\ttfamily bool igl\+::opengl\+::render\+\_\+to\+\_\+tga (\begin{DoxyParamCaption}\item[{const std\+::string}]{tga\+\_\+file,  }\item[{const int}]{width,  }\item[{const int}]{height,  }\item[{const bool}]{alpha }\end{DoxyParamCaption})}



alpha whether to include alpha channel 

\Hypertarget{namespaceigl_1_1opengl_a276e885ccdcfd9e60b772c3c4bb2f866}\label{namespaceigl_1_1opengl_a276e885ccdcfd9e60b772c3c4bb2f866} 
\index{igl::opengl@{igl::opengl}!texture\_from\_tga@{texture\_from\_tga}}
\index{texture\_from\_tga@{texture\_from\_tga}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{texture\_from\_tga()}{texture\_from\_tga()}}
{\footnotesize\ttfamily bool igl\+::opengl\+::texture\+\_\+from\+\_\+tga (\begin{DoxyParamCaption}\item[{const std\+::string}]{tga\+\_\+file,  }\item[{GLuint \&}]{id }\end{DoxyParamCaption})}



Read an image from a .tga file and use it as a texture. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em tga\+\_\+file} & path to .tga file \\
\hline
\mbox{\texttt{ out}}  & {\em id} & of generated open\+GL texture \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on failure 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_a73e1f94f7c5006844213837713652e0f}\label{namespaceigl_1_1opengl_a73e1f94f7c5006844213837713652e0f} 
\index{igl::opengl@{igl::opengl}!gliReadTGA@{gliReadTGA}}
\index{gliReadTGA@{gliReadTGA}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{gliReadTGA()}{gliReadTGA()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structigl_1_1opengl_1_1gliGenericImage}{gli\+Generic\+Image}} \texorpdfstring{$\ast$}{*} igl\+::opengl\+::gli\+Read\+TGA (\begin{DoxyParamCaption}\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp,  }\item[{char \texorpdfstring{$\ast$}{*}}]{name,  }\item[{int}]{hflip,  }\item[{int}]{vflip }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [extern]}}

\Hypertarget{namespaceigl_1_1opengl_a1581cf9fab6f2f7dbc495dc8c601bd9b}\label{namespaceigl_1_1opengl_a1581cf9fab6f2f7dbc495dc8c601bd9b} 
\index{igl::opengl@{igl::opengl}!gli\_verbose@{gli\_verbose}}
\index{gli\_verbose@{gli\_verbose}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{gli\_verbose()}{gli\_verbose()}}
{\footnotesize\ttfamily int igl\+::opengl\+::gli\+\_\+verbose (\begin{DoxyParamCaption}\item[{int}]{new\+\_\+verbose }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_1_1opengl_ab7b723fc81098ef1841429fb1e127d76}\label{namespaceigl_1_1opengl_ab7b723fc81098ef1841429fb1e127d76} 
\index{igl::opengl@{igl::opengl}!gliVerbose@{gliVerbose}}
\index{gliVerbose@{gliVerbose}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{gliVerbose()}{gliVerbose()}}
{\footnotesize\ttfamily int igl\+::opengl\+::gli\+Verbose (\begin{DoxyParamCaption}\item[{int}]{new\+Verbose }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [extern]}}

\Hypertarget{namespaceigl_1_1opengl_a0ee614bf7fc62ec302b276934bc9a8cc}\label{namespaceigl_1_1opengl_a0ee614bf7fc62ec302b276934bc9a8cc} 
\index{igl::opengl@{igl::opengl}!writeTGA@{writeTGA}}
\index{writeTGA@{writeTGA}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{writeTGA()}{writeTGA()}}
{\footnotesize\ttfamily void igl\+::opengl\+::write\+TGA (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structigl_1_1opengl_1_1gliGenericImage}{gli\+Generic\+Image}} \texorpdfstring{$\ast$}{*}}]{image,  }\item[{FILE \texorpdfstring{$\ast$}{*}}]{fp }\end{DoxyParamCaption})}

\Hypertarget{namespaceigl_1_1opengl_aeec995e7405f0abc5605089526f4ed91}\label{namespaceigl_1_1opengl_aeec995e7405f0abc5605089526f4ed91} 
\index{igl::opengl@{igl::opengl}!bind\_vertex\_attrib\_array@{bind\_vertex\_attrib\_array}}
\index{bind\_vertex\_attrib\_array@{bind\_vertex\_attrib\_array}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{bind\_vertex\_attrib\_array()}{bind\_vertex\_attrib\_array()}}
{\footnotesize\ttfamily template$<$typename Scalar , int Rows\+At\+Compile\+Time, int Cols\+At\+Compile\+Time$>$ \\
GLint igl\+::opengl\+::bind\+\_\+vertex\+\_\+attrib\+\_\+array (\begin{DoxyParamCaption}\item[{const GLuint}]{program\+\_\+shader,  }\item[{const std\+::string \&}]{name,  }\item[{GLuint}]{buffer\+ID,  }\item[{const Eigen\+::\+Matrix$<$ Scalar, Rows\+At\+Compile\+Time, Cols\+At\+Compile\+Time, Eigen\+::\+Row\+Major $>$ \&}]{M,  }\item[{const bool}]{refresh }\end{DoxyParamCaption})}



Bind a per-\/vertex array attribute and refresh its contents from an Eigen matrix. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em program\+\_\+shader} & id of shader program \\
\hline
\mbox{\texttt{ in}}  & {\em name} & name of attribute in vertex shader \\
\hline
\mbox{\texttt{ in}}  & {\em buffer\+ID} & id of buffer to bind to \\
\hline
\mbox{\texttt{ in}}  & {\em M} & \#V by dim matrix of per-\/vertex data \\
\hline
\mbox{\texttt{ in}}  & {\em refresh} & whether to actually call gl\+Buffer\+Data or just bind the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
id of named attribute in shader 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_afb53eea84ee235ebd173c8c150ce4759}\label{namespaceigl_1_1opengl_afb53eea84ee235ebd173c8c150ce4759} 
\index{igl::opengl@{igl::opengl}!create\_index\_vbo@{create\_index\_vbo}}
\index{create\_index\_vbo@{create\_index\_vbo}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_index\_vbo()}{create\_index\_vbo()}}
{\footnotesize\ttfamily void igl\+::opengl\+::create\+\_\+index\+\_\+vbo (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{GLuint \&}]{F\+\_\+vbo\+\_\+id }\end{DoxyParamCaption})}



Create a VBO (Vertex Buffer Object) for a list of indices\+: GL\+\_\+\+ELEMENT\+\_\+\+ARRAY\+\_\+\+BUFFER\+\_\+\+ARB for the triangle indices (F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ out}}  & {\em F\+\_\+vbo\+\_\+id} & buffer id for face indices \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_a09b4597fbcc534310ba6cd68ad18e41f}\label{namespaceigl_1_1opengl_a09b4597fbcc534310ba6cd68ad18e41f} 
\index{igl::opengl@{igl::opengl}!create\_mesh\_vbo@{create\_mesh\_vbo}}
\index{create\_mesh\_vbo@{create\_mesh\_vbo}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_mesh\_vbo()}{create\_mesh\_vbo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::opengl\+::create\+\_\+mesh\+\_\+vbo (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{GLuint \&}]{V\+\_\+vbo\+\_\+id,  }\item[{GLuint \&}]{F\+\_\+vbo\+\_\+id }\end{DoxyParamCaption})}



Create a VBO (Vertex Buffer Object) for a mesh. 

Actually two VBOs\+: one GL\+\_\+\+ARRAY\+\_\+\+BUFFER for the vertex positions (V) and one GL\+\_\+\+ELEMENT\+\_\+\+ARRAY\+\_\+\+BUFFER for the triangle indices (F)


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by 3 eigen Matrix of mesh vertex 3D positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 eigen Matrix of face (triangle) indices \\
\hline
\mbox{\texttt{ out}}  & {\em V\+\_\+vbo\+\_\+id} & buffer id for vertex positions \\
\hline
\mbox{\texttt{ out}}  & {\em F\+\_\+vbo\+\_\+id} & buffer id for face indices\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
when using gl\+Draw\+Elements VBOs for V and F using Matrix\+Xd and Matrix\+Xi will have types GL\+\_\+\+DOUBLE and GL\+\_\+\+UNSIGNED\+\_\+\+INT respectively 
\end{DoxyNote}
\Hypertarget{namespaceigl_1_1opengl_a33dff64f122b8ae53a54fb2c9b71445b}\label{namespaceigl_1_1opengl_a33dff64f122b8ae53a54fb2c9b71445b} 
\index{igl::opengl@{igl::opengl}!create\_mesh\_vbo@{create\_mesh\_vbo}}
\index{create\_mesh\_vbo@{create\_mesh\_vbo}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_mesh\_vbo()}{create\_mesh\_vbo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void igl\+::opengl\+::create\+\_\+mesh\+\_\+vbo (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix\+Xd \&}]{V,  }\item[{const Eigen\+::\+Matrix\+Xi \&}]{F,  }\item[{const Eigen\+::\+Matrix\+Xd \&}]{N,  }\item[{GLuint \&}]{V\+\_\+vbo\+\_\+id,  }\item[{GLuint \&}]{F\+\_\+vbo\+\_\+id,  }\item[{GLuint \&}]{N\+\_\+vbo\+\_\+id }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em N} & \#V by 3 eigen Matrix of mesh vertex 3D normals \\
\hline
\mbox{\texttt{ out}}  & {\em N\+\_\+vbo\+\_\+id} & buffer id for vertex positions \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_a387615839bfa5d4d521532cd18e96b23}\label{namespaceigl_1_1opengl_a387615839bfa5d4d521532cd18e96b23} 
\index{igl::opengl@{igl::opengl}!create\_shader\_program@{create\_shader\_program}}
\index{create\_shader\_program@{create\_shader\_program}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_shader\_program()}{create\_shader\_program()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily bool igl\+::opengl\+::create\+\_\+shader\+\_\+program (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{geom\+\_\+source,  }\item[{const std\+::string \&}]{vert\+\_\+source,  }\item[{const std\+::string \&}]{frag\+\_\+source,  }\item[{const std\+::map$<$ std\+::string, GLuint $>$ \&}]{attrib,  }\item[{GLuint \&}]{id }\end{DoxyParamCaption})}



Create a shader program with a vertex and fragments shader loading from source strings and vertex attributes assigned from a map before linking the shaders to the program, making it ready to use with gl\+Use\+Program(id) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em geom\+\_\+source} & string containing source code of geometry shader (can be "{}"{} to mean use default pass-\/through) \\
\hline
\mbox{\texttt{ in}}  & {\em vert\+\_\+source} & string containing source code of vertex shader \\
\hline
\mbox{\texttt{ in}}  & {\em frag\+\_\+source} & string containing source code of fragment shader \\
\hline
\mbox{\texttt{ in}}  & {\em attrib} & map containing table of vertex attribute strings add their correspondingly ids (generated previously using gl\+Bind\+Attrib\+Location) \\
\hline
\mbox{\texttt{ out}}  & {\em id} & index id of created shader, set to 0 on error \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Caller is responsible for making sure that current value of id is not leaking a shader (since it will be overwritten)
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1opengl_a04d4be929fb0aefff3d0bee345e159c5}{destroy\+\_\+shader\+\_\+program} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1opengl_acb61cde775b172998ae6e6f9dffd5d96}\label{namespaceigl_1_1opengl_acb61cde775b172998ae6e6f9dffd5d96} 
\index{igl::opengl@{igl::opengl}!create\_shader\_program@{create\_shader\_program}}
\index{create\_shader\_program@{create\_shader\_program}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_shader\_program()}{create\_shader\_program()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily bool igl\+::opengl\+::create\+\_\+shader\+\_\+program (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{vert\+\_\+source,  }\item[{const std\+::string \&}]{frag\+\_\+source,  }\item[{const std\+::map$<$ std\+::string, GLuint $>$ \&}]{attrib,  }\item[{GLuint \&}]{id }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1opengl_a8804baac0135e31d5b9f585a1adb5cb5}\label{namespaceigl_1_1opengl_a8804baac0135e31d5b9f585a1adb5cb5} 
\index{igl::opengl@{igl::opengl}!create\_shader\_program@{create\_shader\_program}}
\index{create\_shader\_program@{create\_shader\_program}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_shader\_program()}{create\_shader\_program()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily GLuint igl\+::opengl\+::create\+\_\+shader\+\_\+program (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{geom\+\_\+source,  }\item[{const std\+::string \&}]{vert\+\_\+source,  }\item[{const std\+::string \&}]{frag\+\_\+source,  }\item[{const std\+::map$<$ std\+::string, GLuint $>$ \&}]{attrib }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\begin{DoxyReturn}{Returns}
index id of created shader, set to 0 on error 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_a69e00ecaf2b3546583b44f5876a9f32c}\label{namespaceigl_1_1opengl_a69e00ecaf2b3546583b44f5876a9f32c} 
\index{igl::opengl@{igl::opengl}!create\_shader\_program@{create\_shader\_program}}
\index{create\_shader\_program@{create\_shader\_program}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_shader\_program()}{create\_shader\_program()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily GLuint igl\+::opengl\+::create\+\_\+shader\+\_\+program (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{vert\+\_\+source,  }\item[{const std\+::string \&}]{frag\+\_\+source,  }\item[{const std\+::map$<$ std\+::string, GLuint $>$ \&}]{attrib }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\begin{DoxyReturn}{Returns}
index id of created shader, set to 0 on error 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_a4d8948cd3db199a58744bcb5ecb8e010}\label{namespaceigl_1_1opengl_a4d8948cd3db199a58744bcb5ecb8e010} 
\index{igl::opengl@{igl::opengl}!create\_vector\_vbo@{create\_vector\_vbo}}
\index{create\_vector\_vbo@{create\_vector\_vbo}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{create\_vector\_vbo()}{create\_vector\_vbo()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::opengl\+::create\+\_\+vector\+\_\+vbo (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{V,  }\item[{GLuint \&}]{V\+\_\+vbo\+\_\+id }\end{DoxyParamCaption})}



Create a VBO (Vertex Buffer Object) for a list of vectors\+: GL\+\_\+\+ARRAY\+\_\+\+BUFFER for the vectors (V) 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & should be a eigen matrix primitive type like int or double \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & m by n eigen Matrix of type T values \\
\hline
\mbox{\texttt{ out}}  & {\em V\+\_\+vbo\+\_\+id} & buffer id for vectors \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_a04d4be929fb0aefff3d0bee345e159c5}\label{namespaceigl_1_1opengl_a04d4be929fb0aefff3d0bee345e159c5} 
\index{igl::opengl@{igl::opengl}!destroy\_shader\_program@{destroy\_shader\_program}}
\index{destroy\_shader\_program@{destroy\_shader\_program}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{destroy\_shader\_program()}{destroy\_shader\_program()}}
{\footnotesize\ttfamily bool igl\+::opengl\+::destroy\+\_\+shader\+\_\+program (\begin{DoxyParamCaption}\item[{const GLuint}]{id }\end{DoxyParamCaption})}



Properly destroy a shader program. 

Detach and delete each of its shaders and delete it


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em id} & index id of created shader, set to 0 on error \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true on success, false on error
\end{DoxyReturn}
\begin{DoxyNote}{Note}
caller is responsible for making sure he doesn\textquotesingle{}t foolishly continue to use id as if it still contains a program
\end{DoxyNote}
\begin{DoxySeeAlso}{See also}
\doxylink{namespaceigl_1_1opengl_a387615839bfa5d4d521532cd18e96b23}{create\+\_\+shader\+\_\+program} 
\end{DoxySeeAlso}
\Hypertarget{namespaceigl_1_1opengl_ab44717ffa90f441c2b8597a3809e516a}\label{namespaceigl_1_1opengl_ab44717ffa90f441c2b8597a3809e516a} 
\index{igl::opengl@{igl::opengl}!gl\_type\_size@{gl\_type\_size}}
\index{gl\_type\_size@{gl\_type\_size}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{gl\_type\_size()}{gl\_type\_size()}}
{\footnotesize\ttfamily int igl\+::opengl\+::gl\+\_\+type\+\_\+size (\begin{DoxyParamCaption}\item[{const GLenum}]{type }\end{DoxyParamCaption})}



Return the number of bytes for a given Open\+GL type. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em type} & enum value of opengl type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size in bytes of type 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_ac2d55d2b5f33e5c392361023b7c49c8f}\label{namespaceigl_1_1opengl_ac2d55d2b5f33e5c392361023b7c49c8f} 
\index{igl::opengl@{igl::opengl}!init\_render\_to\_texture@{init\_render\_to\_texture}}
\index{init\_render\_to\_texture@{init\_render\_to\_texture}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{init\_render\_to\_texture()}{init\_render\_to\_texture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void igl\+::opengl\+::init\+\_\+render\+\_\+to\+\_\+texture (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{width,  }\item[{const size\+\_\+t}]{height,  }\item[{const bool}]{depth\+\_\+texture,  }\item[{GLuint \&}]{tex\+\_\+id,  }\item[{GLuint \&}]{fbo\+\_\+id,  }\item[{GLuint \&}]{d\+\_\+id }\end{DoxyParamCaption})}



Create a frame buffer that renders color to a RGBA texture a depth to a "{}render buffer"{}. 

After calling this, you can use with something like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{glBindFramebuffer(GL\_FRAMEBUFFER,\ fbo\_id);}
\DoxyCodeLine{\textcolor{keywordflow}{if}(!depth\_texture)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ glBindRenderbuffer(GL\_RENDERBUFFER,\ d\_id);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{//\ draw\ scene\ ...}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{//\ clean\ up}}
\DoxyCodeLine{glBindFramebuffer(GL\_FRAMEBUFFER,0);}
\DoxyCodeLine{\textcolor{keywordflow}{if}(!depth\_texture)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ glBindRenderbuffer(GL\_RENDERBUFFER,\ 0);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{comment}{//\ Later\ ...}}
\DoxyCodeLine{glActiveTexture(GL\_TEXTURE0+0);}
\DoxyCodeLine{glBindTexture(GL\_TEXTURE\_2D,tex\_id);}
\DoxyCodeLine{\textcolor{keywordflow}{if}(depth\_texture)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ glActiveTexture(GL\_TEXTURE0+1);}
\DoxyCodeLine{\ \ glBindTexture(GL\_TEXTURE\_2D,d\_id);}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{comment}{//\ draw\ textures}}

\end{DoxyCode}



\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em width} & image width \\
\hline
\mbox{\texttt{ in}}  & {\em height} & image height \\
\hline
\mbox{\texttt{ in}}  & {\em depth\+\_\+texture} & whether to create a texture for depth or to create a render buffer for depth \\
\hline
\mbox{\texttt{ out}}  & {\em tex\+\_\+id} & id of the texture \\
\hline
\mbox{\texttt{ out}}  & {\em fbo\+\_\+id} & id of the frame buffer object \\
\hline
\mbox{\texttt{ out}}  & {\em d\+\_\+id} & id of the depth texture or frame buffer object \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_ab6b653878f685eeea5feff5bc55d65b0}\label{namespaceigl_1_1opengl_ab6b653878f685eeea5feff5bc55d65b0} 
\index{igl::opengl@{igl::opengl}!init\_render\_to\_texture@{init\_render\_to\_texture}}
\index{init\_render\_to\_texture@{init\_render\_to\_texture}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{init\_render\_to\_texture()}{init\_render\_to\_texture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void igl\+::opengl\+::init\+\_\+render\+\_\+to\+\_\+texture (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{width,  }\item[{const size\+\_\+t}]{height,  }\item[{GLuint \&}]{tex\+\_\+id,  }\item[{GLuint \&}]{fbo\+\_\+id,  }\item[{GLuint \&}]{dfbo\+\_\+id }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

Wrapper with depth\+\_\+texture = false for legacy reasons \Hypertarget{namespaceigl_1_1opengl_a7d28d636421f0c47d69d4dc2b73fbe39}\label{namespaceigl_1_1opengl_a7d28d636421f0c47d69d4dc2b73fbe39} 
\index{igl::opengl@{igl::opengl}!load\_shader@{load\_shader}}
\index{load\_shader@{load\_shader}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{load\_shader()}{load\_shader()}}
{\footnotesize\ttfamily GLuint igl\+::opengl\+::load\+\_\+shader (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{src,  }\item[{const GLenum}]{type }\end{DoxyParamCaption})}



Creates and compiles a shader from a given string. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em src} & string containing GLSL shader code \\
\hline
\mbox{\texttt{ in}}  & {\em type} & GLSL type of shader, one of\+: GL\+\_\+\+VERTEX\+\_\+\+SHADER GL\+\_\+\+FRAGMENT\+\_\+\+SHADER GL\+\_\+\+GEOMETRY\+\_\+\+SHADER \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
index id of the newly created shader, 0 on error
\end{DoxyReturn}
Will immediately return 0 if src is empty. \Hypertarget{namespaceigl_1_1opengl_ad53ec95dc32499a84b78cc753c0be4b4}\label{namespaceigl_1_1opengl_ad53ec95dc32499a84b78cc753c0be4b4} 
\index{igl::opengl@{igl::opengl}!print\_program\_info\_log@{print\_program\_info\_log}}
\index{print\_program\_info\_log@{print\_program\_info\_log}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{print\_program\_info\_log()}{print\_program\_info\_log()}}
{\footnotesize\ttfamily void igl\+::opengl\+::print\+\_\+program\+\_\+info\+\_\+log (\begin{DoxyParamCaption}\item[{const GLuint}]{obj }\end{DoxyParamCaption})}



Print the information log for a program object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & Open\+GL index of program to print info log about \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_ad2c5575db902618e488ef49d8ab34358}\label{namespaceigl_1_1opengl_ad2c5575db902618e488ef49d8ab34358} 
\index{igl::opengl@{igl::opengl}!print\_shader\_info\_log@{print\_shader\_info\_log}}
\index{print\_shader\_info\_log@{print\_shader\_info\_log}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{print\_shader\_info\_log()}{print\_shader\_info\_log()}}
{\footnotesize\ttfamily void igl\+::opengl\+::print\+\_\+shader\+\_\+info\+\_\+log (\begin{DoxyParamCaption}\item[{const GLuint}]{obj }\end{DoxyParamCaption})}



Print the info log for a shader object. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em obj} & Open\+GL index of shader to print info log about \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_ad678bcaf9e800de821aab97429b0ceee}\label{namespaceigl_1_1opengl_ad678bcaf9e800de821aab97429b0ceee} 
\index{igl::opengl@{igl::opengl}!read\_pixels@{read\_pixels}}
\index{read\_pixels@{read\_pixels}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{read\_pixels()}{read\_pixels()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void igl\+::opengl\+::read\+\_\+pixels (\begin{DoxyParamCaption}\item[{const GLuint}]{width,  }\item[{const GLuint}]{height,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{R,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{G,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{B,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{A,  }\item[{Eigen\+::\+Matrix$<$ T, Eigen\+::\+Dynamic, Eigen\+::\+Dynamic $>$ \&}]{D }\end{DoxyParamCaption})}



Read full viewport into color, alpha and depth arrays suitable for igl\+::png\+::write\+PNG. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em width} & width of viewport \\
\hline
\mbox{\texttt{ in}}  & {\em height} & height of viewport \\
\hline
\mbox{\texttt{ out}}  & {\em R} & width by height list of red values \\
\hline
\mbox{\texttt{ out}}  & {\em G} & width by height list of green values \\
\hline
\mbox{\texttt{ out}}  & {\em B} & width by height list of blue values \\
\hline
\mbox{\texttt{ out}}  & {\em A} & width by height list of alpha values \\
\hline
\mbox{\texttt{ out}}  & {\em D} & width by height list of depth values \\
\hline
\end{DoxyParams}
\Hypertarget{namespaceigl_1_1opengl_aeb894bef3132fc177a66d54235c66133}\label{namespaceigl_1_1opengl_aeb894bef3132fc177a66d54235c66133} 
\index{igl::opengl@{igl::opengl}!report\_gl\_error@{report\_gl\_error}}
\index{report\_gl\_error@{report\_gl\_error}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{report\_gl\_error()}{report\_gl\_error()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily GLenum igl\+::opengl\+::report\+\_\+gl\+\_\+error (\begin{DoxyParamCaption}\item[{const std\+::string}]{id }\end{DoxyParamCaption})}



Print last Open\+GL error to stderr prefixed by specified id string. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em id} & string to appear before any error msgs \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
result of gl\+Get\+Error() ~\newline
 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_a94637f36af5a94bbe26eaaecf41bf8ba}\label{namespaceigl_1_1opengl_a94637f36af5a94bbe26eaaecf41bf8ba} 
\index{igl::opengl@{igl::opengl}!report\_gl\_error@{report\_gl\_error}}
\index{report\_gl\_error@{report\_gl\_error}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{report\_gl\_error()}{report\_gl\_error()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily GLenum igl\+::opengl\+::report\+\_\+gl\+\_\+error (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 

\Hypertarget{namespaceigl_1_1opengl_aefa41e1672680581a7f43a0633d85776}\label{namespaceigl_1_1opengl_aefa41e1672680581a7f43a0633d85776} 
\index{igl::opengl@{igl::opengl}!uniform\_type\_to\_string@{uniform\_type\_to\_string}}
\index{uniform\_type\_to\_string@{uniform\_type\_to\_string}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{uniform\_type\_to\_string()}{uniform\_type\_to\_string()}}
{\footnotesize\ttfamily std\+::string igl\+::opengl\+::uniform\+\_\+type\+\_\+to\+\_\+string (\begin{DoxyParamCaption}\item[{const GLenum}]{type }\end{DoxyParamCaption})}



Convert a GL uniform variable type (say, returned from gl\+Get\+Active\+Uniform) and output a string naming that type. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em type} & enum for given type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string name of that type 
\end{DoxyReturn}
\Hypertarget{namespaceigl_1_1opengl_a35c6b235682036b135e9a0cb32b6d3cf}\label{namespaceigl_1_1opengl_a35c6b235682036b135e9a0cb32b6d3cf} 
\index{igl::opengl@{igl::opengl}!decompress\_verasansmono\_atlas@{decompress\_verasansmono\_atlas}}
\index{decompress\_verasansmono\_atlas@{decompress\_verasansmono\_atlas}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{decompress\_verasansmono\_atlas()}{decompress\_verasansmono\_atlas()}}
{\footnotesize\ttfamily void igl\+::opengl\+::decompress\+\_\+verasansmono\+\_\+atlas (\begin{DoxyParamCaption}\item[{unsigned char \texorpdfstring{$\ast$}{*}}]{\+\_\+fontatlas }\end{DoxyParamCaption})}



Decompress the vera sans mono font atlas. 

\Hypertarget{namespaceigl_1_1opengl_a87b82a5ef0d8e4ba0e84f940804ac380}\label{namespaceigl_1_1opengl_a87b82a5ef0d8e4ba0e84f940804ac380} 
\index{igl::opengl@{igl::opengl}!vertex\_array@{vertex\_array}}
\index{vertex\_array@{vertex\_array}!igl::opengl@{igl::opengl}}
\doxysubsubsection{\texorpdfstring{vertex\_array()}{vertex\_array()}}
{\footnotesize\ttfamily template$<$typename DerivedV , typename DerivedF $>$ \\
void igl\+::opengl\+::vertex\+\_\+array (\begin{DoxyParamCaption}\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedV $>$ \&}]{V,  }\item[{const Eigen\+::\+Plain\+Object\+Base$<$ DerivedF $>$ \&}]{F,  }\item[{GLuint \&}]{va\+\_\+id,  }\item[{GLuint \&}]{ab\+\_\+id,  }\item[{GLuint \&}]{eab\+\_\+id }\end{DoxyParamCaption})}



Create a GL\+\_\+\+VERTEX\+\_\+\+ARRAY for a given mesh (V,F) 


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em V} & \#V by dim list of mesh vertex positions \\
\hline
\mbox{\texttt{ in}}  & {\em F} & \#F by 3 list of mesh triangle indices into V \\
\hline
\mbox{\texttt{ out}}  & {\em va\+\_\+id} & id of vertex array \\
\hline
\mbox{\texttt{ out}}  & {\em ab\+\_\+id} & id of array buffer (vertex buffer object) \\
\hline
\mbox{\texttt{ out}}  & {\em eab\+\_\+id} & id of element array buffer (element/face buffer object)\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Unlike most libigl functions, the {\bfseries{input}} Eigen matrices must be {\ttfamily Eigen\+::\+Plain\+Object\+Base} because we want to directly access it\textquotesingle{}s underlying storage. It cannot be {\ttfamily Eigen\+::\+Matrix\+Base} (see \href{http://stackoverflow.com/questions/25094948/}{\texttt{ http\+://stackoverflow.\+com/questions/25094948/}}) 
\end{DoxyNote}
