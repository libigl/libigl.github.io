<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libigl: igl::predicates Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libigl<span id="projectnumber">&#160;v2.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceigl_1_1predicates.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">igl::predicates Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aacb20fd4a9b17ca7521e3d96e39d418b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418baab6c31432785221bae58327ef5f6ea58">POSITIVE</a> =1
, <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418ba554a7418c4c0dafd902ebd377b87c80c">INSIDE</a> =1
, <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418ba50546bf973283065b6ccf09faf7a580a">NEGATIVE</a> =-1
, <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418ba93da25bafef6761717afc6b25c17ea16">OUTSIDE</a> =-1
, <br />
&#160;&#160;<a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418bac514333ce2954c3110061a9d61666f8c">COLLINEAR</a> =0
, <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418ba9b1fc8879c96b8594f626bd204405336">COPLANAR</a> =0
, <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418bacfb327ad336ef0a1ba58a8651000d228">COCIRCULAR</a> =0
, <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418ba744ce244a9eef07f7a7fed2073d10947">COSPHERICAL</a> =0
, <br />
&#160;&#160;<a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418ba6084ee8bb30ae219127db8b7aece408a">DEGENERATE</a> =0
<br />
 }</td></tr>
<tr class="memdesc:aacb20fd4a9b17ca7521e3d96e39d418b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of orientations and other predicate results.  <a href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">More...</a><br /></td></tr>
<tr class="separator:aacb20fd4a9b17ca7521e3d96e39d418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7edd289c72535b2014622b5fc55c397e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a7edd289c72535b2014622b5fc55c397e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a7edd289c72535b2014622b5fc55c397e">delaunay_triangulation</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a7edd289c72535b2014622b5fc55c397e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in 2D, return a Delaunay triangulation of these points using predicates.  <br /></td></tr>
<tr class="separator:a7edd289c72535b2014622b5fc55c397e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87050342a2559880af3a5d0b550bfd0a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedRT , typename DerivedF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a87050342a2559880af3a5d0b550bfd0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a87050342a2559880af3a5d0b550bfd0a">ear_clipping</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedRT &gt; &amp;RT, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;eF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a87050342a2559880af3a5d0b550bfd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of ear clipping triangulation algorithm for a 2D polygon.  <br /></td></tr>
<tr class="separator:a87050342a2559880af3a5d0b550bfd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada15b6ecd90806923001927e53180fd4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedF &gt; </td></tr>
<tr class="memitem:ada15b6ecd90806923001927e53180fd4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#ada15b6ecd90806923001927e53180fd4">ear_clipping</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;eF)</td></tr>
<tr class="memdesc:ada15b6ecd90806923001927e53180fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ada15b6ecd90806923001927e53180fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e6a3ff4a055fb5e6c749d601d3e694"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a61e6a3ff4a055fb5e6c749d601d3e694"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a61e6a3ff4a055fb5e6c749d601d3e694">lexicographic_triangulation</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a61e6a3ff4a055fb5e6c749d601d3e694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in 2D, return a lexicographic triangulation of these points using predicates.  <br /></td></tr>
<tr class="separator:a61e6a3ff4a055fb5e6c749d601d3e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780c668969af51b6d39c023d8850192"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedQ &gt; </td></tr>
<tr class="memitem:a7780c668969af51b6d39c023d8850192"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a7780c668969af51b6d39c023d8850192">point_inside_convex_polygon</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;q)</td></tr>
<tr class="memdesc:a7780c668969af51b6d39c023d8850192"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether 2d point lies inside 2d convex polygon  <br /></td></tr>
<tr class="separator:a7780c668969af51b6d39c023d8850192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c1fbb1f6a62e7083463a89556bdfc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:ae34c1fbb1f6a62e7083463a89556bdfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#ae34c1fbb1f6a62e7083463a89556bdfc">polygons_to_triangles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:ae34c1fbb1f6a62e7083463a89556bdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a polygon mesh, trivially triangulate each polygon with a fan.  <br /></td></tr>
<tr class="separator:ae34c1fbb1f6a62e7083463a89556bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b443360a322c1ab15643ea1bad58d58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a7b443360a322c1ab15643ea1bad58d58">exactinit</a> ()</td></tr>
<tr class="memdesc:a7b443360a322c1ab15643ea1bad58d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize internal variable used by predciates.  <br /></td></tr>
<tr class="separator:a7b443360a322c1ab15643ea1bad58d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85f8a0e2f35b55088ba76fa3e269a1a"><td class="memTemplParams" colspan="2">template&lt;typename Vector2D &gt; </td></tr>
<tr class="memitem:ab85f8a0e2f35b55088ba76fa3e269a1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#ab85f8a0e2f35b55088ba76fa3e269a1a">orient2d</a> (const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pa, const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pb, const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pc)</td></tr>
<tr class="memdesc:ab85f8a0e2f35b55088ba76fa3e269a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the orientation of the triangle formed by pa, pb, pc.  <br /></td></tr>
<tr class="separator:ab85f8a0e2f35b55088ba76fa3e269a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16875914854207c54ce309a69d802292"><td class="memTemplParams" colspan="2">template&lt;typename Vector3D &gt; </td></tr>
<tr class="memitem:a16875914854207c54ce309a69d802292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a16875914854207c54ce309a69d802292">orient3d</a> (const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pa, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pb, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pc, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pd)</td></tr>
<tr class="memdesc:a16875914854207c54ce309a69d802292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the orientation of the tetrahedron formed by pa, pb, pc, pd.  <br /></td></tr>
<tr class="separator:a16875914854207c54ce309a69d802292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dc07d0d7c3e70d012a400c07fea6d5"><td class="memTemplParams" colspan="2">template&lt;typename Vector2D &gt; </td></tr>
<tr class="memitem:a34dc07d0d7c3e70d012a400c07fea6d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a34dc07d0d7c3e70d012a400c07fea6d5">incircle</a> (const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pa, const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pb, const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pc, const Eigen::MatrixBase&lt; Vector2D &gt; &amp;pd)</td></tr>
<tr class="memdesc:a34dc07d0d7c3e70d012a400c07fea6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a point is inside/outside/on a circle.  <br /></td></tr>
<tr class="separator:a34dc07d0d7c3e70d012a400c07fea6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f8cfda1a577af57f2729330ca6a459"><td class="memTemplParams" colspan="2">template&lt;typename Vector3D &gt; </td></tr>
<tr class="memitem:aa3f8cfda1a577af57f2729330ca6a459"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#aa3f8cfda1a577af57f2729330ca6a459">insphere</a> (const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pa, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pb, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pc, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pd, const Eigen::MatrixBase&lt; Vector3D &gt; &amp;pe)</td></tr>
<tr class="memdesc:aa3f8cfda1a577af57f2729330ca6a459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide whether a point is inside/outside/on a sphere.  <br /></td></tr>
<tr class="separator:aa3f8cfda1a577af57f2729330ca6a459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660dbf746a2adc274bc12ba3938bd049"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP &gt; </td></tr>
<tr class="memitem:a660dbf746a2adc274bc12ba3938bd049"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html#a660dbf746a2adc274bc12ba3938bd049">segment_segment_intersect</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;D)</td></tr>
<tr class="memdesc:a660dbf746a2adc274bc12ba3938bd049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two segments in 2d test whether they intersect each other using predicates orient2d.  <br /></td></tr>
<tr class="separator:a660dbf746a2adc274bc12ba3938bd049"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aacb20fd4a9b17ca7521e3d96e39d418b" name="aacb20fd4a9b17ca7521e3d96e39d418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb20fd4a9b17ca7521e3d96e39d418b">&#9670;&#160;</a></span>Orientation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">igl::predicates::Orientation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of orientations and other predicate results. </p>
<p><a class="el" href="predicates_8h.html">include/igl/predicates/predicates.h</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418baab6c31432785221bae58327ef5f6ea58" name="aacb20fd4a9b17ca7521e3d96e39d418baab6c31432785221bae58327ef5f6ea58"></a>POSITIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418ba554a7418c4c0dafd902ebd377b87c80c" name="aacb20fd4a9b17ca7521e3d96e39d418ba554a7418c4c0dafd902ebd377b87c80c"></a>INSIDE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418ba50546bf973283065b6ccf09faf7a580a" name="aacb20fd4a9b17ca7521e3d96e39d418ba50546bf973283065b6ccf09faf7a580a"></a>NEGATIVE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418ba93da25bafef6761717afc6b25c17ea16" name="aacb20fd4a9b17ca7521e3d96e39d418ba93da25bafef6761717afc6b25c17ea16"></a>OUTSIDE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418bac514333ce2954c3110061a9d61666f8c" name="aacb20fd4a9b17ca7521e3d96e39d418bac514333ce2954c3110061a9d61666f8c"></a>COLLINEAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418ba9b1fc8879c96b8594f626bd204405336" name="aacb20fd4a9b17ca7521e3d96e39d418ba9b1fc8879c96b8594f626bd204405336"></a>COPLANAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418bacfb327ad336ef0a1ba58a8651000d228" name="aacb20fd4a9b17ca7521e3d96e39d418bacfb327ad336ef0a1ba58a8651000d228"></a>COCIRCULAR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418ba744ce244a9eef07f7a7fed2073d10947" name="aacb20fd4a9b17ca7521e3d96e39d418ba744ce244a9eef07f7a7fed2073d10947"></a>COSPHERICAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aacb20fd4a9b17ca7521e3d96e39d418ba6084ee8bb30ae219127db8b7aece408a" name="aacb20fd4a9b17ca7521e3d96e39d418ba6084ee8bb30ae219127db8b7aece408a"></a>DEGENERATE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7edd289c72535b2014622b5fc55c397e" name="a7edd289c72535b2014622b5fc55c397e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7edd289c72535b2014622b5fc55c397e">&#9670;&#160;</a></span>delaunay_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::predicates::delaunay_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in 2D, return a Delaunay triangulation of these points using predicates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 of faces in Delaunay triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87050342a2559880af3a5d0b550bfd0a" name="a87050342a2559880af3a5d0b550bfd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87050342a2559880af3a5d0b550bfd0a">&#9670;&#160;</a></span>ear_clipping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedRT , typename DerivedF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::predicates::ear_clipping </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedRT &gt; &amp;&#160;</td>
          <td class="paramname"><em>RT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>eF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of ear clipping triangulation algorithm for a 2D polygon. </p>
<p><a href="https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf">https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf</a> If the polygon is simple and oriented counter-clockwise, all vertices will be clipped and the result mesh is (P,eF) Otherwise, the function will try to clip as many ears as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>: n*2, size n 2D polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">RT</td><td>n*1, preserved vertices (do not clip) marked as 1, otherwise 0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eF</td><td>clipped ears, in original index of P </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>: size #nP vector, maps index from nP to P, e.g. nP's ith vertex is origianlly I(i) in P</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>To result in a proper mesh, P should be oriented counter-clockwise with no self-intersections.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This implementation does not handle polygons with holes.</dd></dl>

</div>
</div>
<a id="ada15b6ecd90806923001927e53180fd4" name="ada15b6ecd90806923001927e53180fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada15b6ecd90806923001927e53180fd4">&#9670;&#160;</a></span>ear_clipping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::predicates::ear_clipping </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>eF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Reverses P if necessary. Orientation of output will match input </p><dl class="section return"><dt>Returns</dt><dd>true if mesh is proper (should correspond to input being a simple polygon in either orientation), false otherwise. </dd></dl>

</div>
</div>
<a id="a61e6a3ff4a055fb5e6c749d601d3e694" name="a61e6a3ff4a055fb5e6c749d601d3e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e6a3ff4a055fb5e6c749d601d3e694">&#9670;&#160;</a></span>lexicographic_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::predicates::lexicographic_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in 2D, return a lexicographic triangulation of these points using predicates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 of faces in Delaunay triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7780c668969af51b6d39c023d8850192" name="a7780c668969af51b6d39c023d8850192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7780c668969af51b6d39c023d8850192">&#9670;&#160;</a></span>point_inside_convex_polygon()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::predicates::point_inside_convex_polygon </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether 2d point lies inside 2d convex polygon </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>n*2 polygon, n &gt;= 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>2d query point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if point is inside polygon </dd></dl>

</div>
</div>
<a id="ae34c1fbb1f6a62e7083463a89556bdfc" name="ae34c1fbb1f6a62e7083463a89556bdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c1fbb1f6a62e7083463a89556bdfc">&#9670;&#160;</a></span>polygons_to_triangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::predicates::polygons_to_triangles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a polygon mesh, trivially triangulate each polygon with a fan. </p>
<p>This purely combinatorial triangulation will work well for convex/flat polygons and degrade otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F list of indices into 0:#P-1 of corresponding polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b443360a322c1ab15643ea1bad58d58" name="a7b443360a322c1ab15643ea1bad58d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b443360a322c1ab15643ea1bad58d58">&#9670;&#160;</a></span>exactinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::predicates::exactinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize internal variable used by predciates. </p>
<p>Must be called before using exact predicates. It is safe to call this function from multiple threads.</p>
<p><a class="el" href="predicates_8h.html">include/igl/predicates/predicates.h</a> </p>

</div>
</div>
<a id="ab85f8a0e2f35b55088ba76fa3e269a1a" name="ab85f8a0e2f35b55088ba76fa3e269a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85f8a0e2f35b55088ba76fa3e269a1a">&#9670;&#160;</a></span>orient2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector2D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a> igl::predicates::orient2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the orientation of the triangle formed by pa, pb, pc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>2D point on line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>2D point on line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>2D query point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>POSITIVE if pa, pb, pc are counterclockwise oriented. NEGATIVE if they are clockwise oriented. COLLINEAR if they are collinear.</dd></dl>
<p><a class="el" href="predicates_8h.html">include/igl/predicates/predicates.h</a> </p>

</div>
</div>
<a id="a16875914854207c54ce309a69d802292" name="a16875914854207c54ce309a69d802292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16875914854207c54ce309a69d802292">&#9670;&#160;</a></span>orient3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector3D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a> igl::predicates::orient3d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the orientation of the tetrahedron formed by pa, pb, pc, pd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>2D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>2D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>2D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>2D query point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>POSITIVE if pd is "below" the oriented plane formed by pa, pb and pc. NEGATIVE if pd is "above" the plane. COPLANAR if pd is on the plane.</dd></dl>
<p><a class="el" href="predicates_8h.html">include/igl/predicates/predicates.h</a> </p>

</div>
</div>
<a id="a34dc07d0d7c3e70d012a400c07fea6d5" name="a34dc07d0d7c3e70d012a400c07fea6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34dc07d0d7c3e70d012a400c07fea6d5">&#9670;&#160;</a></span>incircle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector2D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a> igl::predicates::incircle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector2D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether a point is inside/outside/on a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>2D point on circle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>2D point on circle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>2D point on circle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>2D point query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>INSIDE if pd is inside of the circle defined by pa, pb and pc. OUSIDE if pd is outside of the circle. COCIRCULAR pd is exactly on the circle.</dd></dl>
<p><a class="el" href="predicates_8h.html">include/igl/predicates/predicates.h</a> </p>

</div>
</div>
<a id="aa3f8cfda1a577af57f2729330ca6a459" name="aa3f8cfda1a577af57f2729330ca6a459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f8cfda1a577af57f2729330ca6a459">&#9670;&#160;</a></span>insphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector3D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl_1_1predicates.html#aacb20fd4a9b17ca7521e3d96e39d418b">Orientation</a> igl::predicates::insphere </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Vector3D &gt; &amp;&#160;</td>
          <td class="paramname"><em>pe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide whether a point is inside/outside/on a sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>2D point query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>INSIDE if pe is inside of the sphere defined by pa, pb, pc and pd. OUSIDE if pe is outside of the sphere. COSPHERICAL pd is exactly on the sphere.</dd></dl>
<p><a class="el" href="predicates_8h.html">include/igl/predicates/predicates.h</a> </p>

</div>
</div>
<a id="a660dbf746a2adc274bc12ba3938bd049" name="a660dbf746a2adc274bc12ba3938bd049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660dbf746a2adc274bc12ba3938bd049">&#9670;&#160;</a></span>segment_segment_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::predicates::segment_segment_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two segments in 2d test whether they intersect each other using predicates orient2d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>1st endpoint of segment 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>2st endpoint of segment 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>1st endpoint of segment 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>2st endpoint of segment 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if they intersect </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceigl.html">igl</a></li><li class="navelem"><a class="el" href="namespaceigl_1_1predicates.html">predicates</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
