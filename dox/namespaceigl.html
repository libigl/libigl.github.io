<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libigl: igl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libigl<span id="projectnumber">&#160;v2.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceigl.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">igl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceigl_1_1copyleft" id="r_namespaceigl_1_1copyleft"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html">copyleft</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1embree" id="r_namespaceigl_1_1embree"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html">embree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1matlab" id="r_namespaceigl_1_1matlab"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1matlab.html">matlab</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1mosek" id="r_namespaceigl_1_1mosek"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1mosek.html">mosek</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1opengl" id="r_namespaceigl_1_1opengl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1opengl.html">opengl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1predicates" id="r_namespaceigl_1_1predicates"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1predicates.html">predicates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1serialization" id="r_namespaceigl_1_1serialization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1serialization.html">serialization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1spectra" id="r_namespaceigl_1_1spectra"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1spectra.html">spectra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1stb" id="r_namespaceigl_1_1stb"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1stb.html">stb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1triangle" id="r_namespaceigl_1_1triangle"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1triangle.html">triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1xml" id="r_namespaceigl_1_1xml"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1xml.html">xml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1AABB.html">AABB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of semi-general purpose axis-aligned bounding box hierarchy.  <a href="classigl_1_1AABB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1active__set__params.html">active_set_params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Input parameters controling active_set.  <a href="structigl_1_1active__set__params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1ARAPData.html">ARAPData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters and precomputed values for arap solver.  <a href="structigl_1_1ARAPData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that contains fields for all precomputed data or data that needs to be remembered at update.  <a href="structigl_1_1ArapDOFData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1AtA__cached__data.html">AtA_cached_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hold precomputed data for AtA_cached.  <a href="structigl_1_1AtA__cached__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1BBWData.html">BBWData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for BBW computation related data and flags.  <a href="classigl_1_1BBWData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>FastWindingNumberBVH</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for caching precomputation for fast winding number for triangle soups. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1FileMemoryBuffer.html">FileMemoryBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1FileMemoryStream.html">FileMemoryStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to convert a FILE * to an std::istream.  <a href="structigl_1_1FileMemoryStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1HalfEdgeIterator.html">HalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake halfedge for fast and easy navigation on triangle meshes with vertex_triangle_adjacency and triangle_triangle adjacency.  <a href="classigl_1_1HalfEdgeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputation data for heat_geodesics_solve.  <a href="structigl_1_1HeatGeodesicsData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1Hit.html">Hit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reimplementation of the embree::Hit struct from embree1.0.  <a href="structigl_1_1Hit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexDimLessThan.html">IndexDimLessThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison struct for use with functions like std::sort.  <a href="structigl_1_1IndexDimLessThan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexedPointer.html">IndexedPointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexedPointerBase.html">IndexedPointerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexEquals.html">IndexEquals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison struct used by unique.  <a href="structigl_1_1IndexEquals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexLessThan.html">IndexLessThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison struct used by sort <a href="http://bytes.com/topic/c/answers/132045-sort-get-index">http://bytes.com/topic/c/answers/132045-sort-get-index</a>.  <a href="structigl_1_1IndexLessThan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexRowEquals.html">IndexRowEquals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison struct for use with functions like std::sort.  <a href="structigl_1_1IndexRowEquals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexRowLessThan.html">IndexRowLessThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison struct For use with functions like std::sort.  <a href="structigl_1_1IndexRowLessThan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1IndexVectorLessThan.html">IndexVectorLessThan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison struct for vectors for use with functions like std::sort.  <a href="structigl_1_1IndexVectorLessThan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1KelvinletParams.html">KelvinletParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for controling kelvinlets.  <a href="structigl_1_1KelvinletParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters and precomputed values for min_quad_with_fixed.  <a href="structigl_1_1min__quad__with__fixed__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1MshLoader.html">MshLoader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for loading information from .msh file depends only on c++stl library.  <a href="classigl_1_1MshLoader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1MshSaver.html">MshSaver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for dumping information to .msh file depends only on c++stl library current implementation works only with 3D information.  <a href="classigl_1_1MshSaver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1Serializable.html">Serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1SerializableBase.html">SerializableBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1ShapeupData.html">ShapeupData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters and precomputed data for ShapeUp.  <a href="structigl_1_1ShapeupData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1SLIMData.html">SLIMData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters and precomputed data for computing a SLIM map as derived in "Scalable Locally Injective Maps" [Rabinovich et al.  <a href="structigl_1_1SLIMData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1SortableRow.html">SortableRow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A row of things that can be sorted against other rows.  <a href="classigl_1_1SortableRow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple timer class.  <a href="classigl_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1WindingNumberAABB.html">WindingNumberAABB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for building an <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree to implement the divide and conquer algorithm described in [Jacobson et al.  <a href="classigl_1_1WindingNumberAABB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1WindingNumberTree.html">WindingNumberTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Space partitioning tree for computing winding number hierarchically.  <a href="classigl_1_1WindingNumberTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af967096efcc39e806f0c2b374e2ccc5f" id="r_af967096efcc39e806f0c2b374e2ccc5f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> = std::function&lt; void(const int, const Eigen::MatrixXd &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, double &amp;, Eigen::RowVectorXd &amp;)&gt;</td></tr>
<tr class="memdesc:af967096efcc39e806f0c2b374e2ccc5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function handle used to control the cost of each edge collapse in <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>.  <br /></td></tr>
<tr class="separator:af967096efcc39e806f0c2b374e2ccc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c8b006ed52af02a20d1664722a94b3" id="r_a64c8b006ed52af02a20d1664722a94b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> = std::function&lt; bool(const Eigen::MatrixXd &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXd &amp;, const int, const int, const int, const int, const int)&gt;</td></tr>
<tr class="memdesc:a64c8b006ed52af02a20d1664722a94b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function handle used to control whether the queue processing in <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a> should stop.  <br /></td></tr>
<tr class="separator:a64c8b006ed52af02a20d1664722a94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af695d0b4a424387592b06f466a86088e" id="r_af695d0b4a424387592b06f466a86088e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> = std::function&lt; bool(const Eigen::MatrixXd &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXd &amp;, const int)&gt;</td></tr>
<tr class="memdesc:af695d0b4a424387592b06f466a86088e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function handle called just before <code>collapse_edge</code> is attempted.  <br /></td></tr>
<tr class="separator:af695d0b4a424387592b06f466a86088e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fd55ae4f3085d4ed4d3c6bff008426" id="r_a16fd55ae4f3085d4ed4d3c6bff008426"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> = std::function&lt; void(const Eigen::MatrixXd &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, const <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;, const Eigen::VectorXi &amp;, const Eigen::MatrixXd &amp;, const int, const int, const int, const int, const int, const bool)&gt;</td></tr>
<tr class="memdesc:a16fd55ae4f3085d4ed4d3c6bff008426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function handle called just after <code>collapse_edge</code> is attempted.  <br /></td></tr>
<tr class="separator:a16fd55ae4f3085d4ed4d3c6bff008426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bbc303acee156af52ab587c4680502" id="r_a60bbc303acee156af52ab587c4680502"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a60bbc303acee156af52ab587c4680502">DEFAULT_URBG</a> = std::mt19937</td></tr>
<tr class="separator:a60bbc303acee156af52ab587c4680502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3e0aca98df4cd1576aecb262342dbf" id="r_acd3e0aca98df4cd1576aecb262342dbf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acd3e0aca98df4cd1576aecb262342dbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">min_heap</a> = std::priority_queue&lt; T, std::vector&lt; T &gt;, std::greater&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:acd3e0aca98df4cd1576aecb262342dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated min heap (reverses sort order of std::priority_queue)  <br /></td></tr>
<tr class="separator:acd3e0aca98df4cd1576aecb262342dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b7710824b3b35bfcda5dd2d5c723f5" id="r_af2b7710824b3b35bfcda5dd2d5c723f5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af2b7710824b3b35bfcda5dd2d5c723f5">shapeup_projection_function</a> = std::function&lt; bool(const Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;, const Eigen::PlainObjectBase&lt; Eigen::VectorXi &gt; &amp;, const Eigen::PlainObjectBase&lt; Eigen::MatrixXi &gt; &amp;, Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:af2b7710824b3b35bfcda5dd2d5c723f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every function here defines a local projection for ShapeUp, and must have the following structure to qualify:  <br /></td></tr>
<tr class="separator:af2b7710824b3b35bfcda5dd2d5c723f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afcbc9001656cf2d4cc135602618c97e5" id="r_afcbc9001656cf2d4cc135602618c97e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">ARAPEnergyType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5a97e873f2663a9aceb16484fb07de5ff5">ARAP_ENERGY_TYPE_SPOKES</a> = 0
, <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5a5f5f83bb36e2e299284c9a95ed2ff961">ARAP_ENERGY_TYPE_SPOKES_AND_RIMS</a> = 1
, <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5af2f155e8dfb975ad92b08f029e49a150">ARAP_ENERGY_TYPE_ELEMENTS</a> = 2
, <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5a0ab35acc294ac22e4f4d125fce81bb2e">ARAP_ENERGY_TYPE_DEFAULT</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5a9a04adfc9ec2f8a964e26ee1e79e192d">NUM_ARAP_ENERGY_TYPES</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:afcbc9001656cf2d4cc135602618c97e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for choosing ARAP energy type.  <a href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">More...</a><br /></td></tr>
<tr class="separator:afcbc9001656cf2d4cc135602618c97e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b823cd12b22dd7d7c16b36223e68dea" id="r_a1b823cd12b22dd7d7c16b36223e68dea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaa6825c15830b7858ad1cae2b2ca8fdf04">COLOR_MAP_TYPE_INFERNO</a> = 0
, <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaab42bc8bb5154a66ce55adfc8a55ca23b">COLOR_MAP_TYPE_JET</a> = 1
, <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaa2f48b6200837d4a9504dc985d9555a43">COLOR_MAP_TYPE_MAGMA</a> = 2
, <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaa34771169730e68f97bd795796088a1bd">COLOR_MAP_TYPE_PARULA</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaa02ba4c2ca7ae86203e286cc7e7681be8">COLOR_MAP_TYPE_PLASMA</a> = 4
, <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaac0949b6bec17c57dae985f9945f0ba87">COLOR_MAP_TYPE_VIRIDIS</a> = 5
, <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaa215964e6083ae591d01d8fc75696b7e4">COLOR_MAP_TYPE_TURBO</a> = 6
, <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68deaa6fe9ac780033d4a02584149c2079171f">NUM_COLOR_MAP_TYPES</a> = 7
<br />
 }</td></tr>
<tr class="separator:a1b823cd12b22dd7d7c16b36223e68dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bb96a0597986315dc20d78ba46a50d" id="r_a39bb96a0597986315dc20d78ba46a50d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50d">EigsType</a> { <a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50da2b8b23d6ed6bab31827ce232b5c4b753">EIGS_TYPE_SM</a> = 0
, <a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50daea338bf4c5326fb6e1534be0d2d8c3ff">EIGS_TYPE_LM</a> = 1
, <a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50dad803c6fe03f39ed4ef76376e6ba1d2c2">NUM_EIGS_TYPES</a> = 2
 }</td></tr>
<tr class="memdesc:a39bb96a0597986315dc20d78ba46a50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of eigen values to extract.  <a href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50d">More...</a><br /></td></tr>
<tr class="separator:a39bb96a0597986315dc20d78ba46a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ec0330094fed10f10bb12010bbcdbf" id="r_a85ec0330094fed10f10bb12010bbcdbf"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> { <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa6ce976e8f061b2b5cfe4d0c50c3405dd">Binary</a>
, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">Ascii</a>
 }</td></tr>
<tr class="memdesc:a85ec0330094fed10f10bb12010bbcdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">File encoding types for writing files.  <a href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">More...</a><br /></td></tr>
<tr class="separator:a85ec0330094fed10f10bb12010bbcdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c0d149c7cb41a263f858b695eeb988" id="r_a69c0d149c7cb41a263f858b695eeb988"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988">BrushType</a> : int { <a class="el" href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988a8695c57e30e957161af26fe52d8a5826">GRAB</a>
, <a class="el" href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988a127ea1d20becc4dba06d9d152db0c2e5">SCALE</a>
, <a class="el" href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988a7d503f3470adcef7d9b24cdfa82ea1c1">TWIST</a>
, <a class="el" href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988a1519953796ab374eeab96e42a849ed19">PINCH</a>
 }</td></tr>
<tr class="memdesc:a69c0d149c7cb41a263f858b695eeb988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kelvinlets brush type.  <a href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988">More...</a><br /></td></tr>
<tr class="separator:a69c0d149c7cb41a263f858b695eeb988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79904ddf7fe8d79169b339cf43f9e739" id="r_a79904ddf7fe8d79169b339cf43f9e739"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">MappingEnergyType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739ad4c5e62ae2264ce291d4d66fa3603d72">ARAP</a> = 0
, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739ac7e97754f63944f8a1abcd0157df2c24">LOG_ARAP</a> = 1
, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739a4aaaa0e435526b23bf5f26cfbb5c03b9">SYMMETRIC_DIRICHLET</a> = 2
, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739a83bccae0282cd84b5ae8c0d260ae7243">CONFORMAL</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739a26c394b5336e61022324d35b9c070a9b">EXP_CONFORMAL</a> = 4
, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739a265347b4667fbc30a911bb0be708072f">EXP_SYMMETRIC_DIRICHLET</a> = 5
, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739abcbff3ae074247ae8998591317528163">NUM_SLIM_ENERGY_TYPES</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a79904ddf7fe8d79169b339cf43f9e739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy Types used for Parameterization/Mapping.  <a href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">More...</a><br /></td></tr>
<tr class="separator:a79904ddf7fe8d79169b339cf43f9e739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed02513847d2f3fdb8c74dcbe55bb90" id="r_a8ed02513847d2f3fdb8c74dcbe55bb90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90ad236264764d4f478ccb31c36be553483">MASSMATRIX_TYPE_BARYCENTRIC</a> = 0
, <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90a8e91d83387a6cdc5e1c58d3249ed8484">MASSMATRIX_TYPE_VORONOI</a> = 1
, <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90aa3067b3f2630f50a9806bf46b60e6fb7">MASSMATRIX_TYPE_FULL</a> = 2
, <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90a69f57abe461a4a62943a5c38cbbf22f0">MASSMATRIX_TYPE_DEFAULT</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90a90c5b05e42d20ca21fd5849e64bae2ae">NUM_MASSMATRIX_TYPES</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a8ed02513847d2f3fdb8c74dcbe55bb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of mass matrix.  <a href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">More...</a><br /></td></tr>
<tr class="separator:a8ed02513847d2f3fdb8c74dcbe55bb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cc7fd8778cd880be528227e0318b9f" id="r_a16cc7fd8778cd880be528227e0318b9f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056">MESH_BOOLEAN_TYPE_UNION</a> = 0
, <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34">MESH_BOOLEAN_TYPE_INTERSECT</a> = 1
, <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80">MESH_BOOLEAN_TYPE_MINUS</a> = 2
, <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b">MESH_BOOLEAN_TYPE_XOR</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708">MESH_BOOLEAN_TYPE_RESOLVE</a> = 4
, <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fadbaeed658c3fa4c89de4dc951cb9cff9">NUM_MESH_BOOLEAN_TYPES</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a16cc7fd8778cd880be528227e0318b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean operation types.  <a href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">More...</a><br /></td></tr>
<tr class="separator:a16cc7fd8778cd880be528227e0318b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6483aa681000a106ae0973fc53b2d2e8" id="r_a6483aa681000a106ae0973fc53b2d2e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6483aa681000a106ae0973fc53b2d2e8">NormalType</a> { <a class="el" href="namespaceigl.html#a6483aa681000a106ae0973fc53b2d2e8af907c6f40997626d2c36a67963c8431d">PER_VERTEX_NORMALS</a>
, <a class="el" href="namespaceigl.html#a6483aa681000a106ae0973fc53b2d2e8a17cf07533db59fd90e513a7d89d40664">PER_FACE_NORMALS</a>
, <a class="el" href="namespaceigl.html#a6483aa681000a106ae0973fc53b2d2e8a5c44ccab7f461834b6ecc16928196627">PER_CORNER_NORMALS</a>
 }</td></tr>
<tr class="memdesc:a6483aa681000a106ae0973fc53b2d2e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of mesh normal computation method.  <a href="namespaceigl.html#a6483aa681000a106ae0973fc53b2d2e8">More...</a><br /></td></tr>
<tr class="separator:a6483aa681000a106ae0973fc53b2d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347183daf701cad3537c990f8ce0cf55" id="r_a347183daf701cad3537c990f8ce0cf55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">PerEdgeNormalsWeightingType</a> { <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55a832e9d6bd24abeb23b15bc815c888fe9">PER_EDGE_NORMALS_WEIGHTING_TYPE_UNIFORM</a> = 0
, <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55a2822a9a485d6d667e1fc7eb6a9e3788c">PER_EDGE_NORMALS_WEIGHTING_TYPE_AREA</a> = 1
, <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55a545aa62c3fac5887f2a8a939af47395c">PER_EDGE_NORMALS_WEIGHTING_TYPE_DEFAULT</a> = 2
, <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55a163eb96bb83248476c499a06d08c7630">NUM_PER_EDGE_NORMALS_WEIGHTING_TYPE</a> = 3
 }</td></tr>
<tr class="memdesc:a347183daf701cad3537c990f8ce0cf55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighting schemes for per edge normals.  <a href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">More...</a><br /></td></tr>
<tr class="separator:a347183daf701cad3537c990f8ce0cf55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd1d9465ddaaed7691194b99b3b9f94" id="r_a9bd1d9465ddaaed7691194b99b3b9f94"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">PerVertexNormalsWeightingType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94a221b3f6444f4194512508cce2c89d605">PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM</a> = 0
, <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94a6f6afda8e7e65ddb0214f4bf4fe9d714">PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA</a> = 1
, <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94a3929a73f6d85de3ab2e7f61c4c569f8d">PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE</a> = 2
, <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94a8384f77b5ce9bc68e6ed0c9dac5520f8">PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94ae39893168b9c7f1fb96cbe18aabcaf90">NUM_PER_VERTEX_NORMALS_WEIGHTING_TYPE</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a9bd1d9465ddaaed7691194b99b3b9f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighting schemes for computing per-vertex normals.  <a href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">More...</a><br /></td></tr>
<tr class="separator:a9bd1d9465ddaaed7691194b99b3b9f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ae0e8cefa226a1e493b33684b0b02e" id="r_a92ae0e8cefa226a1e493b33684b0b02e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a> { <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02eac0557ab91e577c1b1f918891b6b3a9ce">SIGNED_DISTANCE_TYPE_PSEUDONORMAL</a> = 0
, <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02ea2d092ad20bad8b2e4d6b015e0f64d5c8">SIGNED_DISTANCE_TYPE_WINDING_NUMBER</a> = 1
, <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02ea53947827c1a799002057e5dc4ffe3a6e">SIGNED_DISTANCE_TYPE_DEFAULT</a> = 2
, <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02ea3455ee3fba0a6898acccb895b94003ae">SIGNED_DISTANCE_TYPE_UNSIGNED</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02ea840c3ff04b4ec159043f1c6168ad383d">SIGNED_DISTANCE_TYPE_FAST_WINDING_NUMBER</a> = 4
, <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02ea5ba484850e00fd63057bf36e540ffe57">NUM_SIGNED_DISTANCE_TYPE</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a92ae0e8cefa226a1e493b33684b0b02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of signing a distance field.  <a href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">More...</a><br /></td></tr>
<tr class="separator:a92ae0e8cefa226a1e493b33684b0b02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b754bfef0dda338efc49cbf1fb6cfc2" id="r_a9b754bfef0dda338efc49cbf1fb6cfc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2">SolverStatus</a> { <a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2aefd03ba8a40ae92dd30b9608543d723a">SOLVER_STATUS_CONVERGED</a> = 0
, <a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2a59f8eece563fe4ae6e55c2363f349322">SOLVER_STATUS_MAX_ITER</a> = 1
, <a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2aea9aaec839ab7074d95b32649f9a7ccc">SOLVER_STATUS_ERROR</a> = 2
, <a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2aea329543d3b14ae5d7df63289014df41">NUM_SOLVER_STATUSES</a> = 3
 }</td></tr>
<tr class="memdesc:a9b754bfef0dda338efc49cbf1fb6cfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solver status type used by min_quad_with_fixed.  <a href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2">More...</a><br /></td></tr>
<tr class="separator:a9b754bfef0dda338efc49cbf1fb6cfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bae8c76c2714f3cce8b651ae93fae2" id="r_ac3bae8c76c2714f3cce8b651ae93fae2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">TetrahedralizedGripType</a> { <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2a6c9f3915cd235c5f5d9ec1f849c4f45a">TETRAHEDRALIZED_GRID_TYPE_5</a> = 0
, <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2a0f009090a25fab927bfc17ed8c95ccf7">TETRAHEDRALIZED_GRID_TYPE_6_ROTATIONAL</a> = 1
, <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2a4945d263c917ea6178567ad57cedddd6">NUM_TETRAHEDRALIZED_GRID_TYPE</a> = 2
 }</td></tr>
<tr class="memdesc:ac3bae8c76c2714f3cce8b651ae93fae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of tetrahedralizations of a cubical cell.  <a href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">More...</a><br /></td></tr>
<tr class="separator:ac3bae8c76c2714f3cce8b651ae93fae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509f63ef3c5ff8b238920eb0fe3ceecf" id="r_a509f63ef3c5ff8b238920eb0fe3ceecf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a509f63ef3c5ff8b238920eb0fe3ceecf">WindingNumberMethod</a> { <a class="el" href="namespaceigl.html#a509f63ef3c5ff8b238920eb0fe3ceecfaa10945b526da7066079013ebe7efa315">EXACT_WINDING_NUMBER_METHOD</a> = 0
, <a class="el" href="namespaceigl.html#a509f63ef3c5ff8b238920eb0fe3ceecfa0d9a88899ed0568e9ea92020c2202c90">APPROX_SIMPLE_WINDING_NUMBER_METHOD</a> = 1
, <a class="el" href="namespaceigl.html#a509f63ef3c5ff8b238920eb0fe3ceecfa8a0f3017839d2e66a55fabbd269bff19">APPROX_CACHE_WINDING_NUMBER_METHOD</a> = 2
, <a class="el" href="namespaceigl.html#a509f63ef3c5ff8b238920eb0fe3ceecfa3d5ef75b451374bbaa7aecc358a66558">NUM_WINDING_NUMBER_METHODS</a> = 3
 }</td></tr>
<tr class="separator:a509f63ef3c5ff8b238920eb0fe3ceecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8012b0115ea55d7e1ef308d01a37d65c" id="r_a8012b0115ea55d7e1ef308d01a37d65c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedV , typename DerivedA &gt; </td></tr>
<tr class="memitem:a8012b0115ea55d7e1ef308d01a37d65c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8012b0115ea55d7e1ef308d01a37d65c">accumarray</a> (const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a8012b0115ea55d7e1ef308d01a37d65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate values in V using subscripts in S.  <br /></td></tr>
<tr class="separator:a8012b0115ea55d7e1ef308d01a37d65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6380cf19be5242826791dfb3b26b113" id="r_aa6380cf19be5242826791dfb3b26b113"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedA &gt; </td></tr>
<tr class="memitem:aa6380cf19be5242826791dfb3b26b113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa6380cf19be5242826791dfb3b26b113">accumarray</a> (const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedA::Scalar V, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:aa6380cf19be5242826791dfb3b26b113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate constant value <code>V</code> using subscripts in S.  <br /></td></tr>
<tr class="separator:aa6380cf19be5242826791dfb3b26b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbfd2ea11fa90111a31666f48cc5f00" id="r_aebbfd2ea11fa90111a31666f48cc5f00"><td class="memTemplParams" colspan="2">template&lt;typename AT , typename DerivedB , typename Derivedknown , typename DerivedY , typename AeqT , typename DerivedBeq , typename AieqT , typename DerivedBieq , typename Derivedlx , typename Derivedux , typename DerivedZ &gt; </td></tr>
<tr class="memitem:aebbfd2ea11fa90111a31666f48cc5f00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2">igl::SolverStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aebbfd2ea11fa90111a31666f48cc5f00">active_set</a> (const Eigen::SparseMatrix&lt; AT &gt; &amp;A, const Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, const Eigen::PlainObjectBase&lt; Derivedknown &gt; &amp;known, const Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, const Eigen::SparseMatrix&lt; AeqT &gt; &amp;Aeq, const Eigen::PlainObjectBase&lt; DerivedBeq &gt; &amp;Beq, const Eigen::SparseMatrix&lt; AieqT &gt; &amp;Aieq, const Eigen::PlainObjectBase&lt; DerivedBieq &gt; &amp;Bieq, const Eigen::PlainObjectBase&lt; Derivedlx &gt; &amp;lx, const Eigen::PlainObjectBase&lt; Derivedux &gt; &amp;ux, const <a class="el" href="structigl_1_1active__set__params.html">igl::active_set_params</a> &amp;params, Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;Z)</td></tr>
<tr class="memdesc:aebbfd2ea11fa90111a31666f48cc5f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize convex quadratic energy subject to linear inequality constraints.  <br /></td></tr>
<tr class="separator:aebbfd2ea11fa90111a31666f48cc5f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c905c0e9124bb38a79769497fa9b48b" id="r_a4c905c0e9124bb38a79769497fa9b48b"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename IndexVector &gt; </td></tr>
<tr class="memitem:a4c905c0e9124bb38a79769497fa9b48b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4c905c0e9124bb38a79769497fa9b48b">adjacency_list</a> (const Eigen::MatrixBase&lt; Index &gt; &amp;F, std::vector&lt; std::vector&lt; IndexVector &gt; &gt; &amp;A, bool sorted=false)</td></tr>
<tr class="memdesc:a4c905c0e9124bb38a79769497fa9b48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the graph adjacency list of a given mesh (V,F)  <br /></td></tr>
<tr class="separator:a4c905c0e9124bb38a79769497fa9b48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b938bdb46eece91f62ab35a1e152a61" id="r_a3b938bdb46eece91f62ab35a1e152a61"><td class="memTemplParams" colspan="2">template&lt;typename Index &gt; </td></tr>
<tr class="memitem:a3b938bdb46eece91f62ab35a1e152a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3b938bdb46eece91f62ab35a1e152a61">adjacency_list</a> (const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;A)</td></tr>
<tr class="memdesc:a3b938bdb46eece91f62ab35a1e152a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the graph adjacency list of a given <em>polygon</em> mesh (V,F)  <br /></td></tr>
<tr class="separator:a3b938bdb46eece91f62ab35a1e152a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705a8f51137d1dd807bbe517c0567735" id="r_a705a8f51137d1dd807bbe517c0567735"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename T &gt; </td></tr>
<tr class="memitem:a705a8f51137d1dd807bbe517c0567735"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735">adjacency_matrix</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a705a8f51137d1dd807bbe517c0567735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the graph adjacency matrix of a given mesh (V,F)  <br /></td></tr>
<tr class="separator:a705a8f51137d1dd807bbe517c0567735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6ba9089b88d1e5ba18a153462c750c" id="r_a9b6ba9089b88d1e5ba18a153462c750c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedI , typename DerivedC , typename T &gt; </td></tr>
<tr class="memitem:a9b6ba9089b88d1e5ba18a153462c750c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b6ba9089b88d1e5ba18a153462c750c">adjacency_matrix</a> (const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9b6ba9089b88d1e5ba18a153462c750c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an vertex adjacency for a polygon mesh.  <br /></td></tr>
<tr class="separator:a9b6ba9089b88d1e5ba18a153462c750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8bd73fedf2cafd491f61084874c2cc" id="r_abf8bd73fedf2cafd491f61084874c2cc"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedB &gt; </td></tr>
<tr class="memitem:abf8bd73fedf2cafd491f61084874c2cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc">all</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:abf8bd73fedf2cafd491f61084874c2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether all values are logically true along a dimension.  <br /></td></tr>
<tr class="separator:abf8bd73fedf2cafd491f61084874c2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad119e257b19a34797c3c9af92d7cc56b" id="r_ad119e257b19a34797c3c9af92d7cc56b"><td class="memTemplParams" colspan="2">template&lt;typename Mat &gt; </td></tr>
<tr class="memitem:ad119e257b19a34797c3c9af92d7cc56b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad119e257b19a34797c3c9af92d7cc56b">all_pairs_distances</a> (const Mat &amp;V, const Mat &amp;U, const bool squared, Mat &amp;D)</td></tr>
<tr class="memdesc:ad119e257b19a34797c3c9af92d7cc56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distances between each point i in V and point j in U.  <br /></td></tr>
<tr class="separator:ad119e257b19a34797c3c9af92d7cc56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5e79a82d06f353e2cc7364bb63d6ec" id="r_acc5e79a82d06f353e2cc7364bb63d6ec"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:acc5e79a82d06f353e2cc7364bb63d6ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acc5e79a82d06f353e2cc7364bb63d6ec">ambient_occlusion</a> (const std::function&lt; bool(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;) &gt; &amp;shoot_ray, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:acc5e79a82d06f353e2cc7364bb63d6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ambient occlusion per given point using ray-mesh intersection function handle.  <br /></td></tr>
<tr class="separator:acc5e79a82d06f353e2cc7364bb63d6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5409ff272904057655baa541161f63" id="r_a8e5409ff272904057655baa541161f63"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a8e5409ff272904057655baa541161f63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8e5409ff272904057655baa541161f63">ambient_occlusion</a> (const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedV, DIM &gt; &amp;aabb, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a8e5409ff272904057655baa541161f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ambient occlusion per given point for mesh (V,F) with precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree.  <br /></td></tr>
<tr class="separator:a8e5409ff272904057655baa541161f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9892f183be30982954280fde853dd8f3" id="r_a9892f183be30982954280fde853dd8f3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a9892f183be30982954280fde853dd8f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9892f183be30982954280fde853dd8f3">ambient_occlusion</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a9892f183be30982954280fde853dd8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ambient occlusion per given point for mesh (V,F)  <br /></td></tr>
<tr class="separator:a9892f183be30982954280fde853dd8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2267549a29a1b490b0b2f56b6ec84ef6" id="r_a2267549a29a1b490b0b2f56b6ec84ef6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2267549a29a1b490b0b2f56b6ec84ef6">angular_distance</a> (const Eigen::Quaterniond &amp;A, const Eigen::Quaterniond &amp;B)</td></tr>
<tr class="memdesc:a2267549a29a1b490b0b2f56b6ec84ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "angular distance" between two unit quaternions is the angle of the smallest rotation (treated as an Axis and Angle) that takes A to B.  <br /></td></tr>
<tr class="separator:a2267549a29a1b490b0b2f56b6ec84ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b265abd1563e69c5b980e38f0eff3b9" id="r_a8b265abd1563e69c5b980e38f0eff3b9"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedB &gt; </td></tr>
<tr class="memitem:a8b265abd1563e69c5b980e38f0eff3b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8b265abd1563e69c5b980e38f0eff3b9">any</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a8b265abd1563e69c5b980e38f0eff3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether any values are logically true along a dimension.  <br /></td></tr>
<tr class="separator:a8b265abd1563e69c5b980e38f0eff3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e5f486e14127dc6eb9013a7dc312bd" id="r_a48e5f486e14127dc6eb9013a7dc312bd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedb &gt; </td></tr>
<tr class="memitem:a48e5f486e14127dc6eb9013a7dc312bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a48e5f486e14127dc6eb9013a7dc312bd">arap_precomputation</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int dim, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, <a class="el" href="structigl_1_1ARAPData.html">ARAPData</a> &amp;data)</td></tr>
<tr class="memdesc:a48e5f486e14127dc6eb9013a7dc312bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute necessary information to start using an ARAP deformation using local-global solver as described in "As-rigid-as-possible surface
modeling" [Sorkine and Alexa 2007].  <br /></td></tr>
<tr class="separator:a48e5f486e14127dc6eb9013a7dc312bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a45ef9782fe4b54d7487a8b3bb45e9" id="r_a62a45ef9782fe4b54d7487a8b3bb45e9"><td class="memTemplParams" colspan="2">template&lt;typename Derivedbc , typename DerivedU &gt; </td></tr>
<tr class="memitem:a62a45ef9782fe4b54d7487a8b3bb45e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a62a45ef9782fe4b54d7487a8b3bb45e9">arap_solve</a> (const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, <a class="el" href="structigl_1_1ARAPData.html">ARAPData</a> &amp;data, Eigen::MatrixBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a62a45ef9782fe4b54d7487a8b3bb45e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct arap solve.  <br /></td></tr>
<tr class="separator:a62a45ef9782fe4b54d7487a8b3bb45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26233fdaaff7c535c5cf9e54d58f6f80" id="r_a26233fdaaff7c535c5cf9e54d58f6f80"><td class="memTemplParams" colspan="2">template&lt;typename LbsMatrixType , typename SSCALAR &gt; </td></tr>
<tr class="memitem:a26233fdaaff7c535c5cf9e54d58f6f80"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a26233fdaaff7c535c5cf9e54d58f6f80">arap_dof_precomputation</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const LbsMatrixType &amp;M, const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;G, <a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a>&lt; LbsMatrixType, SSCALAR &gt; &amp;data)</td></tr>
<tr class="memdesc:a26233fdaaff7c535c5cf9e54d58f6f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputes the system to optimize for "Fast Automatic Skinning
Transformations" [Jacobson et al. 2012] skinning degrees of freedom optimization using as-rigid-as-possible energy.  <br /></td></tr>
<tr class="separator:a26233fdaaff7c535c5cf9e54d58f6f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec31e2faca7eecae08c921a0430d0aa" id="r_acec31e2faca7eecae08c921a0430d0aa"><td class="memTemplParams" colspan="2">template&lt;typename LbsMatrixType , typename SSCALAR &gt; </td></tr>
<tr class="memitem:acec31e2faca7eecae08c921a0430d0aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acec31e2faca7eecae08c921a0430d0aa">arap_dof_recomputation</a> (const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;fixed_dim, const Eigen::SparseMatrix&lt; double &gt; &amp;A_eq, <a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a>&lt; LbsMatrixType, SSCALAR &gt; &amp;data)</td></tr>
<tr class="memdesc:acec31e2faca7eecae08c921a0430d0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should always be called after arap_dof_precomputation, but may be called in between successive calls to arap_dof_update, recomputes precomputation given that there are only changes in free and fixed.  <br /></td></tr>
<tr class="separator:acec31e2faca7eecae08c921a0430d0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31279c751ae3a7d24bc56dd4c8029d1e" id="r_a31279c751ae3a7d24bc56dd4c8029d1e"><td class="memTemplParams" colspan="2">template&lt;typename LbsMatrixType , typename SSCALAR &gt; </td></tr>
<tr class="memitem:a31279c751ae3a7d24bc56dd4c8029d1e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a31279c751ae3a7d24bc56dd4c8029d1e">arap_dof_update</a> (const <a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a>&lt; LbsMatrixType, SSCALAR &gt; &amp;data, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;B_eq, const Eigen::MatrixXd &amp;L0, const int max_iters, const double tol, Eigen::MatrixXd &amp;L)</td></tr>
<tr class="memdesc:a31279c751ae3a7d24bc56dd4c8029d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimizes the transformations attached to each weight function based on precomputed system.  <br /></td></tr>
<tr class="separator:a31279c751ae3a7d24bc56dd4c8029d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1324ec871ee5fe0f3d6fa9b461ced93" id="r_ae1324ec871ee5fe0f3d6fa9b461ced93"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF , typename MatK &gt; </td></tr>
<tr class="memitem:ae1324ec871ee5fe0f3d6fa9b461ced93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae1324ec871ee5fe0f3d6fa9b461ced93">arap_linear_block</a> (const MatV &amp;V, const MatF &amp;F, const int d, const <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">igl::ARAPEnergyType</a> energy, MatK &amp;Kd)</td></tr>
<tr class="memdesc:ae1324ec871ee5fe0f3d6fa9b461ced93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a block of the matrix which constructs the linear terms of a given arap energy.  <br /></td></tr>
<tr class="separator:ae1324ec871ee5fe0f3d6fa9b461ced93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13e109be700043c1228c300bac31daf" id="r_ad13e109be700043c1228c300bac31daf"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF , typename MatK &gt; </td></tr>
<tr class="memitem:ad13e109be700043c1228c300bac31daf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad13e109be700043c1228c300bac31daf">arap_linear_block_spokes</a> (const MatV &amp;V, const MatF &amp;F, const int d, MatK &amp;Kd)</td></tr>
<tr class="memdesc:ad13e109be700043c1228c300bac31daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a block of the matrix which constructs the linear terms for spokes energy.  <br /></td></tr>
<tr class="separator:ad13e109be700043c1228c300bac31daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280d256cac58af8c0dceb1e0ab487ca" id="r_a7280d256cac58af8c0dceb1e0ab487ca"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF , typename MatK &gt; </td></tr>
<tr class="memitem:a7280d256cac58af8c0dceb1e0ab487ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7280d256cac58af8c0dceb1e0ab487ca">arap_linear_block_spokes_and_rims</a> (const MatV &amp;V, const MatF &amp;F, const int d, MatK &amp;Kd)</td></tr>
<tr class="memdesc:a7280d256cac58af8c0dceb1e0ab487ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a block of the matrix which constructs the linear terms for spokes and rims energy.  <br /></td></tr>
<tr class="separator:a7280d256cac58af8c0dceb1e0ab487ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81355594a143ab2601ce468536c0112" id="r_af81355594a143ab2601ce468536c0112"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF , typename MatK &gt; </td></tr>
<tr class="memitem:af81355594a143ab2601ce468536c0112"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af81355594a143ab2601ce468536c0112">arap_linear_block_elements</a> (const MatV &amp;V, const MatF &amp;F, const int d, MatK &amp;Kd)</td></tr>
<tr class="memdesc:af81355594a143ab2601ce468536c0112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a block of the matrix which constructs the linear terms for per element energy.  <br /></td></tr>
<tr class="separator:af81355594a143ab2601ce468536c0112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a8f8a4c016647d6f9c823ae3e32eaa" id="r_a02a8f8a4c016647d6f9c823ae3e32eaa"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </td></tr>
<tr class="memitem:a02a8f8a4c016647d6f9c823ae3e32eaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a02a8f8a4c016647d6f9c823ae3e32eaa">arap_rhs</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int dim, const <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">igl::ARAPEnergyType</a> energy, Eigen::SparseCompressedBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:a02a8f8a4c016647d6f9c823ae3e32eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right-hand side constructor of global poisson solve for various Arap energies.  <br /></td></tr>
<tr class="separator:a02a8f8a4c016647d6f9c823ae3e32eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fde5a5b34007efccb521fd4f571f153" id="r_a2fde5a5b34007efccb521fd4f571f153"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a2fde5a5b34007efccb521fd4f571f153"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2fde5a5b34007efccb521fd4f571f153">AtA_cached_precompute</a> (const Eigen::SparseMatrix&lt; Scalar &gt; &amp;A, <a class="el" href="structigl_1_1AtA__cached__data.html">AtA_cached_data</a> &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;AtA)</td></tr>
<tr class="memdesc:a2fde5a5b34007efccb521fd4f571f153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes At * W * A, where A is sparse and W is diagonal.  <br /></td></tr>
<tr class="separator:a2fde5a5b34007efccb521fd4f571f153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62e1e593efb31faa3ecb727695f3e53" id="r_ac62e1e593efb31faa3ecb727695f3e53"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac62e1e593efb31faa3ecb727695f3e53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac62e1e593efb31faa3ecb727695f3e53">AtA_cached</a> (const Eigen::SparseMatrix&lt; Scalar &gt; &amp;A, const <a class="el" href="structigl_1_1AtA__cached__data.html">AtA_cached_data</a> &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;AtA)</td></tr>
<tr class="memdesc:ac62e1e593efb31faa3ecb727695f3e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes At * W * A, where A is sparse and W is diagonal precomputed into data.  <br /></td></tr>
<tr class="separator:ac62e1e593efb31faa3ecb727695f3e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb9891e472fd984b8e86dfc5b7a279c" id="r_a7cb9891e472fd984b8e86dfc5b7a279c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DerivedoE , typename DeriveduE , typename DeriveduV &gt; </td></tr>
<tr class="memitem:a7cb9891e472fd984b8e86dfc5b7a279c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7cb9891e472fd984b8e86dfc5b7a279c">average_from_edges_onto_vertices</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;oE, const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DeriveduV &gt; &amp;uV)</td></tr>
<tr class="memdesc:a7cb9891e472fd984b8e86dfc5b7a279c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a scalar field defined on edges to vertices by averaging.  <br /></td></tr>
<tr class="separator:a7cb9891e472fd984b8e86dfc5b7a279c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac457ea2c4e31fec1d7a3855fefb0260d" id="r_ac457ea2c4e31fec1d7a3855fefb0260d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedS , typename DerivedSF &gt; </td></tr>
<tr class="memitem:ac457ea2c4e31fec1d7a3855fefb0260d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac457ea2c4e31fec1d7a3855fefb0260d">average_onto_faces</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF)</td></tr>
<tr class="memdesc:ac457ea2c4e31fec1d7a3855fefb0260d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a scalar field defined on vertices to faces by averaging.  <br /></td></tr>
<tr class="separator:ac457ea2c4e31fec1d7a3855fefb0260d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14f50dc6ec911af71c62d6c187fe3c2" id="r_ac14f50dc6ec911af71c62d6c187fe3c2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedSV &gt; </td></tr>
<tr class="memitem:ac14f50dc6ec911af71c62d6c187fe3c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac14f50dc6ec911af71c62d6c187fe3c2">average_onto_vertices</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV)</td></tr>
<tr class="memdesc:ac14f50dc6ec911af71c62d6c187fe3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move a scalar field defined on faces to vertices by averaging.  <br /></td></tr>
<tr class="separator:ac14f50dc6ec911af71c62d6c187fe3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc598da20b66905a5f3edb6f985cfb1" id="r_a2fc598da20b66905a5f3edb6f985cfb1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a2fc598da20b66905a5f3edb6f985cfb1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2fc598da20b66905a5f3edb6f985cfb1">avg_edge_length</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a2fc598da20b66905a5f3edb6f985cfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average edge length for the given triangle mesh.  <br /></td></tr>
<tr class="separator:a2fc598da20b66905a5f3edb6f985cfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bab06e3533fb4130d508453175889f" id="r_af6bab06e3533fb4130d508453175889f"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:af6bab06e3533fb4130d508453175889f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af6bab06e3533fb4130d508453175889f">axis_angle_to_quat</a> (const Q_type *axis, const Q_type angle, Q_type *out)</td></tr>
<tr class="memdesc:af6bab06e3533fb4130d508453175889f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert axis angle representation of a rotation to a quaternion.  <br /></td></tr>
<tr class="separator:af6bab06e3533fb4130d508453175889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952c606ce07c40eb966cd5e55874f92d" id="r_a952c606ce07c40eb966cd5e55874f92d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedBC &gt; </td></tr>
<tr class="memitem:a952c606ce07c40eb966cd5e55874f92d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a952c606ce07c40eb966cd5e55874f92d">barycenter</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedBC &gt; &amp;BC)</td></tr>
<tr class="memdesc:a952c606ce07c40eb966cd5e55874f92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the barycenter of every simplex.  <br /></td></tr>
<tr class="separator:a952c606ce07c40eb966cd5e55874f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b111b83aabbda680af965294681b5b" id="r_ad4b111b83aabbda680af965294681b5b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename DerivedL &gt; </td></tr>
<tr class="memitem:ad4b111b83aabbda680af965294681b5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad4b111b83aabbda680af965294681b5b">barycentric_coordinates</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:ad4b111b83aabbda680af965294681b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute barycentric coordinates of each point in a corresponding tetrahedron.  <br /></td></tr>
<tr class="separator:ad4b111b83aabbda680af965294681b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a603159f2a82b981f00ca10be97d62e" id="r_a8a603159f2a82b981f00ca10be97d62e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedL &gt; </td></tr>
<tr class="memitem:a8a603159f2a82b981f00ca10be97d62e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8a603159f2a82b981f00ca10be97d62e">barycentric_coordinates</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:a8a603159f2a82b981f00ca10be97d62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute barycentric coordinates in a triangle.  <br /></td></tr>
<tr class="separator:a8a603159f2a82b981f00ca10be97d62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d34543d4673ecc638e11d0340f7c38" id="r_ac2d34543d4673ecc638e11d0340f7c38"><td class="memTemplParams" colspan="2">template&lt;typename DerivedD , typename DerivedF , typename DerivedB , typename DerivedI , typename DerivedX &gt; </td></tr>
<tr class="memitem:ac2d34543d4673ecc638e11d0340f7c38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac2d34543d4673ecc638e11d0340f7c38">barycentric_interpolation</a> (const Eigen::MatrixBase&lt; DerivedD &gt; &amp;D, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X)</td></tr>
<tr class="memdesc:ac2d34543d4673ecc638e11d0340f7c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data on a triangle mesh using barycentric coordinates.  <br /></td></tr>
<tr class="separator:ac2d34543d4673ecc638e11d0340f7c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32f08d2b80c8d69515001b7d6347e82" id="r_aa32f08d2b80c8d69515001b7d6347e82"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa32f08d2b80c8d69515001b7d6347e82">basename</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:aa32f08d2b80c8d69515001b7d6347e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract basename of file path (like PHP's basename).  <br /></td></tr>
<tr class="separator:aa32f08d2b80c8d69515001b7d6347e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3dc749c63b65a87635a309d322e9c" id="r_a33e3dc749c63b65a87635a309d322e9c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedEle , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </td></tr>
<tr class="memitem:a33e3dc749c63b65a87635a309d322e9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a33e3dc749c63b65a87635a309d322e9c">bbw</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedEle &gt; &amp;Ele, const Eigen::PlainObjectBase&lt; Derivedb &gt; &amp;b, const Eigen::PlainObjectBase&lt; Derivedbc &gt; &amp;bc, <a class="el" href="classigl_1_1BBWData.html">BBWData</a> &amp;data, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a33e3dc749c63b65a87635a309d322e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Bounded Biharmonic Weights on a given domain (V,Ele) with a given set of boundary conditions.  <br /></td></tr>
<tr class="separator:a33e3dc749c63b65a87635a309d322e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5227bd6077c6a709c20789e5c0d70cd" id="r_ae5227bd6077c6a709c20789e5c0d70cd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedP &gt; </td></tr>
<tr class="memitem:ae5227bd6077c6a709c20789e5c0d70cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae5227bd6077c6a709c20789e5c0d70cd">bezier</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const typename DerivedV::Scalar t, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:ae5227bd6077c6a709c20789e5c0d70cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial Bezier Curve at single parameter value.  <br /></td></tr>
<tr class="separator:ae5227bd6077c6a709c20789e5c0d70cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0860a64b8a1678d63bea76c8b1999c78" id="r_a0860a64b8a1678d63bea76c8b1999c78"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename DerivedP &gt; </td></tr>
<tr class="memitem:a0860a64b8a1678d63bea76c8b1999c78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0860a64b8a1678d63bea76c8b1999c78">bezier</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a0860a64b8a1678d63bea76c8b1999c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial Bezier Curve at many parameter values.  <br /></td></tr>
<tr class="separator:a0860a64b8a1678d63bea76c8b1999c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be736f827b4ba341d4b2cb40f21f844" id="r_a4be736f827b4ba341d4b2cb40f21f844"><td class="memTemplParams" colspan="2">template&lt;typename VMat , typename DerivedT , typename DerivedP &gt; </td></tr>
<tr class="memitem:a4be736f827b4ba341d4b2cb40f21f844"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4be736f827b4ba341d4b2cb40f21f844">bezier</a> (const std::vector&lt; VMat &gt; &amp;spline, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a4be736f827b4ba341d4b2cb40f21f844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial Bezier spline with a fixed parameter set for each sub-curve.  <br /></td></tr>
<tr class="separator:a4be736f827b4ba341d4b2cb40f21f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1dcc1386b54083fe6a2b70c7b7225" id="r_a75b1dcc1386b54083fe6a2b70c7b7225"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedD , typename DerivedP &gt; </td></tr>
<tr class="memitem:a75b1dcc1386b54083fe6a2b70c7b7225"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a75b1dcc1386b54083fe6a2b70c7b7225">bfs</a> (const AType &amp;A, const size_t s, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a75b1dcc1386b54083fe6a2b70c7b7225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse a <b>directed</b> graph represented by an adjacency list using.  <br /></td></tr>
<tr class="separator:a75b1dcc1386b54083fe6a2b70c7b7225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed9474cc5d1478971346be27092d3a2" id="r_a9ed9474cc5d1478971346be27092d3a2"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DType , typename PType &gt; </td></tr>
<tr class="memitem:a9ed9474cc5d1478971346be27092d3a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9ed9474cc5d1478971346be27092d3a2">bfs</a> (const std::vector&lt; std::vector&lt; AType &gt; &gt; &amp;A, const size_t s, std::vector&lt; DType &gt; &amp;D, std::vector&lt; PType &gt; &amp;P)</td></tr>
<tr class="memdesc:a9ed9474cc5d1478971346be27092d3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse a <b>directed</b> graph represented by an adjacency list using.  <br /></td></tr>
<tr class="separator:a9ed9474cc5d1478971346be27092d3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3199a27a3e8403ef457e2a7b56f338f3" id="r_a3199a27a3e8403ef457e2a7b56f338f3"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DType , typename PType &gt; </td></tr>
<tr class="memitem:a3199a27a3e8403ef457e2a7b56f338f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3199a27a3e8403ef457e2a7b56f338f3">bfs</a> (const Eigen::SparseCompressedBase&lt; AType &gt; &amp;A, const size_t s, std::vector&lt; DType &gt; &amp;D, std::vector&lt; PType &gt; &amp;P)</td></tr>
<tr class="memdesc:a3199a27a3e8403ef457e2a7b56f338f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3199a27a3e8403ef457e2a7b56f338f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9225d219645e80e01f409b151e7cc1" id="r_a8b9225d219645e80e01f409b151e7cc1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedFF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a8b9225d219645e80e01f409b151e7cc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8b9225d219645e80e01f409b151e7cc1">bfs_orient</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a8b9225d219645e80e01f409b151e7cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consistently orient faces in orientable patches using BFS.  <br /></td></tr>
<tr class="separator:a8b9225d219645e80e01f409b151e7cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ba6f8afae42bb09f687fe9a518ee94" id="r_aa0ba6f8afae42bb09f687fe9a518ee94"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename SType , typename DerivedW &gt; </td></tr>
<tr class="memitem:aa0ba6f8afae42bb09f687fe9a518ee94"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa0ba6f8afae42bb09f687fe9a518ee94">biharmonic_coordinates</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, const std::vector&lt; std::vector&lt; SType &gt; &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:aa0ba6f8afae42bb09f687fe9a518ee94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute "discrete biharmonic generalized barycentric coordinates" as described in "Linear Subspace Design for Real-Time Shape Deformation" [Wang et al.  <br /></td></tr>
<tr class="separator:aa0ba6f8afae42bb09f687fe9a518ee94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb917f3b67e2fe53d03e8a2c98b6a276" id="r_abb917f3b67e2fe53d03e8a2c98b6a276"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename SType , typename DerivedW &gt; </td></tr>
<tr class="memitem:abb917f3b67e2fe53d03e8a2c98b6a276"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abb917f3b67e2fe53d03e8a2c98b6a276">biharmonic_coordinates</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, const std::vector&lt; std::vector&lt; SType &gt; &gt; &amp;S, const int k, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:abb917f3b67e2fe53d03e8a2c98b6a276"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abb917f3b67e2fe53d03e8a2c98b6a276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867e7d0b5a7f134059e8205e6e16cc9" id="r_a6867e7d0b5a7f134059e8205e6e16cc9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU &gt; </td></tr>
<tr class="memitem:a6867e7d0b5a7f134059e8205e6e16cc9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6867e7d0b5a7f134059e8205e6e16cc9">bijective_composite_harmonic_mapping</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a6867e7d0b5a7f134059e8205e6e16cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a injective planar mapping of a triangulated polygon (V,F) subjected to boundary conditions (b,bc).  <br /></td></tr>
<tr class="separator:a6867e7d0b5a7f134059e8205e6e16cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef34b7c5ad3903df6e31eb7d57bc6aa" id="r_a7ef34b7c5ad3903df6e31eb7d57bc6aa"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU &gt; </td></tr>
<tr class="memitem:a7ef34b7c5ad3903df6e31eb7d57bc6aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7ef34b7c5ad3903df6e31eb7d57bc6aa">bijective_composite_harmonic_mapping</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, const int min_steps, const int max_steps, const int num_inner_iters, const bool test_for_flips, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a7ef34b7c5ad3903df6e31eb7d57bc6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7ef34b7c5ad3903df6e31eb7d57bc6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b12780a4ac9de89f929034ab464726" id="r_a72b12780a4ac9de89f929034ab464726"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a72b12780a4ac9de89f929034ab464726"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a72b12780a4ac9de89f929034ab464726">blkdiag</a> (const std::vector&lt; Eigen::SparseMatrix&lt; Scalar &gt; &gt; &amp;L, Eigen::SparseMatrix&lt; Scalar &gt; &amp;Y)</td></tr>
<tr class="memdesc:a72b12780a4ac9de89f929034ab464726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of matrices place them along the diagonal as blocks of the output matrix.  <br /></td></tr>
<tr class="separator:a72b12780a4ac9de89f929034ab464726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137f77a6ebc0d59e4f7f3f43e862274e" id="r_a137f77a6ebc0d59e4f7f3f43e862274e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedY &gt; </td></tr>
<tr class="memitem:a137f77a6ebc0d59e4f7f3f43e862274e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a137f77a6ebc0d59e4f7f3f43e862274e">blkdiag</a> (const std::vector&lt; DerivedY &gt; &amp;L, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a137f77a6ebc0d59e4f7f3f43e862274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a137f77a6ebc0d59e4f7f3f43e862274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fdfaea612ac6f626571df84ba43dd0" id="r_af6fdfaea612ac6f626571df84ba43dd0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedB , typename DerivedFI , typename DerivedP , typename URBG  = DEFAULT_URBG&gt; </td></tr>
<tr class="memitem:af6fdfaea612ac6f626571df84ba43dd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af6fdfaea612ac6f626571df84ba43dd0">blue_noise</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedV::Scalar r, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;FI, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, URBG &amp;&amp;urbg=<a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>())</td></tr>
<tr class="memdesc:af6fdfaea612ac6f626571df84ba43dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Fast Poisson Disk Sampling in Arbitrary Dimensions" [Bridson 2007].  <br /></td></tr>
<tr class="separator:af6fdfaea612ac6f626571df84ba43dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bff7fe392542fa173e6665ddaf7a21" id="r_af9bff7fe392542fa173e6665ddaf7a21"><td class="memTemplParams" colspan="2">template&lt;typename DerivedBE , typename DerivedP &gt; </td></tr>
<tr class="memitem:af9bff7fe392542fa173e6665ddaf7a21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af9bff7fe392542fa173e6665ddaf7a21">bone_parents</a> (const Eigen::MatrixBase&lt; DerivedBE &gt; &amp;BE, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:af9bff7fe392542fa173e6665ddaf7a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover "parent" bones from directed graph representation.  <br /></td></tr>
<tr class="separator:af9bff7fe392542fa173e6665ddaf7a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366cd5eb6c56116ad697c23065fb8b40" id="r_a366cd5eb6c56116ad697c23065fb8b40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a366cd5eb6c56116ad697c23065fb8b40">boundary_conditions</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;Ele, const Eigen::MatrixXd &amp;C, const Eigen::VectorXi &amp;P, const Eigen::MatrixXi &amp;BE, const Eigen::MatrixXi &amp;CE, const Eigen::MatrixXi &amp;CF, Eigen::VectorXi &amp;b, Eigen::MatrixXd &amp;bc)</td></tr>
<tr class="memdesc:a366cd5eb6c56116ad697c23065fb8b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute boundary conditions for automatic weights computation.  <br /></td></tr>
<tr class="separator:a366cd5eb6c56116ad697c23065fb8b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d8c6202cbd9be61850e58d65fd3096" id="r_aa7d8c6202cbd9be61850e58d65fd3096"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename DerivedF , typename DerivedJ , typename DerivedK &gt; </td></tr>
<tr class="memitem:aa7d8c6202cbd9be61850e58d65fd3096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa7d8c6202cbd9be61850e58d65fd3096">boundary_facets</a> (const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:aa7d8c6202cbd9be61850e58d65fd3096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine boundary faces (edges) of tetrahedra (triangles) stored in T (analogous to qptoolbox's <code>outline</code> and <code>boundary_faces</code>).  <br /></td></tr>
<tr class="separator:aa7d8c6202cbd9be61850e58d65fd3096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68133ab0b5aaff2f739a42c49f769512" id="r_a68133ab0b5aaff2f739a42c49f769512"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename DerivedF &gt; </td></tr>
<tr class="memitem:a68133ab0b5aaff2f739a42c49f769512"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a68133ab0b5aaff2f739a42c49f769512">boundary_facets</a> (const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a68133ab0b5aaff2f739a42c49f769512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine boundary faces (edges) of tetrahedra (triangles) stored in T.  <br /></td></tr>
<tr class="separator:a68133ab0b5aaff2f739a42c49f769512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd8cee60db0ccd9448521c2c828430d" id="r_adfd8cee60db0ccd9448521c2c828430d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename Ret &gt; </td></tr>
<tr class="memitem:adfd8cee60db0ccd9448521c2c828430d"><td class="memTemplItemLeft" align="right" valign="top">Ret&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adfd8cee60db0ccd9448521c2c828430d">boundary_facets</a> (const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:adfd8cee60db0ccd9448521c2c828430d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine boundary faces (edges) of tetrahedra (triangles) stored in T.  <br /></td></tr>
<tr class="separator:adfd8cee60db0ccd9448521c2c828430d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782f0e0282464889f69540a72db9e88b" id="r_a782f0e0282464889f69540a72db9e88b"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT , typename IntegerF &gt; </td></tr>
<tr class="memitem:a782f0e0282464889f69540a72db9e88b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a782f0e0282464889f69540a72db9e88b">boundary_facets</a> (const std::vector&lt; std::vector&lt; IntegerT &gt; &gt; &amp;T, std::vector&lt; std::vector&lt; IntegerF &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a782f0e0282464889f69540a72db9e88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine boundary faces (edges) of tetrahedra (triangles) stored in T; inputs and outputs lists.  <br /></td></tr>
<tr class="separator:a782f0e0282464889f69540a72db9e88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb06d6406b52700028680b4b2c727700" id="r_adb06d6406b52700028680b4b2c727700"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Index &gt; </td></tr>
<tr class="memitem:adb06d6406b52700028680b4b2c727700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adb06d6406b52700028680b4b2c727700">boundary_loop</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;L)</td></tr>
<tr class="memdesc:adb06d6406b52700028680b4b2c727700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute list of ordered boundary loops for a manifold mesh.  <br /></td></tr>
<tr class="separator:adb06d6406b52700028680b4b2c727700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21468e50560667302d1637ed6895b29a" id="r_a21468e50560667302d1637ed6895b29a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Index &gt; </td></tr>
<tr class="memitem:a21468e50560667302d1637ed6895b29a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a21468e50560667302d1637ed6895b29a">boundary_loop</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; Index &gt; &amp;L)</td></tr>
<tr class="memdesc:a21468e50560667302d1637ed6895b29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices.  <br /></td></tr>
<tr class="separator:a21468e50560667302d1637ed6895b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fec963303eda50e7dec22793b756d8" id="r_a82fec963303eda50e7dec22793b756d8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL &gt; </td></tr>
<tr class="memitem:a82fec963303eda50e7dec22793b756d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a82fec963303eda50e7dec22793b756d8">boundary_loop</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:a82fec963303eda50e7dec22793b756d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices.  <br /></td></tr>
<tr class="separator:a82fec963303eda50e7dec22793b756d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3dc35283c38c7712366f3b0f9dd09a7" id="r_ad3dc35283c38c7712366f3b0f9dd09a7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedBV , typename DerivedBF &gt; </td></tr>
<tr class="memitem:ad3dc35283c38c7712366f3b0f9dd09a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad3dc35283c38c7712366f3b0f9dd09a7">bounding_box</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedBV &gt; &amp;BV, Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;BF)</td></tr>
<tr class="memdesc:ad3dc35283c38c7712366f3b0f9dd09a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a triangle mesh of the bounding box of a given list of vertices.  <br /></td></tr>
<tr class="separator:ad3dc35283c38c7712366f3b0f9dd09a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a1ef8fd908031e5b30d1aba9614cb7" id="r_a42a1ef8fd908031e5b30d1aba9614cb7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedBV , typename DerivedBF &gt; </td></tr>
<tr class="memitem:a42a1ef8fd908031e5b30d1aba9614cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a42a1ef8fd908031e5b30d1aba9614cb7">bounding_box</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const typename DerivedV::Scalar pad, Eigen::PlainObjectBase&lt; DerivedBV &gt; &amp;BV, Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;BF)</td></tr>
<tr class="separator:a42a1ef8fd908031e5b30d1aba9614cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1efbdec1a5c13888e2ec44b70c100a" id="r_aac1efbdec1a5c13888e2ec44b70c100a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aac1efbdec1a5c13888e2ec44b70c100a">bounding_box_diagonal</a> (const Eigen::MatrixXd &amp;V)</td></tr>
<tr class="memdesc:aac1efbdec1a5c13888e2ec44b70c100a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of the diagonal of a given meshes axis-aligned bounding box.  <br /></td></tr>
<tr class="separator:aac1efbdec1a5c13888e2ec44b70c100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03aa82f1ac2c783bc64cbc9b869531e" id="r_ab03aa82f1ac2c783bc64cbc9b869531e"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:ab03aa82f1ac2c783bc64cbc9b869531e"><td class="memTemplItemLeft" align="right" valign="top">Q_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab03aa82f1ac2c783bc64cbc9b869531e">CANONICAL_VIEW_QUAT</a> (int i, int j)</td></tr>
<tr class="separator:ab03aa82f1ac2c783bc64cbc9b869531e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac4840ccfe1570de9ff6efc2fba06a5" id="r_a9ac4840ccfe1570de9ff6efc2fba06a5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9ac4840ccfe1570de9ff6efc2fba06a5"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9ac4840ccfe1570de9ff6efc2fba06a5">CANONICAL_VIEW_QUAT&lt; float &gt;</a> (int i, int j)</td></tr>
<tr class="separator:a9ac4840ccfe1570de9ff6efc2fba06a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834139f67af87775d3524a90be997edc" id="r_a834139f67af87775d3524a90be997edc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a834139f67af87775d3524a90be997edc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a834139f67af87775d3524a90be997edc">CANONICAL_VIEW_QUAT&lt; double &gt;</a> (int i, int j)</td></tr>
<tr class="separator:a834139f67af87775d3524a90be997edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f624eb7c4015b813215c87880eb54d" id="r_ad5f624eb7c4015b813215c87880eb54d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad5f624eb7c4015b813215c87880eb54d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad5f624eb7c4015b813215c87880eb54d">cat</a> (const int dim, const Eigen::SparseMatrix&lt; Scalar &gt; &amp;A, const Eigen::SparseMatrix&lt; Scalar &gt; &amp;B, Eigen::SparseMatrix&lt; Scalar &gt; &amp;C)</td></tr>
<tr class="memdesc:ad5f624eb7c4015b813215c87880eb54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform concatenation of a two <em>sparse</em> matrices along a single dimension If dim == 1, then C = [A;B]; If dim == 2 then C = [A B].  <br /></td></tr>
<tr class="separator:ad5f624eb7c4015b813215c87880eb54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0834acd824362d58a9a06710cde2e964" id="r_a0834acd824362d58a9a06710cde2e964"><td class="memTemplParams" colspan="2">template&lt;typename Derived , class MatC &gt; </td></tr>
<tr class="memitem:a0834acd824362d58a9a06710cde2e964"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0834acd824362d58a9a06710cde2e964">cat</a> (const int dim, const Eigen::MatrixBase&lt; Derived &gt; &amp;A, const Eigen::MatrixBase&lt; Derived &gt; &amp;B, MatC &amp;C)</td></tr>
<tr class="memdesc:a0834acd824362d58a9a06710cde2e964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform concatenation of a two <em>dense</em> matrices along a single dimension If dim == 1, then C = [A;B]; If dim == 2 then C = [A B].  <br /></td></tr>
<tr class="separator:a0834acd824362d58a9a06710cde2e964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203a47235dd090370a7dccffd385002f" id="r_a203a47235dd090370a7dccffd385002f"><td class="memTemplParams" colspan="2">template&lt;class Mat &gt; </td></tr>
<tr class="memitem:a203a47235dd090370a7dccffd385002f"><td class="memTemplItemLeft" align="right" valign="top">Mat&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a203a47235dd090370a7dccffd385002f">cat</a> (const int dim, const Mat &amp;A, const Mat &amp;B)</td></tr>
<tr class="memdesc:a203a47235dd090370a7dccffd385002f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform concatenation of a two <em>dense</em> matrices along a single dimension If dim == 1, then C = [A;B]; If dim == 2 then C = [A B].  <br /></td></tr>
<tr class="separator:a203a47235dd090370a7dccffd385002f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1d04cfbdfdbb8a94fa5712aa9b868e" id="r_a2b1d04cfbdfdbb8a94fa5712aa9b868e"><td class="memTemplParams" colspan="2">template&lt;class Mat &gt; </td></tr>
<tr class="memitem:a2b1d04cfbdfdbb8a94fa5712aa9b868e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2b1d04cfbdfdbb8a94fa5712aa9b868e">cat</a> (const std::vector&lt; std::vector&lt; Mat &gt; &gt; &amp;A, Mat &amp;C)</td></tr>
<tr class="memdesc:a2b1d04cfbdfdbb8a94fa5712aa9b868e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a "matrix" of sub-blocks C = [A0;A1;A2;...;An] where Ai = [A[i][0] A[i][1] ... A[i][m]];.  <br /></td></tr>
<tr class="separator:a2b1d04cfbdfdbb8a94fa5712aa9b868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13402260035cb13a7110a755ae31c487" id="r_a13402260035cb13a7110a755ae31c487"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedC &gt; </td></tr>
<tr class="memitem:a13402260035cb13a7110a755ae31c487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a13402260035cb13a7110a755ae31c487">cat</a> (const int dim, const std::vector&lt; T &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a13402260035cb13a7110a755ae31c487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate a std::vector of matrices along the specified dimension.  <br /></td></tr>
<tr class="separator:a13402260035cb13a7110a755ae31c487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacaeba967f62ca7f67bfddf604fd60f" id="r_afacaeba967f62ca7f67bfddf604fd60f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:afacaeba967f62ca7f67bfddf604fd60f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afacaeba967f62ca7f67bfddf604fd60f">ceil</a> (const Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:afacaeba967f62ca7f67bfddf604fd60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ceil a given matrix to nearest integers.  <br /></td></tr>
<tr class="separator:afacaeba967f62ca7f67bfddf604fd60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa0102450153380ae5ecdb948352556" id="r_adaa0102450153380ae5ecdb948352556"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedc , typename Derivedvol &gt; </td></tr>
<tr class="memitem:adaa0102450153380ae5ecdb948352556"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adaa0102450153380ae5ecdb948352556">centroid</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, Derivedvol &amp;vol)</td></tr>
<tr class="memdesc:adaa0102450153380ae5ecdb948352556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the centroid and enclosed volume of a closed mesh using a surface integral.  <br /></td></tr>
<tr class="separator:adaa0102450153380ae5ecdb948352556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b05ef9da68218494452d38460a07835" id="r_a3b05ef9da68218494452d38460a07835"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedc &gt; </td></tr>
<tr class="memitem:a3b05ef9da68218494452d38460a07835"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3b05ef9da68218494452d38460a07835">centroid</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c)</td></tr>
<tr class="memdesc:a3b05ef9da68218494452d38460a07835"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3b05ef9da68218494452d38460a07835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2779ad7549dc5da4bed4c7042e2f780" id="r_ad2779ad7549dc5da4bed4c7042e2f780"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad2779ad7549dc5da4bed4c7042e2f780">circulation</a> (const int e, const bool ccw, const Eigen::VectorXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI)</td></tr>
<tr class="memdesc:ad2779ad7549dc5da4bed4c7042e2f780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of faces around the end point of an edge.  <br /></td></tr>
<tr class="separator:ad2779ad7549dc5da4bed4c7042e2f780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0491f8d6a5d5bd769ab23851f43bb2e0" id="r_a0491f8d6a5d5bd769ab23851f43bb2e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0491f8d6a5d5bd769ab23851f43bb2e0">circulation</a> (const int e, const bool ccw, const Eigen::VectorXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI, Eigen::VectorXi &amp;vN)</td></tr>
<tr class="memdesc:a0491f8d6a5d5bd769ab23851f43bb2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of faces around the end point of an edge.  <br /></td></tr>
<tr class="separator:a0491f8d6a5d5bd769ab23851f43bb2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904a58ea245b35cce0feec144140e368" id="r_a904a58ea245b35cce0feec144140e368"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a904a58ea245b35cce0feec144140e368">circulation</a> (const int e, const bool ccw, const Eigen::MatrixXi &amp;F, const Eigen::VectorXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI, std::vector&lt; int &gt; &amp;Nv, std::vector&lt; int &gt; &amp;Nf)</td></tr>
<tr class="memdesc:a904a58ea245b35cce0feec144140e368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return list of faces around the end point of an edge.  <br /></td></tr>
<tr class="separator:a904a58ea245b35cce0feec144140e368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3ed506f1a1d753e1c342b42f008170" id="r_a8d3ed506f1a1d753e1c342b42f008170"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedR &gt; </td></tr>
<tr class="memitem:a8d3ed506f1a1d753e1c342b42f008170"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8d3ed506f1a1d753e1c342b42f008170">circumradius</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R)</td></tr>
<tr class="memdesc:a8d3ed506f1a1d753e1c342b42f008170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the circumradius of each triangle in a mesh (V,F)  <br /></td></tr>
<tr class="separator:a8d3ed506f1a1d753e1c342b42f008170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e3cfdf30adcadd5172a4f0b862bf59" id="r_aa8e3cfdf30adcadd5172a4f0b862bf59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa8e3cfdf30adcadd5172a4f0b862bf59">collapse_edge</a> (const int e, const Eigen::RowVectorXd &amp;p, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI, int &amp;e1, int &amp;e2, int &amp;f1, int &amp;f2)</td></tr>
<tr class="memdesc:aa8e3cfdf30adcadd5172a4f0b862bf59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to collapse a given edge of a mesh.  <br /></td></tr>
<tr class="separator:aa8e3cfdf30adcadd5172a4f0b862bf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382e1bd40b951c6f6c14da9773f2fea" id="r_a2382e1bd40b951c6f6c14da9773f2fea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2382e1bd40b951c6f6c14da9773f2fea">collapse_edge</a> (const int e, const Eigen::RowVectorXd &amp;p, std::vector&lt; int &gt; &amp;Nsv, const std::vector&lt; int &gt; &amp;Nsf, std::vector&lt; int &gt; &amp;Ndv, const std::vector&lt; int &gt; &amp;Ndf, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI, int &amp;e1, int &amp;e2, int &amp;f1, int &amp;f2)</td></tr>
<tr class="memdesc:a2382e1bd40b951c6f6c14da9773f2fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2382e1bd40b951c6f6c14da9773f2fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43afe015e0827032a90d6a916c223b2f" id="r_a43afe015e0827032a90d6a916c223b2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a43afe015e0827032a90d6a916c223b2f">collapse_edge</a> (const int e, const Eigen::RowVectorXd &amp;p, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI)</td></tr>
<tr class="memdesc:a43afe015e0827032a90d6a916c223b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a43afe015e0827032a90d6a916c223b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943c00b18c9d77e42372a02ac5429bd0" id="r_a943c00b18c9d77e42372a02ac5429bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a943c00b18c9d77e42372a02ac5429bd0">collapse_edge</a> (const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;pre_collapse, const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;post_collapse, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI, <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;Q, Eigen::VectorXi &amp;EQ, Eigen::MatrixXd &amp;C, int &amp;e, int &amp;e1, int &amp;e2, int &amp;f1, int &amp;f2)</td></tr>
<tr class="memdesc:a943c00b18c9d77e42372a02ac5429bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse least-cost edge from a priority queue and update queue.  <br /></td></tr>
<tr class="separator:a943c00b18c9d77e42372a02ac5429bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134e573db7b2488d9118ebcf88419f62" id="r_a134e573db7b2488d9118ebcf88419f62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a134e573db7b2488d9118ebcf88419f62">collapse_edge</a> (const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI, <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;Q, Eigen::VectorXi &amp;EQ, Eigen::MatrixXd &amp;C)</td></tr>
<tr class="memdesc:a134e573db7b2488d9118ebcf88419f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a134e573db7b2488d9118ebcf88419f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f5c61d84a3d91b0e701df01c97c26c" id="r_a16f5c61d84a3d91b0e701df01c97c26c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a16f5c61d84a3d91b0e701df01c97c26c">collapse_edge</a> (const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;pre_collapse, const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;post_collapse, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI, <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;Q, Eigen::VectorXi &amp;EQ, Eigen::MatrixXd &amp;C)</td></tr>
<tr class="memdesc:a16f5c61d84a3d91b0e701df01c97c26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a16f5c61d84a3d91b0e701df01c97c26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b31209f04c3bbfb3e3e54836c60d21f" id="r_a6b31209f04c3bbfb3e3e54836c60d21f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6b31209f04c3bbfb3e3e54836c60d21f">collapse_small_triangles</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const double eps, Eigen::MatrixXi &amp;FF)</td></tr>
<tr class="memdesc:a6b31209f04c3bbfb3e3e54836c60d21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse.  <br /></td></tr>
<tr class="separator:a6b31209f04c3bbfb3e3e54836c60d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b87a97bec71e27b622eadb0ba9314ea" id="r_a3b87a97bec71e27b622eadb0ba9314ea"><td class="memTemplParams" colspan="2">template&lt;typename L , typename S , typename H , typename T &gt; </td></tr>
<tr class="memitem:a3b87a97bec71e27b622eadb0ba9314ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3b87a97bec71e27b622eadb0ba9314ea">colon</a> (const L low, const S step, const H hi, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;I)</td></tr>
<tr class="memdesc:a3b87a97bec71e27b622eadb0ba9314ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colon operator like matlab's colon operator.  <br /></td></tr>
<tr class="separator:a3b87a97bec71e27b622eadb0ba9314ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e3b6d9995f83e6e09df72c562f7dec" id="r_af0e3b6d9995f83e6e09df72c562f7dec"><td class="memTemplParams" colspan="2">template&lt;typename L , typename H , typename T &gt; </td></tr>
<tr class="memitem:af0e3b6d9995f83e6e09df72c562f7dec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af0e3b6d9995f83e6e09df72c562f7dec">colon</a> (const L low, const H hi, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;I)</td></tr>
<tr class="memdesc:af0e3b6d9995f83e6e09df72c562f7dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colon operator like matlab's colon operator.  <br /></td></tr>
<tr class="separator:af0e3b6d9995f83e6e09df72c562f7dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbc9102801940ac0f884e2749ac1113" id="r_afcbc9102801940ac0f884e2749ac1113"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afcbc9102801940ac0f884e2749ac1113"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afcbc9102801940ac0f884e2749ac1113">colormap</a> (const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a> cm, const T f, T *rgb)</td></tr>
<tr class="memdesc:afcbc9102801940ac0f884e2749ac1113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute [r,g,b] values of the selected colormap for a given factor f between 0 and 1.  <br /></td></tr>
<tr class="separator:afcbc9102801940ac0f884e2749ac1113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b414ed243eb5c329d25492c74f0047a" id="r_a2b414ed243eb5c329d25492c74f0047a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b414ed243eb5c329d25492c74f0047a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2b414ed243eb5c329d25492c74f0047a">colormap</a> (const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a> cm, const T f, T &amp;r, T &amp;g, T &amp;b)</td></tr>
<tr class="memdesc:a2b414ed243eb5c329d25492c74f0047a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute [r,g,b] values of the selected colormap for a given factor f between 0 and 1.  <br /></td></tr>
<tr class="separator:a2b414ed243eb5c329d25492c74f0047a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39d4724e45beaa1e1f8562f0e5e54fd" id="r_ab39d4724e45beaa1e1f8562f0e5e54fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab39d4724e45beaa1e1f8562f0e5e54fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab39d4724e45beaa1e1f8562f0e5e54fd">colormap</a> (const double palette[256][3], const T x_in, T &amp;r, T &amp;g, T &amp;b)</td></tr>
<tr class="memdesc:ab39d4724e45beaa1e1f8562f0e5e54fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute [r,g,b] values of the colormap palette for a given factor f between 0 and 1.  <br /></td></tr>
<tr class="separator:ab39d4724e45beaa1e1f8562f0e5e54fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae915229f4fed51bf2f7df5850aa5b" id="r_ab3ae915229f4fed51bf2f7df5850aa5b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedZ , typename DerivedC &gt; </td></tr>
<tr class="memitem:ab3ae915229f4fed51bf2f7df5850aa5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab3ae915229f4fed51bf2f7df5850aa5b">colormap</a> (const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a> cm, const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, const bool normalize, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:ab3ae915229f4fed51bf2f7df5850aa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute [r,g,b] values of the colormap palette for a given factors between 0 and 1.  <br /></td></tr>
<tr class="separator:ab3ae915229f4fed51bf2f7df5850aa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d9c681c034e001a790a6c31555d429" id="r_a50d9c681c034e001a790a6c31555d429"><td class="memTemplParams" colspan="2">template&lt;typename DerivedZ , typename DerivedC &gt; </td></tr>
<tr class="memitem:a50d9c681c034e001a790a6c31555d429"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a50d9c681c034e001a790a6c31555d429">colormap</a> (const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a> cm, const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, const double min_Z, const double max_Z, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a50d9c681c034e001a790a6c31555d429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute [r,g,b] values of the colormap palette for a given factors between <code>min_Z</code> and <code>max_Z</code>  <br /></td></tr>
<tr class="separator:a50d9c681c034e001a790a6c31555d429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012bb449a5e1b088fd42ed4eb801391a" id="r_a012bb449a5e1b088fd42ed4eb801391a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a012bb449a5e1b088fd42ed4eb801391a">column_to_quats</a> (const Eigen::VectorXd &amp;Q, std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;vQ)</td></tr>
<tr class="memdesc:a012bb449a5e1b088fd42ed4eb801391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">de-"Columnize" a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...)  <br /></td></tr>
<tr class="separator:a012bb449a5e1b088fd42ed4eb801391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae4ea0e51288d468b77d2303f7b60e5" id="r_a2ae4ea0e51288d468b77d2303f7b60e5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a2ae4ea0e51288d468b77d2303f7b60e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2ae4ea0e51288d468b77d2303f7b60e5">columnize</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, const int k, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a2ae4ea0e51288d468b77d2303f7b60e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Columnize" a stack of block matrices.  <br /></td></tr>
<tr class="separator:a2ae4ea0e51288d468b77d2303f7b60e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d3578aca0da0bea74041ca2b239c1d" id="r_a42d3578aca0da0bea74041ca2b239c1d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a42d3578aca0da0bea74041ca2b239c1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a42d3578aca0da0bea74041ca2b239c1d">comb_cross_field</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD1in, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD2in, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;PD1out, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;PD2out)</td></tr>
<tr class="memdesc:a42d3578aca0da0bea74041ca2b239c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces.  <br /></td></tr>
<tr class="separator:a42d3578aca0da0bea74041ca2b239c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406fa0cb0c3fafe5a7b06e31ba757329" id="r_a406fa0cb0c3fafe5a7b06e31ba757329"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP &gt; </td></tr>
<tr class="memitem:a406fa0cb0c3fafe5a7b06e31ba757329"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a406fa0cb0c3fafe5a7b06e31ba757329">comb_frame_field</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;PD1, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;PD2, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;BIS1_combed, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;BIS2_combed, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;PD1_combed, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;PD2_combed)</td></tr>
<tr class="memdesc:a406fa0cb0c3fafe5a7b06e31ba757329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes principal matchings of the vectors of a frame field across face edges, and generates a combed frame field defined on the mesh faces.  <br /></td></tr>
<tr class="separator:a406fa0cb0c3fafe5a7b06e31ba757329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702a263c5565f41ca8e4585619b746f7" id="r_a702a263c5565f41ca8e4585619b746f7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a702a263c5565f41ca8e4585619b746f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a702a263c5565f41ca8e4585619b746f7">comb_line_field</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD1in, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;PD1out)</td></tr>
<tr class="memdesc:a702a263c5565f41ca8e4585619b746f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces.  <br /></td></tr>
<tr class="separator:a702a263c5565f41ca8e4585619b746f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add396b23f15d16510156bfa839f58661" id="r_add396b23f15d16510156bfa839f58661"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVV , typename DerivedFF , typename DerivedV , typename DerivedF , typename DerivedVsizes , typename DerivedFsizes &gt; </td></tr>
<tr class="memitem:add396b23f15d16510156bfa839f58661"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#add396b23f15d16510156bfa839f58661">combine</a> (const std::vector&lt; DerivedVV &gt; &amp;VV, const std::vector&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedVsizes &gt; &amp;Vsizes, Eigen::PlainObjectBase&lt; DerivedFsizes &gt; &amp;Fsizes)</td></tr>
<tr class="memdesc:add396b23f15d16510156bfa839f58661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate k meshes into a single &gt;=k connected component mesh with a single vertex list and face list.  <br /></td></tr>
<tr class="separator:add396b23f15d16510156bfa839f58661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f28ec0548f636eb6dc9551eca554bc" id="r_a75f28ec0548f636eb6dc9551eca554bc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVV , typename DerivedFF , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a75f28ec0548f636eb6dc9551eca554bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a75f28ec0548f636eb6dc9551eca554bc">combine</a> (const std::vector&lt; DerivedVV &gt; &amp;VV, const std::vector&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a75f28ec0548f636eb6dc9551eca554bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a75f28ec0548f636eb6dc9551eca554bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab190df5efbd072173791f9ae36b0c58c" id="r_ab190df5efbd072173791f9ae36b0c58c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ab190df5efbd072173791f9ae36b0c58c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab190df5efbd072173791f9ae36b0c58c">compute_frame_field_bisectors</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;B1, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;B2, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD1, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD2, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;BIS1, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;BIS2)</td></tr>
<tr class="memdesc:ab190df5efbd072173791f9ae36b0c58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute bisectors of a frame field defined on mesh faces.  <br /></td></tr>
<tr class="separator:ab190df5efbd072173791f9ae36b0c58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b8f100ec84d5b9dfc68558f6e3e0b" id="r_a062b8f100ec84d5b9dfc68558f6e3e0b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a062b8f100ec84d5b9dfc68558f6e3e0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a062b8f100ec84d5b9dfc68558f6e3e0b">compute_frame_field_bisectors</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD1, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD2, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;BIS1, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;BIS2)</td></tr>
<tr class="memdesc:a062b8f100ec84d5b9dfc68558f6e3e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a062b8f100ec84d5b9dfc68558f6e3e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8cf9368d76d69d41ea95bc5b4fd13b" id="r_a6c8cf9368d76d69d41ea95bc5b4fd13b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedFO &gt; </td></tr>
<tr class="memitem:a6c8cf9368d76d69d41ea95bc5b4fd13b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6c8cf9368d76d69d41ea95bc5b4fd13b">connect_boundary_to_infinity</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFO &gt; &amp;FO)</td></tr>
<tr class="memdesc:a6c8cf9368d76d69d41ea95bc5b4fd13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect all boundary edges to a fictitious point at infinity.  <br /></td></tr>
<tr class="separator:a6c8cf9368d76d69d41ea95bc5b4fd13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb409818f72dece08eaa0c0f71d5b2e9" id="r_abb409818f72dece08eaa0c0f71d5b2e9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedFO &gt; </td></tr>
<tr class="memitem:abb409818f72dece08eaa0c0f71d5b2e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abb409818f72dece08eaa0c0f71d5b2e9">connect_boundary_to_infinity</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedF::Scalar inf_index, Eigen::PlainObjectBase&lt; DerivedFO &gt; &amp;FO)</td></tr>
<tr class="memdesc:abb409818f72dece08eaa0c0f71d5b2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect all boundary edges to a fictitious point at infinity.  <br /></td></tr>
<tr class="separator:abb409818f72dece08eaa0c0f71d5b2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d651ddb82e5e25cc25fbab3813190da" id="r_a1d651ddb82e5e25cc25fbab3813190da"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVO , typename DerivedFO &gt; </td></tr>
<tr class="memitem:a1d651ddb82e5e25cc25fbab3813190da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1d651ddb82e5e25cc25fbab3813190da">connect_boundary_to_infinity</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedVO &gt; &amp;VO, Eigen::PlainObjectBase&lt; DerivedFO &gt; &amp;FO)</td></tr>
<tr class="memdesc:a1d651ddb82e5e25cc25fbab3813190da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect all boundary edges to a fictitious point at infinity.  <br /></td></tr>
<tr class="separator:a1d651ddb82e5e25cc25fbab3813190da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493c0508f1454ae875031906899d4de" id="r_ad493c0508f1454ae875031906899d4de"><td class="memTemplParams" colspan="2">template&lt;typename Atype , typename DerivedC , typename DerivedK &gt; </td></tr>
<tr class="memitem:ad493c0508f1454ae875031906899d4de"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad493c0508f1454ae875031906899d4de">connected_components</a> (const Eigen::SparseMatrix&lt; Atype &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:ad493c0508f1454ae875031906899d4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the connected components of a graph described by the input adjacency matrix (similar to MATLAB's graphconncomp or gptoolbox's conncomp, but A is transposed for unsymmetric graphs).  <br /></td></tr>
<tr class="separator:ad493c0508f1454ae875031906899d4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbfe6ae19ab6f94e36b3d92be1159fe9" id="r_acbfe6ae19ab6f94e36b3d92be1159fe9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:acbfe6ae19ab6f94e36b3d92be1159fe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9">cotmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;L)</td></tr>
<tr class="memdesc:acbfe6ae19ab6f94e36b3d92be1159fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,F).  <br /></td></tr>
<tr class="separator:acbfe6ae19ab6f94e36b3d92be1159fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d5463d31cf82b23668e9680975301a" id="r_a42d5463d31cf82b23668e9680975301a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename Scalar &gt; </td></tr>
<tr class="memitem:a42d5463d31cf82b23668e9680975301a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a42d5463d31cf82b23668e9680975301a">cotmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; Scalar &gt; &amp;L, Eigen::SparseMatrix&lt; Scalar &gt; &amp;M, Eigen::SparseMatrix&lt; Scalar &gt; &amp;P)</td></tr>
<tr class="memdesc:a42d5463d31cf82b23668e9680975301a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cotangent Laplacian (and mass matrix) for polygon meshes according to "Polygon Laplacian Made Simple" [Bunge et al. 2020].  <br /></td></tr>
<tr class="separator:a42d5463d31cf82b23668e9680975301a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5e7ebbe20f12078dc576d644935f83" id="r_a4c5e7ebbe20f12078dc576d644935f83"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a4c5e7ebbe20f12078dc576d644935f83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4c5e7ebbe20f12078dc576d644935f83">cotmatrix_entries</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a4c5e7ebbe20f12078dc576d644935f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotmatrix contributions (cotangents) of each angle in mesh (V,F)  <br /></td></tr>
<tr class="separator:a4c5e7ebbe20f12078dc576d644935f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01189493d30a0e8a2cbd6e053641545f" id="r_a01189493d30a0e8a2cbd6e053641545f"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedC &gt; </td></tr>
<tr class="memitem:a01189493d30a0e8a2cbd6e053641545f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a01189493d30a0e8a2cbd6e053641545f">cotmatrix_entries</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a01189493d30a0e8a2cbd6e053641545f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the cotmatrix contributions (cotangents) of each angle in mesh with edge lengths (l)  <br /></td></tr>
<tr class="separator:a01189493d30a0e8a2cbd6e053641545f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47d4dd3239dba392f54b8dc3f62e8dd" id="r_ae47d4dd3239dba392f54b8dc3f62e8dd"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:ae47d4dd3239dba392f54b8dc3f62e8dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae47d4dd3239dba392f54b8dc3f62e8dd">cotmatrix_intrinsic</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;L)</td></tr>
<tr class="memdesc:ae47d4dd3239dba392f54b8dc3f62e8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh with faces F and edge lengths l.  <br /></td></tr>
<tr class="separator:ae47d4dd3239dba392f54b8dc3f62e8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83819bb842f4bc4c8af21a98e1db44b3" id="r_a83819bb842f4bc4c8af21a98e1db44b3"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename SType &gt; </td></tr>
<tr class="memitem:a83819bb842f4bc4c8af21a98e1db44b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a83819bb842f4bc4c8af21a98e1db44b3">count</a> (const Eigen::SparseMatrix&lt; XType &gt; &amp;X, const int dim, Eigen::SparseVector&lt; SType &gt; &amp;S)</td></tr>
<tr class="memdesc:a83819bb842f4bc4c8af21a98e1db44b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of non-zeros in the columns or rows of a sparse matrix.  <br /></td></tr>
<tr class="separator:a83819bb842f4bc4c8af21a98e1db44b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91399ecb01f4828dbe0b5d3e9c51a73b" id="r_a91399ecb01f4828dbe0b5d3e9c51a73b"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename DerivedS &gt; </td></tr>
<tr class="memitem:a91399ecb01f4828dbe0b5d3e9c51a73b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a91399ecb01f4828dbe0b5d3e9c51a73b">count</a> (const Eigen::SparseMatrix&lt; XType &gt; &amp;X, const int dim, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a91399ecb01f4828dbe0b5d3e9c51a73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a91399ecb01f4828dbe0b5d3e9c51a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566bead6b8810ca47f10d8e0b184c2ab" id="r_a566bead6b8810ca47f10d8e0b184c2ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a566bead6b8810ca47f10d8e0b184c2ab">covariance_scatter_matrix</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">ARAPEnergyType</a> energy, Eigen::SparseMatrix&lt; double &gt; &amp;CSM)</td></tr>
<tr class="memdesc:a566bead6b8810ca47f10d8e0b184c2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the covariance scatter matrix for a given arap energy.  <br /></td></tr>
<tr class="separator:a566bead6b8810ca47f10d8e0b184c2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8762cbd164779fc2b875dd73ab70d0" id="r_a9a8762cbd164779fc2b875dd73ab70d0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </td></tr>
<tr class="memitem:a9a8762cbd164779fc2b875dd73ab70d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9a8762cbd164779fc2b875dd73ab70d0">cr_vector_curvature_correction</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarK &gt; &amp;K)</td></tr>
<tr class="memdesc:a9a8762cbd164779fc2b875dd73ab70d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the vector Crouzeix-Raviart curvature correction term of Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020.  <br /></td></tr>
<tr class="separator:a9a8762cbd164779fc2b875dd73ab70d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca2a3d390d85a9432843e481cc1b2ca" id="r_aeca2a3d390d85a9432843e481cc1b2ca"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </td></tr>
<tr class="memitem:aeca2a3d390d85a9432843e481cc1b2ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aeca2a3d390d85a9432843e481cc1b2ca">cr_vector_curvature_correction</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarK &gt; &amp;K)</td></tr>
<tr class="memdesc:aeca2a3d390d85a9432843e481cc1b2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aeca2a3d390d85a9432843e481cc1b2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ef6fb71a86a0dc23499f0d2859578" id="r_a8e4ef6fb71a86a0dc23499f0d2859578"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename Derivedtheta , typename Derivedkappa , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </td></tr>
<tr class="memitem:a8e4ef6fb71a86a0dc23499f0d2859578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8e4ef6fb71a86a0dc23499f0d2859578">cr_vector_curvature_correction_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; Derivedtheta &gt; &amp;theta, const Eigen::MatrixBase&lt; Derivedkappa &gt; &amp;kappa, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarK &gt; &amp;K)</td></tr>
<tr class="memdesc:a8e4ef6fb71a86a0dc23499f0d2859578"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a8e4ef6fb71a86a0dc23499f0d2859578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9522053349c7920e8399af8da638720d" id="r_a9522053349c7920e8399af8da638720d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </td></tr>
<tr class="memitem:a9522053349c7920e8399af8da638720d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9522053349c7920e8399af8da638720d">cr_vector_curvature_correction_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarK &gt; &amp;K)</td></tr>
<tr class="memdesc:a9522053349c7920e8399af8da638720d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="cr__vector__curvature__correction_8h.html">include/igl/cr_vector_curvature_correction.h</a>.  <br /></td></tr>
<tr class="separator:a9522053349c7920e8399af8da638720d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d76cb9c1bfa1cc13c9bc19f4bcbdc8" id="r_a27d76cb9c1bfa1cc13c9bc19f4bcbdc8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename Derivedtheta , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </td></tr>
<tr class="memitem:a27d76cb9c1bfa1cc13c9bc19f4bcbdc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a27d76cb9c1bfa1cc13c9bc19f4bcbdc8">cr_vector_curvature_correction_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; Derivedtheta &gt; &amp;theta, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarK &gt; &amp;K)</td></tr>
<tr class="memdesc:a27d76cb9c1bfa1cc13c9bc19f4bcbdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="cr__vector__curvature__correction_8h.html">include/igl/cr_vector_curvature_correction.h</a>.  <br /></td></tr>
<tr class="separator:a27d76cb9c1bfa1cc13c9bc19f4bcbdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b4cd87c1b79a3e8220217907e2f92d" id="r_ad3b4cd87c1b79a3e8220217907e2f92d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </td></tr>
<tr class="memitem:ad3b4cd87c1b79a3e8220217907e2f92d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad3b4cd87c1b79a3e8220217907e2f92d">cr_vector_laplacian</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarL &gt; &amp;L)</td></tr>
<tr class="memdesc:ad3b4cd87c1b79a3e8220217907e2f92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the CR vector Laplacian matrix.  <br /></td></tr>
<tr class="separator:ad3b4cd87c1b79a3e8220217907e2f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc88ca84e384cf6d28d2fc8a0f9bebf" id="r_a6cc88ca84e384cf6d28d2fc8a0f9bebf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </td></tr>
<tr class="memitem:a6cc88ca84e384cf6d28d2fc8a0f9bebf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6cc88ca84e384cf6d28d2fc8a0f9bebf">cr_vector_laplacian</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarL &gt; &amp;L)</td></tr>
<tr class="memdesc:a6cc88ca84e384cf6d28d2fc8a0f9bebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6cc88ca84e384cf6d28d2fc8a0f9bebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2c2b7f03004fbcca3d3fa8f4fef60f" id="r_a7a2c2b7f03004fbcca3d3fa8f4fef60f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DeriveddA , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </td></tr>
<tr class="memitem:a7a2c2b7f03004fbcca3d3fa8f4fef60f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7a2c2b7f03004fbcca3d3fa8f4fef60f">cr_vector_laplacian_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarL &gt; &amp;L)</td></tr>
<tr class="memdesc:a7a2c2b7f03004fbcca3d3fa8f4fef60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7a2c2b7f03004fbcca3d3fa8f4fef60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c1a4348f8eeba501dac71ffe89a71c" id="r_a74c1a4348f8eeba501dac71ffe89a71c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </td></tr>
<tr class="memitem:a74c1a4348f8eeba501dac71ffe89a71c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a74c1a4348f8eeba501dac71ffe89a71c">cr_vector_laplacian_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarL &gt; &amp;L)</td></tr>
<tr class="memdesc:a74c1a4348f8eeba501dac71ffe89a71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="cr__vector__laplacian_8h.html">include/igl/cr_vector_laplacian.h</a>.  <br /></td></tr>
<tr class="separator:a74c1a4348f8eeba501dac71ffe89a71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb956da2f2c2355242b2c267b86d8fea" id="r_adb956da2f2c2355242b2c267b86d8fea"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM &gt; </td></tr>
<tr class="memitem:adb956da2f2c2355242b2c267b86d8fea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adb956da2f2c2355242b2c267b86d8fea">cr_vector_mass</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::SparseMatrix&lt; ScalarM &gt; &amp;M)</td></tr>
<tr class="memdesc:adb956da2f2c2355242b2c267b86d8fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the CR vector mass matrix, using an arrangement of all parallel degrees of freedom first, and all perpendicular degrees of freedom next.  <br /></td></tr>
<tr class="separator:adb956da2f2c2355242b2c267b86d8fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dabc69504695d2ad3ea01676bf9353" id="r_ab2dabc69504695d2ad3ea01676bf9353"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM &gt; </td></tr>
<tr class="memitem:ab2dabc69504695d2ad3ea01676bf9353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab2dabc69504695d2ad3ea01676bf9353">cr_vector_mass</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::SparseMatrix&lt; ScalarM &gt; &amp;M)</td></tr>
<tr class="memdesc:ab2dabc69504695d2ad3ea01676bf9353"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab2dabc69504695d2ad3ea01676bf9353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ed1159cd7e63e2d4993c501085be42" id="r_a10ed1159cd7e63e2d4993c501085be42"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DeriveddA , typename DerivedE , typename ScalarM &gt; </td></tr>
<tr class="memitem:a10ed1159cd7e63e2d4993c501085be42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a10ed1159cd7e63e2d4993c501085be42">cr_vector_mass_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::SparseMatrix&lt; ScalarM &gt; &amp;M)</td></tr>
<tr class="memdesc:a10ed1159cd7e63e2d4993c501085be42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a10ed1159cd7e63e2d4993c501085be42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb65039a597811fba7c59d41d039b4c" id="r_a8eb65039a597811fba7c59d41d039b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8eb65039a597811fba7c59d41d039b4c">cross</a> (const double *a, const double *b, double *out)</td></tr>
<tr class="memdesc:a8eb65039a597811fba7c59d41d039b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product; out = cross(a,b)  <br /></td></tr>
<tr class="separator:a8eb65039a597811fba7c59d41d039b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4887506ff673ad3a57ca0697dda4d029" id="r_a4887506ff673ad3a57ca0697dda4d029"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC &gt; </td></tr>
<tr class="memitem:a4887506ff673ad3a57ca0697dda4d029"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4887506ff673ad3a57ca0697dda4d029">cross</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, const Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a4887506ff673ad3a57ca0697dda4d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes rowwise cross product C = cross(A,B,2);.  <br /></td></tr>
<tr class="separator:a4887506ff673ad3a57ca0697dda4d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916e1792b25fb32f0554288f22dcaa21" id="r_a916e1792b25fb32f0554288f22dcaa21"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedM &gt; </td></tr>
<tr class="memitem:a916e1792b25fb32f0554288f22dcaa21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a916e1792b25fb32f0554288f22dcaa21">cross_field_mismatch</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD1, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD2, const bool isCombed, Eigen::PlainObjectBase&lt; DerivedM &gt; &amp;mismatch)</td></tr>
<tr class="memdesc:a916e1792b25fb32f0554288f22dcaa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces.  <br /></td></tr>
<tr class="separator:a916e1792b25fb32f0554288f22dcaa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528d6ff188e05af669e3369a40562268" id="r_a528d6ff188e05af669e3369a40562268"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename LT , typename DerivedE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:a528d6ff188e05af669e3369a40562268"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a528d6ff188e05af669e3369a40562268">crouzeix_raviart_cotmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; LT &gt; &amp;L, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:a528d6ff188e05af669e3369a40562268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Crouzeix-Raviart cotangent stiffness matrix.  <br /></td></tr>
<tr class="separator:a528d6ff188e05af669e3369a40562268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba460e00e27a7947e2d7d7d569ec04" id="r_a0cba460e00e27a7947e2d7d7d569ec04"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedEMAP , typename LT &gt; </td></tr>
<tr class="memitem:a0cba460e00e27a7947e2d7d7d569ec04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0cba460e00e27a7947e2d7d7d569ec04">crouzeix_raviart_cotmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, Eigen::SparseMatrix&lt; LT &gt; &amp;L)</td></tr>
<tr class="memdesc:a0cba460e00e27a7947e2d7d7d569ec04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Crouzeix-Raviart cotangent stiffness matrix.  <br /></td></tr>
<tr class="separator:a0cba460e00e27a7947e2d7d7d569ec04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1d2b58df45ae7555c3719963bb39d6" id="r_a1e1d2b58df45ae7555c3719963bb39d6"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:a1e1d2b58df45ae7555c3719963bb39d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1e1d2b58df45ae7555c3719963bb39d6">crouzeix_raviart_massmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; MT &gt; &amp;M, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:a1e1d2b58df45ae7555c3719963bb39d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e.  <br /></td></tr>
<tr class="separator:a1e1d2b58df45ae7555c3719963bb39d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbcad6ddce4e7c8f209f87f5deb5f81" id="r_a4fbcad6ddce4e7c8f209f87f5deb5f81"><td class="memTemplParams" colspan="2">template&lt;typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:a4fbcad6ddce4e7c8f209f87f5deb5f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4fbcad6ddce4e7c8f209f87f5deb5f81">crouzeix_raviart_massmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, Eigen::SparseMatrix&lt; MT &gt; &amp;M)</td></tr>
<tr class="memdesc:a4fbcad6ddce4e7c8f209f87f5deb5f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e.  <br /></td></tr>
<tr class="separator:a4fbcad6ddce4e7c8f209f87f5deb5f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8115269b075eef2f1c35db347806319d" id="r_a8115269b075eef2f1c35db347806319d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a8115269b075eef2f1c35db347806319d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8115269b075eef2f1c35db347806319d">cumprod</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const int dim, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a8115269b075eef2f1c35db347806319d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a cumulative product of the columns of X, like matlab's <code>cumprod</code>.  <br /></td></tr>
<tr class="separator:a8115269b075eef2f1c35db347806319d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad6bf440539af2b6aa5b38ce6d8f4ec" id="r_a6ad6bf440539af2b6aa5b38ce6d8f4ec"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a6ad6bf440539af2b6aa5b38ce6d8f4ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6ad6bf440539af2b6aa5b38ce6d8f4ec">cumsum</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const int dim, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a6ad6bf440539af2b6aa5b38ce6d8f4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a cumulative sum of the columns of X, like matlab's <code>cumsum</code>.  <br /></td></tr>
<tr class="separator:a6ad6bf440539af2b6aa5b38ce6d8f4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717f5ffd3d4bc3771bdd7e2e2786bb95" id="r_a717f5ffd3d4bc3771bdd7e2e2786bb95"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a717f5ffd3d4bc3771bdd7e2e2786bb95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a717f5ffd3d4bc3771bdd7e2e2786bb95">cumsum</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const int dim, const bool zero_prefix, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a717f5ffd3d4bc3771bdd7e2e2786bb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a cumulative sum of the columns of [0;X].  <br /></td></tr>
<tr class="separator:a717f5ffd3d4bc3771bdd7e2e2786bb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8191d83bb2517d430b625c5416988b" id="r_adf8191d83bb2517d430b625c5416988b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename ScalarQ &gt; </td></tr>
<tr class="memitem:adf8191d83bb2517d430b625c5416988b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adf8191d83bb2517d430b625c5416988b">curved_hessian_energy</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:adf8191d83bb2517d430b625c5416988b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the curved Hessian energy using the Crouzeix-Raviart discretization.  <br /></td></tr>
<tr class="separator:adf8191d83bb2517d430b625c5416988b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805b9c22927ea42f1756d0094e373f9f" id="r_a805b9c22927ea42f1756d0094e373f9f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </td></tr>
<tr class="memitem:a805b9c22927ea42f1756d0094e373f9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a805b9c22927ea42f1756d0094e373f9f">curved_hessian_energy</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:a805b9c22927ea42f1756d0094e373f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the curved Hessian energy using the Crouzeix-Raviart discretization.  <br /></td></tr>
<tr class="separator:a805b9c22927ea42f1756d0094e373f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef8866a2a9dee7c48ba52640e2d1f0" id="r_a22ef8866a2a9dee7c48ba52640e2d1f0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </td></tr>
<tr class="memitem:a22ef8866a2a9dee7c48ba52640e2d1f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a22ef8866a2a9dee7c48ba52640e2d1f0">curved_hessian_energy</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:a22ef8866a2a9dee7c48ba52640e2d1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the curved Hessian energy using the Crouzeix-Raviart discretization.  <br /></td></tr>
<tr class="separator:a22ef8866a2a9dee7c48ba52640e2d1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2f70635c7e74512f3a00c9fbf0175f" id="r_adf2f70635c7e74512f3a00c9fbf0175f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </td></tr>
<tr class="memitem:adf2f70635c7e74512f3a00c9fbf0175f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adf2f70635c7e74512f3a00c9fbf0175f">curved_hessian_energy_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:adf2f70635c7e74512f3a00c9fbf0175f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the curved Hessian energy using the Crouzeix-Raviart discretization.  <br /></td></tr>
<tr class="separator:adf2f70635c7e74512f3a00c9fbf0175f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee4e11b54bb3477734d8f83e33c01c7" id="r_a6ee4e11b54bb3477734d8f83e33c01c7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DeriveddA , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </td></tr>
<tr class="memitem:a6ee4e11b54bb3477734d8f83e33c01c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6ee4e11b54bb3477734d8f83e33c01c7">curved_hessian_energy_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:a6ee4e11b54bb3477734d8f83e33c01c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the curved Hessian energy using the Crouzeix-Raviart discretization.  <br /></td></tr>
<tr class="separator:a6ee4e11b54bb3477734d8f83e33c01c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221b56ac51e76ede2f88111bd099e2c" id="r_a3221b56ac51e76ede2f88111bd099e2c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI &gt; </td></tr>
<tr class="memitem:a3221b56ac51e76ede2f88111bd099e2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3221b56ac51e76ede2f88111bd099e2c">cut_mesh</a> (Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;cuts, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a3221b56ac51e76ede2f88111bd099e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary.  <br /></td></tr>
<tr class="separator:a3221b56ac51e76ede2f88111bd099e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4e732845de9d7f23536e1e6afe4a12" id="r_a9a4e732845de9d7f23536e1e6afe4a12"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFF , typename DerivedFFi , typename DerivedC , typename DerivedI &gt; </td></tr>
<tr class="memitem:a9a4e732845de9d7f23536e1e6afe4a12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9a4e732845de9d7f23536e1e6afe4a12">cut_mesh</a> (Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::MatrixBase&lt; DerivedFF &gt; &amp;FF, Eigen::MatrixBase&lt; DerivedFFi &gt; &amp;FFi, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a9a4e732845de9d7f23536e1e6afe4a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary.  <br /></td></tr>
<tr class="separator:a9a4e732845de9d7f23536e1e6afe4a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c53d1e5c547015ed9a3a31941c9e80" id="r_ab4c53d1e5c547015ed9a3a31941c9e80"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:ab4c53d1e5c547015ed9a3a31941c9e80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab4c53d1e5c547015ed9a3a31941c9e80">cut_mesh</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;cuts, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;Vn, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;Fn)</td></tr>
<tr class="memdesc:ab4c53d1e5c547015ed9a3a31941c9e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary.  <br /></td></tr>
<tr class="separator:ab4c53d1e5c547015ed9a3a31941c9e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073f4b026cc266fb9d229b0063139681" id="r_a073f4b026cc266fb9d229b0063139681"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI &gt; </td></tr>
<tr class="memitem:a073f4b026cc266fb9d229b0063139681"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a073f4b026cc266fb9d229b0063139681">cut_mesh</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;cuts, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;Vn, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;Fn, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a073f4b026cc266fb9d229b0063139681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary.  <br /></td></tr>
<tr class="separator:a073f4b026cc266fb9d229b0063139681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719fb78367f00bac1b9ef47dacead128" id="r_a719fb78367f00bac1b9ef47dacead128"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO &gt; </td></tr>
<tr class="memitem:a719fb78367f00bac1b9ef47dacead128"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a719fb78367f00bac1b9ef47dacead128">cut_mesh_from_singularities</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;MMatch, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;seams)</td></tr>
<tr class="memdesc:a719fb78367f00bac1b9ef47dacead128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh (V,F) and the integer mismatch of a cross field per edge (mismatch), finds the cut_graph connecting the singularities (seams) and the degree of the singularities singularity_index.  <br /></td></tr>
<tr class="separator:a719fb78367f00bac1b9ef47dacead128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2b58d7048e2871ef70de6761fe10f2" id="r_ace2b58d7048e2871ef70de6761fe10f2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Index &gt; </td></tr>
<tr class="memitem:ace2b58d7048e2871ef70de6761fe10f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ace2b58d7048e2871ef70de6761fe10f2">cut_to_disk</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;cuts)</td></tr>
<tr class="memdesc:ace2b58d7048e2871ef70de6761fe10f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a triangle mesh, computes a set of edge cuts sufficient to carve the mesh into a topological disk, without disconnecting any connected components.  <br /></td></tr>
<tr class="separator:ace2b58d7048e2871ef70de6761fe10f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77a363af4a0fcf59e15409bd8a09fc4" id="r_ab77a363af4a0fcf59e15409bd8a09fc4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ab77a363af4a0fcf59e15409bd8a09fc4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab77a363af4a0fcf59e15409bd8a09fc4">cylinder</a> (const int axis_devisions, const int height_devisions, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ab77a363af4a0fcf59e15409bd8a09fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a triangle mesh of a cylinder (without caps)  <br /></td></tr>
<tr class="separator:ab77a363af4a0fcf59e15409bd8a09fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73748b03f3e779d764d30d920653aba6" id="r_a73748b03f3e779d764d30d920653aba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a73748b03f3e779d764d30d920653aba6">dated_copy</a> (const std::string &amp;src_path, const std::string &amp;dir)</td></tr>
<tr class="memdesc:a73748b03f3e779d764d30d920653aba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the given file to a new file with the same basename in <code>dir</code> directory with the current date and time as a suffix.  <br /></td></tr>
<tr class="separator:a73748b03f3e779d764d30d920653aba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50bddf10510ab0ef1bda0bb11641fef" id="r_ad50bddf10510ab0ef1bda0bb11641fef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad50bddf10510ab0ef1bda0bb11641fef">dated_copy</a> (const std::string &amp;src_path)</td></tr>
<tr class="memdesc:ad50bddf10510ab0ef1bda0bb11641fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad50bddf10510ab0ef1bda0bb11641fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e2a2c1ae537d160f7767a230be66b3" id="r_a48e2a2c1ae537d160f7767a230be66b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3">decimate</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const size_t max_m, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J, Eigen::VectorXi &amp;I)</td></tr>
<tr class="memdesc:a48e2a2c1ae537d160f7767a230be66b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of faces is achieved.  <br /></td></tr>
<tr class="separator:a48e2a2c1ae537d160f7767a230be66b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012dde4236352501b14abc42b746906e" id="r_a012dde4236352501b14abc42b746906e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a012dde4236352501b14abc42b746906e">decimate</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const size_t max_m, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J)</td></tr>
<tr class="memdesc:a012dde4236352501b14abc42b746906e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a012dde4236352501b14abc42b746906e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61885a8ab4cc1e4ed8ed1fba6e42ecb6" id="r_a61885a8ab4cc1e4ed8ed1fba6e42ecb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a61885a8ab4cc1e4ed8ed1fba6e42ecb6">decimate</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, const <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;stopping_condition, const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;pre_collapse, const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;post_collapse, const Eigen::MatrixXi &amp;E, const Eigen::VectorXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J, Eigen::VectorXi &amp;I)</td></tr>
<tr class="memdesc:a61885a8ab4cc1e4ed8ed1fba6e42ecb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses edges of a <b>closed manifold mesh</b> (V,F) using user defined callbacks in a priority queue.  <br /></td></tr>
<tr class="separator:a61885a8ab4cc1e4ed8ed1fba6e42ecb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e383abbd367d0ed68c602a7ae7ea2f7" id="r_a8e383abbd367d0ed68c602a7ae7ea2f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8e383abbd367d0ed68c602a7ae7ea2f7">decimate</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, const <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;stopping_condition, const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;pre_collapse, const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;post_collapse, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J, Eigen::VectorXi &amp;I)</td></tr>
<tr class="memdesc:a8e383abbd367d0ed68c602a7ae7ea2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a8e383abbd367d0ed68c602a7ae7ea2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa716c4de65ed56fd9f9968f9d79ee657" id="r_aa716c4de65ed56fd9f9968f9d79ee657"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa716c4de65ed56fd9f9968f9d79ee657">decimate</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, const <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;stopping_condition, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J, Eigen::VectorXi &amp;I)</td></tr>
<tr class="memdesc:aa716c4de65ed56fd9f9968f9d79ee657"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa716c4de65ed56fd9f9968f9d79ee657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199e2a88dcf8d16e8b0244d20e4743c1" id="r_a199e2a88dcf8d16e8b0244d20e4743c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a199e2a88dcf8d16e8b0244d20e4743c1">decimate_trivial_callbacks</a> (<a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;always_try, <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;never_care)</td></tr>
<tr class="memdesc:a199e2a88dcf8d16e8b0244d20e4743c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to build trivial pre and post collapse actions.  <br /></td></tr>
<tr class="separator:a199e2a88dcf8d16e8b0244d20e4743c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03c54b4a3c8a07853528d49455f4fcc" id="r_aa03c54b4a3c8a07853528d49455f4fcc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa03c54b4a3c8a07853528d49455f4fcc">default_num_threads</a> (unsigned int force_num_threads=0)</td></tr>
<tr class="memdesc:aa03c54b4a3c8a07853528d49455f4fcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default number of threads used in libigl.  <br /></td></tr>
<tr class="separator:aa03c54b4a3c8a07853528d49455f4fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5819845b8bcf251d5e25bc93bf425e35" id="r_a5819845b8bcf251d5e25bc93bf425e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5819845b8bcf251d5e25bc93bf425e35">deform_skeleton</a> (const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;BE, const std::vector&lt; Eigen::Affine3d, Eigen::aligned_allocator&lt; Eigen::Affine3d &gt; &gt; &amp;vA, Eigen::MatrixXd &amp;CT, Eigen::MatrixXi &amp;BET)</td></tr>
<tr class="memdesc:a5819845b8bcf251d5e25bc93bf425e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deform a skeleton.  <br /></td></tr>
<tr class="separator:a5819845b8bcf251d5e25bc93bf425e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473e4f58cfd34838b53114e315604728" id="r_a473e4f58cfd34838b53114e315604728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a473e4f58cfd34838b53114e315604728">deform_skeleton</a> (const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;BE, const Eigen::MatrixXd &amp;T, Eigen::MatrixXd &amp;CT, Eigen::MatrixXi &amp;BET)</td></tr>
<tr class="memdesc:a473e4f58cfd34838b53114e315604728"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a473e4f58cfd34838b53114e315604728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85b334c412de101ce6003dabbd6ad70" id="r_ad85b334c412de101ce6003dabbd6ad70"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename Orient2D , typename InCircle , typename DerivedF &gt; </td></tr>
<tr class="memitem:ad85b334c412de101ce6003dabbd6ad70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad85b334c412de101ce6003dabbd6ad70">delaunay_triangulation</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Orient2D orient2D, InCircle incircle, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ad85b334c412de101ce6003dabbd6ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in 2D, return a Delaunay triangulation of these points.  <br /></td></tr>
<tr class="separator:ad85b334c412de101ce6003dabbd6ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bed0a54e4a3d573a8ca709f613d2b8c" id="r_a9bed0a54e4a3d573a8ca709f613d2b8c"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedD , typename DerivedP , typename DerivedC &gt; </td></tr>
<tr class="memitem:a9bed0a54e4a3d573a8ca709f613d2b8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9bed0a54e4a3d573a8ca709f613d2b8c">dfs</a> (const std::vector&lt; std::vector&lt; AType &gt; &gt; &amp;A, const size_t s, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a9bed0a54e4a3d573a8ca709f613d2b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse a <b>directed</b> graph represented by an adjacency list using depth first search.  <br /></td></tr>
<tr class="separator:a9bed0a54e4a3d573a8ca709f613d2b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95618dab6ef7c11351e352297c2d77fc" id="r_a95618dab6ef7c11351e352297c2d77fc"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DType , typename PType , typename CType &gt; </td></tr>
<tr class="memitem:a95618dab6ef7c11351e352297c2d77fc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a95618dab6ef7c11351e352297c2d77fc">dfs</a> (const std::vector&lt; std::vector&lt; AType &gt; &gt; &amp;A, const size_t s, std::vector&lt; DType &gt; &amp;D, std::vector&lt; PType &gt; &amp;P, std::vector&lt; CType &gt; &amp;C)</td></tr>
<tr class="memdesc:a95618dab6ef7c11351e352297c2d77fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a95618dab6ef7c11351e352297c2d77fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d2eff20a5c7b15bbe61a1d53eadc9b" id="r_ae1d2eff20a5c7b15bbe61a1d53eadc9b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename Derivedtheta , typename Derivedcos_theta &gt; </td></tr>
<tr class="memitem:ae1d2eff20a5c7b15bbe61a1d53eadc9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae1d2eff20a5c7b15bbe61a1d53eadc9b">dihedral_angles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; Derivedtheta &gt; &amp;theta, Eigen::PlainObjectBase&lt; Derivedcos_theta &gt; &amp;cos_theta)</td></tr>
<tr class="memdesc:ae1d2eff20a5c7b15bbe61a1d53eadc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute dihedral angles for all tets of a given tet mesh (V,T).  <br /></td></tr>
<tr class="separator:ae1d2eff20a5c7b15bbe61a1d53eadc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fd16e614bedafbd69fa739a29a7622" id="r_af8fd16e614bedafbd69fa739a29a7622"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename DerivedA , typename Derivedtheta , typename Derivedcos_theta &gt; </td></tr>
<tr class="memitem:af8fd16e614bedafbd69fa739a29a7622"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af8fd16e614bedafbd69fa739a29a7622">dihedral_angles_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedL &gt; &amp;L, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; Derivedtheta &gt; &amp;theta, Eigen::PlainObjectBase&lt; Derivedcos_theta &gt; &amp;cos_theta)</td></tr>
<tr class="memdesc:af8fd16e614bedafbd69fa739a29a7622"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af8fd16e614bedafbd69fa739a29a7622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b06e5e2a37a01b6648acb209437f78" id="r_a16b06e5e2a37a01b6648acb209437f78"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename DerivedD , typename DerivedP &gt; </td></tr>
<tr class="memitem:a16b06e5e2a37a01b6648acb209437f78"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a16b06e5e2a37a01b6648acb209437f78">dijkstra</a> (const IndexType &amp;source, const std::set&lt; IndexType &gt; &amp;targets, const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;VV, const std::vector&lt; double &gt; &amp;weights, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;min_distance, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;previous)</td></tr>
<tr class="memdesc:a16b06e5e2a37a01b6648acb209437f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dijkstra's algorithm for vertex-weighted shortest paths, with multiple targets.  <br /></td></tr>
<tr class="separator:a16b06e5e2a37a01b6648acb209437f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2bd7c3c9affbdcd476b68cfe36a41d" id="r_a5a2bd7c3c9affbdcd476b68cfe36a41d"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename DerivedV , typename DerivedD , typename DerivedP &gt; </td></tr>
<tr class="memitem:a5a2bd7c3c9affbdcd476b68cfe36a41d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5a2bd7c3c9affbdcd476b68cfe36a41d">dijkstra</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;VV, const IndexType &amp;source, const std::set&lt; IndexType &gt; &amp;targets, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;min_distance, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;previous)</td></tr>
<tr class="memdesc:a5a2bd7c3c9affbdcd476b68cfe36a41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5a2bd7c3c9affbdcd476b68cfe36a41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95f2745c0d523d9b1b8d7b7ef2707b9" id="r_ad95f2745c0d523d9b1b8d7b7ef2707b9"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename DerivedD , typename DerivedP &gt; </td></tr>
<tr class="memitem:ad95f2745c0d523d9b1b8d7b7ef2707b9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad95f2745c0d523d9b1b8d7b7ef2707b9">dijkstra</a> (const IndexType &amp;source, const std::set&lt; IndexType &gt; &amp;targets, const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;VV, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;min_distance, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;previous)</td></tr>
<tr class="memdesc:ad95f2745c0d523d9b1b8d7b7ef2707b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad95f2745c0d523d9b1b8d7b7ef2707b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574a508288788ba1c5a7c8c2adbd0c33" id="r_a574a508288788ba1c5a7c8c2adbd0c33"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename DerivedP &gt; </td></tr>
<tr class="memitem:a574a508288788ba1c5a7c8c2adbd0c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a574a508288788ba1c5a7c8c2adbd0c33">dijkstra</a> (const IndexType &amp;vertex, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;previous, std::vector&lt; IndexType &gt; &amp;path)</td></tr>
<tr class="memdesc:a574a508288788ba1c5a7c8c2adbd0c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backtracking after Dijkstra's algorithm, to find shortest path.  <br /></td></tr>
<tr class="separator:a574a508288788ba1c5a7c8c2adbd0c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aaa9b2bd870165bee8f9c18c826496" id="r_a24aaa9b2bd870165bee8f9c18c826496"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedOmega , typename DerivedU &gt; </td></tr>
<tr class="memitem:a24aaa9b2bd870165bee8f9c18c826496"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a24aaa9b2bd870165bee8f9c18c826496">direct_delta_mush</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const std::vector&lt; Eigen::Affine3d, Eigen::aligned_allocator&lt; Eigen::Affine3d &gt; &gt; &amp;T, const Eigen::MatrixBase&lt; DerivedOmega &gt; &amp;Omega, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a24aaa9b2bd870165bee8f9c18c826496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes Direct Delta Mush Skinning (Variant 0) from "Direct Delta Mush
Skinning and Variants".  <br /></td></tr>
<tr class="separator:a24aaa9b2bd870165bee8f9c18c826496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dbae56ef5784518387be01caf9bb5c" id="r_a48dbae56ef5784518387be01caf9bb5c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedW , typename DerivedOmega &gt; </td></tr>
<tr class="memitem:a48dbae56ef5784518387be01caf9bb5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a48dbae56ef5784518387be01caf9bb5c">direct_delta_mush_precomputation</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedW &gt; &amp;W, const int p, const typename DerivedV::Scalar lambda, const typename DerivedV::Scalar kappa, const typename DerivedV::Scalar alpha, Eigen::PlainObjectBase&lt; DerivedOmega &gt; &amp;Omega)</td></tr>
<tr class="memdesc:a48dbae56ef5784518387be01caf9bb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputation for Direct Delta Mush Skinning.  <br /></td></tr>
<tr class="separator:a48dbae56ef5784518387be01caf9bb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a57e1816cf4b6448d72f2f98b5e071" id="r_a72a57e1816cf4b6448d72f2f98b5e071"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC , typename DerivedE &gt; </td></tr>
<tr class="memitem:a72a57e1816cf4b6448d72f2f98b5e071"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a72a57e1816cf4b6448d72f2f98b5e071">directed_edge_orientations</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;Q)</td></tr>
<tr class="memdesc:a72a57e1816cf4b6448d72f2f98b5e071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine rotations that take each edge from the x-axis to its given rest orientation.  <br /></td></tr>
<tr class="separator:a72a57e1816cf4b6448d72f2f98b5e071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8de9b7859fbf82291598bae63e47550" id="r_af8de9b7859fbf82291598bae63e47550"><td class="memTemplParams" colspan="2">template&lt;typename DerivedE , typename DerivedP &gt; </td></tr>
<tr class="memitem:af8de9b7859fbf82291598bae63e47550"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af8de9b7859fbf82291598bae63e47550">directed_edge_parents</a> (const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:af8de9b7859fbf82291598bae63e47550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover "parents" (preceding edges) in a tree given just directed edges.  <br /></td></tr>
<tr class="separator:af8de9b7859fbf82291598bae63e47550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1ff1d390be65861384b6ff764ebe09" id="r_aef1ff1d390be65861384b6ff764ebe09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aef1ff1d390be65861384b6ff764ebe09">dirname</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:aef1ff1d390be65861384b6ff764ebe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function like PHP's dirname: /etc/passwd --&gt; /etc,.  <br /></td></tr>
<tr class="separator:aef1ff1d390be65861384b6ff764ebe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdaab27eb4626ff5685a3a4f9347b6a" id="r_a3bdaab27eb4626ff5685a3a4f9347b6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3bdaab27eb4626ff5685a3a4f9347b6a">dot</a> (const double *a, const double *b)</td></tr>
<tr class="memdesc:a3bdaab27eb4626ff5685a3a4f9347b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes out = dot(a,b)  <br /></td></tr>
<tr class="separator:a3bdaab27eb4626ff5685a3a4f9347b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23322b4cdcba5a31a7e95dc0a29b83f1" id="r_a23322b4cdcba5a31a7e95dc0a29b83f1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV &gt; </td></tr>
<tr class="memitem:a23322b4cdcba5a31a7e95dc0a29b83f1"><td class="memTemplItemLeft" align="right" valign="top">DerivedV&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a23322b4cdcba5a31a7e95dc0a29b83f1">dot_row</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;A, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;B)</td></tr>
<tr class="memdesc:a23322b4cdcba5a31a7e95dc0a29b83f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dot product between each row of A and B.  <br /></td></tr>
<tr class="separator:a23322b4cdcba5a31a7e95dc0a29b83f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bae61a0f8a1bbe72e7832381c9beca5" id="r_a7bae61a0f8a1bbe72e7832381c9beca5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DeriveddblA &gt; </td></tr>
<tr class="memitem:a7bae61a0f8a1bbe72e7832381c9beca5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7bae61a0f8a1bbe72e7832381c9beca5">doublearea</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;dblA)</td></tr>
<tr class="memdesc:a7bae61a0f8a1bbe72e7832381c9beca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes twice the area for each input triangle or quad.  <br /></td></tr>
<tr class="separator:a7bae61a0f8a1bbe72e7832381c9beca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2512ac1588eb6929dee61b2fb70955" id="r_adb2512ac1588eb6929dee61b2fb70955"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD &gt; </td></tr>
<tr class="memitem:adb2512ac1588eb6929dee61b2fb70955"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adb2512ac1588eb6929dee61b2fb70955">doublearea</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:adb2512ac1588eb6929dee61b2fb70955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the twice the signed area of a each triangle.  <br /></td></tr>
<tr class="separator:adb2512ac1588eb6929dee61b2fb70955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace08ffa72a43a1758a45fe097625aef" id="r_aace08ffa72a43a1758a45fe097625aef"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC &gt; </td></tr>
<tr class="memitem:aace08ffa72a43a1758a45fe097625aef"><td class="memTemplItemLeft" align="right" valign="top">DerivedA::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aace08ffa72a43a1758a45fe097625aef">doublearea_single</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:aace08ffa72a43a1758a45fe097625aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the twice the signed area of a single triangle.  <br /></td></tr>
<tr class="separator:aace08ffa72a43a1758a45fe097625aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f3fcc3d502d79e4617250e0ea85ef6" id="r_aa4f3fcc3d502d79e4617250e0ea85ef6"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DeriveddblA &gt; </td></tr>
<tr class="memitem:aa4f3fcc3d502d79e4617250e0ea85ef6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa4f3fcc3d502d79e4617250e0ea85ef6">doublearea</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const typename Derivedl::Scalar nan_replacement, Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;dblA)</td></tr>
<tr class="memdesc:aa4f3fcc3d502d79e4617250e0ea85ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute twice the area of each intrinsic triangle in a mesh.  <br /></td></tr>
<tr class="separator:aa4f3fcc3d502d79e4617250e0ea85ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcad7016d7021778f7ec4ff91cec557" id="r_a0fcad7016d7021778f7ec4ff91cec557"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DeriveddblA &gt; </td></tr>
<tr class="memitem:a0fcad7016d7021778f7ec4ff91cec557"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0fcad7016d7021778f7ec4ff91cec557">doublearea</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;dblA)</td></tr>
<tr class="memdesc:a0fcad7016d7021778f7ec4ff91cec557"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0fcad7016d7021778f7ec4ff91cec557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516b190062ec90a40ecce7a721951303" id="r_a516b190062ec90a40ecce7a721951303"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DeriveddblA &gt; </td></tr>
<tr class="memitem:a516b190062ec90a40ecce7a721951303"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a516b190062ec90a40ecce7a721951303">doublearea_quad</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;dblA)</td></tr>
<tr class="memdesc:a516b190062ec90a40ecce7a721951303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes twice the area for each input quadrilateral.  <br /></td></tr>
<tr class="separator:a516b190062ec90a40ecce7a721951303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae135ef705d377be39be52549ba816de4" id="r_ae135ef705d377be39be52549ba816de4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedW , typename Q , typename QAlloc , typename T , typename DerivedU &gt; </td></tr>
<tr class="memitem:ae135ef705d377be39be52549ba816de4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae135ef705d377be39be52549ba816de4">dqs</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedW &gt; &amp;W, const std::vector&lt; Q, QAlloc &gt; &amp;vQ, const std::vector&lt; T &gt; &amp;vT, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:ae135ef705d377be39be52549ba816de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual quaternion skinning.  <br /></td></tr>
<tr class="separator:ae135ef705d377be39be52549ba816de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43379fb55c1019ff88c726aacb64b91" id="r_ac43379fb55c1019ff88c726aacb64b91"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedQ &gt; </td></tr>
<tr class="memitem:ac43379fb55c1019ff88c726aacb64b91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac43379fb55c1019ff88c726aacb64b91">dual_contouring</a> (const std::function&lt; typename DerivedV::Scalar(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;f, const std::function&lt; Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt;(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;f_grad, const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;min_corner, const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;max_corner, const int nx, const int ny, const int nz, const bool constrained, const bool triangles, const bool root_finding, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:ac43379fb55c1019ff88c726aacb64b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dual contouring to extract a pure quad mesh from differentiable implicit function using a dense grid.  <br /></td></tr>
<tr class="separator:ac43379fb55c1019ff88c726aacb64b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab912fd8e785a570ce48146acf3c84597" id="r_ab912fd8e785a570ce48146acf3c84597"><td class="memTemplParams" colspan="2">template&lt;typename DerivedGf , typename DerivedGV , typename DerivedV , typename DerivedQ &gt; </td></tr>
<tr class="memitem:ab912fd8e785a570ce48146acf3c84597"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab912fd8e785a570ce48146acf3c84597">dual_contouring</a> (const std::function&lt; typename DerivedV::Scalar(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;f, const std::function&lt; Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt;(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;f_grad, const Eigen::MatrixBase&lt; DerivedGf &gt; &amp;Gf, const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;GV, const int nx, const int ny, const int nz, const bool constrained, const bool triangles, const bool root_finding, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:ab912fd8e785a570ce48146acf3c84597"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab912fd8e785a570ce48146acf3c84597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab25bc6339ed9e928df2fcb7bd20ef7e" id="r_aab25bc6339ed9e928df2fcb7bd20ef7e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedGf , typename DerivedGV , typename DerivedGI , typename DerivedV , typename DerivedQ &gt; </td></tr>
<tr class="memitem:aab25bc6339ed9e928df2fcb7bd20ef7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aab25bc6339ed9e928df2fcb7bd20ef7e">dual_contouring</a> (const std::function&lt; typename DerivedV::Scalar(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;f, const std::function&lt; Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt;(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;f_grad, const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;step, const Eigen::MatrixBase&lt; DerivedGf &gt; &amp;Gf, const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;GV, const Eigen::MatrixBase&lt; DerivedGI &gt; &amp;GI, const bool constrained, const bool triangles, const bool root_finding, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:aab25bc6339ed9e928df2fcb7bd20ef7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aab25bc6339ed9e928df2fcb7bd20ef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484fcecc222d6c50ff16fe61ff820a80" id="r_a484fcecc222d6c50ff16fe61ff820a80"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Derivedear , typename Derivedear_opp &gt; </td></tr>
<tr class="memitem:a484fcecc222d6c50ff16fe61ff820a80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a484fcecc222d6c50ff16fe61ff820a80">ears</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; Derivedear &gt; &amp;ear, Eigen::PlainObjectBase&lt; Derivedear_opp &gt; &amp;ear_opp)</td></tr>
<tr class="memdesc:a484fcecc222d6c50ff16fe61ff820a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all ears (faces with two boundary edges) in a given mesh.  <br /></td></tr>
<tr class="separator:a484fcecc222d6c50ff16fe61ff820a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77cd5878fb81e389480d12080f8679c" id="r_aa77cd5878fb81e389480d12080f8679c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa77cd5878fb81e389480d12080f8679c">edge_collapse_is_valid</a> (const int e, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXi &amp;E, const Eigen::VectorXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI)</td></tr>
<tr class="memdesc:aa77cd5878fb81e389480d12080f8679c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology.  <br /></td></tr>
<tr class="separator:aa77cd5878fb81e389480d12080f8679c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4449e689db8a9360f41451ad4980b354" id="r_a4449e689db8a9360f41451ad4980b354"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4449e689db8a9360f41451ad4980b354">edge_collapse_is_valid</a> (std::vector&lt; int &gt; &amp;Nsv, std::vector&lt; int &gt; &amp;Ndv)</td></tr>
<tr class="memdesc:a4449e689db8a9360f41451ad4980b354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology.  <br /></td></tr>
<tr class="separator:a4449e689db8a9360f41451ad4980b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf37d2a8f8c08387438a60ba3bcb2ca" id="r_a0cf37d2a8f8c08387438a60ba3bcb2ca"><td class="memTemplParams" colspan="2">template&lt;typename DeriveduE , typename DerivedS , typename DerivedT &gt; </td></tr>
<tr class="memitem:a0cf37d2a8f8c08387438a60ba3bcb2ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0cf37d2a8f8c08387438a60ba3bcb2ca">edge_crossings</a> (const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;uE, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar val, std::unordered_map&lt; int, int &gt; &amp;uE2I, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:a0cf37d2a8f8c08387438a60ba3bcb2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the each point that a scalar field crosses a specified value along an edge of a mesh.  <br /></td></tr>
<tr class="separator:a0cf37d2a8f8c08387438a60ba3bcb2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1b6d5e7d874099d4260df5291e63e7" id="r_a6c1b6d5e7d874099d4260df5291e63e7"><td class="memTemplParams" colspan="2">template&lt;typename DeriveduE , typename DerivedEMAP , typename uE2EType , typename Index &gt; </td></tr>
<tr class="memitem:a6c1b6d5e7d874099d4260df5291e63e7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6c1b6d5e7d874099d4260df5291e63e7">edge_exists_near</a> (const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;uE, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, const Index &amp;a, const Index &amp;b, const Index &amp;uei)</td></tr>
<tr class="memdesc:a6c1b6d5e7d874099d4260df5291e63e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does edge (a,b) exist in the edges of all faces incident on existing unique edge uei.  <br /></td></tr>
<tr class="separator:a6c1b6d5e7d874099d4260df5291e63e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c604c49a10f557933850d8c8e2a76" id="r_a984c604c49a10f557933850d8c8e2a76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a984c604c49a10f557933850d8c8e2a76">edge_flaps</a> (const Eigen::MatrixXi &amp;F, const Eigen::MatrixXi &amp;uE, const Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI)</td></tr>
<tr class="memdesc:a984c604c49a10f557933850d8c8e2a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine "edge flaps": two faces on either side of a unique edge (assumes edge-manifold mesh)  <br /></td></tr>
<tr class="separator:a984c604c49a10f557933850d8c8e2a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00745ad61704fb8a6dc941ebf003f628" id="r_a00745ad61704fb8a6dc941ebf003f628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a00745ad61704fb8a6dc941ebf003f628">edge_flaps</a> (const Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;uE, Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI)</td></tr>
<tr class="memdesc:a00745ad61704fb8a6dc941ebf003f628"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a00745ad61704fb8a6dc941ebf003f628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2b3d2e2b569256e7704f81859b4d2a" id="r_a9b2b3d2e2b569256e7704f81859b4d2a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedL &gt; </td></tr>
<tr class="memitem:a9b2b3d2e2b569256e7704f81859b4d2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b2b3d2e2b569256e7704f81859b4d2a">edge_lengths</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:a9b2b3d2e2b569256e7704f81859b4d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list of lengths of edges opposite each index in a face (triangle/tet) list.  <br /></td></tr>
<tr class="separator:a9b2b3d2e2b569256e7704f81859b4d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98288ab94dfbdf3104687419fe33b704" id="r_a98288ab94dfbdf3104687419fe33b704"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedmps &gt; </td></tr>
<tr class="memitem:a98288ab94dfbdf3104687419fe33b704"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a98288ab94dfbdf3104687419fe33b704">edge_midpoints</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;oE, Eigen::PlainObjectBase&lt; Derivedmps &gt; &amp;mps)</td></tr>
<tr class="memdesc:a98288ab94dfbdf3104687419fe33b704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the midpoints of edges in a triangle mesh.  <br /></td></tr>
<tr class="separator:a98288ab94dfbdf3104687419fe33b704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182268447e88dbae647fd2971598226a" id="r_a182268447e88dbae647fd2971598226a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </td></tr>
<tr class="memitem:a182268447e88dbae647fd2971598226a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a182268447e88dbae647fd2971598226a">edge_topology</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;EV, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;FE, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;EF)</td></tr>
<tr class="memdesc:a182268447e88dbae647fd2971598226a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Edges and their topological relations (assumes an edge-manifold mesh).  <br /></td></tr>
<tr class="separator:a182268447e88dbae647fd2971598226a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb415384505882dfd1de98f678d214a2" id="r_aeb415384505882dfd1de98f678d214a2"><td class="memTemplParams" colspan="2">template&lt;bool computePerpendicular = true, typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename DerivedvecParallel , typename DerivedvecPerpendicular &gt; </td></tr>
<tr class="memitem:aeb415384505882dfd1de98f678d214a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aeb415384505882dfd1de98f678d214a2">edge_vectors</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;oE, Eigen::PlainObjectBase&lt; DerivedvecParallel &gt; &amp;vecParallel, Eigen::PlainObjectBase&lt; DerivedvecPerpendicular &gt; &amp;vecPerpendicular)</td></tr>
<tr class="memdesc:aeb415384505882dfd1de98f678d214a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the normalized edge vectors for edges in a triangle mesh.  <br /></td></tr>
<tr class="separator:aeb415384505882dfd1de98f678d214a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c252b86d3deff637414b045dce9d271" id="r_a7c252b86d3deff637414b045dce9d271"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedvec &gt; </td></tr>
<tr class="memitem:a7c252b86d3deff637414b045dce9d271"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7c252b86d3deff637414b045dce9d271">edge_vectors</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;oE, Eigen::PlainObjectBase&lt; Derivedvec &gt; &amp;vec)</td></tr>
<tr class="memdesc:a7c252b86d3deff637414b045dce9d271"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7c252b86d3deff637414b045dce9d271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efd6c6b371a55178d53cf0afacf34ee" id="r_a0efd6c6b371a55178d53cf0afacf34ee"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE &gt; </td></tr>
<tr class="memitem:a0efd6c6b371a55178d53cf0afacf34ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee">edges</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:a0efd6c6b371a55178d53cf0afacf34ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list of unique edges represented in a given mesh (V,F)  <br /></td></tr>
<tr class="separator:a0efd6c6b371a55178d53cf0afacf34ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ad8afcbeffbd52acd213150ef184cc" id="r_aa0ad8afcbeffbd52acd213150ef184cc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedI , typename DerivedC , typename DerivedE &gt; </td></tr>
<tr class="memitem:aa0ad8afcbeffbd52acd213150ef184cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa0ad8afcbeffbd52acd213150ef184cc">edges</a> (const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:aa0ad8afcbeffbd52acd213150ef184cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list of unique edges represented in a given polygon mesh.  <br /></td></tr>
<tr class="separator:aa0ad8afcbeffbd52acd213150ef184cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93abf38f4293f5e3010211137c9a6ea4" id="r_a93abf38f4293f5e3010211137c9a6ea4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedE &gt; </td></tr>
<tr class="memitem:a93abf38f4293f5e3010211137c9a6ea4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a93abf38f4293f5e3010211137c9a6ea4">edges</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:a93abf38f4293f5e3010211137c9a6ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list of unique edges represented in a given adjacency matrix.  <br /></td></tr>
<tr class="separator:a93abf38f4293f5e3010211137c9a6ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa1bf0ca6473ee9234b38b59c90e800" id="r_acfa1bf0ca6473ee9234b38b59c90e800"><td class="memTemplParams" colspan="2">template&lt;typename DerivedE , typename DerivedI , typename DerivedJ , typename DerivedK &gt; </td></tr>
<tr class="memitem:acfa1bf0ca6473ee9234b38b59c90e800"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acfa1bf0ca6473ee9234b38b59c90e800">edges_to_path</a> (const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:acfa1bf0ca6473ee9234b38b59c90e800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of undirected, unique edges such that all form a single connected compoent with exactly 0 or 2 nodes with valence =1, determine the/a path visiting all nodes.  <br /></td></tr>
<tr class="separator:acfa1bf0ca6473ee9234b38b59c90e800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bf75e3dc429d5ca9d830c137ac1b1f" id="r_a77bf75e3dc429d5ca9d830c137ac1b1f"><td class="memTemplParams" colspan="2">template&lt;typename Atype , typename Btype , typename DerivedU , typename DerivedS &gt; </td></tr>
<tr class="memitem:a77bf75e3dc429d5ca9d830c137ac1b1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a77bf75e3dc429d5ca9d830c137ac1b1f">eigs</a> (const Eigen::SparseMatrix&lt; Atype &gt; &amp;A, const Eigen::SparseMatrix&lt; Btype &gt; &amp;B, const size_t k, const <a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50d">EigsType</a> type, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;sU, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;sS)</td></tr>
<tr class="memdesc:a77bf75e3dc429d5ca9d830c137ac1b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first/last k eigen pairs of the generalized eigen value problem:  <br /></td></tr>
<tr class="separator:a77bf75e3dc429d5ca9d830c137ac1b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad059c2eefaa87bb31a2b03a1787f133d" id="r_ad059c2eefaa87bb31a2b03a1787f133d"><td class="memTemplParams" colspan="2">template&lt;typename S_type &gt; </td></tr>
<tr class="memitem:ad059c2eefaa87bb31a2b03a1787f133d"><td class="memTemplItemLeft" align="right" valign="top">S_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad059c2eefaa87bb31a2b03a1787f133d">EPS</a> ()</td></tr>
<tr class="memdesc:ad059c2eefaa87bb31a2b03a1787f133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returning EPS for corresponding type.  <br /></td></tr>
<tr class="separator:ad059c2eefaa87bb31a2b03a1787f133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba458ce3c4cbdd9d0cbb3c83b3a255c7" id="r_aba458ce3c4cbdd9d0cbb3c83b3a255c7"><td class="memTemplParams" colspan="2">template&lt;typename S_type &gt; </td></tr>
<tr class="memitem:aba458ce3c4cbdd9d0cbb3c83b3a255c7"><td class="memTemplItemLeft" align="right" valign="top">S_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aba458ce3c4cbdd9d0cbb3c83b3a255c7">EPS_SQ</a> ()</td></tr>
<tr class="memdesc:aba458ce3c4cbdd9d0cbb3c83b3a255c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returning EPS_SQ for corresponding type.  <br /></td></tr>
<tr class="separator:aba458ce3c4cbdd9d0cbb3c83b3a255c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc53046d44a2c9f6c3c6e32cb3ae024" id="r_abfc53046d44a2c9f6c3c6e32cb3ae024"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:abfc53046d44a2c9f6c3c6e32cb3ae024"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abfc53046d44a2c9f6c3c6e32cb3ae024">EPS&lt; float &gt;</a> ()</td></tr>
<tr class="separator:abfc53046d44a2c9f6c3c6e32cb3ae024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0aed7321fc747f72cd8f680826ed8e" id="r_a8d0aed7321fc747f72cd8f680826ed8e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a8d0aed7321fc747f72cd8f680826ed8e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8d0aed7321fc747f72cd8f680826ed8e">EPS&lt; double &gt;</a> ()</td></tr>
<tr class="separator:a8d0aed7321fc747f72cd8f680826ed8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa724bd6d64eb6b639407db5b87f1ac64" id="r_aa724bd6d64eb6b639407db5b87f1ac64"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa724bd6d64eb6b639407db5b87f1ac64"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa724bd6d64eb6b639407db5b87f1ac64">EPS_SQ&lt; float &gt;</a> ()</td></tr>
<tr class="separator:aa724bd6d64eb6b639407db5b87f1ac64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39a8d172ad95e01e3171a06a3a0bac" id="r_a5e39a8d172ad95e01e3171a06a3a0bac"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a5e39a8d172ad95e01e3171a06a3a0bac"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5e39a8d172ad95e01e3171a06a3a0bac">EPS_SQ&lt; double &gt;</a> ()</td></tr>
<tr class="separator:a5e39a8d172ad95e01e3171a06a3a0bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bda900bb61246ae8c8ec80881cf14c1" id="r_a4bda900bb61246ae8c8ec80881cf14c1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:a4bda900bb61246ae8c8ec80881cf14c1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4bda900bb61246ae8c8ec80881cf14c1">euler_characteristic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a4bda900bb61246ae8c8ec80881cf14c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Euler characteristic of a given mesh (V,F)  <br /></td></tr>
<tr class="separator:a4bda900bb61246ae8c8ec80881cf14c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb59555ec8b85d9c5d492f449a24b4b" id="r_addb59555ec8b85d9c5d492f449a24b4b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVS , typename DerivedFS , typename DerivedVT , typename DerivedFT , typename DerivedD &gt; </td></tr>
<tr class="memitem:addb59555ec8b85d9c5d492f449a24b4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#addb59555ec8b85d9c5d492f449a24b4b">exact_geodesic</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedVS &gt; &amp;VS, const Eigen::MatrixBase&lt; DerivedFS &gt; &amp;FS, const Eigen::MatrixBase&lt; DerivedVT &gt; &amp;VT, const Eigen::MatrixBase&lt; DerivedFT &gt; &amp;FT, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:addb59555ec8b85d9c5d492f449a24b4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exact geodesic algorithm for triangular mesh with the implementation from <a href="https://code.google.com/archive/p/geodesic/">https://code.google.com/archive/p/geodesic/</a>, and the algorithm first described by Mitchell, Mount and Papadimitriou in 1987.  <br /></td></tr>
<tr class="separator:addb59555ec8b85d9c5d492f449a24b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb99ccd45b42797c3490bf4dfefe9d02" id="r_adb99ccd45b42797c3490bf4dfefe9d02"><td class="memTemplParams" colspan="2">template&lt;typename Printable &gt; </td></tr>
<tr class="memitem:adb99ccd45b42797c3490bf4dfefe9d02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adb99ccd45b42797c3490bf4dfefe9d02">example_fun</a> (const Printable &amp;input)</td></tr>
<tr class="memdesc:adb99ccd45b42797c3490bf4dfefe9d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an example of a function, it takes a templated parameter and shovels it into cout.  <br /></td></tr>
<tr class="separator:adb99ccd45b42797c3490bf4dfefe9d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad617638bca753edfeed7b8cdb65794ad" id="r_ad617638bca753edfeed7b8cdb65794ad"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename DerivedEV , typename DerivedEF , typename DerivedI , typename DerivedJ &gt; </td></tr>
<tr class="memitem:ad617638bca753edfeed7b8cdb65794ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad617638bca753edfeed7b8cdb65794ad">exploded_view</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, const typename DerivedV::Scalar s, const typename DerivedV::Scalar t, Eigen::PlainObjectBase&lt; DerivedEV &gt; &amp;EV, Eigen::PlainObjectBase&lt; DerivedEF &gt; &amp;EF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:ad617638bca753edfeed7b8cdb65794ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tet-mesh, create a trivial surface mesh (4 triangles per tet) with each tet scaled individually and translated outward from the mesh's centroid, creating an exploded-view visualization.  <br /></td></tr>
<tr class="separator:ad617638bca753edfeed7b8cdb65794ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53e1e0ea4e1632ee9d5b5a6411093e2" id="r_af53e1e0ea4e1632ee9d5b5a6411093e2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af53e1e0ea4e1632ee9d5b5a6411093e2">extension</a> (const std::string &amp;path)</td></tr>
<tr class="memdesc:af53e1e0ea4e1632ee9d5b5a6411093e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract file extension from path.  <br /></td></tr>
<tr class="separator:af53e1e0ea4e1632ee9d5b5a6411093e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269a81c6ea4fcbc58882d48720e1a4f5" id="r_a269a81c6ea4fcbc58882d48720e1a4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a269a81c6ea4fcbc58882d48720e1a4f5">exterior_edges</a> (const Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;E)</td></tr>
<tr class="memdesc:a269a81c6ea4fcbc58882d48720e1a4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines boundary "edges" and also edges with an odd number of occurrences where seeing edge (i,j) counts as +1 and seeing the opposite edge (j,i) counts as -1.  <br /></td></tr>
<tr class="separator:a269a81c6ea4fcbc58882d48720e1a4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47866518a950145c0151a245889b502f" id="r_a47866518a950145c0151a245889b502f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a47866518a950145c0151a245889b502f">exterior_edges</a> (const Eigen::MatrixXi &amp;F)</td></tr>
<tr class="memdesc:a47866518a950145c0151a245889b502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a47866518a950145c0151a245889b502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b637953696bc3821b0a15ebbd4b5105" id="r_a9b637953696bc3821b0a15ebbd4b5105"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedP &gt; </td></tr>
<tr class="memitem:a9b637953696bc3821b0a15ebbd4b5105"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b637953696bc3821b0a15ebbd4b5105">extract_manifold_patches</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;uEE, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a9b637953696bc3821b0a15ebbd4b5105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of maximal patches from a given mesh.  <br /></td></tr>
<tr class="separator:a9b637953696bc3821b0a15ebbd4b5105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86020caa06983927879da2393cf5095" id="r_ac86020caa06983927879da2393cf5095"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedEMAP , typename uE2EType , typename DerivedP &gt; </td></tr>
<tr class="memitem:ac86020caa06983927879da2393cf5095"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac86020caa06983927879da2393cf5095">extract_manifold_patches</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:ac86020caa06983927879da2393cf5095"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac86020caa06983927879da2393cf5095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644f27405a7cb3bf6b00a451381e8210" id="r_a644f27405a7cb3bf6b00a451381e8210"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedP &gt; </td></tr>
<tr class="memitem:a644f27405a7cb3bf6b00a451381e8210"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a644f27405a7cb3bf6b00a451381e8210">extract_manifold_patches</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a644f27405a7cb3bf6b00a451381e8210"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a644f27405a7cb3bf6b00a451381e8210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f66eca661e45dd9827bf7cae56c61ce" id="r_a4f66eca661e45dd9827bf7cae56c61ce"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedEMAP , typename uE2EType &gt; </td></tr>
<tr class="memitem:a4f66eca661e45dd9827bf7cae56c61ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4f66eca661e45dd9827bf7cae56c61ce">extract_non_manifold_edge_curves</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;curves)</td></tr>
<tr class="memdesc:a4f66eca661e45dd9827bf7cae56c61ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract non-manifold curves from a given mesh.  <br /></td></tr>
<tr class="separator:a4f66eca661e45dd9827bf7cae56c61ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7de3a366fede697c4cc178a8f36e30e" id="r_ad7de3a366fede697c4cc178a8f36e30e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename DerivedA &gt; </td></tr>
<tr class="memitem:ad7de3a366fede697c4cc178a8f36e30e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad7de3a366fede697c4cc178a8f36e30e">face_areas</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:ad7de3a366fede697c4cc178a8f36e30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list of face areas of faces opposite each index in a tet list.  <br /></td></tr>
<tr class="separator:ad7de3a366fede697c4cc178a8f36e30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7448c2f83363e1920d02fe6bcb12c5eb" id="r_a7448c2f83363e1920d02fe6bcb12c5eb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename DerivedA &gt; </td></tr>
<tr class="memitem:a7448c2f83363e1920d02fe6bcb12c5eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7448c2f83363e1920d02fe6bcb12c5eb">face_areas</a> (const Eigen::MatrixBase&lt; DerivedL &gt; &amp;L, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a7448c2f83363e1920d02fe6bcb12c5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7448c2f83363e1920d02fe6bcb12c5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c2271033be3dc067310683ec802e22" id="r_a41c2271033be3dc067310683ec802e22"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename DerivedA &gt; </td></tr>
<tr class="memitem:a41c2271033be3dc067310683ec802e22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a41c2271033be3dc067310683ec802e22">face_areas</a> (const Eigen::MatrixBase&lt; DerivedL &gt; &amp;L, const typename DerivedL::Scalar doublearea_nan_replacement, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a41c2271033be3dc067310683ec802e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a41c2271033be3dc067310683ec802e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4885ed7913bafcb653dade6c257a29e" id="r_aa4885ed7913bafcb653dade6c257a29e"><td class="memTemplParams" colspan="2">template&lt;typename IntegerF , typename IntegerC &gt; </td></tr>
<tr class="memitem:aa4885ed7913bafcb653dade6c257a29e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa4885ed7913bafcb653dade6c257a29e">face_occurrences</a> (const std::vector&lt; std::vector&lt; IntegerF &gt; &gt; &amp;F, std::vector&lt; IntegerC &gt; &amp;C)</td></tr>
<tr class="memdesc:aa4885ed7913bafcb653dade6c257a29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the occurances of each face (row) in a list of face indices (irrespecitive of order)  <br /></td></tr>
<tr class="separator:aa4885ed7913bafcb653dade6c257a29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c8ab57f00492797e93f9da9cf3c63e" id="r_a02c8ab57f00492797e93f9da9cf3c63e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a02c8ab57f00492797e93f9da9cf3c63e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a02c8ab57f00492797e93f9da9cf3c63e">face_occurrences</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a02c8ab57f00492797e93f9da9cf3c63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a02c8ab57f00492797e93f9da9cf3c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7aa77ffc481c82074bcdd0ae765c090" id="r_af7aa77ffc481c82074bcdd0ae765c090"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF , typename VecI &gt; </td></tr>
<tr class="memitem:af7aa77ffc481c82074bcdd0ae765c090"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af7aa77ffc481c82074bcdd0ae765c090">faces_first</a> (const MatV &amp;V, const MatF &amp;F, MatV &amp;RV, MatF &amp;RF, VecI &amp;IM)</td></tr>
<tr class="memdesc:af7aa77ffc481c82074bcdd0ae765c090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder vertices so that vertices in face list come before vertices that don't appear in the face list.  <br /></td></tr>
<tr class="separator:af7aa77ffc481c82074bcdd0ae765c090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e44af09a10d6457aa439a6afbb3a6b2" id="r_a9e44af09a10d6457aa439a6afbb3a6b2"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF , typename VecI &gt; </td></tr>
<tr class="memitem:a9e44af09a10d6457aa439a6afbb3a6b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9e44af09a10d6457aa439a6afbb3a6b2">faces_first</a> (MatV &amp;V, MatF &amp;F, VecI &amp;IM)</td></tr>
<tr class="memdesc:a9e44af09a10d6457aa439a6afbb3a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9e44af09a10d6457aa439a6afbb3a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c84999e29d9e168fe33b0ca7f2b199" id="r_ab3c84999e29d9e168fe33b0ca7f2b199"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Atype &gt; </td></tr>
<tr class="memitem:ab3c84999e29d9e168fe33b0ca7f2b199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab3c84999e29d9e168fe33b0ca7f2b199">facet_adjacency_matrix</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Atype &gt; &amp;A)</td></tr>
<tr class="memdesc:ab3c84999e29d9e168fe33b0ca7f2b199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a #F×#F adjacency matrix with A(i,j)&gt;0 indicating that faces i and j share an edge.  <br /></td></tr>
<tr class="separator:ab3c84999e29d9e168fe33b0ca7f2b199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7823f08d518cb237ee3cb47bb03cdb6d" id="r_a7823f08d518cb237ee3cb47bb03cdb6d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a7823f08d518cb237ee3cb47bb03cdb6d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7823f08d518cb237ee3cb47bb03cdb6d">facet_components</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a7823f08d518cb237ee3cb47bb03cdb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of facets based on edge-edge adjacency.  <br /></td></tr>
<tr class="separator:a7823f08d518cb237ee3cb47bb03cdb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0320b3e4f5075ce62360f96080b57a92" id="r_a0320b3e4f5075ce62360f96080b57a92"><td class="memTemplParams" colspan="2">template&lt;typename TTIndex , typename DerivedC , typename Derivedcounts &gt; </td></tr>
<tr class="memitem:a0320b3e4f5075ce62360f96080b57a92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0320b3e4f5075ce62360f96080b57a92">facet_components</a> (const std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;TT, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; Derivedcounts &gt; &amp;counts)</td></tr>
<tr class="memdesc:a0320b3e4f5075ce62360f96080b57a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0320b3e4f5075ce62360f96080b57a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772265419ff3f9f3c3716644191fa4ff" id="r_a772265419ff3f9f3c3716644191fa4ff"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a772265419ff3f9f3c3716644191fa4ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a772265419ff3f9f3c3716644191fa4ff">false_barycentric_subdivision</a> (const Eigen::PlainObjectBase&lt; Scalar &gt; &amp;V, const Eigen::PlainObjectBase&lt; Index &gt; &amp;F, Eigen::PlainObjectBase&lt; Scalar &gt; &amp;VD, Eigen::PlainObjectBase&lt; Index &gt; &amp;FD)</td></tr>
<tr class="memdesc:a772265419ff3f9f3c3716644191fa4ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine the mesh by adding the barycenter of each face.  <br /></td></tr>
<tr class="separator:a772265419ff3f9f3c3716644191fa4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b7f81580d0eb77cfa387adaa4e9c67" id="r_a30b7f81580d0eb77cfa387adaa4e9c67"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV1 , typename DerivedF1 , typename DerivedV2 , typename DerivedF2 , typename DerivedI , typename DerivedE &gt; </td></tr>
<tr class="memitem:a30b7f81580d0eb77cfa387adaa4e9c67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a30b7f81580d0eb77cfa387adaa4e9c67">fast_find_intersections</a> (const Eigen::MatrixBase&lt; DerivedV1 &gt; &amp;V1, const Eigen::MatrixBase&lt; DerivedF1 &gt; &amp;F1, const Eigen::MatrixBase&lt; DerivedV2 &gt; &amp;V2, const Eigen::MatrixBase&lt; DerivedF2 &gt; &amp;F2, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;intersect_pairs, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;<a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee">edges</a>)</td></tr>
<tr class="memdesc:a30b7f81580d0eb77cfa387adaa4e9c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify triangles where two meshes interesect using AABBTree and tri_tri_intersection_test_3d.  <br /></td></tr>
<tr class="separator:a30b7f81580d0eb77cfa387adaa4e9c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768af49174bc1daafe45f9eedda6eb8f" id="r_a768af49174bc1daafe45f9eedda6eb8f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV1 , typename DerivedF1 , typename DerivedV2 , typename DerivedF2 , typename DerivedI , typename DerivedE &gt; </td></tr>
<tr class="memitem:a768af49174bc1daafe45f9eedda6eb8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a768af49174bc1daafe45f9eedda6eb8f">fast_find_intersections</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV1, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV1 &gt; &amp;V1, const Eigen::MatrixBase&lt; DerivedF1 &gt; &amp;F1, const Eigen::MatrixBase&lt; DerivedV2 &gt; &amp;V2, const Eigen::MatrixBase&lt; DerivedF2 &gt; &amp;F2, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;intersect_pairs, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;<a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee">edges</a>)</td></tr>
<tr class="memdesc:a768af49174bc1daafe45f9eedda6eb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a768af49174bc1daafe45f9eedda6eb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1a7f1d5201633025a2ac99846b1b78" id="r_a2f1a7f1d5201633025a2ac99846b1b78"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedE &gt; </td></tr>
<tr class="memitem:a2f1a7f1d5201633025a2ac99846b1b78"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2f1a7f1d5201633025a2ac99846b1b78">fast_find_self_intersections</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;<a class="el" href="namespaceigl.html#a4f72acbb659a5c1d291a4cff36910a87">intersect</a>, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;<a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee">edges</a>)</td></tr>
<tr class="memdesc:a2f1a7f1d5201633025a2ac99846b1b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify triangles where mesh intersects itself using AABBTree and tri_tri_intersection_test_3d.  <br /></td></tr>
<tr class="separator:a2f1a7f1d5201633025a2ac99846b1b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa607a0b8a29847a27f3e92685a652d51" id="r_aa607a0b8a29847a27f3e92685a652d51"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </td></tr>
<tr class="memitem:aa607a0b8a29847a27f3e92685a652d51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa607a0b8a29847a27f3e92685a652d51">fast_find_self_intersections</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;<a class="el" href="namespaceigl.html#a4f72acbb659a5c1d291a4cff36910a87">intersect</a>)</td></tr>
<tr class="memdesc:aa607a0b8a29847a27f3e92685a652d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa607a0b8a29847a27f3e92685a652d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a50987fefc0df065fb3e2cde90c92e" id="r_af9a50987fefc0df065fb3e2cde90c92e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename DerivedCH , typename DerivedCM , typename DerivedR , typename DerivedEC &gt; </td></tr>
<tr class="memitem:af9a50987fefc0df065fb3e2cde90c92e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af9a50987fefc0df065fb3e2cde90c92e">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;point_indices, const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;CH, const int expansion_order, Eigen::PlainObjectBase&lt; DerivedCM &gt; &amp;CM, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedEC &gt; &amp;EC)</td></tr>
<tr class="memdesc:af9a50987fefc0df065fb3e2cde90c92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the precomputation for the fast winding number for point data [Barill et.  <br /></td></tr>
<tr class="separator:af9a50987fefc0df065fb3e2cde90c92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f25aa098c2a53832cc8d86022bf0691" id="r_a9f25aa098c2a53832cc8d86022bf0691"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename DerivedCH , typename DerivedCM , typename DerivedR , typename DerivedEC , typename DerivedQ , typename BetaType , typename DerivedWN &gt; </td></tr>
<tr class="memitem:a9f25aa098c2a53832cc8d86022bf0691"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9f25aa098c2a53832cc8d86022bf0691">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;point_indices, const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;CH, const Eigen::MatrixBase&lt; DerivedCM &gt; &amp;CM, const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedEC &gt; &amp;EC, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, const BetaType beta, Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;WN)</td></tr>
<tr class="memdesc:a9f25aa098c2a53832cc8d86022bf0691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the fast winding number for point data, having already done the the precomputation.  <br /></td></tr>
<tr class="separator:a9f25aa098c2a53832cc8d86022bf0691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397e83be466a676e5e932eb176222024" id="r_a397e83be466a676e5e932eb176222024"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename BetaType , typename DerivedWN &gt; </td></tr>
<tr class="memitem:a397e83be466a676e5e932eb176222024"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a397e83be466a676e5e932eb176222024">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, const int expansion_order, const BetaType beta, Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;WN)</td></tr>
<tr class="memdesc:a397e83be466a676e5e932eb176222024"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a397e83be466a676e5e932eb176222024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8da00864c2893af6726906818520d94" id="r_ad8da00864c2893af6726906818520d94"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename DerivedWN &gt; </td></tr>
<tr class="memitem:ad8da00864c2893af6726906818520d94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad8da00864c2893af6726906818520d94">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;WN)</td></tr>
<tr class="memdesc:ad8da00864c2893af6726906818520d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad8da00864c2893af6726906818520d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c8f607d6379a200ca2b06d48a177c7" id="r_ab8c8f607d6379a200ca2b06d48a177c7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedQ , typename DerivedW &gt; </td></tr>
<tr class="memitem:ab8c8f607d6379a200ca2b06d48a177c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab8c8f607d6379a200ca2b06d48a177c7">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:ab8c8f607d6379a200ca2b06d48a177c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute approximate winding number of a triangle soup mesh according to "Fast Winding Numbers for Soups and Clouds" [Barill et al.  <br /></td></tr>
<tr class="separator:ab8c8f607d6379a200ca2b06d48a177c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903c781c6e83ef8f7cf2f8791a603cff" id="r_a903c781c6e83ef8f7cf2f8791a603cff"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a903c781c6e83ef8f7cf2f8791a603cff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a903c781c6e83ef8f7cf2f8791a603cff">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int order, FastWindingNumberBVH &amp;fwn_bvh)</td></tr>
<tr class="memdesc:a903c781c6e83ef8f7cf2f8791a603cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precomputation for computing approximate winding numbers of a triangle soup.  <br /></td></tr>
<tr class="separator:a903c781c6e83ef8f7cf2f8791a603cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cd97bb9dcfdb31036cb2d61a8feec7" id="r_a82cd97bb9dcfdb31036cb2d61a8feec7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedW &gt; </td></tr>
<tr class="memitem:a82cd97bb9dcfdb31036cb2d61a8feec7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a82cd97bb9dcfdb31036cb2d61a8feec7">fast_winding_number</a> (const FastWindingNumberBVH &amp;fwn_bvh, const float accuracy_scale, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a82cd97bb9dcfdb31036cb2d61a8feec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">After precomputation, compute winding number at a each of many points in a list.  <br /></td></tr>
<tr class="separator:a82cd97bb9dcfdb31036cb2d61a8feec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3142103ed9b3cdf64d5a81fbaa34dc4c" id="r_a3142103ed9b3cdf64d5a81fbaa34dc4c"><td class="memTemplParams" colspan="2">template&lt;typename Derivedp &gt; </td></tr>
<tr class="memitem:a3142103ed9b3cdf64d5a81fbaa34dc4c"><td class="memTemplItemLeft" align="right" valign="top">Derivedp::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3142103ed9b3cdf64d5a81fbaa34dc4c">fast_winding_number</a> (const FastWindingNumberBVH &amp;fwn_bvh, const float accuracy_scale, const Eigen::MatrixBase&lt; Derivedp &gt; &amp;p)</td></tr>
<tr class="memdesc:a3142103ed9b3cdf64d5a81fbaa34dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">After precomputation, compute winding number at a single point.  <br /></td></tr>
<tr class="separator:a3142103ed9b3cdf64d5a81fbaa34dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740022c998c2a894e28fb49bb7ed4d24" id="r_a740022c998c2a894e28fb49bb7ed4d24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a740022c998c2a894e28fb49bb7ed4d24">file_contents_as_string</a> (const std::string file_name, std::string &amp;content)</td></tr>
<tr class="memdesc:a740022c998c2a894e28fb49bb7ed4d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a files contents as plain text into a given string.  <br /></td></tr>
<tr class="separator:a740022c998c2a894e28fb49bb7ed4d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555b9d7f83d39b3fc2dee6eabb79c0ec" id="r_a555b9d7f83d39b3fc2dee6eabb79c0ec"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a555b9d7f83d39b3fc2dee6eabb79c0ec">file_contents_as_string</a> (const std::string file_name)</td></tr>
<tr class="memdesc:a555b9d7f83d39b3fc2dee6eabb79c0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a555b9d7f83d39b3fc2dee6eabb79c0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784c417892e831c40ced7805b23be275" id="r_a784c417892e831c40ced7805b23be275"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a784c417892e831c40ced7805b23be275">file_dialog_open</a> ()</td></tr>
<tr class="memdesc:a784c417892e831c40ced7805b23be275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file dialog to select a file.  <br /></td></tr>
<tr class="separator:a784c417892e831c40ced7805b23be275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f585cff929022ed45d00faee99eea3" id="r_a85f585cff929022ed45d00faee99eea3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a85f585cff929022ed45d00faee99eea3">file_dialog_save</a> ()</td></tr>
<tr class="memdesc:a85f585cff929022ed45d00faee99eea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file dialog to select a file.  <br /></td></tr>
<tr class="separator:a85f585cff929022ed45d00faee99eea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e14036599fdc6d4f6706d26a542e92" id="r_a63e14036599fdc6d4f6706d26a542e92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a63e14036599fdc6d4f6706d26a542e92">file_exists</a> (const std::string filename)</td></tr>
<tr class="memdesc:a63e14036599fdc6d4f6706d26a542e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file or directory exists like PHP's file_exists function:  <br /></td></tr>
<tr class="separator:a63e14036599fdc6d4f6706d26a542e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ba264f987871035fb7d12de96fccab" id="r_ad0ba264f987871035fb7d12de96fccab"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedI , typename DerivedJ , typename DerivedV &gt; </td></tr>
<tr class="memitem:ad0ba264f987871035fb7d12de96fccab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad0ba264f987871035fb7d12de96fccab">find</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;X, Eigen::DenseBase&lt; DerivedI &gt; &amp;I, Eigen::DenseBase&lt; DerivedJ &gt; &amp;J, Eigen::DenseBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:ad0ba264f987871035fb7d12de96fccab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the non-zero entries and there respective indices in a sparse matrix.  <br /></td></tr>
<tr class="separator:ad0ba264f987871035fb7d12de96fccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed5d2d6c493023192c2b2f1c5ed0bf0" id="r_a7ed5d2d6c493023192c2b2f1c5ed0bf0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ed5d2d6c493023192c2b2f1c5ed0bf0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Triplet&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7ed5d2d6c493023192c2b2f1c5ed0bf0">find</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:a7ed5d2d6c493023192c2b2f1c5ed0bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7ed5d2d6c493023192c2b2f1c5ed0bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6c699f94449b23813f0d80df36db8e" id="r_a2f6c699f94449b23813f0d80df36db8e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedI , typename DerivedJ , typename DerivedV &gt; </td></tr>
<tr class="memitem:a2f6c699f94449b23813f0d80df36db8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2f6c699f94449b23813f0d80df36db8e">find</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:a2f6c699f94449b23813f0d80df36db8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2f6c699f94449b23813f0d80df36db8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c874cf1ad179744026898ded3da4ea7" id="r_a1c874cf1ad179744026898ded3da4ea7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedI &gt; </td></tr>
<tr class="memitem:a1c874cf1ad179744026898ded3da4ea7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1c874cf1ad179744026898ded3da4ea7">find</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a1c874cf1ad179744026898ded3da4ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1c874cf1ad179744026898ded3da4ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6758ca13380f9bd099c860aba705d45" id="r_ab6758ca13380f9bd099c860aba705d45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6758ca13380f9bd099c860aba705d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab6758ca13380f9bd099c860aba705d45">find</a> (const Eigen::SparseVector&lt; T &gt; &amp;X, Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;I, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;V)</td></tr>
<tr class="memdesc:ab6758ca13380f9bd099c860aba705d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab6758ca13380f9bd099c860aba705d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cd54b6c6bf02c39e4caf02782fcfbc" id="r_a35cd54b6c6bf02c39e4caf02782fcfbc"><td class="memTemplParams" colspan="2">template&lt;int RowsAtCompileTime, int MaxRowsAtCompileTime&gt; </td></tr>
<tr class="memitem:a35cd54b6c6bf02c39e4caf02782fcfbc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a35cd54b6c6bf02c39e4caf02782fcfbc">find</a> (const Eigen::Array&lt; bool, RowsAtCompileTime, 1, 0, MaxRowsAtCompileTime, 1 &gt; &amp;M)</td></tr>
<tr class="memdesc:a35cd54b6c6bf02c39e4caf02782fcfbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a35cd54b6c6bf02c39e4caf02782fcfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0edb6d4f1aed375b757bdc5c273246" id="r_abb0edb6d4f1aed375b757bdc5c273246"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO &gt; </td></tr>
<tr class="memitem:abb0edb6d4f1aed375b757bdc5c273246"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abb0edb6d4f1aed375b757bdc5c273246">find_cross_field_singularities</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;mismatch, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;isSingularity, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;singularityIndex)</td></tr>
<tr class="memdesc:abb0edb6d4f1aed375b757bdc5c273246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes singularities of a cross field, assumed combed.  <br /></td></tr>
<tr class="separator:abb0edb6d4f1aed375b757bdc5c273246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6081a94201c4aee0d64d44fb108b82b3" id="r_a6081a94201c4aee0d64d44fb108b82b3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedO &gt; </td></tr>
<tr class="memitem:a6081a94201c4aee0d64d44fb108b82b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6081a94201c4aee0d64d44fb108b82b3">find_cross_field_singularities</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD1, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;PD2, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;isSingularity, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;singularityIndex, bool isCombed=false)</td></tr>
<tr class="memdesc:a6081a94201c4aee0d64d44fb108b82b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6081a94201c4aee0d64d44fb108b82b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805390aaedf0c7993e52697b46e85be8" id="r_a805390aaedf0c7993e52697b46e85be8"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedI &gt; </td></tr>
<tr class="memitem:a805390aaedf0c7993e52697b46e85be8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a805390aaedf0c7993e52697b46e85be8">find_zero</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a805390aaedf0c7993e52697b46e85be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first zero (whether implicit or explicitly stored) in the rows/columns of a matrix.  <br /></td></tr>
<tr class="separator:a805390aaedf0c7993e52697b46e85be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e61e6506e142c21944010806e350df3" id="r_a7e61e6506e142c21944010806e350df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7e61e6506e142c21944010806e350df3">fit_cubic_bezier</a> (const Eigen::MatrixXd &amp;d, const double error, std::vector&lt; Eigen::MatrixXd &gt; &amp;cubics)</td></tr>
<tr class="memdesc:a7e61e6506e142c21944010806e350df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a cubic bezier spline (G1 continuous) to an ordered list of input points in any dimension, according to "An algorithm for automatically
fitting digitized curves" [Schneider 1990].  <br /></td></tr>
<tr class="separator:a7e61e6506e142c21944010806e350df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fbe8999a386dbd7193683db1ed7ea7" id="r_a30fbe8999a386dbd7193683db1ed7ea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a30fbe8999a386dbd7193683db1ed7ea7">fit_cubic_bezier_substring</a> (const Eigen::MatrixXd &amp;d, const int first, const int last, const Eigen::RowVectorXd &amp;tHat1, const Eigen::RowVectorXd &amp;tHat2, const double error, const bool force_split, std::vector&lt; Eigen::MatrixXd &gt; &amp;cubics)</td></tr>
<tr class="memdesc:a30fbe8999a386dbd7193683db1ed7ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive helper function for fit_cubic_bezier.  <br /></td></tr>
<tr class="separator:a30fbe8999a386dbd7193683db1ed7ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7e5fc6b5fac0540a715a429d1196da" id="r_ade7e5fc6b5fac0540a715a429d1196da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ade7e5fc6b5fac0540a715a429d1196da">fit_plane</a> (const Eigen::MatrixXd &amp;V, Eigen::RowVector3d &amp;N, Eigen::RowVector3d &amp;C)</td></tr>
<tr class="memdesc:ade7e5fc6b5fac0540a715a429d1196da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fit a plane to a point cloud.  <br /></td></tr>
<tr class="separator:ade7e5fc6b5fac0540a715a429d1196da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9cbb962b540c16acdca0c7d168345d" id="r_aab9cbb962b540c16acdca0c7d168345d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedD &gt; </td></tr>
<tr class="memitem:aab9cbb962b540c16acdca0c7d168345d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aab9cbb962b540c16acdca0c7d168345d">fit_rotations</a> (const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, const bool single_precision, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;R)</td></tr>
<tr class="memdesc:aab9cbb962b540c16acdca0c7d168345d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input mesh and new positions find rotations for every covariance matrix in a stack of covariance matrices.  <br /></td></tr>
<tr class="separator:aab9cbb962b540c16acdca0c7d168345d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84591b34ac42f8f958c015edabec2d6" id="r_ac84591b34ac42f8f958c015edabec2d6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedD &gt; </td></tr>
<tr class="memitem:ac84591b34ac42f8f958c015edabec2d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac84591b34ac42f8f958c015edabec2d6">fit_rotations_planar</a> (const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;R)</td></tr>
<tr class="memdesc:ac84591b34ac42f8f958c015edabec2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an input mesh and new positions find 2D rotations for every vertex that best maps its one ring to the new one ring.  <br /></td></tr>
<tr class="separator:ac84591b34ac42f8f958c015edabec2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63ab7ae87908c83fc544443d41b87e5" id="r_ae63ab7ae87908c83fc544443d41b87e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae63ab7ae87908c83fc544443d41b87e5">flip_avoiding_line_search</a> (const Eigen::MatrixXi &amp;F, Eigen::MatrixXd &amp;cur_v, const Eigen::MatrixXd &amp;dst_v, std::function&lt; double(Eigen::MatrixXd &amp;)&gt; &amp;energy, double cur_energy=-1)</td></tr>
<tr class="memdesc:ae63ab7ae87908c83fc544443d41b87e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bisection line search for a mesh based energy that avoids triangle flips as suggested in "Bijective Parameterization with Free Boundaries" (Smith J.  <br /></td></tr>
<tr class="separator:ae63ab7ae87908c83fc544443d41b87e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac891db77f570329431e6c333c3d08b26" id="r_ac891db77f570329431e6c333c3d08b26"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2EType &gt; </td></tr>
<tr class="memitem:ac891db77f570329431e6c333c3d08b26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac891db77f570329431e6c333c3d08b26">flip_edge</a> (Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, const size_t uei)</td></tr>
<tr class="memdesc:ac891db77f570329431e6c333c3d08b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip an edge in a triangle mesh.  <br /></td></tr>
<tr class="separator:ac891db77f570329431e6c333c3d08b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82175bae9b6801c8c9012785317f2a" id="r_a6f82175bae9b6801c8c9012785317f2a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedX &gt; </td></tr>
<tr class="memitem:a6f82175bae9b6801c8c9012785317f2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6f82175bae9b6801c8c9012785317f2a">flipped_triangles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X)</td></tr>
<tr class="memdesc:a6f82175bae9b6801c8c9012785317f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the ids of the flipped triangles of the mesh V,F in the UV mapping uv.  <br /></td></tr>
<tr class="separator:a6f82175bae9b6801c8c9012785317f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a1df627820c7b21a02a7ec429af4e7" id="r_a20a1df627820c7b21a02a7ec429af4e7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a20a1df627820c7b21a02a7ec429af4e7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a20a1df627820c7b21a02a7ec429af4e7">flipped_triangles</a> (const Eigen::MatrixBase&lt; Scalar &gt; &amp;V, const Eigen::MatrixBase&lt; Index &gt; &amp;F)</td></tr>
<tr class="memdesc:a20a1df627820c7b21a02a7ec429af4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a20a1df627820c7b21a02a7ec429af4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac512b1b084fa118f737ffc49db7a5ba6" id="r_ac512b1b084fa118f737ffc49db7a5ba6"><td class="memTemplParams" colspan="2">template&lt;typename Derivedres , typename DerivedS &gt; </td></tr>
<tr class="memitem:ac512b1b084fa118f737ffc49db7a5ba6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac512b1b084fa118f737ffc49db7a5ba6">flood_fill</a> (const Eigen::MatrixBase&lt; Derivedres &gt; &amp;res, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:ac512b1b084fa118f737ffc49db7a5ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 3D array with sparse non-nan (number?) data fill in the NaNs via flood fill.  <br /></td></tr>
<tr class="separator:ac512b1b084fa118f737ffc49db7a5ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b113177cc099be08ae55cad66b4dcb" id="r_a52b113177cc099be08ae55cad66b4dcb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a52b113177cc099be08ae55cad66b4dcb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a52b113177cc099be08ae55cad66b4dcb">floor</a> (const Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a52b113177cc099be08ae55cad66b4dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Floor a given matrix to nearest integers.  <br /></td></tr>
<tr class="separator:a52b113177cc099be08ae55cad66b4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09311547ed4f12bee75c2631d2d19bfd" id="r_a09311547ed4f12bee75c2631d2d19bfd"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename Func &gt; </td></tr>
<tr class="memitem:a09311547ed4f12bee75c2631d2d19bfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a09311547ed4f12bee75c2631d2d19bfd">for_each</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const Func &amp;func)</td></tr>
<tr class="memdesc:a09311547ed4f12bee75c2631d2d19bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">FOR_EACH Call a given function for each non-zero (i.e., explicit value might actually be ==0) in a Sparse Matrix A <em>in order (of storage)</em>.  <br /></td></tr>
<tr class="separator:a09311547ed4f12bee75c2631d2d19bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ebd81ebaff178e507beedf87766722" id="r_a99ebd81ebaff178e507beedf87766722"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename Func &gt; </td></tr>
<tr class="memitem:a99ebd81ebaff178e507beedf87766722"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a99ebd81ebaff178e507beedf87766722">for_each</a> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, const Func &amp;func)</td></tr>
<tr class="memdesc:a99ebd81ebaff178e507beedf87766722"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a99ebd81ebaff178e507beedf87766722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583ee685a22b43577be16d088b6d3f29" id="r_a583ee685a22b43577be16d088b6d3f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a583ee685a22b43577be16d088b6d3f29">forward_kinematics</a> (const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;BE, const Eigen::VectorXi &amp;P, const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;dQ, const std::vector&lt; Eigen::Vector3d &gt; &amp;dT, std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;vQ, std::vector&lt; Eigen::Vector3d &gt; &amp;vT)</td></tr>
<tr class="memdesc:a583ee685a22b43577be16d088b6d3f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a skeleton and a set of relative bone rotations compute absolute rigid transformations for each bone.  <br /></td></tr>
<tr class="separator:a583ee685a22b43577be16d088b6d3f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4346a6b4e9b7d07955fe6ab59399e82e" id="r_a4346a6b4e9b7d07955fe6ab59399e82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4346a6b4e9b7d07955fe6ab59399e82e">forward_kinematics</a> (const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;BE, const Eigen::VectorXi &amp;P, const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;dQ, std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;vQ, std::vector&lt; Eigen::Vector3d &gt; &amp;vT)</td></tr>
<tr class="memdesc:a4346a6b4e9b7d07955fe6ab59399e82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4346a6b4e9b7d07955fe6ab59399e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be847e42a2d294cdb9014c5b04d5649" id="r_a9be847e42a2d294cdb9014c5b04d5649"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9be847e42a2d294cdb9014c5b04d5649">forward_kinematics</a> (const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;BE, const Eigen::VectorXi &amp;P, const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;dQ, const std::vector&lt; Eigen::Vector3d &gt; &amp;dT, Eigen::MatrixXd &amp;T)</td></tr>
<tr class="memdesc:a9be847e42a2d294cdb9014c5b04d5649"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9be847e42a2d294cdb9014c5b04d5649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedacc380a9c0e97fcb830413a407aee" id="r_adedacc380a9c0e97fcb830413a407aee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adedacc380a9c0e97fcb830413a407aee">forward_kinematics</a> (const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;BE, const Eigen::VectorXi &amp;P, const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;dQ, Eigen::MatrixXd &amp;T)</td></tr>
<tr class="memdesc:adedacc380a9c0e97fcb830413a407aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:adedacc380a9c0e97fcb830413a407aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da75428de04db095ad2b8c01861d9e7" id="r_a2da75428de04db095ad2b8c01861d9e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2da75428de04db095ad2b8c01861d9e7">frame_field_deformer</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXd &amp;FF1, const Eigen::MatrixXd &amp;FF2, Eigen::MatrixXd &amp;V_d, Eigen::MatrixXd &amp;FF1_d, Eigen::MatrixXd &amp;FF2_d, const int iterations=50, const double lambda=0.1, const bool perturb_initial_guess=true)</td></tr>
<tr class="memdesc:a2da75428de04db095ad2b8c01861d9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deform a mesh to transform the given per-face frame field to be as close as possible to a cross field, in the least square sense.  <br /></td></tr>
<tr class="separator:a2da75428de04db095ad2b8c01861d9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1822be03089dbefc97ae0274f7f744" id="r_a9b1822be03089dbefc97ae0274f7f744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b1822be03089dbefc97ae0274f7f744">frame_to_cross_field</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXd &amp;FF1, const Eigen::MatrixXd &amp;FF2, Eigen::MatrixXd &amp;X)</td></tr>
<tr class="memdesc:a9b1822be03089dbefc97ae0274f7f744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a frame field into its closest cross field.  <br /></td></tr>
<tr class="separator:a9b1822be03089dbefc97ae0274f7f744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2f248b52f9534c49484e76be8aa0bc" id="r_acd2f248b52f9534c49484e76be8aa0bc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP &gt; </td></tr>
<tr class="memitem:acd2f248b52f9534c49484e76be8aa0bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acd2f248b52f9534c49484e76be8aa0bc">frustum</a> (const typename DerivedP::Scalar left, const typename DerivedP::Scalar right, const typename DerivedP::Scalar bottom, const typename DerivedP::Scalar top, const typename DerivedP::Scalar nearVal, const typename DerivedP::Scalar farVal, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:acd2f248b52f9534c49484e76be8aa0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the deprecated glFrustum function.  <br /></td></tr>
<tr class="separator:acd2f248b52f9534c49484e76be8aa0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a0406b0fb32f5345361442c0e85c9" id="r_ad31a0406b0fb32f5345361442c0e85c9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </td></tr>
<tr class="memitem:ad31a0406b0fb32f5345361442c0e85c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad31a0406b0fb32f5345361442c0e85c9">gaussian_curvature</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:ad31a0406b0fb32f5345361442c0e85c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2π minus the sum of interior angles at each vertex.  <br /></td></tr>
<tr class="separator:ad31a0406b0fb32f5345361442c0e85c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d8ca74669cc6ed33b89020ee4f9b2e" id="r_a23d8ca74669cc6ed33b89020ee4f9b2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceigl.html#a60bbc303acee156af52ab587c4680502">DEFAULT_URBG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">generate_default_urbg</a> ()</td></tr>
<tr class="separator:a23d8ca74669cc6ed33b89020ee4f9b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a7a848b8b1eb296b5c8b80efc05efc" id="r_a14a7a848b8b1eb296b5c8b80efc05efc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a14a7a848b8b1eb296b5c8b80efc05efc">get_seconds</a> ()</td></tr>
<tr class="memdesc:a14a7a848b8b1eb296b5c8b80efc05efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current time in seconds.  <br /></td></tr>
<tr class="separator:a14a7a848b8b1eb296b5c8b80efc05efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc61afb5c46c76e8be9fcca2e4783d53" id="r_afc61afb5c46c76e8be9fcca2e4783d53"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:afc61afb5c46c76e8be9fcca2e4783d53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afc61afb5c46c76e8be9fcca2e4783d53">grad</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; typename DerivedV::Scalar &gt; &amp;G, bool uniform=false)</td></tr>
<tr class="memdesc:afc61afb5c46c76e8be9fcca2e4783d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient operator on a triangle mesh.  <br /></td></tr>
<tr class="separator:afc61afb5c46c76e8be9fcca2e4783d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae277a1d4cf02f1612ad3c7bb47fc93f7" id="r_ae277a1d4cf02f1612ad3c7bb47fc93f7"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedF , typename Gtype &gt; </td></tr>
<tr class="memitem:ae277a1d4cf02f1612ad3c7bb47fc93f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae277a1d4cf02f1612ad3c7bb47fc93f7">grad_intrinsic</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Gtype &gt; &amp;G)</td></tr>
<tr class="memdesc:ae277a1d4cf02f1612ad3c7bb47fc93f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an intrinsic gradient operator.  <br /></td></tr>
<tr class="separator:ae277a1d4cf02f1612ad3c7bb47fc93f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb4bab2b437369dce2059e85836bd9a" id="r_adfb4bab2b437369dce2059e85836bd9a"><td class="memTemplParams" colspan="2">template&lt;typename Derivedres , typename DerivedGV &gt; </td></tr>
<tr class="memitem:adfb4bab2b437369dce2059e85836bd9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adfb4bab2b437369dce2059e85836bd9a">grid</a> (const Eigen::MatrixBase&lt; Derivedres &gt; &amp;res, Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;GV)</td></tr>
<tr class="memdesc:adfb4bab2b437369dce2059e85836bd9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vertices of a regular grid, suitable for input to <code><a class="el" href="namespaceigl.html#a3e677970b7188cac95bc9f93181f2ed7" title="Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh ...">igl::marching_cubes</a></code>  <br /></td></tr>
<tr class="separator:adfb4bab2b437369dce2059e85836bd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a189dbba012d12c812bb7b0970b4ab9" id="r_a9a189dbba012d12c812bb7b0970b4ab9"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB , typename DerivedI &gt; </td></tr>
<tr class="memitem:a9a189dbba012d12c812bb7b0970b4ab9"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9a189dbba012d12c812bb7b0970b4ab9">grid_search</a> (const std::function&lt; Scalar(DerivedX &amp;) &gt; f, const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;LB, const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;UB, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, DerivedX &amp;X)</td></tr>
<tr class="memdesc:a9a189dbba012d12c812bb7b0970b4ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global optimization via grid search.  <br /></td></tr>
<tr class="separator:a9a189dbba012d12c812bb7b0970b4ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d530c8efa1612e1bb3aa180064451d" id="r_af3d530c8efa1612e1bb3aa180064451d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3d530c8efa1612e1bb3aa180064451d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af3d530c8efa1612e1bb3aa180064451d">group_sum_matrix</a> (const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;G, const int k, Eigen::SparseMatrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:af3d530c8efa1612e1bb3aa180064451d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a matrix A such that A*V computes the sum of vertices in each group specified by G.  <br /></td></tr>
<tr class="separator:af3d530c8efa1612e1bb3aa180064451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef361caeca0b62001b9d59df11b5c06" id="r_a3ef361caeca0b62001b9d59df11b5c06"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ef361caeca0b62001b9d59df11b5c06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3ef361caeca0b62001b9d59df11b5c06">group_sum_matrix</a> (const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;G, Eigen::SparseMatrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a3ef361caeca0b62001b9d59df11b5c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3ef361caeca0b62001b9d59df11b5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229749fb9c004cc9a77f83a4c1881adb" id="r_a229749fb9c004cc9a77f83a4c1881adb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a229749fb9c004cc9a77f83a4c1881adb">guess_extension</a> (FILE *fp, std::string &amp;guess)</td></tr>
<tr class="memdesc:a229749fb9c004cc9a77f83a4c1881adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a file pointer at the beginning of a "mesh" file, try to guess the extension of the file format it comes from.  <br /></td></tr>
<tr class="separator:a229749fb9c004cc9a77f83a4c1881adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79410fbbb723767aecc21edcc5941cb" id="r_ab79410fbbb723767aecc21edcc5941cb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab79410fbbb723767aecc21edcc5941cb">guess_extension</a> (FILE *fp)</td></tr>
<tr class="memdesc:ab79410fbbb723767aecc21edcc5941cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab79410fbbb723767aecc21edcc5941cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ade90c5c56252e2c88f4452996c50a0" id="r_a5ade90c5c56252e2c88f4452996c50a0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </td></tr>
<tr class="memitem:a5ade90c5c56252e2c88f4452996c50a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5ade90c5c56252e2c88f4452996c50a0">harmonic</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, const int k, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a5ade90c5c56252e2c88f4452996c50a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute k-harmonic weight functions "coordinates".  <br /></td></tr>
<tr class="separator:a5ade90c5c56252e2c88f4452996c50a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3baf24e87966423e7c6dac58f40c406" id="r_ac3baf24e87966423e7c6dac58f40c406"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </td></tr>
<tr class="memitem:ac3baf24e87966423e7c6dac58f40c406"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac3baf24e87966423e7c6dac58f40c406">harmonic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, const int k, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:ac3baf24e87966423e7c6dac58f40c406"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac3baf24e87966423e7c6dac58f40c406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720d55d920ca7659102fd8dd267e7936" id="r_a720d55d920ca7659102fd8dd267e7936"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename DerivedM , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </td></tr>
<tr class="memitem:a720d55d920ca7659102fd8dd267e7936"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a720d55d920ca7659102fd8dd267e7936">harmonic</a> (const Eigen::SparseCompressedBase&lt; DerivedL &gt; &amp;L, const Eigen::SparseCompressedBase&lt; DerivedM &gt; &amp;M, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, const int k, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a720d55d920ca7659102fd8dd267e7936"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Compute a harmonic map using a given Laplacian and mass matrix.  <br /></td></tr>
<tr class="separator:a720d55d920ca7659102fd8dd267e7936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba39f8e29962d636cfae080188ec1da7" id="r_aba39f8e29962d636cfae080188ec1da7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename DerivedM , typename DerivedQ &gt; </td></tr>
<tr class="memitem:aba39f8e29962d636cfae080188ec1da7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aba39f8e29962d636cfae080188ec1da7">harmonic</a> (const Eigen::SparseCompressedBase&lt; DerivedL &gt; &amp;L, const Eigen::SparseCompressedBase&lt; DerivedM &gt; &amp;M, const int k, DerivedQ &amp;Q)</td></tr>
<tr class="memdesc:aba39f8e29962d636cfae080188ec1da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the discrete k-harmonic operator (computing integrated quantities).  <br /></td></tr>
<tr class="separator:aba39f8e29962d636cfae080188ec1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdfdc1795f3cd0fbf66aeb3ca316604" id="r_accdfdc1795f3cd0fbf66aeb3ca316604"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedQ &gt; </td></tr>
<tr class="memitem:accdfdc1795f3cd0fbf66aeb3ca316604"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#accdfdc1795f3cd0fbf66aeb3ca316604">harmonic</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int k, DerivedQ &amp;Q)</td></tr>
<tr class="memdesc:accdfdc1795f3cd0fbf66aeb3ca316604"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:accdfdc1795f3cd0fbf66aeb3ca316604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073322f93d4fd2e161868d738abdfc09" id="r_a073322f93d4fd2e161868d738abdfc09"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a073322f93d4fd2e161868d738abdfc09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a073322f93d4fd2e161868d738abdfc09">harwell_boeing</a> (const Eigen::SparseMatrix&lt; Scalar &gt; &amp;A, int &amp;num_rows, std::vector&lt; Scalar &gt; &amp;V, std::vector&lt; Index &gt; &amp;R, std::vector&lt; Index &gt; &amp;C)</td></tr>
<tr class="memdesc:a073322f93d4fd2e161868d738abdfc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the matrix to Compressed sparse column (CSC or CCS) format, also known as Harwell Boeing format.  <br /></td></tr>
<tr class="separator:a073322f93d4fd2e161868d738abdfc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64901d7f496bd1cccbccceddbc091603" id="r_a64901d7f496bd1cccbccceddbc091603"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename Scalar &gt; </td></tr>
<tr class="memitem:a64901d7f496bd1cccbccceddbc091603"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a64901d7f496bd1cccbccceddbc091603">hausdorff</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;VB, const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;FB, Scalar &amp;d)</td></tr>
<tr class="memdesc:a64901d7f496bd1cccbccceddbc091603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB).  <br /></td></tr>
<tr class="separator:a64901d7f496bd1cccbccceddbc091603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de06347c75f90acb8cc0114c7249e58" id="r_a3de06347c75f90acb8cc0114c7249e58"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename Scalar &gt; </td></tr>
<tr class="memitem:a3de06347c75f90acb8cc0114c7249e58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3de06347c75f90acb8cc0114c7249e58">hausdorff</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const std::function&lt; Scalar(const Scalar &amp;, const Scalar &amp;, const Scalar &amp;)&gt; &amp;dist_to_B, Scalar &amp;l, Scalar &amp;u)</td></tr>
<tr class="memdesc:a3de06347c75f90acb8cc0114c7249e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.g., mesh, triangle soup) given by a distance function handle (dist_to_B).  <br /></td></tr>
<tr class="separator:a3de06347c75f90acb8cc0114c7249e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbddd3e363a529044cd4bd848b278f4" id="r_affbddd3e363a529044cd4bd848b278f4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:affbddd3e363a529044cd4bd848b278f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#affbddd3e363a529044cd4bd848b278f4">heat_geodesics_precompute</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, <a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a>&lt; Scalar &gt; &amp;data)</td></tr>
<tr class="memdesc:affbddd3e363a529044cd4bd848b278f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precompute factorized solvers for computing a fast approximation of geodesic distances on a mesh (V,F).  <br /></td></tr>
<tr class="separator:affbddd3e363a529044cd4bd848b278f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12efa6b8fc863b52dd131d478a456802" id="r_a12efa6b8fc863b52dd131d478a456802"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:a12efa6b8fc863b52dd131d478a456802"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a12efa6b8fc863b52dd131d478a456802">heat_geodesics_precompute</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Scalar t, <a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a>&lt; Scalar &gt; &amp;data)</td></tr>
<tr class="memdesc:a12efa6b8fc863b52dd131d478a456802"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a12efa6b8fc863b52dd131d478a456802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae558cd690e05ad2e41caa655251e23c4" id="r_ae558cd690e05ad2e41caa655251e23c4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Derivedgamma , typename DerivedD &gt; </td></tr>
<tr class="memitem:ae558cd690e05ad2e41caa655251e23c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae558cd690e05ad2e41caa655251e23c4">heat_geodesics_solve</a> (const <a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a>&lt; Scalar &gt; &amp;data, const Eigen::MatrixBase&lt; Derivedgamma &gt; &amp;gamma, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:ae558cd690e05ad2e41caa655251e23c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute fast approximate geodesic distances using precomputed data from a set of selected source vertices (gamma).  <br /></td></tr>
<tr class="separator:ae558cd690e05ad2e41caa655251e23c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6dbdaae94657379ac8491942082d20" id="r_a8e6dbdaae94657379ac8491942082d20"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:a8e6dbdaae94657379ac8491942082d20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8e6dbdaae94657379ac8491942082d20">hessian</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;H)</td></tr>
<tr class="memdesc:a8e6dbdaae94657379ac8491942082d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the finite element Hessian matrix as described in <a href="https://arxiv.org/abs/1707.04348">https://arxiv.org/abs/1707.04348</a>, Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) The interior vertices are NOT set to zero yet.  <br /></td></tr>
<tr class="separator:a8e6dbdaae94657379ac8491942082d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3d292215a6020d9e70cd7cfdd29ec1" id="r_a5d3d292215a6020d9e70cd7cfdd29ec1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:a5d3d292215a6020d9e70cd7cfdd29ec1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5d3d292215a6020d9e70cd7cfdd29ec1">hessian_energy</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;Q)</td></tr>
<tr class="memdesc:a5d3d292215a6020d9e70cd7cfdd29ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the Hessian energy matrix using mixed FEM as described in <a href="https://arxiv.org/abs/1707.04348">https://arxiv.org/abs/1707.04348</a> Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson)  <br /></td></tr>
<tr class="separator:a5d3d292215a6020d9e70cd7cfdd29ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e66c7ad3404c4e5a43a2ecaf1c21819" id="r_a7e66c7ad3404c4e5a43a2ecaf1c21819"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedE , typename DerivedN , typename DerivedB &gt; </td></tr>
<tr class="memitem:a7e66c7ad3404c4e5a43a2ecaf1c21819"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7e66c7ad3404c4e5a43a2ecaf1c21819">histc</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a7e66c7ad3404c4e5a43a2ecaf1c21819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count occurrences of values in X between consecutive entries in E.  <br /></td></tr>
<tr class="separator:a7e66c7ad3404c4e5a43a2ecaf1c21819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c4ce0e45c4fc1ab9e958c93ef4437" id="r_af74c4ce0e45c4fc1ab9e958c93ef4437"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedE , typename DerivedB &gt; </td></tr>
<tr class="memitem:af74c4ce0e45c4fc1ab9e958c93ef4437"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af74c4ce0e45c4fc1ab9e958c93ef4437">histc</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:af74c4ce0e45c4fc1ab9e958c93ef4437"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af74c4ce0e45c4fc1ab9e958c93ef4437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946a214630848d43ddc7df74e00f4d57" id="r_a946a214630848d43ddc7df74e00f4d57"><td class="memTemplParams" colspan="2">template&lt;typename DerivedE &gt; </td></tr>
<tr class="memitem:a946a214630848d43ddc7df74e00f4d57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a946a214630848d43ddc7df74e00f4d57">histc</a> (const typename DerivedE::Scalar &amp;x, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, typename DerivedE::Index &amp;b)</td></tr>
<tr class="memdesc:a946a214630848d43ddc7df74e00f4d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a946a214630848d43ddc7df74e00f4d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840674ca4222700909ca8197e27800a5" id="r_a840674ca4222700909ca8197e27800a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a840674ca4222700909ca8197e27800a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a840674ca4222700909ca8197e27800a5">hsv_to_rgb</a> (const T *hsv, T *rgb)</td></tr>
<tr class="memdesc:a840674ca4222700909ca8197e27800a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert RGB to HSV.  <br /></td></tr>
<tr class="separator:a840674ca4222700909ca8197e27800a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a8efe9fd3b48830cd07fd2fb45ece6" id="r_a67a8efe9fd3b48830cd07fd2fb45ece6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a67a8efe9fd3b48830cd07fd2fb45ece6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a67a8efe9fd3b48830cd07fd2fb45ece6">hsv_to_rgb</a> (const T &amp;h, const T &amp;s, const T &amp;v, T &amp;r, T &amp;g, T &amp;b)</td></tr>
<tr class="memdesc:a67a8efe9fd3b48830cd07fd2fb45ece6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a67a8efe9fd3b48830cd07fd2fb45ece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2573040155e553e83f6b2098417ed2" id="r_a3e2573040155e553e83f6b2098417ed2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedH , typename DerivedR &gt; </td></tr>
<tr class="memitem:a3e2573040155e553e83f6b2098417ed2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3e2573040155e553e83f6b2098417ed2">hsv_to_rgb</a> (const Eigen::PlainObjectBase&lt; DerivedH &gt; &amp;H, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R)</td></tr>
<tr class="memdesc:a3e2573040155e553e83f6b2098417ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3e2573040155e553e83f6b2098417ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91986768165db4e2fe4f6541db3a100e" id="r_a91986768165db4e2fe4f6541db3a100e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a91986768165db4e2fe4f6541db3a100e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a91986768165db4e2fe4f6541db3a100e">icosahedron</a> (Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="separator:a91986768165db4e2fe4f6541db3a100e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a48ea815ed7c6fce66c5fb16643592" id="r_ae6a48ea815ed7c6fce66c5fb16643592"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedQ , int DIM&gt; </td></tr>
<tr class="memitem:ae6a48ea815ed7c6fce66c5fb16643592"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae6a48ea815ed7c6fce66c5fb16643592">in_element</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixXi &amp;Ele, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, DIM &gt; &amp;aabb, Eigen::VectorXi &amp;I)</td></tr>
<tr class="memdesc:ae6a48ea815ed7c6fce66c5fb16643592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether each point in a list of points is in the elements of a mesh.  <br /></td></tr>
<tr class="separator:ae6a48ea815ed7c6fce66c5fb16643592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc28747ccc281b8790d1ec2a07daf42" id="r_a1cc28747ccc281b8790d1ec2a07daf42"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedQ , int DIM, typename Scalar &gt; </td></tr>
<tr class="memitem:a1cc28747ccc281b8790d1ec2a07daf42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1cc28747ccc281b8790d1ec2a07daf42">in_element</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixXi &amp;Ele, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, DIM &gt; &amp;aabb, Eigen::SparseMatrix&lt; Scalar &gt; &amp;I)</td></tr>
<tr class="memdesc:a1cc28747ccc281b8790d1ec2a07daf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1cc28747ccc281b8790d1ec2a07daf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35f10d1dc8993c19f76b5c2ba6c48e7" id="r_ac35f10d1dc8993c19f76b5c2ba6c48e7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac35f10d1dc8993c19f76b5c2ba6c48e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac35f10d1dc8993c19f76b5c2ba6c48e7">increment_ulp</a> (Eigen::MatrixBase&lt; Derived &gt; &amp;inout, int it)</td></tr>
<tr class="memdesc:ac35f10d1dc8993c19f76b5c2ba6c48e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment Unit in Last Place of a matrix.  <br /></td></tr>
<tr class="separator:ac35f10d1dc8993c19f76b5c2ba6c48e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba56449805461c9713bc29b8ebcc79" id="r_a0cba56449805461c9713bc29b8ebcc79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0cba56449805461c9713bc29b8ebcc79">infinite_cost_stopping_condition</a> (const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement, <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;stopping_condition)</td></tr>
<tr class="memdesc:a0cba56449805461c9713bc29b8ebcc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stopping condition function compatible with <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>.  <br /></td></tr>
<tr class="separator:a0cba56449805461c9713bc29b8ebcc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f95773129e4cd1a29171858e1f313b5" id="r_a6f95773129e4cd1a29171858e1f313b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6f95773129e4cd1a29171858e1f313b5">infinite_cost_stopping_condition</a> (const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;cost_and_placement)</td></tr>
<tr class="memdesc:a6f95773129e4cd1a29171858e1f313b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6f95773129e4cd1a29171858e1f313b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461e3490769bd9ac20f48a0179f58b0f" id="r_a461e3490769bd9ac20f48a0179f58b0f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedR &gt; </td></tr>
<tr class="memitem:a461e3490769bd9ac20f48a0179f58b0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a461e3490769bd9ac20f48a0179f58b0f">inradius</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R)</td></tr>
<tr class="memdesc:a461e3490769bd9ac20f48a0179f58b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inradius of each triangle in a mesh (V,F)  <br /></td></tr>
<tr class="separator:a461e3490769bd9ac20f48a0179f58b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748a89868e9e150c9d02736c6f304318" id="r_a748a89868e9e150c9d02736c6f304318"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </td></tr>
<tr class="memitem:a748a89868e9e150c9d02736c6f304318"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a748a89868e9e150c9d02736c6f304318">internal_angles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:a748a89868e9e150c9d02736c6f304318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute internal angles for a triangle mesh.  <br /></td></tr>
<tr class="separator:a748a89868e9e150c9d02736c6f304318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cf87a6db6ebff753475465b9e0a6f3" id="r_a42cf87a6db6ebff753475465b9e0a6f3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename DerivedK &gt; </td></tr>
<tr class="memitem:a42cf87a6db6ebff753475465b9e0a6f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a42cf87a6db6ebff753475465b9e0a6f3">internal_angles_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedL &gt; &amp;L_sq, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:a42cf87a6db6ebff753475465b9e0a6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute internal angles for a triangle mesh.  <br /></td></tr>
<tr class="separator:a42cf87a6db6ebff753475465b9e0a6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f72acbb659a5c1d291a4cff36910a87" id="r_a4f72acbb659a5c1d291a4cff36910a87"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a4f72acbb659a5c1d291a4cff36910a87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4f72acbb659a5c1d291a4cff36910a87">intersect</a> (const M &amp;A, const M &amp;B, M &amp;C)</td></tr>
<tr class="memdesc:a4f72acbb659a5c1d291a4cff36910a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the intersect between two sets of coefficients using ==.  <br /></td></tr>
<tr class="separator:a4f72acbb659a5c1d291a4cff36910a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a6a9d793818a4836de7c3faa524e26" id="r_a41a6a9d793818a4836de7c3faa524e26"><td class="memTemplParams" colspan="2">template&lt;class M &gt; </td></tr>
<tr class="memitem:a41a6a9d793818a4836de7c3faa524e26"><td class="memTemplItemLeft" align="right" valign="top">M&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a41a6a9d793818a4836de7c3faa524e26">intersect</a> (const M &amp;A, const M &amp;B)</td></tr>
<tr class="memdesc:a41a6a9d793818a4836de7c3faa524e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload  <br /></td></tr>
<tr class="separator:a41a6a9d793818a4836de7c3faa524e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6173f608f5bae73866cc21f0159562dc" id="r_a6173f608f5bae73866cc21f0159562dc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar , typename Derivedl_intrinsic , typename DerivedF_intrinsic &gt; </td></tr>
<tr class="memitem:a6173f608f5bae73866cc21f0159562dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6173f608f5bae73866cc21f0159562dc">intrinsic_delaunay_cotmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;L, Eigen::PlainObjectBase&lt; Derivedl_intrinsic &gt; &amp;l_intrinsic, Eigen::PlainObjectBase&lt; DerivedF_intrinsic &gt; &amp;F_intrinsic)</td></tr>
<tr class="memdesc:a6173f608f5bae73866cc21f0159562dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the discrete cotangent Laplacian of a mesh after converting it into its intrinsic Delaunay triangulation (see, e.g., [Fisher et al.  <br /></td></tr>
<tr class="separator:a6173f608f5bae73866cc21f0159562dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab774229e4511d5f186a394c39f813d2f" id="r_ab774229e4511d5f186a394c39f813d2f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:ab774229e4511d5f186a394c39f813d2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab774229e4511d5f186a394c39f813d2f">intrinsic_delaunay_cotmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;L)</td></tr>
<tr class="memdesc:ab774229e4511d5f186a394c39f813d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab774229e4511d5f186a394c39f813d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4975f69822136269d681f02b2c3279" id="r_abf4975f69822136269d681f02b2c3279"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl_in , typename DerivedF_in , typename Derivedl , typename DerivedF &gt; </td></tr>
<tr class="memitem:abf4975f69822136269d681f02b2c3279"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abf4975f69822136269d681f02b2c3279">intrinsic_delaunay_triangulation</a> (const Eigen::MatrixBase&lt; Derivedl_in &gt; &amp;l_in, const Eigen::MatrixBase&lt; DerivedF_in &gt; &amp;F_in, Eigen::PlainObjectBase&lt; Derivedl &gt; &amp;l, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:abf4975f69822136269d681f02b2c3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTRINSIC_DELAUNAY_TRIANGULATION Flip edges <em>intrinsically</em> until all are "intrinsic Delaunay".  <br /></td></tr>
<tr class="separator:abf4975f69822136269d681f02b2c3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0bd085d3b95f40fe92ef1c75f6ad32" id="r_a6c0bd085d3b95f40fe92ef1c75f6ad32"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl_in , typename DerivedF_in , typename Derivedl , typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2EType &gt; </td></tr>
<tr class="memitem:a6c0bd085d3b95f40fe92ef1c75f6ad32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6c0bd085d3b95f40fe92ef1c75f6ad32">intrinsic_delaunay_triangulation</a> (const Eigen::MatrixBase&lt; Derivedl_in &gt; &amp;l_in, const Eigen::MatrixBase&lt; DerivedF_in &gt; &amp;F_in, Eigen::PlainObjectBase&lt; Derivedl &gt; &amp;l, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E)</td></tr>
<tr class="memdesc:a6c0bd085d3b95f40fe92ef1c75f6ad32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6c0bd085d3b95f40fe92ef1c75f6ad32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc59b895f5ad4472ca15758fd947b5" id="r_ad6fc59b895f5ad4472ca15758fd947b5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename MatY &gt; </td></tr>
<tr class="memitem:ad6fc59b895f5ad4472ca15758fd947b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad6fc59b895f5ad4472ca15758fd947b5">invert_diag</a> (const Eigen::SparseCompressedBase&lt; DerivedX &gt; &amp;X, MatY &amp;Y)</td></tr>
<tr class="memdesc:ad6fc59b895f5ad4472ca15758fd947b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the diagonal entries of a matrix (if the matrix is a diagonal matrix then this amounts to inverting the matrix)  <br /></td></tr>
<tr class="separator:ad6fc59b895f5ad4472ca15758fd947b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf49f5f7e92069382f5607639d92555" id="r_addf49f5f7e92069382f5607639d92555"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:addf49f5f7e92069382f5607639d92555"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#addf49f5f7e92069382f5607639d92555">is_border_vertex</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:addf49f5f7e92069382f5607639d92555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine vertices on open boundary of a (manifold) mesh with triangle faces F.  <br /></td></tr>
<tr class="separator:addf49f5f7e92069382f5607639d92555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d02bea0e57dce707ada6bc3228d22a" id="r_a39d02bea0e57dce707ada6bc3228d22a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DerivedB &gt; </td></tr>
<tr class="memitem:a39d02bea0e57dce707ada6bc3228d22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a39d02bea0e57dce707ada6bc3228d22a">is_boundary_edge</a> (const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a39d02bea0e57dce707ada6bc3228d22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine for each edge E if it is a "boundary edge" in F.  <br /></td></tr>
<tr class="separator:a39d02bea0e57dce707ada6bc3228d22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2687ea500d0a998cf01ab3ff7456ba25" id="r_a2687ea500d0a998cf01ab3ff7456ba25"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DerivedB , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:a2687ea500d0a998cf01ab3ff7456ba25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2687ea500d0a998cf01ab3ff7456ba25">is_boundary_edge</a> (const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:a2687ea500d0a998cf01ab3ff7456ba25"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2687ea500d0a998cf01ab3ff7456ba25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8670d8afa68524c4d0e4745faa89efc7" id="r_a8670d8afa68524c4d0e4745faa89efc7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedD &gt; </td></tr>
<tr class="memitem:a8670d8afa68524c4d0e4745faa89efc7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8670d8afa68524c4d0e4745faa89efc7">is_delaunay</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:a8670d8afa68524c4d0e4745faa89efc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDetermine if each edge in the mesh (V,F) is Delaunay.  <br /></td></tr>
<tr class="separator:a8670d8afa68524c4d0e4745faa89efc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e60388b9f45015b2d555acf24b9b4e" id="r_ae3e60388b9f45015b2d555acf24b9b4e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename uE2EType , typename InCircle , typename ueiType &gt; </td></tr>
<tr class="memitem:ae3e60388b9f45015b2d555acf24b9b4e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae3e60388b9f45015b2d555acf24b9b4e">is_delaunay</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, const InCircle incircle, const ueiType uei)</td></tr>
<tr class="memdesc:ae3e60388b9f45015b2d555acf24b9b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test.  <br /></td></tr>
<tr class="separator:ae3e60388b9f45015b2d555acf24b9b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2105d7b15672349f4662a1c77ea4d5" id="r_acc2105d7b15672349f4662a1c77ea4d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acc2105d7b15672349f4662a1c77ea4d5">is_dir</a> (const char *filename)</td></tr>
<tr class="memdesc:acc2105d7b15672349f4662a1c77ea4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the given filename is a directory.  <br /></td></tr>
<tr class="separator:acc2105d7b15672349f4662a1c77ea4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab086008065bab7abde580f8bdea5d156" id="r_ab086008065bab7abde580f8bdea5d156"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:ab086008065bab7abde580f8bdea5d156"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab086008065bab7abde580f8bdea5d156">is_edge_manifold</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ab086008065bab7abde580f8bdea5d156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the mesh is edge-manifold (every edge is incident one one face (boundary) or two oppositely oriented faces).  <br /></td></tr>
<tr class="separator:ab086008065bab7abde580f8bdea5d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d04d883ce83ec8376b7eb4f22db6f03" id="r_a7d04d883ce83ec8376b7eb4f22db6f03"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedBF , typename DerivedE , typename DerivedEMAP , typename DerivedBE &gt; </td></tr>
<tr class="memitem:a7d04d883ce83ec8376b7eb4f22db6f03"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7d04d883ce83ec8376b7eb4f22db6f03">is_edge_manifold</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;BF, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, Eigen::PlainObjectBase&lt; DerivedBE &gt; &amp;BE)</td></tr>
<tr class="memdesc:a7d04d883ce83ec8376b7eb4f22db6f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if mesh is edge-manifold and outputs per-edge info.  <br /></td></tr>
<tr class="separator:a7d04d883ce83ec8376b7eb4f22db6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd5dfc80e3180cb9f8cfbeb0049c2b5" id="r_a1bd5dfc80e3180cb9f8cfbeb0049c2b5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedEMAP , typename DerivedBF , typename DerivedBE &gt; </td></tr>
<tr class="memitem:a1bd5dfc80e3180cb9f8cfbeb0049c2b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1bd5dfc80e3180cb9f8cfbeb0049c2b5">is_edge_manifold</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedF::Index ne, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;BF, Eigen::PlainObjectBase&lt; DerivedBE &gt; &amp;BE)</td></tr>
<tr class="memdesc:a1bd5dfc80e3180cb9f8cfbeb0049c2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1bd5dfc80e3180cb9f8cfbeb0049c2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d660daa58e9ec65ac1756adc4b61454" id="r_a5d660daa58e9ec65ac1756adc4b61454"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5d660daa58e9ec65ac1756adc4b61454">is_file</a> (const char *filename)</td></tr>
<tr class="memdesc:a5d660daa58e9ec65ac1756adc4b61454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells whether the given filename is a regular file.  <br /></td></tr>
<tr class="separator:a5d660daa58e9ec65ac1756adc4b61454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a946e409259bd08727637f7fd15b74" id="r_a95a946e409259bd08727637f7fd15b74"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedF , typename DerivedD &gt; </td></tr>
<tr class="memitem:a95a946e409259bd08727637f7fd15b74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a95a946e409259bd08727637f7fd15b74">is_intrinsic_delaunay</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:a95a946e409259bd08727637f7fd15b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if each edge in the mesh (V,F) is Delaunay.  <br /></td></tr>
<tr class="separator:a95a946e409259bd08727637f7fd15b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6b3f9347053522b1fc5da210be1968" id="r_ada6b3f9347053522b1fc5da210be1968"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedF , typename uE2EType , typename DerivedD &gt; </td></tr>
<tr class="memitem:ada6b3f9347053522b1fc5da210be1968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ada6b3f9347053522b1fc5da210be1968">is_intrinsic_delaunay</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:ada6b3f9347053522b1fc5da210be1968"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ada6b3f9347053522b1fc5da210be1968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63e0780a4c5344cbafb31919f77bd0a" id="r_ae63e0780a4c5344cbafb31919f77bd0a"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename uE2EType , typename Index &gt; </td></tr>
<tr class="memitem:ae63e0780a4c5344cbafb31919f77bd0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae63e0780a4c5344cbafb31919f77bd0a">is_intrinsic_delaunay</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, const Index num_faces, const Index uei)</td></tr>
<tr class="memdesc:ae63e0780a4c5344cbafb31919f77bd0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test.  <br /></td></tr>
<tr class="separator:ae63e0780a4c5344cbafb31919f77bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f076e50c33c9998c7f9c9559ed36e0" id="r_a05f076e50c33c9998c7f9c9559ed36e0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:a05f076e50c33c9998c7f9c9559ed36e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a05f076e50c33c9998c7f9c9559ed36e0">is_irregular_vertex</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a05f076e50c33c9998c7f9c9559ed36e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a vertex is irregular, i.e.  <br /></td></tr>
<tr class="separator:a05f076e50c33c9998c7f9c9559ed36e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd09a46e564a0d19ae4f97891b95de9" id="r_aedd09a46e564a0d19ae4f97891b95de9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aedd09a46e564a0d19ae4f97891b95de9">is_planar</a> (const Eigen::MatrixXd &amp;V)</td></tr>
<tr class="memdesc:aedd09a46e564a0d19ae4f97891b95de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a set of points lies on the XY plane.  <br /></td></tr>
<tr class="separator:aedd09a46e564a0d19ae4f97891b95de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036d4412fb94156420eff091457a73b3" id="r_a036d4412fb94156420eff091457a73b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a036d4412fb94156420eff091457a73b3">is_readable</a> (const char *filename)</td></tr>
<tr class="memdesc:a036d4412fb94156420eff091457a73b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file is reabable like PHP's is_readable function: <a href="http://www.php.net/manual/en/function.is-readable.php">http://www.php.net/manual/en/function.is-readable.php</a>.  <br /></td></tr>
<tr class="separator:a036d4412fb94156420eff091457a73b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7968d06fbb2bcb8b64f707ec4b29f87" id="r_ad7968d06fbb2bcb8b64f707ec4b29f87"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7968d06fbb2bcb8b64f707ec4b29f87"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad7968d06fbb2bcb8b64f707ec4b29f87">is_sparse</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ad7968d06fbb2bcb8b64f707ec4b29f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a matrix A is sparse.  <br /></td></tr>
<tr class="separator:ad7968d06fbb2bcb8b64f707ec4b29f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910c84c58fdea4379d5e0ff34588ffe6" id="r_a910c84c58fdea4379d5e0ff34588ffe6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA &gt; </td></tr>
<tr class="memitem:a910c84c58fdea4379d5e0ff34588ffe6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a910c84c58fdea4379d5e0ff34588ffe6">is_sparse</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a910c84c58fdea4379d5e0ff34588ffe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a910c84c58fdea4379d5e0ff34588ffe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f40e6e779275ad817df4c8d1ac22aa6" id="r_a1f40e6e779275ad817df4c8d1ac22aa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1f40e6e779275ad817df4c8d1ac22aa6">is_stl</a> (FILE *stl_file, bool &amp;is_ascii)</td></tr>
<tr class="memdesc:a1f40e6e779275ad817df4c8d1ac22aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a file pointer, determine if it contains an .stl file and then rewind it.  <br /></td></tr>
<tr class="separator:a1f40e6e779275ad817df4c8d1ac22aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623b66ea2a39ba8c09f3c72599272562" id="r_a623b66ea2a39ba8c09f3c72599272562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a623b66ea2a39ba8c09f3c72599272562">is_stl</a> (FILE *stl_file)</td></tr>
<tr class="separator:a623b66ea2a39ba8c09f3c72599272562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f840791a21ca650ec1d68910c3ec900" id="r_a4f840791a21ca650ec1d68910c3ec900"><td class="memTemplParams" colspan="2">template&lt;typename AT &gt; </td></tr>
<tr class="memitem:a4f840791a21ca650ec1d68910c3ec900"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4f840791a21ca650ec1d68910c3ec900">is_symmetric</a> (const Eigen::SparseMatrix&lt; AT &gt; &amp;A)</td></tr>
<tr class="memdesc:a4f840791a21ca650ec1d68910c3ec900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given matrix is symmetric.  <br /></td></tr>
<tr class="separator:a4f840791a21ca650ec1d68910c3ec900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819c37589176cb7dde8fb52796314fc3" id="r_a819c37589176cb7dde8fb52796314fc3"><td class="memTemplParams" colspan="2">template&lt;typename AT , typename epsilonT &gt; </td></tr>
<tr class="memitem:a819c37589176cb7dde8fb52796314fc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a819c37589176cb7dde8fb52796314fc3">is_symmetric</a> (const Eigen::SparseMatrix&lt; AT &gt; &amp;A, const epsilonT epsilon)</td></tr>
<tr class="memdesc:a819c37589176cb7dde8fb52796314fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a819c37589176cb7dde8fb52796314fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ac1f26b40979584dfa370cee528d71" id="r_a00ac1f26b40979584dfa370cee528d71"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA &gt; </td></tr>
<tr class="memitem:a00ac1f26b40979584dfa370cee528d71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a00ac1f26b40979584dfa370cee528d71">is_symmetric</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a00ac1f26b40979584dfa370cee528d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a00ac1f26b40979584dfa370cee528d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0dbef9a4a2738b2c33de0cb6938bfb" id="r_abd0dbef9a4a2738b2c33de0cb6938bfb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedB &gt; </td></tr>
<tr class="memitem:abd0dbef9a4a2738b2c33de0cb6938bfb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abd0dbef9a4a2738b2c33de0cb6938bfb">is_vertex_manifold</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:abd0dbef9a4a2738b2c33de0cb6938bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a mesh is vertex-manifold.  <br /></td></tr>
<tr class="separator:abd0dbef9a4a2738b2c33de0cb6938bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081c3e366717287e1be24e695b5b034e" id="r_a081c3e366717287e1be24e695b5b034e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:a081c3e366717287e1be24e695b5b034e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a081c3e366717287e1be24e695b5b034e">is_vertex_manifold</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a081c3e366717287e1be24e695b5b034e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a081c3e366717287e1be24e695b5b034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6584dca7db2b1e9f2601973c2609e6c1" id="r_a6584dca7db2b1e9f2601973c2609e6c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6584dca7db2b1e9f2601973c2609e6c1">is_writable</a> (const char *filename)</td></tr>
<tr class="memdesc:a6584dca7db2b1e9f2601973c2609e6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a file exists <em>and</em> is writable like PHP's is_writable function: <a href="http://www.php.net/manual/en/function.is-writable.php">http://www.php.net/manual/en/function.is-writable.php</a>.  <br /></td></tr>
<tr class="separator:a6584dca7db2b1e9f2601973c2609e6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fb666256b9e2c9aa5bd79cbfb5397b" id="r_a28fb666256b9e2c9aa5bd79cbfb5397b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a28fb666256b9e2c9aa5bd79cbfb5397b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a28fb666256b9e2c9aa5bd79cbfb5397b">isdiag</a> (const Eigen::SparseCompressedBase&lt; Derived &gt; &amp;A)</td></tr>
<tr class="memdesc:a28fb666256b9e2c9aa5bd79cbfb5397b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given matrix is diagonal: all non-zeros lie on the main diagonal.  <br /></td></tr>
<tr class="separator:a28fb666256b9e2c9aa5bd79cbfb5397b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1dfc725b9f364c46cc835853c4d154" id="r_a3b1dfc725b9f364c46cc835853c4d154"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedIA , typename DerivedLOCB &gt; </td></tr>
<tr class="memitem:a3b1dfc725b9f364c46cc835853c4d154"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3b1dfc725b9f364c46cc835853c4d154">ismember</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedLOCB &gt; &amp;LOCB)</td></tr>
<tr class="memdesc:a3b1dfc725b9f364c46cc835853c4d154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if elements of A exist in elements of B.  <br /></td></tr>
<tr class="separator:a3b1dfc725b9f364c46cc835853c4d154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22eecc8e676dfea634eedb0f1121ed88" id="r_a22eecc8e676dfea634eedb0f1121ed88"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedIA , typename DerivedLOCB &gt; </td></tr>
<tr class="memitem:a22eecc8e676dfea634eedb0f1121ed88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a22eecc8e676dfea634eedb0f1121ed88">ismember_rows</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedLOCB &gt; &amp;LOCB)</td></tr>
<tr class="memdesc:a22eecc8e676dfea634eedb0f1121ed88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if row of A exist in rows of B.  <br /></td></tr>
<tr class="separator:a22eecc8e676dfea634eedb0f1121ed88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e807a90c41e3a89ee0171b1518c27d" id="r_a24e807a90c41e3a89ee0171b1518c27d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediV , typename DerivediE , typename DerivedI &gt; </td></tr>
<tr class="memitem:a24e807a90c41e3a89ee0171b1518c27d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a24e807a90c41e3a89ee0171b1518c27d">isolines</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; Derivedvals &gt; &amp;vals, Eigen::PlainObjectBase&lt; DerivediV &gt; &amp;iV, Eigen::PlainObjectBase&lt; DerivediE &gt; &amp;iE, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a24e807a90c41e3a89ee0171b1518c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute isolines of a scalar field on a triangle mesh.  <br /></td></tr>
<tr class="separator:a24e807a90c41e3a89ee0171b1518c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616f5985cbb36acb190f207f9dff82df" id="r_a616f5985cbb36acb190f207f9dff82df"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediB , typename DerivediFI , typename DerivediE , typename DerivedI &gt; </td></tr>
<tr class="memitem:a616f5985cbb36acb190f207f9dff82df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a616f5985cbb36acb190f207f9dff82df">isolines_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; Derivedvals &gt; &amp;vals, Eigen::PlainObjectBase&lt; DerivediB &gt; &amp;iB, Eigen::PlainObjectBase&lt; DerivediFI &gt; &amp;iFI, Eigen::PlainObjectBase&lt; DerivediE &gt; &amp;iE, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a616f5985cbb36acb190f207f9dff82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute isolines of a scalar field on a triangle mesh intrinsically.  <br /></td></tr>
<tr class="separator:a616f5985cbb36acb190f207f9dff82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276bde6ae2e23fb1811ec18a353b15be" id="r_a276bde6ae2e23fb1811ec18a353b15be"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedS , typename DeriveduE , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivediB , typename DerivediFI , typename DerivediE &gt; </td></tr>
<tr class="memitem:a276bde6ae2e23fb1811ec18a353b15be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a276bde6ae2e23fb1811ec18a353b15be">isolines_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;uE, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;uEE, const typename DerivedS::Scalar val, Eigen::PlainObjectBase&lt; DerivediB &gt; &amp;iB, Eigen::PlainObjectBase&lt; DerivediFI &gt; &amp;iFI, Eigen::PlainObjectBase&lt; DerivediE &gt; &amp;iE)</td></tr>
<tr class="memdesc:a276bde6ae2e23fb1811ec18a353b15be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a276bde6ae2e23fb1811ec18a353b15be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac262ba447b16b5edccade00d31f39722" id="r_ac262ba447b16b5edccade00d31f39722"><td class="memTemplParams" colspan="2">template&lt;typename DerivedCM , typename Derivediso_color , typename DerivedICM &gt; </td></tr>
<tr class="memitem:ac262ba447b16b5edccade00d31f39722"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac262ba447b16b5edccade00d31f39722">isolines_map</a> (const Eigen::MatrixBase&lt; DerivedCM &gt; &amp;CM, const Eigen::MatrixBase&lt; Derivediso_color &gt; &amp;iso_color, const int interval_thickness, const int iso_thickness, Eigen::PlainObjectBase&lt; DerivedICM &gt; &amp;ICM)</td></tr>
<tr class="memdesc:ac262ba447b16b5edccade00d31f39722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inject a given colormap with evenly spaced isolines.  <br /></td></tr>
<tr class="separator:ac262ba447b16b5edccade00d31f39722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807d847189eeb2aa93fb387f81452494" id="r_a807d847189eeb2aa93fb387f81452494"><td class="memTemplParams" colspan="2">template&lt;typename DerivedCM , typename DerivedICM &gt; </td></tr>
<tr class="memitem:a807d847189eeb2aa93fb387f81452494"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a807d847189eeb2aa93fb387f81452494">isolines_map</a> (const Eigen::MatrixBase&lt; DerivedCM &gt; &amp;CM, Eigen::PlainObjectBase&lt; DerivedICM &gt; &amp;ICM)</td></tr>
<tr class="memdesc:a807d847189eeb2aa93fb387f81452494"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a807d847189eeb2aa93fb387f81452494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b2dbd6e4ee3d5ca15dd5dce9928453" id="r_aa7b2dbd6e4ee3d5ca15dd5dce9928453"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVX , typename DerivedFX , typename DerivedVY , typename DerivedFY , typename DerivedR , typename Derivedt &gt; </td></tr>
<tr class="memitem:aa7b2dbd6e4ee3d5ca15dd5dce9928453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa7b2dbd6e4ee3d5ca15dd5dce9928453">iterative_closest_point</a> (const Eigen::MatrixBase&lt; DerivedVX &gt; &amp;VX, const Eigen::MatrixBase&lt; DerivedFX &gt; &amp;FX, const Eigen::MatrixBase&lt; DerivedVY &gt; &amp;VY, const Eigen::MatrixBase&lt; DerivedFY &gt; &amp;FY, const int num_samples, const int max_iters, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;t)</td></tr>
<tr class="memdesc:aa7b2dbd6e4ee3d5ca15dd5dce9928453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve for the rigid transformation that places mesh X onto mesh Y using the iterative closest point method.  <br /></td></tr>
<tr class="separator:aa7b2dbd6e4ee3d5ca15dd5dce9928453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd54b56f1bb183ab3898eb0e78949da" id="r_a1cd54b56f1bb183ab3898eb0e78949da"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVX , typename DerivedFX , typename DerivedVY , typename DerivedFY , typename DerivedNY , typename DerivedR , typename Derivedt &gt; </td></tr>
<tr class="memitem:a1cd54b56f1bb183ab3898eb0e78949da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1cd54b56f1bb183ab3898eb0e78949da">iterative_closest_point</a> (const Eigen::MatrixBase&lt; DerivedVX &gt; &amp;VX, const Eigen::MatrixBase&lt; DerivedFX &gt; &amp;FX, const Eigen::MatrixBase&lt; DerivedVY &gt; &amp;VY, const Eigen::MatrixBase&lt; DerivedFY &gt; &amp;FY, const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedVY, 3 &gt; &amp;Ytree, const Eigen::MatrixBase&lt; DerivedNY &gt; &amp;NY, const int num_samples, const int max_iters, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;t)</td></tr>
<tr class="memdesc:a1cd54b56f1bb183ab3898eb0e78949da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1cd54b56f1bb183ab3898eb0e78949da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86feeac6e40d21e10cc147d82782000a" id="r_a86feeac6e40d21e10cc147d82782000a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86feeac6e40d21e10cc147d82782000a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a86feeac6e40d21e10cc147d82782000a">jet</a> (const T f, T *rgb)</td></tr>
<tr class="memdesc:a86feeac6e40d21e10cc147d82782000a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jet colormap like MATLAB's jet.  <br /></td></tr>
<tr class="separator:a86feeac6e40d21e10cc147d82782000a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b40235bb5881e629930f522e5f3ee1a" id="r_a7b40235bb5881e629930f522e5f3ee1a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b40235bb5881e629930f522e5f3ee1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7b40235bb5881e629930f522e5f3ee1a">jet</a> (const T f, T &amp;r, T &amp;g, T &amp;b)</td></tr>
<tr class="memdesc:a7b40235bb5881e629930f522e5f3ee1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7b40235bb5881e629930f522e5f3ee1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495fc46dda1dad8354b6aa9f9f146c89" id="r_a495fc46dda1dad8354b6aa9f9f146c89"><td class="memTemplParams" colspan="2">template&lt;typename DerivedZ , typename DerivedC &gt; </td></tr>
<tr class="memitem:a495fc46dda1dad8354b6aa9f9f146c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a495fc46dda1dad8354b6aa9f9f146c89">jet</a> (const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, const bool normalize, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a495fc46dda1dad8354b6aa9f9f146c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a495fc46dda1dad8354b6aa9f9f146c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecfd839e37628b61641d0e766eaf12b" id="r_a5ecfd839e37628b61641d0e766eaf12b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedZ , typename DerivedC &gt; </td></tr>
<tr class="memitem:a5ecfd839e37628b61641d0e766eaf12b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5ecfd839e37628b61641d0e766eaf12b">jet</a> (const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, const double min_Z, const double max_Z, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a5ecfd839e37628b61641d0e766eaf12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5ecfd839e37628b61641d0e766eaf12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a85e70cd58bcb5ebb5b36ef4a010fde" id="r_a0a85e70cd58bcb5ebb5b36ef4a010fde"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename Derivedx0 , typename Derivedf , typename DerivedF , typename DerivedU &gt; </td></tr>
<tr class="memitem:a0a85e70cd58bcb5ebb5b36ef4a010fde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0a85e70cd58bcb5ebb5b36ef4a010fde">kelvinlets</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; Derivedx0 &gt; &amp;x0, const Eigen::MatrixBase&lt; Derivedf &gt; &amp;f, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="structigl_1_1KelvinletParams.html">KelvinletParams</a>&lt; typename DerivedV::Scalar &gt; &amp;params, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a0a85e70cd58bcb5ebb5b36ef4a010fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Pixar's Regularized Kelvinlets (Pixar Technical Memo #17-03): Sculpting Brushes based on Fundamental Solutions of Elasticity, a technique for real-time physically based volume sculpting of virtual elastic materials.  <br /></td></tr>
<tr class="separator:a0a85e70cd58bcb5ebb5b36ef4a010fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c092ead172c396770ffeda0fcb56089" id="r_a2c092ead172c396770ffeda0fcb56089"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c092ead172c396770ffeda0fcb56089"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2c092ead172c396770ffeda0fcb56089">kkt_inverse</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;A, const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;Aeq, const bool use_lu_decomposition, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S)</td></tr>
<tr class="memdesc:a2c092ead172c396770ffeda0fcb56089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the inverse of the KKT matrix of a convex, linear equality constrained quadratic minimization problem.  <br /></td></tr>
<tr class="separator:a2c092ead172c396770ffeda0fcb56089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2969bd735df2588ce37026375ddefe" id="r_a6f2969bd735df2588ce37026375ddefe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename IndexType , typename DerivedCH , typename DerivedCN , typename DerivedW , typename DerivedI &gt; </td></tr>
<tr class="memitem:a6f2969bd735df2588ce37026375ddefe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6f2969bd735df2588ce37026375ddefe">knn</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, size_t k, const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;point_indices, const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;CH, const Eigen::MatrixBase&lt; DerivedCN &gt; &amp;CN, const Eigen::MatrixBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a6f2969bd735df2588ce37026375ddefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neighbors for each point in P.  <br /></td></tr>
<tr class="separator:a6f2969bd735df2588ce37026375ddefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8937a7fe108b5aa0669d3731c34e281d" id="r_a8937a7fe108b5aa0669d3731c34e281d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedV , typename IndexType , typename DerivedCH , typename DerivedCN , typename DerivedW , typename DerivedI &gt; </td></tr>
<tr class="memitem:a8937a7fe108b5aa0669d3731c34e281d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8937a7fe108b5aa0669d3731c34e281d">knn</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, size_t k, const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;point_indices, const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;CH, const Eigen::MatrixBase&lt; DerivedCN &gt; &amp;CN, const Eigen::MatrixBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a8937a7fe108b5aa0669d3731c34e281d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a8937a7fe108b5aa0669d3731c34e281d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44b520d132c6b6d1941fe5819f45ae1" id="r_af44b520d132c6b6d1941fe5819f45ae1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename DerivedF &gt; </td></tr>
<tr class="memitem:af44b520d132c6b6d1941fe5819f45ae1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af44b520d132c6b6d1941fe5819f45ae1">launch_medit</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const bool wait)</td></tr>
<tr class="memdesc:af44b520d132c6b6d1941fe5819f45ae1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the tetmesh in (V,T,F) to a temporary file, opens it with medit (forking with a system call) and returns.  <br /></td></tr>
<tr class="separator:af44b520d132c6b6d1941fe5819f45ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6a7f8c0fb33cae88074977a12e12fc" id="r_a7e6a7f8c0fb33cae88074977a12e12fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7e6a7f8c0fb33cae88074977a12e12fc">lbs_matrix</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, Eigen::MatrixXd &amp;M)</td></tr>
<tr class="memdesc:a7e6a7f8c0fb33cae88074977a12e12fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear blend skinning can be expressed by V' = M * T where V' is a #V by dim matrix of deformed vertex positions (one vertex per row), M is a #V by (dim+1)*#T (composed of weights and rest positions) and T is a #T*(dim+1) by dim matrix of #T stacked transposed transformation matrices.  <br /></td></tr>
<tr class="separator:a7e6a7f8c0fb33cae88074977a12e12fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf08b3e278ea284934baa0d3f6dc4975" id="r_abf08b3e278ea284934baa0d3f6dc4975"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abf08b3e278ea284934baa0d3f6dc4975">lbs_matrix_column</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, Eigen::SparseMatrix&lt; double &gt; &amp;M)</td></tr>
<tr class="memdesc:abf08b3e278ea284934baa0d3f6dc4975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix that when multiplied against a column of affine transformation entries computes new coordinates of the vertices.  <br /></td></tr>
<tr class="separator:abf08b3e278ea284934baa0d3f6dc4975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafa8162de573ea1c1c90b3f4ffad4a7" id="r_aaafa8162de573ea1c1c90b3f4ffad4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aaafa8162de573ea1c1c90b3f4ffad4a7">lbs_matrix_column</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, Eigen::MatrixXd &amp;M)</td></tr>
<tr class="memdesc:aaafa8162de573ea1c1c90b3f4ffad4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aaafa8162de573ea1c1c90b3f4ffad4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0754d811bd0e0c95fac0317917c255" id="r_a5f0754d811bd0e0c95fac0317917c255"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5f0754d811bd0e0c95fac0317917c255">lbs_matrix_column</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::MatrixXi &amp;WI, Eigen::SparseMatrix&lt; double &gt; &amp;M)</td></tr>
<tr class="memdesc:a5f0754d811bd0e0c95fac0317917c255"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5f0754d811bd0e0c95fac0317917c255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24aaeb1753decc0b7602a6cb0432458e" id="r_a24aaeb1753decc0b7602a6cb0432458e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a24aaeb1753decc0b7602a6cb0432458e">lbs_matrix_column</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::MatrixXi &amp;WI, Eigen::MatrixXd &amp;M)</td></tr>
<tr class="memdesc:a24aaeb1753decc0b7602a6cb0432458e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a24aaeb1753decc0b7602a6cb0432458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afcff53e324c859c08eaa01e48f4581" id="r_a7afcff53e324c859c08eaa01e48f4581"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename Orient2D , typename DerivedF &gt; </td></tr>
<tr class="memitem:a7afcff53e324c859c08eaa01e48f4581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7afcff53e324c859c08eaa01e48f4581">lexicographic_triangulation</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, Orient2D orient2D, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a7afcff53e324c859c08eaa01e48f4581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in 2D, return a lexicographic triangulation of these points.  <br /></td></tr>
<tr class="separator:a7afcff53e324c859c08eaa01e48f4581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2365ceb20a3b51fb10c3050cc456e343" id="r_a2365ceb20a3b51fb10c3050cc456e343"><td class="memTemplParams" colspan="2">template&lt;typename MatF , typename VecL &gt; </td></tr>
<tr class="memitem:a2365ceb20a3b51fb10c3050cc456e343"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2365ceb20a3b51fb10c3050cc456e343">limit_faces</a> (const MatF &amp;F, const VecL &amp;L, const bool exclusive, MatF &amp;LF)</td></tr>
<tr class="memdesc:a2365ceb20a3b51fb10c3050cc456e343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit given faces F to those which contain (only) indices found in L.  <br /></td></tr>
<tr class="separator:a2365ceb20a3b51fb10c3050cc456e343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4deb0e936a117ec6c8c973f3d0670770" id="r_a4deb0e936a117ec6c8c973f3d0670770"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedO &gt; </td></tr>
<tr class="memitem:a4deb0e936a117ec6c8c973f3d0670770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4deb0e936a117ec6c8c973f3d0670770">line_field_mismatch</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;PD1, const bool isCombed, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;mismatch)</td></tr>
<tr class="memdesc:a4deb0e936a117ec6c8c973f3d0670770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces.  <br /></td></tr>
<tr class="separator:a4deb0e936a117ec6c8c973f3d0670770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9145bd261a2cf691294d8104c99a4ab9" id="r_a9145bd261a2cf691294d8104c99a4ab9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9145bd261a2cf691294d8104c99a4ab9">line_search</a> (Eigen::MatrixXd &amp;x, const Eigen::MatrixXd &amp;d, double i_step_size, std::function&lt; double(Eigen::MatrixXd &amp;)&gt; energy, double cur_energy=-1)</td></tr>
<tr class="memdesc:a9145bd261a2cf691294d8104c99a4ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a bisection linesearch to minimize a mesh-based energy on vertices given at 'x' at a search direction 'd', with initial step size.  <br /></td></tr>
<tr class="separator:a9145bd261a2cf691294d8104c99a4ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b5853a837850f17eadaff857ad1e463" id="r_a2b5853a837850f17eadaff857ad1e463"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2b5853a837850f17eadaff857ad1e463">line_segment_in_rectangle</a> (const Eigen::Vector2d &amp;s, const Eigen::Vector2d &amp;d, const Eigen::Vector2d &amp;A, const Eigen::Vector2d &amp;B)</td></tr>
<tr class="memdesc:a2b5853a837850f17eadaff857ad1e463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a line segment overlaps with a rectangle.  <br /></td></tr>
<tr class="separator:a2b5853a837850f17eadaff857ad1e463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9c39cf6f0bef4857b1dc66360e4f52" id="r_afa9c39cf6f0bef4857b1dc66360e4f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afa9c39cf6f0bef4857b1dc66360e4f52">linprog</a> (const Eigen::VectorXd &amp;c, const Eigen::MatrixXd &amp;A, const Eigen::VectorXd &amp;b, const int k, Eigen::VectorXd &amp;x)</td></tr>
<tr class="memdesc:afa9c39cf6f0bef4857b1dc66360e4f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear program given in "standard form".  <br /></td></tr>
<tr class="separator:afa9c39cf6f0bef4857b1dc66360e4f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9455a41cb54a91242fe498354445bd28" id="r_a9455a41cb54a91242fe498354445bd28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9455a41cb54a91242fe498354445bd28">linprog</a> (const Eigen::VectorXd &amp;f, const Eigen::MatrixXd &amp;A, const Eigen::VectorXd &amp;b, const Eigen::MatrixXd &amp;B, const Eigen::VectorXd &amp;c, Eigen::VectorXd &amp;x)</td></tr>
<tr class="memdesc:a9455a41cb54a91242fe498354445bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9455a41cb54a91242fe498354445bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a4579279c09a298a5988c18f215d33" id="r_ae8a4579279c09a298a5988c18f215d33"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae8a4579279c09a298a5988c18f215d33"><td class="memTemplItemLeft" align="right" valign="top">Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae8a4579279c09a298a5988c18f215d33">LinSpaced</a> (typename Derived::Index size, const typename Derived::Scalar &amp;low, const typename Derived::Scalar &amp;high)</td></tr>
<tr class="memdesc:ae8a4579279c09a298a5988c18f215d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replacement for Eigen::DenseBase::LinSpaced.  <br /></td></tr>
<tr class="separator:ae8a4579279c09a298a5988c18f215d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6ee5a6c7852f628cefbb8dbb025af" id="r_a6df6ee5a6c7852f628cefbb8dbb025af"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derived &gt; </td></tr>
<tr class="memitem:a6df6ee5a6c7852f628cefbb8dbb025af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6df6ee5a6c7852f628cefbb8dbb025af">list_to_matrix</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;V, Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:a6df6ee5a6c7852f628cefbb8dbb025af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list (std::vector) of row vectors of the same length to a matrix.  <br /></td></tr>
<tr class="separator:a6df6ee5a6c7852f628cefbb8dbb025af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fd001a788d43f744d257d305ddb1b3" id="r_ae5fd001a788d43f744d257d305ddb1b3"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename Derived &gt; </td></tr>
<tr class="memitem:ae5fd001a788d43f744d257d305ddb1b3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae5fd001a788d43f744d257d305ddb1b3">list_to_matrix</a> (const std::vector&lt; std::array&lt; T, N &gt; &gt; &amp;V, Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:ae5fd001a788d43f744d257d305ddb1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae5fd001a788d43f744d257d305ddb1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b768c6f9bfb5e3e0342cbe32f91110" id="r_a47b768c6f9bfb5e3e0342cbe32f91110"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derived &gt; </td></tr>
<tr class="memitem:a47b768c6f9bfb5e3e0342cbe32f91110"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a47b768c6f9bfb5e3e0342cbe32f91110">list_to_matrix</a> (const std::vector&lt; T &gt; &amp;V, Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:a47b768c6f9bfb5e3e0342cbe32f91110"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a47b768c6f9bfb5e3e0342cbe32f91110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bb0b08ed4407588cdc107ce3f99b3d" id="r_a25bb0b08ed4407588cdc107ce3f99b3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derived &gt; </td></tr>
<tr class="memitem:a25bb0b08ed4407588cdc107ce3f99b3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a25bb0b08ed4407588cdc107ce3f99b3d">list_to_matrix</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;V, const int n, const T &amp;padding, Eigen::PlainObjectBase&lt; Derived &gt; &amp;M)</td></tr>
<tr class="memdesc:a25bb0b08ed4407588cdc107ce3f99b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of row vectors of <code>n</code> or less to a matrix and pad on the right with <code>padding</code>.  <br /></td></tr>
<tr class="separator:a25bb0b08ed4407588cdc107ce3f99b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a662cae580e5c3459d81435f32e24" id="r_a108a662cae580e5c3459d81435f32e24"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a108a662cae580e5c3459d81435f32e24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a108a662cae580e5c3459d81435f32e24">local_basis</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;B1, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;B2, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;B3)</td></tr>
<tr class="memdesc:a108a662cae580e5c3459d81435f32e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a local orthogonal reference system for each triangle in the given mesh.  <br /></td></tr>
<tr class="separator:a108a662cae580e5c3459d81435f32e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46bcc8364a310c7a3bc0ee718b91fb1" id="r_ae46bcc8364a310c7a3bc0ee718b91fb1"><td class="memTemplParams" colspan="2">template&lt;typename Derivedeye , typename Derivedcenter , typename Derivedup , typename DerivedR &gt; </td></tr>
<tr class="memitem:ae46bcc8364a310c7a3bc0ee718b91fb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae46bcc8364a310c7a3bc0ee718b91fb1">look_at</a> (const Eigen::PlainObjectBase&lt; Derivedeye &gt; &amp;eye, const Eigen::PlainObjectBase&lt; Derivedcenter &gt; &amp;center, const Eigen::PlainObjectBase&lt; Derivedup &gt; &amp;up, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R)</td></tr>
<tr class="memdesc:ae46bcc8364a310c7a3bc0ee718b91fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the deprecated gluLookAt function.  <br /></td></tr>
<tr class="separator:ae46bcc8364a310c7a3bc0ee718b91fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9965bc615b0a851fabf90d37a73320" id="r_aea9965bc615b0a851fabf90d37a73320"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename SType , typename DerivedNF &gt; </td></tr>
<tr class="memitem:aea9965bc615b0a851fabf90d37a73320"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aea9965bc615b0a851fabf90d37a73320">loop</a> (const int n_verts, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; SType &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;NF)</td></tr>
<tr class="memdesc:aea9965bc615b0a851fabf90d37a73320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the triangle mesh [V, F], where n_verts = V.rows(), computes newV and a sparse matrix S s.t.  <br /></td></tr>
<tr class="separator:aea9965bc615b0a851fabf90d37a73320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee95891ee4e9418b27c3fbfa92542784" id="r_aee95891ee4e9418b27c3fbfa92542784"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF &gt; </td></tr>
<tr class="memitem:aee95891ee4e9418b27c3fbfa92542784"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aee95891ee4e9418b27c3fbfa92542784">loop</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;NV, Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;NF, const int number_of_subdivs=1)</td></tr>
<tr class="memdesc:aee95891ee4e9418b27c3fbfa92542784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the triangle mesh [V, F], computes number_of_subdivs steps of loop subdivision and outputs the new mesh [newV, newF].  <br /></td></tr>
<tr class="separator:aee95891ee4e9418b27c3fbfa92542784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31de2a4d188ef681f7057d0d948edbf1" id="r_a31de2a4d188ef681f7057d0d948edbf1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedV_uv , typename QScalar &gt; </td></tr>
<tr class="memitem:a31de2a4d188ef681f7057d0d948edbf1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a31de2a4d188ef681f7057d0d948edbf1">lscm</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, Eigen::PlainObjectBase&lt; DerivedV_uv &gt; &amp;V_uv, Eigen::SparseMatrix&lt; QScalar &gt; &amp;Q)</td></tr>
<tr class="memdesc:a31de2a4d188ef681f7057d0d948edbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a Least-squares conformal map parametrization (equivalently derived in "Intrinsic Parameterizations of Surface Meshes" [Desbrun et al.  <br /></td></tr>
<tr class="separator:a31de2a4d188ef681f7057d0d948edbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c37dc9607d1629ed72cba5af4e64554" id="r_a1c37dc9607d1629ed72cba5af4e64554"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedV_uv &gt; </td></tr>
<tr class="memitem:a1c37dc9607d1629ed72cba5af4e64554"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1c37dc9607d1629ed72cba5af4e64554">lscm</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedb &gt; &amp;b, const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;bc, Eigen::PlainObjectBase&lt; DerivedV_uv &gt; &amp;V_uv)</td></tr>
<tr class="memdesc:a1c37dc9607d1629ed72cba5af4e64554"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1c37dc9607d1629ed72cba5af4e64554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378192fe12df93afb032da2706ff5c0a" id="r_a378192fe12df93afb032da2706ff5c0a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedV_uv &gt; </td></tr>
<tr class="memitem:a378192fe12df93afb032da2706ff5c0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a378192fe12df93afb032da2706ff5c0a">lscm</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedV_uv &gt; &amp;V_uv)</td></tr>
<tr class="memdesc:a378192fe12df93afb032da2706ff5c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a378192fe12df93afb032da2706ff5c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf5daa1660b341b111456aabafc1f9b" id="r_a1cf5daa1660b341b111456aabafc1f9b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename QScalar &gt; </td></tr>
<tr class="memitem:a1cf5daa1660b341b111456aabafc1f9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1cf5daa1660b341b111456aabafc1f9b">lscm_hessian</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; QScalar &gt; &amp;Q)</td></tr>
<tr class="memdesc:a1cf5daa1660b341b111456aabafc1f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a Least-squares conformal map parametrization (equivalently derived in "Intrinsic Parameterizations of Surface Meshes" [Desbrun et al.  <br /></td></tr>
<tr class="separator:a1cf5daa1660b341b111456aabafc1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b077eb9a7d351e5b313ff150dc3eabb" id="r_a8b077eb9a7d351e5b313ff150dc3eabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8b077eb9a7d351e5b313ff150dc3eabb">map_vertices_to_circle</a> (const Eigen::MatrixXd &amp;V, const Eigen::VectorXi &amp;bnd, Eigen::MatrixXd &amp;UV)</td></tr>
<tr class="memdesc:a8b077eb9a7d351e5b313ff150dc3eabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths.  <br /></td></tr>
<tr class="separator:a8b077eb9a7d351e5b313ff150dc3eabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a118619cf44f20a0956f9e856707aa2" id="r_a0a118619cf44f20a0956f9e856707aa2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0a118619cf44f20a0956f9e856707aa2">mapping_energy_with_jacobians</a> (const Eigen::MatrixXd &amp;Ji, const Eigen::VectorXd &amp;areas, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">igl::MappingEnergyType</a> slim_energy, double exp_factor)</td></tr>
<tr class="memdesc:a0a118619cf44f20a0956f9e856707aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the rotation-invariant energy of a mapping (represented in Jacobians and areas)  <br /></td></tr>
<tr class="separator:a0a118619cf44f20a0956f9e856707aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c4985a12f6c71116d36492d2f6154d" id="r_a75c4985a12f6c71116d36492d2f6154d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedGV , typename Scalar , typename Index , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a75c4985a12f6c71116d36492d2f6154d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a75c4985a12f6c71116d36492d2f6154d">march_cube</a> (const DerivedGV &amp;GV, const Eigen::Matrix&lt; Scalar, 8, 1 &gt; &amp;cS, const Eigen::Matrix&lt; Index, 8, 1 &gt; &amp;cI, const Scalar &amp;isovalue, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Index &amp;n, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Index &amp;m, std::unordered_map&lt; int64_t, int &gt; &amp;E2V)</td></tr>
<tr class="memdesc:a75c4985a12f6c71116d36492d2f6154d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a single cube of a marching cubes grid.  <br /></td></tr>
<tr class="separator:a75c4985a12f6c71116d36492d2f6154d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e677970b7188cac95bc9f93181f2ed7" id="r_a3e677970b7188cac95bc9f93181f2ed7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedGV , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a3e677970b7188cac95bc9f93181f2ed7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3e677970b7188cac95bc9f93181f2ed7">marching_cubes</a> (const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;GV, const unsigned nx, const unsigned ny, const unsigned nz, const typename DerivedS::Scalar isovalue, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a3e677970b7188cac95bc9f93181f2ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh defined by vertices and faces.  <br /></td></tr>
<tr class="separator:a3e677970b7188cac95bc9f93181f2ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60d3b30634f77428770f2ae32f34059" id="r_af60d3b30634f77428770f2ae32f34059"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedGV , typename DerivedGI , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:af60d3b30634f77428770f2ae32f34059"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af60d3b30634f77428770f2ae32f34059">marching_cubes</a> (const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;GV, const Eigen::MatrixBase&lt; DerivedGI &gt; &amp;GI, const typename DerivedS::Scalar isovalue, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:af60d3b30634f77428770f2ae32f34059"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af60d3b30634f77428770f2ae32f34059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512306a29939c7ac8d4ebcef2cd032a" id="r_a5512306a29939c7ac8d4ebcef2cd032a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename DerivedJ , typename BCType &gt; </td></tr>
<tr class="memitem:a5512306a29939c7ac8d4ebcef2cd032a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5512306a29939c7ac8d4ebcef2cd032a">marching_tets</a> (const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;TV, const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;TT, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar isovalue, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::SparseMatrix&lt; BCType &gt; &amp;BC)</td></tr>
<tr class="memdesc:a5512306a29939c7ac8d4ebcef2cd032a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the marching tetrahedra algorithm on a tet mesh defined by TV and TT with scalar values defined at each vertex in TV.  <br /></td></tr>
<tr class="separator:a5512306a29939c7ac8d4ebcef2cd032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49f489ae12ec4a901418253fcd3f3ed" id="r_aa49f489ae12ec4a901418253fcd3f3ed"><td class="memTemplParams" colspan="2">template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename DerivedJ , typename BCType &gt; </td></tr>
<tr class="memitem:aa49f489ae12ec4a901418253fcd3f3ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa49f489ae12ec4a901418253fcd3f3ed">marching_tets</a> (const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;TV, const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;TT, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::SparseMatrix&lt; BCType &gt; &amp;BC)</td></tr>
<tr class="memdesc:aa49f489ae12ec4a901418253fcd3f3ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa49f489ae12ec4a901418253fcd3f3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b74374c21bab647512f658e050cc27" id="r_a77b74374c21bab647512f658e050cc27"><td class="memTemplParams" colspan="2">template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a77b74374c21bab647512f658e050cc27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a77b74374c21bab647512f658e050cc27">marching_tets</a> (const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;TV, const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;TT, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar isovalue, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a77b74374c21bab647512f658e050cc27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a77b74374c21bab647512f658e050cc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac630f9be345647d2008378e9489ea50e" id="r_ac630f9be345647d2008378e9489ea50e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename BCType &gt; </td></tr>
<tr class="memitem:ac630f9be345647d2008378e9489ea50e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac630f9be345647d2008378e9489ea50e">marching_tets</a> (const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;TV, const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;TT, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar isovalue, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::SparseMatrix&lt; BCType &gt; &amp;BC)</td></tr>
<tr class="memdesc:ac630f9be345647d2008378e9489ea50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac630f9be345647d2008378e9489ea50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4416636f9a80fb95a7656732a32dbf0f" id="r_a4416636f9a80fb95a7656732a32dbf0f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF &gt; </td></tr>
<tr class="memitem:a4416636f9a80fb95a7656732a32dbf0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4416636f9a80fb95a7656732a32dbf0f">marching_tets</a> (const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;TV, const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;TT, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar isovalue, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF)</td></tr>
<tr class="memdesc:a4416636f9a80fb95a7656732a32dbf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4416636f9a80fb95a7656732a32dbf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cf047d8b4df743c47bbbf0ba9dc6e1" id="r_a72cf047d8b4df743c47bbbf0ba9dc6e1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:a72cf047d8b4df743c47bbbf0ba9dc6e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a72cf047d8b4df743c47bbbf0ba9dc6e1">massmatrix</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a> type, Eigen::SparseMatrix&lt; Scalar &gt; &amp;M)</td></tr>
<tr class="memdesc:a72cf047d8b4df743c47bbbf0ba9dc6e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the mass (area) matrix for a given mesh (V,F).  <br /></td></tr>
<tr class="separator:a72cf047d8b4df743c47bbbf0ba9dc6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab669b8ca4aea8ed68a0ba8c58a39bb" id="r_a4ab669b8ca4aea8ed68a0ba8c58a39bb"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:a4ab669b8ca4aea8ed68a0ba8c58a39bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4ab669b8ca4aea8ed68a0ba8c58a39bb">massmatrix_intrinsic</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a> type, Eigen::SparseMatrix&lt; Scalar &gt; &amp;M)</td></tr>
<tr class="memdesc:a4ab669b8ca4aea8ed68a0ba8c58a39bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the mass (area) matrix for a given mesh (V,F).  <br /></td></tr>
<tr class="separator:a4ab669b8ca4aea8ed68a0ba8c58a39bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f410b7b17ce4aca5873af755825d76" id="r_af2f410b7b17ce4aca5873af755825d76"><td class="memTemplParams" colspan="2">template&lt;typename Derivedl , typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:af2f410b7b17ce4aca5873af755825d76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af2f410b7b17ce4aca5873af755825d76">massmatrix_intrinsic</a> (const Eigen::MatrixBase&lt; Derivedl &gt; &amp;l, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a> type, const int n, Eigen::SparseMatrix&lt; Scalar &gt; &amp;M)</td></tr>
<tr class="memdesc:af2f410b7b17ce4aca5873af755825d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af2f410b7b17ce4aca5873af755825d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45c197a9b5b63af57d2791909442e41" id="r_ae45c197a9b5b63af57d2791909442e41"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:ae45c197a9b5b63af57d2791909442e41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae45c197a9b5b63af57d2791909442e41">mat4_to_quat</a> (const Q_type *m, Q_type *q)</td></tr>
<tr class="memdesc:ae45c197a9b5b63af57d2791909442e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a OpenGL (rotation) matrix to a quaternion.  <br /></td></tr>
<tr class="separator:ae45c197a9b5b63af57d2791909442e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21c6c4b638d223560312607397b5ba8" id="r_aa21c6c4b638d223560312607397b5ba8"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:aa21c6c4b638d223560312607397b5ba8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa21c6c4b638d223560312607397b5ba8">mat3_to_quat</a> (const Q_type *m, Q_type *q)</td></tr>
<tr class="memdesc:aa21c6c4b638d223560312607397b5ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa21c6c4b638d223560312607397b5ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa21880837017adbf621456039ee7682" id="r_afa21880837017adbf621456039ee7682"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afa21880837017adbf621456039ee7682">MAYA_GREEN</a> (128./255., 242./255., 0./255., 1.)</td></tr>
<tr class="separator:afa21880837017adbf621456039ee7682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4babb52f3f1868081e0cefa0e4f56e07" id="r_a4babb52f3f1868081e0cefa0e4f56e07"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4babb52f3f1868081e0cefa0e4f56e07">MAYA_YELLOW</a> (255./255., 247./255., 50./255., 1.)</td></tr>
<tr class="separator:a4babb52f3f1868081e0cefa0e4f56e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e550e4712ab9495265314ad14c3372" id="r_a10e550e4712ab9495265314ad14c3372"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a10e550e4712ab9495265314ad14c3372">MAYA_RED</a> (234./255., 63./255., 52./255., 1.)</td></tr>
<tr class="separator:a10e550e4712ab9495265314ad14c3372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669df861bcae5e90ab84e929012a1007" id="r_a669df861bcae5e90ab84e929012a1007"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a669df861bcae5e90ab84e929012a1007">MAYA_BLUE</a> (0./255., 73./255., 252./255., 1.)</td></tr>
<tr class="separator:a669df861bcae5e90ab84e929012a1007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d3a9a0275b56ed0378893b3e80f0b4" id="r_af3d3a9a0275b56ed0378893b3e80f0b4"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af3d3a9a0275b56ed0378893b3e80f0b4">MAYA_PURPLE</a> (180./255., 73./255., 200./255., 1.)</td></tr>
<tr class="separator:af3d3a9a0275b56ed0378893b3e80f0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2348169281b988537537308cba384db3" id="r_a2348169281b988537537308cba384db3"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2348169281b988537537308cba384db3">MAYA_VIOLET</a> (31./255., 15./255., 66./255., 1.)</td></tr>
<tr class="separator:a2348169281b988537537308cba384db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf86c730ad8ddf83e5c89d8589047364" id="r_acf86c730ad8ddf83e5c89d8589047364"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acf86c730ad8ddf83e5c89d8589047364">MAYA_GREY</a> (0.5, 0.5, 0.5, 1.0)</td></tr>
<tr class="separator:acf86c730ad8ddf83e5c89d8589047364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362ead03e0717a9a1e39f52996e6f6db" id="r_a362ead03e0717a9a1e39f52996e6f6db"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a362ead03e0717a9a1e39f52996e6f6db">MAYA_CYAN</a> (131./255., 219./255., 252./255., 1.)</td></tr>
<tr class="separator:a362ead03e0717a9a1e39f52996e6f6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576798d977c56f9ebd4699e1d9693dd3" id="r_a576798d977c56f9ebd4699e1d9693dd3"><td class="memItemLeft" align="right" valign="top">const Eigen::Vector4f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a576798d977c56f9ebd4699e1d9693dd3">MAYA_SEA_GREEN</a> (70./255., 252./255., 167./255., 1.)</td></tr>
<tr class="separator:a576798d977c56f9ebd4699e1d9693dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d87355c9c3b734e7658eed10bdd764" id="r_a64d87355c9c3b734e7658eed10bdd764"><td class="memTemplParams" colspan="2">template&lt;typename DerivedM &gt; </td></tr>
<tr class="memitem:a64d87355c9c3b734e7658eed10bdd764"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::WithFormat&lt; DerivedM &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a64d87355c9c3b734e7658eed10bdd764">matlab_format</a> (const Eigen::DenseBase&lt; DerivedM &gt; &amp;M, const std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a64d87355c9c3b734e7658eed10bdd764"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a routine to print a matrix using format suitable for pasting into the matlab IDE.  <br /></td></tr>
<tr class="separator:a64d87355c9c3b734e7658eed10bdd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0f1184f42624896cf510cd82ccb6ca" id="r_acc0f1184f42624896cf510cd82ccb6ca"><td class="memTemplParams" colspan="2">template&lt;typename DerivedM &gt; </td></tr>
<tr class="memitem:acc0f1184f42624896cf510cd82ccb6ca"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acc0f1184f42624896cf510cd82ccb6ca">matlab_format_index</a> (const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, const std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:acc0f1184f42624896cf510cd82ccb6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:acc0f1184f42624896cf510cd82ccb6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ca4e0bd6d85899d88544c29389b048" id="r_a92ca4e0bd6d85899d88544c29389b048"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS &gt; </td></tr>
<tr class="memitem:a92ca4e0bd6d85899d88544c29389b048"><td class="memTemplItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a92ca4e0bd6d85899d88544c29389b048">matlab_format</a> (const Eigen::SparseMatrix&lt; DerivedS &gt; &amp;S, const std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a92ca4e0bd6d85899d88544c29389b048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same but for sparse matrices.  <br /></td></tr>
<tr class="separator:a92ca4e0bd6d85899d88544c29389b048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9641504c7ccb6996da7abc34c5ebe6a1" id="r_a9641504c7ccb6996da7abc34c5ebe6a1"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9641504c7ccb6996da7abc34c5ebe6a1">matlab_format</a> (const double v, const std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a9641504c7ccb6996da7abc34c5ebe6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9641504c7ccb6996da7abc34c5ebe6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367414630ebe7f7fe7a243502d57b1ad" id="r_a367414630ebe7f7fe7a243502d57b1ad"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a367414630ebe7f7fe7a243502d57b1ad">matlab_format</a> (const float v, const std::string name=&quot;&quot;)</td></tr>
<tr class="memdesc:a367414630ebe7f7fe7a243502d57b1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a367414630ebe7f7fe7a243502d57b1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b539a21fb577617710f5fce2046e65b" id="r_a6b539a21fb577617710f5fce2046e65b"><td class="memItemLeft" align="right" valign="top">Eigen::IOFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6b539a21fb577617710f5fce2046e65b">matlab_format</a> ()</td></tr>
<tr class="memdesc:a6b539a21fb577617710f5fce2046e65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just build and return the format.  <br /></td></tr>
<tr class="separator:a6b539a21fb577617710f5fce2046e65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d68f355e17a7ba95194bfd46f3ce49" id="r_ac9d68f355e17a7ba95194bfd46f3ce49"><td class="memTemplParams" colspan="2">template&lt;typename DerivedM &gt; </td></tr>
<tr class="memitem:ac9d68f355e17a7ba95194bfd46f3ce49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac9d68f355e17a7ba95194bfd46f3ce49">matrix_to_list</a> (const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, std::vector&lt; std::vector&lt; typename DerivedM::Scalar &gt; &gt; &amp;V)</td></tr>
<tr class="memdesc:ac9d68f355e17a7ba95194bfd46f3ce49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix to a list (std::vector) of row vectors of the same size.  <br /></td></tr>
<tr class="separator:ac9d68f355e17a7ba95194bfd46f3ce49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8c8289cdddc4408bc1e12579de244c" id="r_adc8c8289cdddc4408bc1e12579de244c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedM &gt; </td></tr>
<tr class="memitem:adc8c8289cdddc4408bc1e12579de244c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adc8c8289cdddc4408bc1e12579de244c">matrix_to_list</a> (const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, std::vector&lt; typename DerivedM::Scalar &gt; &amp;V)</td></tr>
<tr class="memdesc:adc8c8289cdddc4408bc1e12579de244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix to a list (std::vector) of elements in column-major ordering.  <br /></td></tr>
<tr class="separator:adc8c8289cdddc4408bc1e12579de244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a51cfa07853b2b45e1226672e16da" id="r_aec3a51cfa07853b2b45e1226672e16da"><td class="memTemplParams" colspan="2">template&lt;typename DerivedM &gt; </td></tr>
<tr class="memitem:aec3a51cfa07853b2b45e1226672e16da"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename DerivedM::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aec3a51cfa07853b2b45e1226672e16da">matrix_to_list</a> (const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M)</td></tr>
<tr class="memdesc:aec3a51cfa07853b2b45e1226672e16da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aec3a51cfa07853b2b45e1226672e16da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b1c228d9a40c7c25062de5c6e20c9" id="r_a406b1c228d9a40c7c25062de5c6e20c9"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedB , typename DerivedI &gt; </td></tr>
<tr class="memitem:a406b1c228d9a40c7c25062de5c6e20c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a406b1c228d9a40c7c25062de5c6e20c9">max</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a406b1c228d9a40c7c25062de5c6e20c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum along dimension dim of a matrix X.  <br /></td></tr>
<tr class="separator:a406b1c228d9a40c7c25062de5c6e20c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2e2d77d83c68427be201b4e3a877a6" id="r_a5e2e2d77d83c68427be201b4e3a877a6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedI &gt; </td></tr>
<tr class="memitem:a5e2e2d77d83c68427be201b4e3a877a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5e2e2d77d83c68427be201b4e3a877a6">max</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a5e2e2d77d83c68427be201b4e3a877a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5e2e2d77d83c68427be201b4e3a877a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b5b6981f78cc7519e2ac080f4ec561" id="r_a74b5b6981f78cc7519e2ac080f4ec561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a74b5b6981f78cc7519e2ac080f4ec561">max_faces_stopping_condition</a> (int &amp;m, const int orig_m, const int max_m, <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;stopping_condition)</td></tr>
<tr class="memdesc:a74b5b6981f78cc7519e2ac080f4ec561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stopping condition function compatible with <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>.  <br /></td></tr>
<tr class="separator:a74b5b6981f78cc7519e2ac080f4ec561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb31e9c7165119e57a70705383c7275d" id="r_afb31e9c7165119e57a70705383c7275d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afb31e9c7165119e57a70705383c7275d">max_faces_stopping_condition</a> (int &amp;m, const int orign_m, const int max_m)</td></tr>
<tr class="memdesc:afb31e9c7165119e57a70705383c7275d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:afb31e9c7165119e57a70705383c7275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4303b454ca438ac3e09fdc506d431df" id="r_ad4303b454ca438ac3e09fdc506d431df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4303b454ca438ac3e09fdc506d431df"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad4303b454ca438ac3e09fdc506d431df">max_size</a> (const std::vector&lt; T &gt; &amp;V)</td></tr>
<tr class="memdesc:ad4303b454ca438ac3e09fdc506d431df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine max size of lists in a vector.  <br /></td></tr>
<tr class="separator:ad4303b454ca438ac3e09fdc506d431df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73289b6fbba95eacda8174e185dcf9f" id="r_ad73289b6fbba95eacda8174e185dcf9f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename mType &gt; </td></tr>
<tr class="memitem:ad73289b6fbba95eacda8174e185dcf9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad73289b6fbba95eacda8174e185dcf9f">median</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, mType &amp;m)</td></tr>
<tr class="memdesc:ad73289b6fbba95eacda8174e185dcf9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of an eigen vector.  <br /></td></tr>
<tr class="separator:ad73289b6fbba95eacda8174e185dcf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea356ce5149b60ed9d36e9f7a94db372" id="r_aea356ce5149b60ed9d36e9f7a94db372"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedB , typename DerivedI &gt; </td></tr>
<tr class="memitem:aea356ce5149b60ed9d36e9f7a94db372"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aea356ce5149b60ed9d36e9f7a94db372">min</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:aea356ce5149b60ed9d36e9f7a94db372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the minimum along dimension dim of a matrix X.  <br /></td></tr>
<tr class="separator:aea356ce5149b60ed9d36e9f7a94db372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c8ab934e0d7755a6c90c0fa6486c4" id="r_a9b9c8ab934e0d7755a6c90c0fa6486c4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedI &gt; </td></tr>
<tr class="memitem:a9b9c8ab934e0d7755a6c90c0fa6486c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b9c8ab934e0d7755a6c90c0fa6486c4">min</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a9b9c8ab934e0d7755a6c90c0fa6486c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9b9c8ab934e0d7755a6c90c0fa6486c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0382628e374a5b92a226ad75ce6b8b" id="r_adc0382628e374a5b92a226ad75ce6b8b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derivedknown &gt; </td></tr>
<tr class="memitem:adc0382628e374a5b92a226ad75ce6b8b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adc0382628e374a5b92a226ad75ce6b8b">min_quad_with_fixed_precompute</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;A, const Eigen::MatrixBase&lt; Derivedknown &gt; &amp;known, const Eigen::SparseMatrix&lt; T &gt; &amp;Aeq, const bool pd, <a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a>&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:adc0382628e374a5b92a226ad75ce6b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimize a convex quadratic energy subject to fixed value and linear equality constraints.  <br /></td></tr>
<tr class="separator:adc0382628e374a5b92a226ad75ce6b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d436a09a132f780d5e503b39499fbb" id="r_ad6d436a09a132f780d5e503b39499fbb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedB , typename DerivedY , typename DerivedBeq , typename DerivedZ , typename Derivedsol &gt; </td></tr>
<tr class="memitem:ad6d436a09a132f780d5e503b39499fbb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad6d436a09a132f780d5e503b39499fbb">min_quad_with_fixed_solve</a> (const <a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a>&lt; T &gt; &amp;data, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const Eigen::MatrixBase&lt; DerivedBeq &gt; &amp;Beq, Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;Z, Eigen::PlainObjectBase&lt; Derivedsol &gt; &amp;sol)</td></tr>
<tr class="memdesc:ad6d436a09a132f780d5e503b39499fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system previously factored using min_quad_with_fixed_precompute.  <br /></td></tr>
<tr class="separator:ad6d436a09a132f780d5e503b39499fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5720740af2df4180f61b1731bd5499f" id="r_ad5720740af2df4180f61b1731bd5499f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedB , typename DerivedY , typename DerivedBeq , typename DerivedZ &gt; </td></tr>
<tr class="memitem:ad5720740af2df4180f61b1731bd5499f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad5720740af2df4180f61b1731bd5499f">min_quad_with_fixed_solve</a> (const <a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a>&lt; T &gt; &amp;data, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const Eigen::MatrixBase&lt; DerivedBeq &gt; &amp;Beq, Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;Z)</td></tr>
<tr class="memdesc:ad5720740af2df4180f61b1731bd5499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad5720740af2df4180f61b1731bd5499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdcf5c62d46412f4b5de5889e51c0d4" id="r_abcdcf5c62d46412f4b5de5889e51c0d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Derivedknown , typename DerivedB , typename DerivedY , typename DerivedBeq , typename DerivedZ &gt; </td></tr>
<tr class="memitem:abcdcf5c62d46412f4b5de5889e51c0d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abcdcf5c62d46412f4b5de5889e51c0d4">min_quad_with_fixed</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; Derivedknown &gt; &amp;known, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const Eigen::SparseMatrix&lt; T &gt; &amp;Aeq, const Eigen::MatrixBase&lt; DerivedBeq &gt; &amp;Beq, const bool pd, Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;Z)</td></tr>
<tr class="memdesc:abcdcf5c62d46412f4b5de5889e51c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abcdcf5c62d46412f4b5de5889e51c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897bf8d157d9e2b51b81603c5fd6e099" id="r_a897bf8d157d9e2b51b81603c5fd6e099"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int n, int m, bool Hpd = true&gt; </td></tr>
<tr class="memitem:a897bf8d157d9e2b51b81603c5fd6e099"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, n, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a897bf8d157d9e2b51b81603c5fd6e099">min_quad_with_fixed</a> (const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;H, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;f, const Eigen::Array&lt; bool, n, 1 &gt; &amp;k, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;bc, const Eigen::Matrix&lt; Scalar, m, n &gt; &amp;A, const Eigen::Matrix&lt; Scalar, m, 1 &gt; &amp;b)</td></tr>
<tr class="memdesc:a897bf8d157d9e2b51b81603c5fd6e099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dense version optimized for very small, known at compile time sizes.  <br /></td></tr>
<tr class="separator:a897bf8d157d9e2b51b81603c5fd6e099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2961e370b73126b4896c0f53cc8af4" id="r_a4f2961e370b73126b4896c0f53cc8af4"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int n, bool Hpd = true&gt; </td></tr>
<tr class="memitem:a4f2961e370b73126b4896c0f53cc8af4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, n, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4f2961e370b73126b4896c0f53cc8af4">min_quad_with_fixed</a> (const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;H, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;f, const Eigen::Array&lt; bool, n, 1 &gt; &amp;k, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;bc)</td></tr>
<tr class="memdesc:a4f2961e370b73126b4896c0f53cc8af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4f2961e370b73126b4896c0f53cc8af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810f069896eadc075940d13f7cc22a4f" id="r_a810f069896eadc075940d13f7cc22a4f"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int n, int kcount, bool Hpd&gt; </td></tr>
<tr class="memitem:a810f069896eadc075940d13f7cc22a4f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, n, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a810f069896eadc075940d13f7cc22a4f">min_quad_with_fixed</a> (const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;H, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;f, const Eigen::Array&lt; bool, n, 1 &gt; &amp;k, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;bc)</td></tr>
<tr class="memdesc:a810f069896eadc075940d13f7cc22a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a810f069896eadc075940d13f7cc22a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4adc0413c180d649f00d8759cf63b3" id="r_aea4adc0413c180d649f00d8759cf63b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea4adc0413c180d649f00d8759cf63b3"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aea4adc0413c180d649f00d8759cf63b3">min_size</a> (const std::vector&lt; T &gt; &amp;V)</td></tr>
<tr class="memdesc:aea4adc0413c180d649f00d8759cf63b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine min size of lists in a vector.  <br /></td></tr>
<tr class="separator:aea4adc0413c180d649f00d8759cf63b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae574038db202105a0eccec2ef233be57" id="r_ae574038db202105a0eccec2ef233be57"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:ae574038db202105a0eccec2ef233be57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae574038db202105a0eccec2ef233be57">mod</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, const int base, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:ae574038db202105a0eccec2ef233be57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute elementwise mod: B = A % base.  <br /></td></tr>
<tr class="separator:ae574038db202105a0eccec2ef233be57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0394947bf9e27382711c730186ec631c" id="r_a0394947bf9e27382711c730186ec631c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA &gt; </td></tr>
<tr class="memitem:a0394947bf9e27382711c730186ec631c"><td class="memTemplItemLeft" align="right" valign="top">DerivedA&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0394947bf9e27382711c730186ec631c">mod</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, const int base)</td></tr>
<tr class="memdesc:a0394947bf9e27382711c730186ec631c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0394947bf9e27382711c730186ec631c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037858abb04a677ebd5cdf660de0b0ae" id="r_a037858abb04a677ebd5cdf660de0b0ae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a037858abb04a677ebd5cdf660de0b0ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a037858abb04a677ebd5cdf660de0b0ae">mode</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;X, const int d, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;M)</td></tr>
<tr class="memdesc:a037858abb04a677ebd5cdf660de0b0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes mode of coefficients in a matrix along a given dimension.  <br /></td></tr>
<tr class="separator:a037858abb04a677ebd5cdf660de0b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c8d358cf9fdbac0bd749920e072b84" id="r_ae9c8d358cf9fdbac0bd749920e072b84"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedm0 , typename Derivedm1 , typename Derivedm2 &gt; </td></tr>
<tr class="memitem:ae9c8d358cf9fdbac0bd749920e072b84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae9c8d358cf9fdbac0bd749920e072b84">moments</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Derivedm0 &amp;m0, Eigen::PlainObjectBase&lt; Derivedm1 &gt; &amp;m1, Eigen::PlainObjectBase&lt; Derivedm2 &gt; &amp;m2)</td></tr>
<tr class="memdesc:ae9c8d358cf9fdbac0bd749920e072b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the moments of mass for a solid object bound by a triangle mesh.  <br /></td></tr>
<tr class="separator:ae9c8d358cf9fdbac0bd749920e072b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6d36d1a68f0978c2b20b1586ccc18f" id="r_a2b6d36d1a68f0978c2b20b1586ccc18f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2b6d36d1a68f0978c2b20b1586ccc18f">mvc</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;C, Eigen::MatrixXd &amp;W)</td></tr>
<tr class="memdesc:a2b6d36d1a68f0978c2b20b1586ccc18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mean value coordinates for a polygon.  <br /></td></tr>
<tr class="separator:a2b6d36d1a68f0978c2b20b1586ccc18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330d1e74582084d2c5d7002ecab40baf" id="r_a330d1e74582084d2c5d7002ecab40baf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a330d1e74582084d2c5d7002ecab40baf">nchoosek</a> (const int n, const int k)</td></tr>
<tr class="memdesc:a330d1e74582084d2c5d7002ecab40baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial coefficient.  <br /></td></tr>
<tr class="separator:a330d1e74582084d2c5d7002ecab40baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa3a7446d17387b412677075b546ebb" id="r_a5aa3a7446d17387b412677075b546ebb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedU &gt; </td></tr>
<tr class="memitem:a5aa3a7446d17387b412677075b546ebb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5aa3a7446d17387b412677075b546ebb">nchoosek</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const int k, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U)</td></tr>
<tr class="memdesc:a5aa3a7446d17387b412677075b546ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">All combinations .  <br /></td></tr>
<tr class="separator:a5aa3a7446d17387b412677075b546ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368a81066e3790575847edac849c6aa9" id="r_a368a81066e3790575847edac849c6aa9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a368a81066e3790575847edac849c6aa9">next_filename</a> (const std::string &amp;prefix, const int zeros, const std::string &amp;suffix, std::string &amp;next)</td></tr>
<tr class="memdesc:a368a81066e3790575847edac849c6aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the file with the first filename of the form "prefix%0[zeros]dsuffix".  <br /></td></tr>
<tr class="separator:a368a81066e3790575847edac849c6aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63be3993b067600b578e85bf0fa186a" id="r_af63be3993b067600b578e85bf0fa186a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedEle , typename Scalar &gt; </td></tr>
<tr class="memitem:af63be3993b067600b578e85bf0fa186a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af63be3993b067600b578e85bf0fa186a">normal_derivative</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;Ele, Eigen::SparseMatrix&lt; Scalar &gt; &amp;DD)</td></tr>
<tr class="memdesc:af63be3993b067600b578e85bf0fa186a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the directional derivative <b>normal</b> to <b>all</b> (half-)edges of a triangle mesh (not just boundary edges).  <br /></td></tr>
<tr class="separator:af63be3993b067600b578e85bf0fa186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a8628fb6a1bef5682ad416cfcd0a5e" id="r_a01a8628fb6a1bef5682ad416cfcd0a5e"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:a01a8628fb6a1bef5682ad416cfcd0a5e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a01a8628fb6a1bef5682ad416cfcd0a5e">normalize_quat</a> (const Q_type *q, Q_type *out)</td></tr>
<tr class="memdesc:a01a8628fb6a1bef5682ad416cfcd0a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w.  <br /></td></tr>
<tr class="separator:a01a8628fb6a1bef5682ad416cfcd0a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8799fd07216a41e98f6ccaa39aec488f" id="r_a8799fd07216a41e98f6ccaa39aec488f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedN &gt; </td></tr>
<tr class="memitem:a8799fd07216a41e98f6ccaa39aec488f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8799fd07216a41e98f6ccaa39aec488f">null</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a8799fd07216a41e98f6ccaa39aec488f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a basis for the null space for the given matrix A: the columns of the output N form a basis for the space orthogonal to that spanned by the rows of A.  <br /></td></tr>
<tr class="separator:a8799fd07216a41e98f6ccaa39aec488f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff69240d0614e6f4ab20ff15b2f21a4" id="r_a3ff69240d0614e6f4ab20ff15b2f21a4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename IndexType , typename DerivedCH , typename DerivedCN , typename DerivedW &gt; </td></tr>
<tr class="memitem:a3ff69240d0614e6f4ab20ff15b2f21a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3ff69240d0614e6f4ab20ff15b2f21a4">octree</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;point_indices, Eigen::PlainObjectBase&lt; DerivedCH &gt; &amp;CH, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a3ff69240d0614e6f4ab20ff15b2f21a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of 3D points P, generate data structures for a pointerless octree.  <br /></td></tr>
<tr class="separator:a3ff69240d0614e6f4ab20ff15b2f21a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff5efd1454c4544da0680e4c410b7cf" id="r_afff5efd1454c4544da0680e4c410b7cf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename isolevelType , typename DerivedSV , typename DerivedSF , typename DerivedGV , typename Derivedside , typename DerivedS &gt; </td></tr>
<tr class="memitem:afff5efd1454c4544da0680e4c410b7cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afff5efd1454c4544da0680e4c410b7cf">offset_surface</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const isolevelType isolevel, const typename Derivedside::Scalar s, const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a> &amp;signed_distance_type, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;GV, Eigen::PlainObjectBase&lt; Derivedside &gt; &amp;side, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:afff5efd1454c4544da0680e4c410b7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a triangulated offset surface using matching cubes on a grid of signed distance values from the input triangle mesh.  <br /></td></tr>
<tr class="separator:afff5efd1454c4544da0680e4c410b7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f19762456ef8396dfc4096f34c841e6" id="r_a9f19762456ef8396dfc4096f34c841e6"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT &gt; </td></tr>
<tr class="memitem:a9f19762456ef8396dfc4096f34c841e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9f19762456ef8396dfc4096f34c841e6">on_boundary</a> (const std::vector&lt; std::vector&lt; IntegerT &gt; &gt; &amp;T, std::vector&lt; bool &gt; &amp;I, std::vector&lt; std::vector&lt; bool &gt; &gt; &amp;C)</td></tr>
<tr class="memdesc:a9f19762456ef8396dfc4096f34c841e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine boundary facets of mesh elements stored in T.  <br /></td></tr>
<tr class="separator:a9f19762456ef8396dfc4096f34c841e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0e9a973c6c86bc98645ef61f4d4b43" id="r_acc0e9a973c6c86bc98645ef61f4d4b43"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:acc0e9a973c6c86bc98645ef61f4d4b43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acc0e9a973c6c86bc98645ef61f4d4b43">on_boundary</a> (const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:acc0e9a973c6c86bc98645ef61f4d4b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:acc0e9a973c6c86bc98645ef61f4d4b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76f879f4715d4a8596d28f12bc7161d" id="r_ae76f879f4715d4a8596d28f12bc7161d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DerivedOE &gt; </td></tr>
<tr class="memitem:ae76f879f4715d4a8596d28f12bc7161d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae76f879f4715d4a8596d28f12bc7161d">orient_halfedges</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;oE)</td></tr>
<tr class="memdesc:ae76f879f4715d4a8596d28f12bc7161d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orients halfedges for a triangle mesh, assigning them to a unique edge.  <br /></td></tr>
<tr class="separator:ae76f879f4715d4a8596d28f12bc7161d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13811b519cd4b97b94f6ef8f3fe90f30" id="r_a13811b519cd4b97b94f6ef8f3fe90f30"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedFF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a13811b519cd4b97b94f6ef8f3fe90f30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a13811b519cd4b97b94f6ef8f3fe90f30">orient_outward</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a13811b519cd4b97b94f6ef8f3fe90f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient each component (identified by C) of a mesh (V,F) so the normals on average point away from the patch's centroid.  <br /></td></tr>
<tr class="separator:a13811b519cd4b97b94f6ef8f3fe90f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ea97ba9a25206eb1ba9d7469b371d1" id="r_aa7ea97ba9a25206eb1ba9d7469b371d1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC , typename AScalar &gt; </td></tr>
<tr class="memitem:aa7ea97ba9a25206eb1ba9d7469b371d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa7ea97ba9a25206eb1ba9d7469b371d1">orientable_patches</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; AScalar &gt; &amp;A)</td></tr>
<tr class="memdesc:aa7ea97ba9a25206eb1ba9d7469b371d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of facets connected by manifold edges.  <br /></td></tr>
<tr class="separator:aa7ea97ba9a25206eb1ba9d7469b371d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c31bf9a8576f1775affb93a5722e85" id="r_ad5c31bf9a8576f1775affb93a5722e85"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:ad5c31bf9a8576f1775affb93a5722e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad5c31bf9a8576f1775affb93a5722e85">orientable_patches</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:ad5c31bf9a8576f1775affb93a5722e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad5c31bf9a8576f1775affb93a5722e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9293ec84689fd8949325ccb22d55fb" id="r_a3f9293ec84689fd8949325ccb22d55fb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE &gt; </td></tr>
<tr class="memitem:a3f9293ec84689fd8949325ccb22d55fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3f9293ec84689fd8949325ccb22d55fb">oriented_facets</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:a3f9293ec84689fd8949325ccb22d55fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines all "directed
[facets](https://en.wikipedia.org/wiki/Simplex#Elements)" of a given set of simplicial elements.  <br /></td></tr>
<tr class="separator:a3f9293ec84689fd8949325ccb22d55fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8010396f68fc2ad676aa1a713b6a7bc4" id="r_a8010396f68fc2ad676aa1a713b6a7bc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8010396f68fc2ad676aa1a713b6a7bc4">orth</a> (const Eigen::MatrixXd &amp;A, Eigen::MatrixXd &amp;Q)</td></tr>
<tr class="memdesc:a8010396f68fc2ad676aa1a713b6a7bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalization of a matrix.  <br /></td></tr>
<tr class="separator:a8010396f68fc2ad676aa1a713b6a7bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa53ae1b1d678353d4056c724b7df7c" id="r_a4aa53ae1b1d678353d4056c724b7df7c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP &gt; </td></tr>
<tr class="memitem:a4aa53ae1b1d678353d4056c724b7df7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4aa53ae1b1d678353d4056c724b7df7c">ortho</a> (const typename DerivedP::Scalar left, const typename DerivedP::Scalar right, const typename DerivedP::Scalar bottom, const typename DerivedP::Scalar top, const typename DerivedP::Scalar nearVal, const typename DerivedP::Scalar farVal, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a4aa53ae1b1d678353d4056c724b7df7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the deprecated glOrtho function.  <br /></td></tr>
<tr class="separator:a4aa53ae1b1d678353d4056c724b7df7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf646b1d4c8ad6dd0d2660d0a5cae584" id="r_abf646b1d4c8ad6dd0d2660d0a5cae584"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </td></tr>
<tr class="memitem:abf646b1d4c8ad6dd0d2660d0a5cae584"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abf646b1d4c8ad6dd0d2660d0a5cae584">outer_vertex</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, IndexType &amp;v_index, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:abf646b1d4c8ad6dd0d2660d0a5cae584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a vertex that is reachable from infinite without crossing any faces.  <br /></td></tr>
<tr class="separator:abf646b1d4c8ad6dd0d2660d0a5cae584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1dbaf3fab3346a4956ef93313e488b" id="r_a8a1dbaf3fab3346a4956ef93313e488b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </td></tr>
<tr class="memitem:a8a1dbaf3fab3346a4956ef93313e488b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8a1dbaf3fab3346a4956ef93313e488b">outer_edge</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, IndexType &amp;v1, IndexType &amp;v2, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a8a1dbaf3fab3346a4956ef93313e488b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an edge that is reachable from infinity without crossing any faces.  <br /></td></tr>
<tr class="separator:a8a1dbaf3fab3346a4956ef93313e488b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ea262d61548f3946263a5c00ed0192" id="r_ab8ea262d61548f3946263a5c00ed0192"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename IndexType &gt; </td></tr>
<tr class="memitem:ab8ea262d61548f3946263a5c00ed0192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab8ea262d61548f3946263a5c00ed0192">outer_facet</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, IndexType &amp;f, bool &amp;flipped)</td></tr>
<tr class="memdesc:ab8ea262d61548f3946263a5c00ed0192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a facet that is reachable from infinity without crossing any faces.  <br /></td></tr>
<tr class="separator:ab8ea262d61548f3946263a5c00ed0192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ba3dac8f2da11935cd7e566f27e69d" id="r_a48ba3dac8f2da11935cd7e566f27e69d"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename FunctionType &gt; </td></tr>
<tr class="memitem:a48ba3dac8f2da11935cd7e566f27e69d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a48ba3dac8f2da11935cd7e566f27e69d">parallel_for</a> (const Index loop_size, const FunctionType &amp;func, const size_t min_parallel=0)</td></tr>
<tr class="memdesc:a48ba3dac8f2da11935cd7e566f27e69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional implementation of a basic, open-mp style, parallel for loop.  <br /></td></tr>
<tr class="separator:a48ba3dac8f2da11935cd7e566f27e69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1804e24a4fefa3bbe3e6241bd00f75" id="r_a8e1804e24a4fefa3bbe3e6241bd00f75"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename PrepFunctionType , typename FunctionType , typename AccumFunctionType &gt; </td></tr>
<tr class="memitem:a8e1804e24a4fefa3bbe3e6241bd00f75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8e1804e24a4fefa3bbe3e6241bd00f75">parallel_for</a> (const Index loop_size, const PrepFunctionType &amp;prep_func, const FunctionType &amp;func, const AccumFunctionType &amp;accum_func, const size_t min_parallel=0)</td></tr>
<tr class="memdesc:a8e1804e24a4fefa3bbe3e6241bd00f75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional implementation of an open-mp style, parallel for loop with accumulation.  <br /></td></tr>
<tr class="separator:a8e1804e24a4fefa3bbe3e6241bd00f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842fd7e11ac0c43a81d15fa137337adb" id="r_a842fd7e11ac0c43a81d15fa137337adb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </td></tr>
<tr class="memitem:a842fd7e11ac0c43a81d15fa137337adb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a842fd7e11ac0c43a81d15fa137337adb">parallel_transport_angles</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;FN, const Eigen::MatrixXi &amp;E2F, const Eigen::MatrixXi &amp;F2E, Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;K)</td></tr>
<tr class="memdesc:a842fd7e11ac0c43a81d15fa137337adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the per-face local bases computed via <a class="el" href="namespaceigl.html#a108a662cae580e5c3459d81435f32e24" title="Compute a local orthogonal reference system for each triangle in the given mesh.">igl::local_basis</a>, this function computes the angle between the two reference frames across each edge.  <br /></td></tr>
<tr class="separator:a842fd7e11ac0c43a81d15fa137337adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85fb6c92debf67385c27c8a06c2a1f9" id="r_af85fb6c92debf67385c27c8a06c2a1f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af85fb6c92debf67385c27c8a06c2a1f9">partition</a> (const Eigen::MatrixXd &amp;W, const int k, Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;G, Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;S, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;D)</td></tr>
<tr class="memdesc:af85fb6c92debf67385c27c8a06c2a1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition vertices into groups based on each vertex's vector: vertices with similar coordinates (close in space) will be put in the same group.  <br /></td></tr>
<tr class="separator:af85fb6c92debf67385c27c8a06c2a1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dfa8a07d0d391278ff5023da5ba1bf" id="r_aa9dfa8a07d0d391278ff5023da5ba1bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9dfa8a07d0d391278ff5023da5ba1bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa9dfa8a07d0d391278ff5023da5ba1bf">parula</a> (const T f, T *rgb)</td></tr>
<tr class="memdesc:aa9dfa8a07d0d391278ff5023da5ba1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parula colormap like MATLAB's parula.  <br /></td></tr>
<tr class="separator:aa9dfa8a07d0d391278ff5023da5ba1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a5375852c84e549987ad3aedd7e80e" id="r_a79a5375852c84e549987ad3aedd7e80e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79a5375852c84e549987ad3aedd7e80e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a79a5375852c84e549987ad3aedd7e80e">parula</a> (const T f, T &amp;r, T &amp;g, T &amp;b)</td></tr>
<tr class="memdesc:a79a5375852c84e549987ad3aedd7e80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a79a5375852c84e549987ad3aedd7e80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36caf45296cda61ad8a61ee3772378e7" id="r_a36caf45296cda61ad8a61ee3772378e7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedZ , typename DerivedC &gt; </td></tr>
<tr class="memitem:a36caf45296cda61ad8a61ee3772378e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a36caf45296cda61ad8a61ee3772378e7">parula</a> (const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, const bool normalize, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a36caf45296cda61ad8a61ee3772378e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a36caf45296cda61ad8a61ee3772378e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff59da460d9fa5095c2cd9447fe9a4" id="r_a70ff59da460d9fa5095c2cd9447fe9a4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedZ , typename DerivedC &gt; </td></tr>
<tr class="memitem:a70ff59da460d9fa5095c2cd9447fe9a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a70ff59da460d9fa5095c2cd9447fe9a4">parula</a> (const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, const double min_Z, const double max_Z, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a70ff59da460d9fa5095c2cd9447fe9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a70ff59da460d9fa5095c2cd9447fe9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9dedb9d3d8f684abb92cef75cacdb69" id="r_ad9dedb9d3d8f684abb92cef75cacdb69"><td class="memTemplParams" colspan="2">template&lt;typename DerivedI , typename DerivedE &gt; </td></tr>
<tr class="memitem:ad9dedb9d3d8f684abb92cef75cacdb69"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad9dedb9d3d8f684abb92cef75cacdb69">path_to_edges</a> (const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, bool make_loop=false)</td></tr>
<tr class="memdesc:ad9dedb9d3d8f684abb92cef75cacdb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a path as an ordered list of N&gt;=2 vertex indices I[0], I[1], ..., I[N-1] construct a list of edges [[I[0],I[1]], [I[1],I[2]], ..., [I[N-2], I[N-1]]] connecting each sequential pair of vertices.  <br /></td></tr>
<tr class="separator:ad9dedb9d3d8f684abb92cef75cacdb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2ac47ac2adbe917283d5dd317dab36" id="r_abc2ac47ac2adbe917283d5dd317dab36"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename DerivedE &gt; </td></tr>
<tr class="memitem:abc2ac47ac2adbe917283d5dd317dab36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abc2ac47ac2adbe917283d5dd317dab36">path_to_edges</a> (const std::vector&lt; Index &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, bool make_loop=false)</td></tr>
<tr class="memdesc:abc2ac47ac2adbe917283d5dd317dab36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abc2ac47ac2adbe917283d5dd317dab36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35cb149bbe78233befd8a3fcbf0bf0f9" id="r_a35cb149bbe78233befd8a3fcbf0bf0f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a35cb149bbe78233befd8a3fcbf0bf0f9">path_to_executable</a> ()</td></tr>
<tr class="memdesc:a35cb149bbe78233befd8a3fcbf0bf0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to current executable.  <br /></td></tr>
<tr class="separator:a35cb149bbe78233befd8a3fcbf0bf0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541dccb34e02684e3d43966fca86bdaf" id="r_a541dccb34e02684e3d43966fca86bdaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a541dccb34e02684e3d43966fca86bdaf">pathinfo</a> (const std::string &amp;path, std::string &amp;<a class="el" href="namespaceigl.html#aef1ff1d390be65861384b6ff764ebe09">dirname</a>, std::string &amp;<a class="el" href="namespaceigl.html#aa32f08d2b80c8d69515001b7d6347e82">basename</a>, std::string &amp;<a class="el" href="namespaceigl.html#af53e1e0ea4e1632ee9d5b5a6411093e2">extension</a>, std::string &amp;filename)</td></tr>
<tr class="memdesc:a541dccb34e02684e3d43966fca86bdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function like PHP's pathinfo to return information about path.  <br /></td></tr>
<tr class="separator:a541dccb34e02684e3d43966fca86bdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a09c2edf78994c6f25f23a9212a3666" id="r_a3a09c2edf78994c6f25f23a9212a3666"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedCN &gt; </td></tr>
<tr class="memitem:a3a09c2edf78994c6f25f23a9212a3666"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3a09c2edf78994c6f25f23a9212a3666">per_corner_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedV::Scalar corner_threshold_degrees, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN)</td></tr>
<tr class="memdesc:a3a09c2edf78994c6f25f23a9212a3666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute per corner normals for a triangle mesh by computing the area-weighted average of normals at incident faces whose normals deviate less than the provided threshold.  <br /></td></tr>
<tr class="separator:a3a09c2edf78994c6f25f23a9212a3666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1038de65b964583d4ea533a631e6c1b8" id="r_a1038de65b964583d4ea533a631e6c1b8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVF , typename DerivedNI , typename DerivedCN &gt; </td></tr>
<tr class="memitem:a1038de65b964583d4ea533a631e6c1b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1038de65b964583d4ea533a631e6c1b8">per_corner_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedV::Scalar corner_threshold_degrees, const Eigen::MatrixBase&lt; DerivedVF &gt; &amp;VF, const Eigen::MatrixBase&lt; DerivedNI &gt; &amp;NI, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN)</td></tr>
<tr class="memdesc:a1038de65b964583d4ea533a631e6c1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1038de65b964583d4ea533a631e6c1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b4e893d7a38a99124fb826f0f337c1" id="r_a01b4e893d7a38a99124fb826f0f337c1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedCI , typename DerivedCC , typename DerivedCN &gt; </td></tr>
<tr class="memitem:a01b4e893d7a38a99124fb826f0f337c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a01b4e893d7a38a99124fb826f0f337c1">per_corner_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedCI &gt; &amp;CI, const Eigen::MatrixBase&lt; DerivedCC &gt; &amp;CC, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN)</td></tr>
<tr class="separator:a01b4e893d7a38a99124fb826f0f337c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d1344faa3702f4c79dcdf54888c68" id="r_aac0d1344faa3702f4c79dcdf54888c68"><td class="memTemplParams" colspan="2">template&lt;typename DerivedNV , typename DerivedNF , typename DerivedCN &gt; </td></tr>
<tr class="memitem:aac0d1344faa3702f4c79dcdf54888c68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aac0d1344faa3702f4c79dcdf54888c68">per_corner_normals</a> (const Eigen::MatrixBase&lt; DerivedNV &gt; &amp;NV, const Eigen::MatrixBase&lt; DerivedNF &gt; &amp;NF, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN)</td></tr>
<tr class="memdesc:aac0d1344faa3702f4c79dcdf54888c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given indexed normals (e.g., read from a .obj file), explode into per-corner normals (e.g., as expected by <a class="el" href="classigl_1_1opengl_1_1ViewerData.html" title="Object being drawn (i.e., mesh and its accessories) by the ViewerCore.">igl::opengl::ViewerData</a>)  <br /></td></tr>
<tr class="separator:aac0d1344faa3702f4c79dcdf54888c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4353bfd8d4ca70d1ea3bdf98dbfb50f4" id="r_a4353bfd8d4ca70d1ea3bdf98dbfb50f4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename DerivedVV , typename DerivedFF , typename DerivedJ , typename DerivedNN &gt; </td></tr>
<tr class="memitem:a4353bfd8d4ca70d1ea3bdf98dbfb50f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4353bfd8d4ca70d1ea3bdf98dbfb50f4">per_corner_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const typename DerivedV::Scalar corner_threshold_degrees, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;VV, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedNN &gt; &amp;NN)</td></tr>
<tr class="memdesc:a4353bfd8d4ca70d1ea3bdf98dbfb50f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-corner normals for a polygon mesh.  <br /></td></tr>
<tr class="separator:a4353bfd8d4ca70d1ea3bdf98dbfb50f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0359520eb722b81b3460a2dc23178e2" id="r_ae0359520eb722b81b3460a2dc23178e2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedN , typename DerivedE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:ae0359520eb722b81b3460a2dc23178e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae0359520eb722b81b3460a2dc23178e2">per_edge_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">PerEdgeNormalsWeightingType</a> weight, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:ae0359520eb722b81b3460a2dc23178e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face normals via vertex position list, face list.  <br /></td></tr>
<tr class="separator:ae0359520eb722b81b3460a2dc23178e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd393d9be7212b4986f0e14328e4acc" id="r_accd393d9be7212b4986f0e14328e4acc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:accd393d9be7212b4986f0e14328e4acc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#accd393d9be7212b4986f0e14328e4acc">per_edge_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">PerEdgeNormalsWeightingType</a> weight, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:accd393d9be7212b4986f0e14328e4acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:accd393d9be7212b4986f0e14328e4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c6976aa15d2689a00df1cbb695776" id="r_abe5c6976aa15d2689a00df1cbb695776"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:abe5c6976aa15d2689a00df1cbb695776"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abe5c6976aa15d2689a00df1cbb695776">per_edge_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:abe5c6976aa15d2689a00df1cbb695776"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abe5c6976aa15d2689a00df1cbb695776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d793baadcefcf122deae556812b2406" id="r_a3d793baadcefcf122deae556812b2406"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedZ , typename DerivedN &gt; </td></tr>
<tr class="memitem:a3d793baadcefcf122deae556812b2406"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3d793baadcefcf122deae556812b2406">per_face_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;Z, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a3d793baadcefcf122deae556812b2406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute face normals via vertex position list, face list.  <br /></td></tr>
<tr class="separator:a3d793baadcefcf122deae556812b2406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e240d2506aa22bb2a07edd7636d6cb" id="r_aa5e240d2506aa22bb2a07edd7636d6cb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:aa5e240d2506aa22bb2a07edd7636d6cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa5e240d2506aa22bb2a07edd7636d6cb">per_face_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:aa5e240d2506aa22bb2a07edd7636d6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa5e240d2506aa22bb2a07edd7636d6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d8e3459f18186d9cbfd36ba4c053bc" id="r_a49d8e3459f18186d9cbfd36ba4c053bc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:a49d8e3459f18186d9cbfd36ba4c053bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a49d8e3459f18186d9cbfd36ba4c053bc">per_face_normals_stable</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a49d8e3459f18186d9cbfd36ba4c053bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a49d8e3459f18186d9cbfd36ba4c053bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95670a831d56f91f1afdd042cc8ae97b" id="r_a95670a831d56f91f1afdd042cc8ae97b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename DerivedVV , typename DerivedFF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a95670a831d56f91f1afdd042cc8ae97b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a95670a831d56f91f1afdd042cc8ae97b">per_face_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;VV, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a95670a831d56f91f1afdd042cc8ae97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per face normals for a general polygon mesh.  <br /></td></tr>
<tr class="separator:a95670a831d56f91f1afdd042cc8ae97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55694e78e07c4a2640cbfa122fa3deed" id="r_a55694e78e07c4a2640cbfa122fa3deed"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a55694e78e07c4a2640cbfa122fa3deed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a55694e78e07c4a2640cbfa122fa3deed">per_vertex_attribute_smoothing</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;Ain, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;Aout)</td></tr>
<tr class="memdesc:a55694e78e07c4a2640cbfa122fa3deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth vertex attributes using uniform Laplacian.  <br /></td></tr>
<tr class="separator:a55694e78e07c4a2640cbfa122fa3deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d913043c5590b413bc2ea64adae0c17" id="r_a7d913043c5590b413bc2ea64adae0c17"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:a7d913043c5590b413bc2ea64adae0c17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7d913043c5590b413bc2ea64adae0c17">per_vertex_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">igl::PerVertexNormalsWeightingType</a> weighting, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a7d913043c5590b413bc2ea64adae0c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute vertex normals via vertex position list, face list.  <br /></td></tr>
<tr class="separator:a7d913043c5590b413bc2ea64adae0c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0ea8f0fee8d96f0acbda506d40fe2d" id="r_a3b0ea8f0fee8d96f0acbda506d40fe2d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:a3b0ea8f0fee8d96f0acbda506d40fe2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3b0ea8f0fee8d96f0acbda506d40fe2d">per_vertex_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a3b0ea8f0fee8d96f0acbda506d40fe2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3b0ea8f0fee8d96f0acbda506d40fe2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29a9edc300d4684a03a6d656d2d715c" id="r_aa29a9edc300d4684a03a6d656d2d715c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedN &gt; </td></tr>
<tr class="memitem:aa29a9edc300d4684a03a6d656d2d715c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa29a9edc300d4684a03a6d656d2d715c">per_vertex_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">PerVertexNormalsWeightingType</a> weighting, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:aa29a9edc300d4684a03a6d656d2d715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa29a9edc300d4684a03a6d656d2d715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addca97c5fd3aeb0c2ed9fb260b020092" id="r_addca97c5fd3aeb0c2ed9fb260b020092"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedN &gt; </td></tr>
<tr class="memitem:addca97c5fd3aeb0c2ed9fb260b020092"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#addca97c5fd3aeb0c2ed9fb260b020092">per_vertex_normals</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:addca97c5fd3aeb0c2ed9fb260b020092"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:addca97c5fd3aeb0c2ed9fb260b020092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac6a5f35466ea9216e1de32fecaf032" id="r_a3ac6a5f35466ea9216e1de32fecaf032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3ac6a5f35466ea9216e1de32fecaf032">per_vertex_point_to_plane_quadrics</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI, std::vector&lt; std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; &gt; &amp;quadrics)</td></tr>
<tr class="memdesc:a3ac6a5f35466ea9216e1de32fecaf032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute quadrics per vertex of a "closed" triangle mesh (V,F).  <br /></td></tr>
<tr class="separator:a3ac6a5f35466ea9216e1de32fecaf032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edfc37639a2817ac5ffde534ec7391a" id="r_a9edfc37639a2817ac5ffde534ec7391a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DeriveduE , typename DeriveduEC , typename DeriveduEE &gt; </td></tr>
<tr class="memitem:a9edfc37639a2817ac5ffde534ec7391a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9edfc37639a2817ac5ffde534ec7391a">piecewise_constant_winding_number</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;uE, const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;uEE)</td></tr>
<tr class="memdesc:a9edfc37639a2817ac5ffde534ec7391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations.  <br /></td></tr>
<tr class="separator:a9edfc37639a2817ac5ffde534ec7391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4321fc08252fa849e3fa6f47f3047fd9" id="r_a4321fc08252fa849e3fa6f47f3047fd9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF &gt; </td></tr>
<tr class="memitem:a4321fc08252fa849e3fa6f47f3047fd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4321fc08252fa849e3fa6f47f3047fd9">piecewise_constant_winding_number</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a4321fc08252fa849e3fa6f47f3047fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4321fc08252fa849e3fa6f47f3047fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad226f56507bf0f6f88843734531e04cb" id="r_ad226f56507bf0f6f88843734531e04cb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedX &gt; </td></tr>
<tr class="memitem:ad226f56507bf0f6f88843734531e04cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad226f56507bf0f6f88843734531e04cb">pinv</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, typename DerivedA::Scalar tol, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X)</td></tr>
<tr class="memdesc:ad226f56507bf0f6f88843734531e04cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Moore-Penrose pseudoinverse.  <br /></td></tr>
<tr class="separator:ad226f56507bf0f6f88843734531e04cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e789f2ff1ea85406f3c41468c7f1b5" id="r_a11e789f2ff1ea85406f3c41468c7f1b5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedX &gt; </td></tr>
<tr class="memitem:a11e789f2ff1ea85406f3c41468c7f1b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a11e789f2ff1ea85406f3c41468c7f1b5">pinv</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X)</td></tr>
<tr class="memdesc:a11e789f2ff1ea85406f3c41468c7f1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a11e789f2ff1ea85406f3c41468c7f1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6123b286eebf1eb6e5ca4957ae2b89" id="r_a4a6123b286eebf1eb6e5ca4957ae2b89"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a4a6123b286eebf1eb6e5ca4957ae2b89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4a6123b286eebf1eb6e5ca4957ae2b89">planarize_quad_mesh</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;Vin, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int maxIter, const double &amp;threshold, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;Vout)</td></tr>
<tr class="memdesc:a4a6123b286eebf1eb6e5ca4957ae2b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Planarizes a given quad mesh using the algorithm described in the paper "Shape-Up: Shaping Discrete Geometry with Projections" by S.  <br /></td></tr>
<tr class="separator:a4a6123b286eebf1eb6e5ca4957ae2b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dad55e28df3f93b606cddb108b85e9d" id="r_a0dad55e28df3f93b606cddb108b85e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0dad55e28df3f93b606cddb108b85e9d">point_in_circle</a> (const double qx, const double qy, const double cx, const double cy, const double r)</td></tr>
<tr class="memdesc:a0dad55e28df3f93b606cddb108b85e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if 2d point is in a circle.  <br /></td></tr>
<tr class="separator:a0dad55e28df3f93b606cddb108b85e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9616bb9fd33e6c00dcb4e8f91952091" id="r_ae9616bb9fd33e6c00dcb4e8f91952091"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedV , typename DerivedEle , typename DerivedsqrD , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:ae9616bb9fd33e6c00dcb4e8f91952091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae9616bb9fd33e6c00dcb4e8f91952091">point_mesh_squared_distance</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;Ele, Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;sqrD, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:ae9616bb9fd33e6c00dcb4e8f91952091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distances from a set of points P to a triangle mesh (V,F)  <br /></td></tr>
<tr class="separator:ae9616bb9fd33e6c00dcb4e8f91952091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c64da392edc068d98cf9c78ec8a6ee3" id="r_a8c64da392edc068d98cf9c78ec8a6ee3"><td class="memTemplParams" colspan="2">template&lt;int DIM, typename Derivedp , typename DerivedV , typename DerivedEle , typename Derivedsqr_d , typename Derivedc &gt; </td></tr>
<tr class="memitem:a8c64da392edc068d98cf9c78ec8a6ee3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8c64da392edc068d98cf9c78ec8a6ee3">point_simplex_squared_distance</a> (const Eigen::MatrixBase&lt; Derivedp &gt; &amp;p, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;Ele, const typename DerivedEle::Index i, Derivedsqr_d &amp;sqr_d, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c)</td></tr>
<tr class="memdesc:a8c64da392edc068d98cf9c78ec8a6ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine squared distance from a point to linear simplex.  <br /></td></tr>
<tr class="separator:a8c64da392edc068d98cf9c78ec8a6ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937e7f60501c5fa10d8ddf3aba6e3d2e" id="r_a937e7f60501c5fa10d8ddf3aba6e3d2e"><td class="memTemplParams" colspan="2">template&lt;int DIM, typename Derivedp , typename DerivedV , typename DerivedEle , typename Derivedsqr_d , typename Derivedc , typename Derivedb &gt; </td></tr>
<tr class="memitem:a937e7f60501c5fa10d8ddf3aba6e3d2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a937e7f60501c5fa10d8ddf3aba6e3d2e">point_simplex_squared_distance</a> (const Eigen::MatrixBase&lt; Derivedp &gt; &amp;p, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;Ele, const typename DerivedEle::Index i, Derivedsqr_d &amp;sqr_d, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, Eigen::PlainObjectBase&lt; Derivedb &gt; &amp;b)</td></tr>
<tr class="memdesc:a937e7f60501c5fa10d8ddf3aba6e3d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine squared distance from a point to linear simplex.  <br /></td></tr>
<tr class="separator:a937e7f60501c5fa10d8ddf3aba6e3d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef4fd6ebad61768a405ac601011aa83" id="r_adef4fd6ebad61768a405ac601011aa83"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </td></tr>
<tr class="memitem:adef4fd6ebad61768a405ac601011aa83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adef4fd6ebad61768a405ac601011aa83">polar_dec</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, bool includeReflections, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:adef4fd6ebad61768a405ac601011aa83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the polar decomposition (R,T) of a matrix A.  <br /></td></tr>
<tr class="separator:adef4fd6ebad61768a405ac601011aa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4542a1ce3e5fc92a58929332bf0d5afe" id="r_a4542a1ce3e5fc92a58929332bf0d5afe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:a4542a1ce3e5fc92a58929332bf0d5afe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4542a1ce3e5fc92a58929332bf0d5afe">polar_dec</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, const bool includeReflections, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:a4542a1ce3e5fc92a58929332bf0d5afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4542a1ce3e5fc92a58929332bf0d5afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cc516e97872405063d0bcf3005f99e" id="r_af5cc516e97872405063d0bcf3005f99e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </td></tr>
<tr class="memitem:af5cc516e97872405063d0bcf3005f99e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af5cc516e97872405063d0bcf3005f99e">polar_dec</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:af5cc516e97872405063d0bcf3005f99e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af5cc516e97872405063d0bcf3005f99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e10aea297c30b7daf1616d1eba2a4f" id="r_a32e10aea297c30b7daf1616d1eba2a4f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:a32e10aea297c30b7daf1616d1eba2a4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a32e10aea297c30b7daf1616d1eba2a4f">polar_dec</a> (const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:a32e10aea297c30b7daf1616d1eba2a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a32e10aea297c30b7daf1616d1eba2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0b3fd9e1e8dbf5c6ddb9750f575b77" id="r_aaa0b3fd9e1e8dbf5c6ddb9750f575b77"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </td></tr>
<tr class="memitem:aaa0b3fd9e1e8dbf5c6ddb9750f575b77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aaa0b3fd9e1e8dbf5c6ddb9750f575b77">polar_svd</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, bool includeReflections, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:aaa0b3fd9e1e8dbf5c6ddb9750f575b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the polar decomposition (R,T) of a matrix A using SVD singular value decomposition.  <br /></td></tr>
<tr class="separator:aaa0b3fd9e1e8dbf5c6ddb9750f575b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9357cd43402973e99dcba962cdc1c8f9" id="r_a9357cd43402973e99dcba962cdc1c8f9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:a9357cd43402973e99dcba962cdc1c8f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9357cd43402973e99dcba962cdc1c8f9">polar_svd</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const bool includeReflections, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:a9357cd43402973e99dcba962cdc1c8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9357cd43402973e99dcba962cdc1c8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf5509fee9fb84f1bce5173d27cb3e4" id="r_a5bf5509fee9fb84f1bce5173d27cb3e4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </td></tr>
<tr class="memitem:a5bf5509fee9fb84f1bce5173d27cb3e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5bf5509fee9fb84f1bce5173d27cb3e4">polar_svd</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:a5bf5509fee9fb84f1bce5173d27cb3e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5bf5509fee9fb84f1bce5173d27cb3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299b725f8b4d5586c64c2c5e22a242db" id="r_a299b725f8b4d5586c64c2c5e22a242db"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:a299b725f8b4d5586c64c2c5e22a242db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a299b725f8b4d5586c64c2c5e22a242db">polar_svd</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:a299b725f8b4d5586c64c2c5e22a242db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a299b725f8b4d5586c64c2c5e22a242db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fc94343abfa102d5a9b95e8faca581" id="r_a78fc94343abfa102d5a9b95e8faca581"><td class="memTemplParams" colspan="2">template&lt;typename Mat &gt; </td></tr>
<tr class="memitem:a78fc94343abfa102d5a9b95e8faca581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a78fc94343abfa102d5a9b95e8faca581">polar_svd3x3</a> (const Mat &amp;A, Mat &amp;R)</td></tr>
<tr class="memdesc:a78fc94343abfa102d5a9b95e8faca581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the closest rotation to input matrix A using specialized 3x3 SVD singular value decomposition (WunderSVD3x3)  <br /></td></tr>
<tr class="separator:a78fc94343abfa102d5a9b95e8faca581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e0eb6f9263af4777dc45bc136e1fd" id="r_ae45e0eb6f9263af4777dc45bc136e1fd"><td class="memTemplParams" colspan="2">template&lt;typename PType , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:ae45e0eb6f9263af4777dc45bc136e1fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae45e0eb6f9263af4777dc45bc136e1fd">polygon_corners</a> (const std::vector&lt; std::vector&lt; PType &gt; &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:ae45e0eb6f9263af4777dc45bc136e1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list-of-lists polygon mesh faces representation to list of polygon corners and sizes.  <br /></td></tr>
<tr class="separator:ae45e0eb6f9263af4777dc45bc136e1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5393c55c226b5d9d116837047c016f14" id="r_a5393c55c226b5d9d116837047c016f14"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:a5393c55c226b5d9d116837047c016f14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5393c55c226b5d9d116837047c016f14">polygon_corners</a> (const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a5393c55c226b5d9d116837047c016f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5393c55c226b5d9d116837047c016f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c951f3fc9bfbbd0c78c007fd43c8337" id="r_a5c951f3fc9bfbbd0c78c007fd43c8337"><td class="memTemplParams" colspan="2">template&lt;typename DerivedI , typename DerivedC , typename DerivedF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a5c951f3fc9bfbbd0c78c007fd43c8337"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5c951f3fc9bfbbd0c78c007fd43c8337">polygons_to_triangles</a> (const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a5c951f3fc9bfbbd0c78c007fd43c8337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a polygon mesh, trivially triangulate each polygon with a fan.  <br /></td></tr>
<tr class="separator:a5c951f3fc9bfbbd0c78c007fd43c8337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381027e74d14b6e7adb31c0565a26027" id="r_a381027e74d14b6e7adb31c0565a26027"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedPD1 , typename DerivedPD2 , typename DerivedPV1 , typename DerivedPV2 &gt; </td></tr>
<tr class="memitem:a381027e74d14b6e7adb31c0565a26027"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a381027e74d14b6e7adb31c0565a26027">principal_curvature</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedPD1 &gt; &amp;PD1, Eigen::PlainObjectBase&lt; DerivedPD2 &gt; &amp;PD2, Eigen::PlainObjectBase&lt; DerivedPV1 &gt; &amp;PV1, Eigen::PlainObjectBase&lt; DerivedPV2 &gt; &amp;PV2, unsigned radius=5, bool useKring=true)</td></tr>
<tr class="memdesc:a381027e74d14b6e7adb31c0565a26027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the principal curvature directions and magnitude of the given triangle mesh DerivedV derived from vertex positions matrix type: i.e.  <br /></td></tr>
<tr class="separator:a381027e74d14b6e7adb31c0565a26027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1521eb853db32a29fdb6eacbf3ad9fc2" id="r_a1521eb853db32a29fdb6eacbf3ad9fc2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedPD1 , typename DerivedPD2 , typename DerivedPV1 , typename DerivedPV2 , typename Index &gt; </td></tr>
<tr class="memitem:a1521eb853db32a29fdb6eacbf3ad9fc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1521eb853db32a29fdb6eacbf3ad9fc2">principal_curvature</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedPD1 &gt; &amp;PD1, Eigen::PlainObjectBase&lt; DerivedPD2 &gt; &amp;PD2, Eigen::PlainObjectBase&lt; DerivedPV1 &gt; &amp;PV1, Eigen::PlainObjectBase&lt; DerivedPV2 &gt; &amp;PV2, std::vector&lt; Index &gt; &amp;bad_vertices, unsigned radius=5, bool useKring=true)</td></tr>
<tr class="memdesc:a1521eb853db32a29fdb6eacbf3ad9fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1521eb853db32a29fdb6eacbf3ad9fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f935d00d75dd71d9b65d2f6a7fe4a19" id="r_a0f935d00d75dd71d9b65d2f6a7fe4a19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f935d00d75dd71d9b65d2f6a7fe4a19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0f935d00d75dd71d9b65d2f6a7fe4a19">print_ijv</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;X, const int offset=0)</td></tr>
<tr class="memdesc:a0f935d00d75dd71d9b65d2f6a7fe4a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a 3 column matrix representing [I,J,V] = find(X).  <br /></td></tr>
<tr class="separator:a0f935d00d75dd71d9b65d2f6a7fe4a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d05e9d7e5d74e1a763370ff141d3628" id="r_a5d05e9d7e5d74e1a763370ff141d3628"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d05e9d7e5d74e1a763370ff141d3628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5d05e9d7e5d74e1a763370ff141d3628">print_vector</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;v)</td></tr>
<tr class="separator:a5d05e9d7e5d74e1a763370ff141d3628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59761c584c133e800d3e0f34dfa717cc" id="r_a59761c584c133e800d3e0f34dfa717cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59761c584c133e800d3e0f34dfa717cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a59761c584c133e800d3e0f34dfa717cc">print_vector</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;v)</td></tr>
<tr class="separator:a59761c584c133e800d3e0f34dfa717cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f43ea8a5c6f5622b8340b9d9d5d3936" id="r_a6f43ea8a5c6f5622b8340b9d9d5d3936"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename Scalar , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:a6f43ea8a5c6f5622b8340b9d9d5d3936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6f43ea8a5c6f5622b8340b9d9d5d3936">procrustes</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const bool includeScaling, const bool includeReflections, Scalar &amp;scale, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;t)</td></tr>
<tr class="memdesc:a6f43ea8a5c6f5622b8340b9d9d5d3936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve Procrustes problem in d dimensions.  <br /></td></tr>
<tr class="separator:a6f43ea8a5c6f5622b8340b9d9d5d3936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71995610b0f5d6e170ea2748950c0138" id="r_a71995610b0f5d6e170ea2748950c0138"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename Scalar , int DIM, int TType&gt; </td></tr>
<tr class="memitem:a71995610b0f5d6e170ea2748950c0138"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a71995610b0f5d6e170ea2748950c0138">procrustes</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const bool includeScaling, const bool includeReflections, Eigen::Transform&lt; Scalar, DIM, TType &gt; &amp;T)</td></tr>
<tr class="memdesc:a71995610b0f5d6e170ea2748950c0138"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a71995610b0f5d6e170ea2748950c0138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f02fa686c9416188ccb0b47bbb41985" id="r_a2f02fa686c9416188ccb0b47bbb41985"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:a2f02fa686c9416188ccb0b47bbb41985"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2f02fa686c9416188ccb0b47bbb41985">procrustes</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const bool includeScaling, const bool includeReflections, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;t)</td></tr>
<tr class="memdesc:a2f02fa686c9416188ccb0b47bbb41985"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2f02fa686c9416188ccb0b47bbb41985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5807bccc7e6795e024af55047f473e6" id="r_aa5807bccc7e6795e024af55047f473e6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT &gt; </td></tr>
<tr class="memitem:aa5807bccc7e6795e024af55047f473e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa5807bccc7e6795e024af55047f473e6">procrustes</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;t)</td></tr>
<tr class="memdesc:aa5807bccc7e6795e024af55047f473e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa5807bccc7e6795e024af55047f473e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1805a74d6529030a2eb932a6f2fa0" id="r_ab2b1805a74d6529030a2eb932a6f2fa0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename Scalar , typename DerivedT &gt; </td></tr>
<tr class="memitem:ab2b1805a74d6529030a2eb932a6f2fa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab2b1805a74d6529030a2eb932a6f2fa0">procrustes</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, Eigen::Rotation2D&lt; Scalar &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;t)</td></tr>
<tr class="memdesc:ab2b1805a74d6529030a2eb932a6f2fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab2b1805a74d6529030a2eb932a6f2fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea21608bab1115f54a773ade037824bd" id="r_aea21608bab1115f54a773ade037824bd"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aea21608bab1115f54a773ade037824bd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aea21608bab1115f54a773ade037824bd">project</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;obj, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;model, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;proj, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;viewport)</td></tr>
<tr class="memdesc:aea21608bab1115f54a773ade037824bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen reimplementation of gluProject.  <br /></td></tr>
<tr class="separator:aea21608bab1115f54a773ade037824bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7eb3109db11f7024416cd77670e4bb6" id="r_af7eb3109db11f7024416cd77670e4bb6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP &gt; </td></tr>
<tr class="memitem:af7eb3109db11f7024416cd77670e4bb6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af7eb3109db11f7024416cd77670e4bb6">project</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;model, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;proj, const Eigen::MatrixBase&lt; DerivedO &gt; &amp;viewport, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:af7eb3109db11f7024416cd77670e4bb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af7eb3109db11f7024416cd77670e4bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f14c3d07d3f875efa80645432c32b8" id="r_a33f14c3d07d3f875efa80645432c32b8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedU , typename DerivedUF , typename Scalar &gt; </td></tr>
<tr class="memitem:a33f14c3d07d3f875efa80645432c32b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a33f14c3d07d3f875efa80645432c32b8">project_isometrically_to_plane</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedUF &gt; &amp;UF, Eigen::SparseMatrix&lt; Scalar &gt; &amp;I)</td></tr>
<tr class="memdesc:a33f14c3d07d3f875efa80645432c32b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project each triangle to the plane.  <br /></td></tr>
<tr class="separator:a33f14c3d07d3f875efa80645432c32b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a1c901184c35afeb294420a2cfe4f5" id="r_a51a1c901184c35afeb294420a2cfe4f5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD &gt; </td></tr>
<tr class="memitem:a51a1c901184c35afeb294420a2cfe4f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a51a1c901184c35afeb294420a2cfe4f5">project_to_line</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;t, Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;sqrD)</td></tr>
<tr class="memdesc:a51a1c901184c35afeb294420a2cfe4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project points onto vectors, that is find the parameter t for a point p such that proj_p = (y-x).  <br /></td></tr>
<tr class="separator:a51a1c901184c35afeb294420a2cfe4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f357976c09a2f618f23fa9710bbf5c" id="r_aa6f357976c09a2f618f23fa9710bbf5c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aa6f357976c09a2f618f23fa9710bbf5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa6f357976c09a2f618f23fa9710bbf5c">project_to_line</a> (const Scalar px, const Scalar py, const Scalar pz, const Scalar sx, const Scalar sy, const Scalar sz, const Scalar dx, const Scalar dy, const Scalar dz, Scalar &amp;projpx, Scalar &amp;projpy, Scalar &amp;projpz, Scalar &amp;t, Scalar &amp;sqrd)</td></tr>
<tr class="memdesc:aa6f357976c09a2f618f23fa9710bbf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa6f357976c09a2f618f23fa9710bbf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3608b109e5112e5f70ff99cbdd56af0a" id="r_a3608b109e5112e5f70ff99cbdd56af0a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3608b109e5112e5f70ff99cbdd56af0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3608b109e5112e5f70ff99cbdd56af0a">project_to_line</a> (const Scalar px, const Scalar py, const Scalar pz, const Scalar sx, const Scalar sy, const Scalar sz, const Scalar dx, const Scalar dy, const Scalar dz, Scalar &amp;t, Scalar &amp;sqrd)</td></tr>
<tr class="memdesc:a3608b109e5112e5f70ff99cbdd56af0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3608b109e5112e5f70ff99cbdd56af0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc57864ef37d9b1d37f52bb65fccc07" id="r_a1dc57864ef37d9b1d37f52bb65fccc07"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD &gt; </td></tr>
<tr class="memitem:a1dc57864ef37d9b1d37f52bb65fccc07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1dc57864ef37d9b1d37f52bb65fccc07">project_to_line_segment</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const Eigen::MatrixBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;t, Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;sqrD)</td></tr>
<tr class="memdesc:a1dc57864ef37d9b1d37f52bb65fccc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project points onto vectors, that is find the parameter t for a point p such that proj_p = (y-x).  <br /></td></tr>
<tr class="separator:a1dc57864ef37d9b1d37f52bb65fccc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2bb56a9aea43d8fc3108544294915" id="r_a6cc2bb56a9aea43d8fc3108544294915"><td class="memTemplParams" colspan="2">template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a6cc2bb56a9aea43d8fc3108544294915"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6cc2bb56a9aea43d8fc3108544294915">projection_constraint</a> (const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;VP, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a6cc2bb56a9aea43d8fc3108544294915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct two constraint equations for projecting a point to the screen.  <br /></td></tr>
<tr class="separator:a6cc2bb56a9aea43d8fc3108544294915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55630c2a7977e397d8b8fbc562a05bc5" id="r_a55630c2a7977e397d8b8fbc562a05bc5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn &gt; </td></tr>
<tr class="memitem:a55630c2a7977e397d8b8fbc562a05bc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a55630c2a7977e397d8b8fbc562a05bc5">pseudonormal_test</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;VN, const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;EN, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, const int f, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, Scalar &amp;s, Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;n)</td></tr>
<tr class="memdesc:a55630c2a7977e397d8b8fbc562a05bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh (V,F), a query point q, and a point on (V,F) c, determine whether q is inside (V,F) --&gt; s=-1 or outside (V,F) s=1, based on the sign of the dot product between (q-c) and n, where n is the normal <em>at c</em>, carefully chosen according to [Bærentzen &amp; Aanæs 2005].  <br /></td></tr>
<tr class="separator:a55630c2a7977e397d8b8fbc562a05bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d059b63286144db10a9dc08d5083d2" id="r_a56d059b63286144db10a9dc08d5083d2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedEN , typename DerivedVN , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn &gt; </td></tr>
<tr class="memitem:a56d059b63286144db10a9dc08d5083d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a56d059b63286144db10a9dc08d5083d2">pseudonormal_test</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;EN, const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;VN, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, const int e, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, Scalar &amp;s, Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;n)</td></tr>
<tr class="memdesc:a56d059b63286144db10a9dc08d5083d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a56d059b63286144db10a9dc08d5083d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011d3a109b2f48a5285cb49b1cf1f288" id="r_a011d3a109b2f48a5285cb49b1cf1f288"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB &gt; </td></tr>
<tr class="memitem:a011d3a109b2f48a5285cb49b1cf1f288"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a011d3a109b2f48a5285cb49b1cf1f288">pso</a> (const std::function&lt; Scalar(DerivedX &amp;) &gt; f, const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;LB, const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;UB, const int max_iters, const int population, DerivedX &amp;X)</td></tr>
<tr class="memdesc:a011d3a109b2f48a5285cb49b1cf1f288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global optimization with the particle swarm algorithm.  <br /></td></tr>
<tr class="separator:a011d3a109b2f48a5285cb49b1cf1f288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1cad08724f66e0be85d15317bb5f11" id="r_a1b1cad08724f66e0be85d15317bb5f11"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB , typename DerivedP &gt; </td></tr>
<tr class="memitem:a1b1cad08724f66e0be85d15317bb5f11"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1b1cad08724f66e0be85d15317bb5f11">pso</a> (const std::function&lt; Scalar(DerivedX &amp;) &gt; f, const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;LB, const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;UB, const Eigen::DenseBase&lt; DerivedP &gt; &amp;P, const int max_iters, const int population, DerivedX &amp;X)</td></tr>
<tr class="memdesc:a1b1cad08724f66e0be85d15317bb5f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1b1cad08724f66e0be85d15317bb5f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a2ee54dd545ede9b79ee62905dfc4d" id="r_ad5a2ee54dd545ede9b79ee62905dfc4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad5a2ee54dd545ede9b79ee62905dfc4d">qslim</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const size_t max_m, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J, Eigen::VectorXi &amp;I)</td></tr>
<tr class="memdesc:ad5a2ee54dd545ede9b79ee62905dfc4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decimate (simplify) a triangle mesh in nD according to the paper "Simplifying Surfaces with Color and Texture using Quadric Error Metrics" by [Garland and Heckbert, 1987] (technically a followup to qslim).  <br /></td></tr>
<tr class="separator:ad5a2ee54dd545ede9b79ee62905dfc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb165fc9bf550b7a4248ef3e4750c7b5" id="r_acb165fc9bf550b7a4248ef3e4750c7b5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedQ , typename DerivedE &gt; </td></tr>
<tr class="memitem:acb165fc9bf550b7a4248ef3e4750c7b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acb165fc9bf550b7a4248ef3e4750c7b5">quad_grid</a> (const int nx, const int ny, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="separator:acb165fc9bf550b7a4248ef3e4750c7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374c6a411a695fa5fec90e301b42daf" id="r_aa374c6a411a695fa5fec90e301b42daf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedE &gt; </td></tr>
<tr class="memitem:aa374c6a411a695fa5fec90e301b42daf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa374c6a411a695fa5fec90e301b42daf">quad_grid</a> (const int nx, const int ny, Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:aa374c6a411a695fa5fec90e301b42daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa374c6a411a695fa5fec90e301b42daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf84125e942c49f765c4d652f607cd2" id="r_addf84125e942c49f765c4d652f607cd2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP &gt; </td></tr>
<tr class="memitem:addf84125e942c49f765c4d652f607cd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#addf84125e942c49f765c4d652f607cd2">quad_planarity</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:addf84125e942c49f765c4d652f607cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute planarity of the faces of a quad mesh.  <br /></td></tr>
<tr class="separator:addf84125e942c49f765c4d652f607cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95394212815de2e493636449c262bfc" id="r_af95394212815de2e493636449c262bfc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int n, int ni&gt; </td></tr>
<tr class="memitem:af95394212815de2e493636449c262bfc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, n, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af95394212815de2e493636449c262bfc">quadprog</a> (const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;H, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;f, const Eigen::Matrix&lt; Scalar, ni, n &gt; &amp;Ai, const Eigen::Matrix&lt; Scalar, ni, 1 &gt; &amp;lbi, const Eigen::Matrix&lt; Scalar, ni, 1 &gt; &amp;ubi, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;lb, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;ub)</td></tr>
<tr class="memdesc:af95394212815de2e493636449c262bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a convex quadratic program.  <br /></td></tr>
<tr class="separator:af95394212815de2e493636449c262bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552c079165c8e8dac0d633ddc36ad8f7" id="r_a552c079165c8e8dac0d633ddc36ad8f7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int n, int m&gt; </td></tr>
<tr class="memitem:a552c079165c8e8dac0d633ddc36ad8f7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, n, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a552c079165c8e8dac0d633ddc36ad8f7">quadprog</a> (const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;H, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;f, const Eigen::Matrix&lt; Scalar, m, n &gt; &amp;A, const Eigen::Matrix&lt; Scalar, m, 1 &gt; &amp;b, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;lb, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;ub)</td></tr>
<tr class="memdesc:a552c079165c8e8dac0d633ddc36ad8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a convex quadratic program.  <br /></td></tr>
<tr class="separator:a552c079165c8e8dac0d633ddc36ad8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4086d9d0f9c0d8f922776a698cbe2055" id="r_a4086d9d0f9c0d8f922776a698cbe2055"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int n&gt; </td></tr>
<tr class="memitem:a4086d9d0f9c0d8f922776a698cbe2055"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, n, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4086d9d0f9c0d8f922776a698cbe2055">quadprog</a> (const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;H, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;f, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;lb, const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;ub)</td></tr>
<tr class="memdesc:a4086d9d0f9c0d8f922776a698cbe2055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a convex quadratic program.  <br /></td></tr>
<tr class="separator:a4086d9d0f9c0d8f922776a698cbe2055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c609e4b0050f7ab7371dcde020c5566" id="r_a0c609e4b0050f7ab7371dcde020c5566"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0c609e4b0050f7ab7371dcde020c5566">operator+</a> (const std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; &amp;a, const std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; &amp;b)</td></tr>
<tr class="memdesc:a0c609e4b0050f7ab7371dcde020c5566"><td class="mdescLeft">&#160;</td><td class="mdescRight">A binary addition operator for Quadric tuples compatible with qslim, computing c = a+b.  <br /></td></tr>
<tr class="separator:a0c609e4b0050f7ab7371dcde020c5566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada511054bec3939ade8f2a9494ada31b" id="r_ada511054bec3939ade8f2a9494ada31b"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:ada511054bec3939ade8f2a9494ada31b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ada511054bec3939ade8f2a9494ada31b">quat_conjugate</a> (const Q_type *q1, Q_type *out)</td></tr>
<tr class="memdesc:ada511054bec3939ade8f2a9494ada31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute conjugate of given quaternion <a href="http://en.wikipedia.org/wiki/Quaternion#Conjugation.2C_the_norm.2C_and_reciprocal">http://en.wikipedia.org/wiki/Quaternion#Conjugation.2C_the_norm.2C_and_reciprocal</a> A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w.  <br /></td></tr>
<tr class="separator:ada511054bec3939ade8f2a9494ada31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19bfa1b6952d8ab0687e3b33f445444" id="r_ac19bfa1b6952d8ab0687e3b33f445444"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:ac19bfa1b6952d8ab0687e3b33f445444"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac19bfa1b6952d8ab0687e3b33f445444">quat_mult</a> (const Q_type *q1, const Q_type *q2, Q_type *out)</td></tr>
<tr class="memdesc:ac19bfa1b6952d8ab0687e3b33f445444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes out = q1 * q2 with quaternion multiplication A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w.  <br /></td></tr>
<tr class="separator:ac19bfa1b6952d8ab0687e3b33f445444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0300d689abe2fb73dcf6b2c51821dada" id="r_a0300d689abe2fb73dcf6b2c51821dada"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:a0300d689abe2fb73dcf6b2c51821dada"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0300d689abe2fb73dcf6b2c51821dada">quat_to_axis_angle</a> (const Q_type *q, Q_type *axis, Q_type &amp;angle)</td></tr>
<tr class="memdesc:a0300d689abe2fb73dcf6b2c51821dada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert quat representation of a rotation to axis angle A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w.  <br /></td></tr>
<tr class="separator:a0300d689abe2fb73dcf6b2c51821dada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279531123a14c37bbfeddb71253c50d9" id="r_a279531123a14c37bbfeddb71253c50d9"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:a279531123a14c37bbfeddb71253c50d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a279531123a14c37bbfeddb71253c50d9">quat_to_axis_angle_deg</a> (const Q_type *q, Q_type *axis, Q_type &amp;angle)</td></tr>
<tr class="memdesc:a279531123a14c37bbfeddb71253c50d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="quat__to__axis__angle_8h.html">include/igl/quat_to_axis_angle.h</a>.  <br /></td></tr>
<tr class="separator:a279531123a14c37bbfeddb71253c50d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3f708cef51eb10e942ea1274a4fdc1" id="r_aeb3f708cef51eb10e942ea1274a4fdc1"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:aeb3f708cef51eb10e942ea1274a4fdc1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aeb3f708cef51eb10e942ea1274a4fdc1">quat_to_mat</a> (const Q_type *quat, Q_type *mat)</td></tr>
<tr class="memdesc:aeb3f708cef51eb10e942ea1274a4fdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a quaternion to a 4x4 matrix A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w.  <br /></td></tr>
<tr class="separator:aeb3f708cef51eb10e942ea1274a4fdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bd78c3679effe1e85e5049ddeba5f4" id="r_af1bd78c3679effe1e85e5049ddeba5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af1bd78c3679effe1e85e5049ddeba5f4">quats_to_column</a> (const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; vQ, Eigen::VectorXd &amp;Q)</td></tr>
<tr class="memdesc:af1bd78c3679effe1e85e5049ddeba5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Columnize" a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...)  <br /></td></tr>
<tr class="separator:af1bd78c3679effe1e85e5049ddeba5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586f0e07552e1ed4293b6e627b2d21a9" id="r_a586f0e07552e1ed4293b6e627b2d21a9"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a586f0e07552e1ed4293b6e627b2d21a9">quats_to_column</a> (const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; vQ)</td></tr>
<tr class="memdesc:a586f0e07552e1ed4293b6e627b2d21a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a586f0e07552e1ed4293b6e627b2d21a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe9e431751b9d9370672f22da915cea" id="r_a0fe9e431751b9d9370672f22da915cea"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedS , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a0fe9e431751b9d9370672f22da915cea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0fe9e431751b9d9370672f22da915cea">ramer_douglas_peucker</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const typename DerivedP::Scalar tol, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a0fe9e431751b9d9370672f22da915cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ramer-Douglas-Peucker piecewise-linear curve simplification.  <br /></td></tr>
<tr class="separator:a0fe9e431751b9d9370672f22da915cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4dc2b120bfd3e28f7e1731a3afe7d1" id="r_aef4dc2b120bfd3e28f7e1731a3afe7d1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedS , typename DerivedJ , typename DerivedQ &gt; </td></tr>
<tr class="memitem:aef4dc2b120bfd3e28f7e1731a3afe7d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aef4dc2b120bfd3e28f7e1731a3afe7d1">ramer_douglas_peucker</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const typename DerivedP::Scalar tol, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q)</td></tr>
<tr class="memdesc:aef4dc2b120bfd3e28f7e1731a3afe7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aef4dc2b120bfd3e28f7e1731a3afe7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0064a7187fded546bbaf927301a9c7c" id="r_ae0064a7187fded546bbaf927301a9c7c"><td class="memItemLeft" align="right" valign="top">Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae0064a7187fded546bbaf927301a9c7c">random_dir</a> ()</td></tr>
<tr class="memdesc:ae0064a7187fded546bbaf927301a9c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a uniformly random unit direction in 3D, return as vector.  <br /></td></tr>
<tr class="separator:ae0064a7187fded546bbaf927301a9c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4782a4291e5724eb403de4686b8c786d" id="r_a4782a4291e5724eb403de4686b8c786d"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4782a4291e5724eb403de4686b8c786d">random_dir_stratified</a> (const int n)</td></tr>
<tr class="memdesc:a4782a4291e5724eb403de4686b8c786d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate n stratified uniformly random unit directions in 3d, return as rows of an n by 3 matrix.  <br /></td></tr>
<tr class="separator:a4782a4291e5724eb403de4686b8c786d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc88d96c492e3bf962501af8bea413e" id="r_a1fc88d96c492e3bf962501af8bea413e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedB , typename DerivedFI , typename DerivedX , typename URBG  = DEFAULT_URBG&gt; </td></tr>
<tr class="memitem:a1fc88d96c492e3bf962501af8bea413e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1fc88d96c492e3bf962501af8bea413e">random_points_on_mesh</a> (const int n, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;FI, Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X, URBG &amp;&amp;urbg=<a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>())</td></tr>
<tr class="memdesc:a1fc88d96c492e3bf962501af8bea413e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly sample a mesh (V,F) n times.  <br /></td></tr>
<tr class="separator:a1fc88d96c492e3bf962501af8bea413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17abb32491125229903977390f4149b6" id="r_a17abb32491125229903977390f4149b6"><td class="memTemplParams" colspan="2">template&lt;typename DeriveddblA , typename DerivedB , typename DerivedFI , typename URBG  = DEFAULT_URBG&gt; </td></tr>
<tr class="memitem:a17abb32491125229903977390f4149b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a17abb32491125229903977390f4149b6">random_points_on_mesh_intrinsic</a> (const int n, const Eigen::MatrixBase&lt; DeriveddblA &gt; &amp;dblA, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;FI, URBG &amp;&amp;urbg=<a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>())</td></tr>
<tr class="memdesc:a17abb32491125229903977390f4149b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly sample a mesh (V,F) n times.  <br /></td></tr>
<tr class="separator:a17abb32491125229903977390f4149b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aa82c3339685c664b22f768a8a6e0e" id="r_a96aa82c3339685c664b22f768a8a6e0e"><td class="memTemplParams" colspan="2">template&lt;typename DeriveddblA , typename DerivedF , typename ScalarB , typename DerivedFI , typename URBG &gt; </td></tr>
<tr class="memitem:a96aa82c3339685c664b22f768a8a6e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a96aa82c3339685c664b22f768a8a6e0e">random_points_on_mesh_intrinsic</a> (const int n, const Eigen::MatrixBase&lt; DeriveddblA &gt; &amp;dblA, const int num_vertices, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; ScalarB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;FI, URBG &amp;&amp;urbg)</td></tr>
<tr class="memdesc:a96aa82c3339685c664b22f768a8a6e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a96aa82c3339685c664b22f768a8a6e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce1200f20db3dc284cca380285517cf" id="r_afce1200f20db3dc284cca380285517cf"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afce1200f20db3dc284cca380285517cf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Quaternion&lt; Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afce1200f20db3dc284cca380285517cf">random_quaternion</a> ()</td></tr>
<tr class="memdesc:afce1200f20db3dc284cca380285517cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a random quaternion via uniform sampling of the 4-sphere.  <br /></td></tr>
<tr class="separator:afce1200f20db3dc284cca380285517cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39042be3d7a469bc3519bc2a6ce7932" id="r_ad39042be3d7a469bc3519bc2a6ce7932"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB &gt; </td></tr>
<tr class="memitem:ad39042be3d7a469bc3519bc2a6ce7932"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad39042be3d7a469bc3519bc2a6ce7932">random_search</a> (const std::function&lt; Scalar(DerivedX &amp;) &gt; f, const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;LB, const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;UB, const int iters, DerivedX &amp;X)</td></tr>
<tr class="memdesc:ad39042be3d7a469bc3519bc2a6ce7932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global optimization via random search.  <br /></td></tr>
<tr class="separator:ad39042be3d7a469bc3519bc2a6ce7932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7279a059983ae9a728c94ccc1983343d" id="r_a7279a059983ae9a728c94ccc1983343d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedI , typename URBG  = DEFAULT_URBG&gt; </td></tr>
<tr class="memitem:a7279a059983ae9a728c94ccc1983343d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7279a059983ae9a728c94ccc1983343d">randperm</a> (const int n, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, URBG &amp;&amp;urbg=<a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>())</td></tr>
<tr class="memdesc:a7279a059983ae9a728c94ccc1983343d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like matlab's randperm(n) but minus 1.  <br /></td></tr>
<tr class="separator:a7279a059983ae9a728c94ccc1983343d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41f8552f81764bc8793cb5f76a87553" id="r_af41f8552f81764bc8793cb5f76a87553"><td class="memTemplParams" colspan="2">template&lt;typename Derivedsource , typename Deriveddir , typename Scalar &gt; </td></tr>
<tr class="memitem:af41f8552f81764bc8793cb5f76a87553"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af41f8552f81764bc8793cb5f76a87553">ray_box_intersect</a> (const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;source, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;dir, const Eigen::AlignedBox&lt; Scalar, 3 &gt; &amp;box, const Scalar &amp;t0, const Scalar &amp;t1, Scalar &amp;tmin, Scalar &amp;tmax)</td></tr>
<tr class="memdesc:af41f8552f81764bc8793cb5f76a87553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a ray origin+t*dir and box intersect within the ray's parameterized range (t0,t1)  <br /></td></tr>
<tr class="separator:af41f8552f81764bc8793cb5f76a87553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18af1e6cc596af264e3a02e02b823a01" id="r_a18af1e6cc596af264e3a02e02b823a01"><td class="memTemplParams" colspan="2">template&lt;typename Derivedsource , typename Deriveddir , typename Scalar &gt; </td></tr>
<tr class="memitem:a18af1e6cc596af264e3a02e02b823a01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a18af1e6cc596af264e3a02e02b823a01">ray_box_intersect</a> (const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;source, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;inv_dir, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;inv_dir_pad, const Eigen::AlignedBox&lt; Scalar, 3 &gt; &amp;box, const Scalar &amp;t0, const Scalar &amp;t1, Scalar &amp;tmin, Scalar &amp;tmax)</td></tr>
<tr class="memdesc:a18af1e6cc596af264e3a02e02b823a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a18af1e6cc596af264e3a02e02b823a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb07bb96941cdba2a28b4239f88a246" id="r_adcb07bb96941cdba2a28b4239f88a246"><td class="memTemplParams" colspan="2">template&lt;typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:adcb07bb96941cdba2a28b4239f88a246"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adcb07bb96941cdba2a28b4239f88a246">ray_mesh_intersect</a> (const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;source, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;dir, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;hits)</td></tr>
<tr class="memdesc:adcb07bb96941cdba2a28b4239f88a246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shoot a ray against a mesh (V,F) and collect all hits.  <br /></td></tr>
<tr class="separator:adcb07bb96941cdba2a28b4239f88a246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a827e72cc935817ec986e83ce56cc73" id="r_a6a827e72cc935817ec986e83ce56cc73"><td class="memTemplParams" colspan="2">template&lt;typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a6a827e72cc935817ec986e83ce56cc73"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6a827e72cc935817ec986e83ce56cc73">ray_mesh_intersect</a> (const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;source, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;dir, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &amp;hit)</td></tr>
<tr class="memdesc:a6a827e72cc935817ec986e83ce56cc73"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6a827e72cc935817ec986e83ce56cc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab2426f066fcd19c79646bcca3501b8" id="r_afab2426f066fcd19c79646bcca3501b8"><td class="memTemplParams" colspan="2">template&lt;typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:afab2426f066fcd19c79646bcca3501b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afab2426f066fcd19c79646bcca3501b8">ray_triangle_intersect</a> (const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;source, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;dir, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int f, <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &amp;hit)</td></tr>
<tr class="separator:afab2426f066fcd19c79646bcca3501b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b3c855b74e0beac5385f073686761e" id="r_a11b3c855b74e0beac5385f073686761e"><td class="memTemplParams" colspan="2">template&lt;typename Derivedo , typename Derivedd , typename Derivedc , typename r_type , typename t_type &gt; </td></tr>
<tr class="memitem:a11b3c855b74e0beac5385f073686761e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a11b3c855b74e0beac5385f073686761e">ray_sphere_intersect</a> (const Eigen::PlainObjectBase&lt; Derivedo &gt; &amp;o, const Eigen::PlainObjectBase&lt; Derivedd &gt; &amp;d, const Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, r_type r, t_type &amp;t0, t_type &amp;t1)</td></tr>
<tr class="memdesc:a11b3c855b74e0beac5385f073686761e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the intersection between a ray from O in direction D and a sphere centered at C with radius r.  <br /></td></tr>
<tr class="separator:a11b3c855b74e0beac5385f073686761e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bb8198773c2124500fd5bc9a5f810b" id="r_a28bb8198773c2124500fd5bc9a5f810b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a28bb8198773c2124500fd5bc9a5f810b">read_file_binary</a> (FILE *fp, std::vector&lt; uint8_t &gt; &amp;fileBufferBytes)</td></tr>
<tr class="memdesc:a28bb8198773c2124500fd5bc9a5f810b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read contents of file into a buffer of uint8_t bytes.  <br /></td></tr>
<tr class="separator:a28bb8198773c2124500fd5bc9a5f810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd18b073b51beb1500c10c4f2825aba" id="r_a6bd18b073b51beb1500c10c4f2825aba"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a6bd18b073b51beb1500c10c4f2825aba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6bd18b073b51beb1500c10c4f2825aba">read_triangle_mesh</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a6bd18b073b51beb1500c10c4f2825aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read mesh from an ascii file with automatic detection of file format among: mesh, msh obj, off, ply, stl, wrl.  <br /></td></tr>
<tr class="separator:a6bd18b073b51beb1500c10c4f2825aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad787fca3bc0010177aa587a1ad0d8bc8" id="r_ad787fca3bc0010177aa587a1ad0d8bc8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ad787fca3bc0010177aa587a1ad0d8bc8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad787fca3bc0010177aa587a1ad0d8bc8">read_triangle_mesh</a> (const std::string str, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:ad787fca3bc0010177aa587a1ad0d8bc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad787fca3bc0010177aa587a1ad0d8bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cf40d2ba95e3819ecc7d733a73d321" id="r_ae6cf40d2ba95e3819ecc7d733a73d321"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ae6cf40d2ba95e3819ecc7d733a73d321"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae6cf40d2ba95e3819ecc7d733a73d321">read_triangle_mesh</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, std::string &amp;dir, std::string &amp;base, std::string &amp;ext, std::string &amp;name)</td></tr>
<tr class="memdesc:ae6cf40d2ba95e3819ecc7d733a73d321"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae6cf40d2ba95e3819ecc7d733a73d321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfd07940eb9445554a8f64c84ea385c" id="r_a8cfd07940eb9445554a8f64c84ea385c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a8cfd07940eb9445554a8f64c84ea385c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8cfd07940eb9445554a8f64c84ea385c">read_triangle_mesh</a> (const std::string &amp;ext, FILE *fp, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a8cfd07940eb9445554a8f64c84ea385c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a8cfd07940eb9445554a8f64c84ea385c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efbc110f683b253ef703142d1406f28" id="r_a4efbc110f683b253ef703142d1406f28"><td class="memTemplParams" colspan="2">template&lt;typename DerivedWI , typename DerivedP , typename DerivedO &gt; </td></tr>
<tr class="memitem:a4efbc110f683b253ef703142d1406f28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4efbc110f683b253ef703142d1406f28">readBF</a> (const std::string &amp;filename, Eigen::PlainObjectBase&lt; DerivedWI &gt; &amp;WI, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;O)</td></tr>
<tr class="memdesc:a4efbc110f683b253ef703142d1406f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a bones forest from a file, returns a list of bone roots.  <br /></td></tr>
<tr class="separator:a4efbc110f683b253ef703142d1406f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad78f74b0306e9a2775575579314170" id="r_a0ad78f74b0306e9a2775575579314170"><td class="memTemplParams" colspan="2">template&lt;typename DerivedWI , typename DerivedbfP , typename DerivedO , typename DerivedC , typename DerivedBE , typename DerivedP &gt; </td></tr>
<tr class="memitem:a0ad78f74b0306e9a2775575579314170"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0ad78f74b0306e9a2775575579314170">readBF</a> (const std::string &amp;filename, Eigen::PlainObjectBase&lt; DerivedWI &gt; &amp;WI, Eigen::PlainObjectBase&lt; DerivedbfP &gt; &amp;bfP, Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;O, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedBE &gt; &amp;BE, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a0ad78f74b0306e9a2775575579314170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read bone forest into pure bone-skeleton format, expects only bones (no point handles), and that a root in the .bf &lt;&mdash;&gt; no weight attachment.  <br /></td></tr>
<tr class="separator:a0ad78f74b0306e9a2775575579314170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b133398a6e09068c97655f27de173a0" id="r_a5b133398a6e09068c97655f27de173a0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5b133398a6e09068c97655f27de173a0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5b133398a6e09068c97655f27de173a0">readCSV</a> (const std::string str, Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;M)</td></tr>
<tr class="memdesc:a5b133398a6e09068c97655f27de173a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a matrix from a csv file into a Eigen matrix  <br /></td></tr>
<tr class="separator:a5b133398a6e09068c97655f27de173a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a50547ab59bcb0705475875bb39a7d" id="r_a44a50547ab59bcb0705475875bb39a7d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedW &gt; </td></tr>
<tr class="memitem:a44a50547ab59bcb0705475875bb39a7d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a44a50547ab59bcb0705475875bb39a7d">readDMAT</a> (const std::string file_name, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a44a50547ab59bcb0705475875bb39a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from an .dmat file.  <br /></td></tr>
<tr class="separator:a44a50547ab59bcb0705475875bb39a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866564d1ac5b6f69fcee878f2ac2429d" id="r_a866564d1ac5b6f69fcee878f2ac2429d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a866564d1ac5b6f69fcee878f2ac2429d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a866564d1ac5b6f69fcee878f2ac2429d">readDMAT</a> (const std::string file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;W)</td></tr>
<tr class="memdesc:a866564d1ac5b6f69fcee878f2ac2429d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a866564d1ac5b6f69fcee878f2ac2429d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40ef4e0517c71c597272824497377b2" id="r_aa40ef4e0517c71c597272824497377b2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedT &gt; </td></tr>
<tr class="memitem:aa40ef4e0517c71c597272824497377b2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa40ef4e0517c71c597272824497377b2">readMESH</a> (const std::string mesh_file_name, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:aa40ef4e0517c71c597272824497377b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a tetrahedral volume mesh from a .mesh file.  <br /></td></tr>
<tr class="separator:aa40ef4e0517c71c597272824497377b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078957e6e3c6a1f4cff7de4d0a28956d" id="r_a078957e6e3c6a1f4cff7de4d0a28956d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a078957e6e3c6a1f4cff7de4d0a28956d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a078957e6e3c6a1f4cff7de4d0a28956d">readMESH</a> (const std::string mesh_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;T, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a078957e6e3c6a1f4cff7de4d0a28956d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a078957e6e3c6a1f4cff7de4d0a28956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1471e99a81d4975918c69176594f4621" id="r_a1471e99a81d4975918c69176594f4621"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedT &gt; </td></tr>
<tr class="memitem:a1471e99a81d4975918c69176594f4621"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1471e99a81d4975918c69176594f4621">readMESH</a> (FILE *mesh_file, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a1471e99a81d4975918c69176594f4621"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1471e99a81d4975918c69176594f4621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcad51e218e111ff185566bea366cb3" id="r_a2bcad51e218e111ff185566bea366cb3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a2bcad51e218e111ff185566bea366cb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2bcad51e218e111ff185566bea366cb3">readMESH</a> (FILE *mesh_file, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;T, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a2bcad51e218e111ff185566bea366cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2bcad51e218e111ff185566bea366cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9364f18a5e9db3da7b923ab9ee054481" id="r_a9364f18a5e9db3da7b923ab9ee054481"><td class="memTemplParams" colspan="2">template&lt;int EigenMatrixOptions&gt; </td></tr>
<tr class="memitem:a9364f18a5e9db3da7b923ab9ee054481"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9364f18a5e9db3da7b923ab9ee054481">readMSH</a> (const std::string &amp;msh, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;X, Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;Tri, Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;Tet, Eigen::VectorXi &amp;TriTag, Eigen::VectorXi &amp;TetTag, std::vector&lt; std::string &gt; &amp;XFields, std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &gt; &amp;XF, std::vector&lt; std::string &gt; &amp;EFields, std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &gt; &amp;TriF, std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &gt; &amp;TetF)</td></tr>
<tr class="memdesc:a9364f18a5e9db3da7b923ab9ee054481"><td class="mdescLeft">&#160;</td><td class="mdescRight">read triangle surface mesh and tetrahedral volume mesh from .msh file  <br /></td></tr>
<tr class="separator:a9364f18a5e9db3da7b923ab9ee054481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcaf1cbdf935ab8ae06264bc17a80b1" id="r_aadcaf1cbdf935ab8ae06264bc17a80b1"><td class="memTemplParams" colspan="2">template&lt;int EigenMatrixOptions&gt; </td></tr>
<tr class="memitem:aadcaf1cbdf935ab8ae06264bc17a80b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aadcaf1cbdf935ab8ae06264bc17a80b1">readMSH</a> (const std::string &amp;msh, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;X, Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;Tri, Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;Tet, Eigen::VectorXi &amp;TriTag, Eigen::VectorXi &amp;TetTag)</td></tr>
<tr class="memdesc:aadcaf1cbdf935ab8ae06264bc17a80b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aadcaf1cbdf935ab8ae06264bc17a80b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3928fbb4033580f092da0afb953cc7c" id="r_ad3928fbb4033580f092da0afb953cc7c"><td class="memTemplParams" colspan="2">template&lt;int EigenMatrixOptions&gt; </td></tr>
<tr class="memitem:ad3928fbb4033580f092da0afb953cc7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad3928fbb4033580f092da0afb953cc7c">readMSH</a> (const std::string &amp;msh, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;X, Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;Tri, Eigen::VectorXi &amp;TriTag)</td></tr>
<tr class="memdesc:ad3928fbb4033580f092da0afb953cc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad3928fbb4033580f092da0afb953cc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a21df0040f4d7799d33535261164ac" id="r_af2a21df0040f4d7799d33535261164ac"><td class="memTemplParams" colspan="2">template&lt;int EigenMatrixOptions&gt; </td></tr>
<tr class="memitem:af2a21df0040f4d7799d33535261164ac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af2a21df0040f4d7799d33535261164ac">readMSH</a> (const std::string &amp;msh, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;X, Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;Tri)</td></tr>
<tr class="memdesc:af2a21df0040f4d7799d33535261164ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af2a21df0040f4d7799d33535261164ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5218e3a581f3ae7d3937db7cb6bafe" id="r_a0a5218e3a581f3ae7d3937db7cb6bafe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedI &gt; </td></tr>
<tr class="memitem:a0a5218e3a581f3ae7d3937db7cb6bafe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0a5218e3a581f3ae7d3937db7cb6bafe">readNODE</a> (const std::string node_file_name, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a0a5218e3a581f3ae7d3937db7cb6bafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">load a list of points from a .node file  <br /></td></tr>
<tr class="separator:a0a5218e3a581f3ae7d3937db7cb6bafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9897d432300521fe95987a223d3c834c" id="r_a9897d432300521fe95987a223d3c834c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a9897d432300521fe95987a223d3c834c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9897d432300521fe95987a223d3c834c">readNODE</a> (const std::string node_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;I)</td></tr>
<tr class="memdesc:a9897d432300521fe95987a223d3c834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9897d432300521fe95987a223d3c834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d68499324615abfb462bf80130431b" id="r_ad3d68499324615abfb462bf80130431b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ad3d68499324615abfb462bf80130431b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad3d68499324615abfb462bf80130431b">readOBJ</a> (const std::string obj_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;TC, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;N, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;FTC, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;FN, std::vector&lt; std::tuple&lt; std::string, Index, Index &gt; &gt; &amp;FM)</td></tr>
<tr class="memdesc:ad3d68499324615abfb462bf80130431b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates.  <br /></td></tr>
<tr class="separator:ad3d68499324615abfb462bf80130431b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8" id="r_aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8">readOBJ</a> (const std::string obj_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;TC, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;N, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;FTC, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;FN)</td></tr>
<tr class="memdesc:aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d39ea33fc7a17fb16a3e02a5065757" id="r_a86d39ea33fc7a17fb16a3e02a5065757"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a86d39ea33fc7a17fb16a3e02a5065757"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a86d39ea33fc7a17fb16a3e02a5065757">readOBJ</a> (FILE *obj_file, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;TC, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;N, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;FTC, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;FN, std::vector&lt; std::tuple&lt; std::string, Index, Index &gt; &gt; &amp;FM)</td></tr>
<tr class="separator:a86d39ea33fc7a17fb16a3e02a5065757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6485914541d342f476f70e9ba97a00ff" id="r_a6485914541d342f476f70e9ba97a00ff"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a6485914541d342f476f70e9ba97a00ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6485914541d342f476f70e9ba97a00ff">readOBJ</a> (const std::string obj_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a6485914541d342f476f70e9ba97a00ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6485914541d342f476f70e9ba97a00ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8c28b2557217c00bb8e146d828cd35" id="r_a2d8c28b2557217c00bb8e146d828cd35"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedTC , typename DerivedCN , typename DerivedF , typename DerivedFTC , typename DerivedFN &gt; </td></tr>
<tr class="memitem:a2d8c28b2557217c00bb8e146d828cd35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2d8c28b2557217c00bb8e146d828cd35">readOBJ</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedTC &gt; &amp;TC, Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;CN, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFTC &gt; &amp;FTC, Eigen::PlainObjectBase&lt; DerivedFN &gt; &amp;FN)</td></tr>
<tr class="memdesc:a2d8c28b2557217c00bb8e146d828cd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2d8c28b2557217c00bb8e146d828cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3034889b938bdf0fa96f79ad62f47641" id="r_a3034889b938bdf0fa96f79ad62f47641"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a3034889b938bdf0fa96f79ad62f47641"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3034889b938bdf0fa96f79ad62f47641">readOBJ</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a3034889b938bdf0fa96f79ad62f47641"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3034889b938bdf0fa96f79ad62f47641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4849d6cdcfeffd1ed7b48c15d493ad" id="r_a4c4849d6cdcfeffd1ed7b48c15d493ad"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:a4c4849d6cdcfeffd1ed7b48c15d493ad"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4c4849d6cdcfeffd1ed7b48c15d493ad">readOBJ</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a4c4849d6cdcfeffd1ed7b48c15d493ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4c4849d6cdcfeffd1ed7b48c15d493ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b3fbb305991ff009d5ef2bf7c2bb99" id="r_ae0b3fbb305991ff009d5ef2bf7c2bb99"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:ae0b3fbb305991ff009d5ef2bf7c2bb99"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae0b3fbb305991ff009d5ef2bf7c2bb99">readOFF</a> (const std::string off_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;N, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;C)</td></tr>
<tr class="memdesc:ae0b3fbb305991ff009d5ef2bf7c2bb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a mesh from an ascii OFF file, filling in vertex positions, normals and texture coordinates.  <br /></td></tr>
<tr class="separator:ae0b3fbb305991ff009d5ef2bf7c2bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e987bbb9c21c44facf425147ce0c0e" id="r_a80e987bbb9c21c44facf425147ce0c0e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a80e987bbb9c21c44facf425147ce0c0e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a80e987bbb9c21c44facf425147ce0c0e">readOFF</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a80e987bbb9c21c44facf425147ce0c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a80e987bbb9c21c44facf425147ce0c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bb9e4bd7e6acfc8838f372351d7fd5" id="r_a53bb9e4bd7e6acfc8838f372351d7fd5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a53bb9e4bd7e6acfc8838f372351d7fd5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a53bb9e4bd7e6acfc8838f372351d7fd5">readOFF</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;N)</td></tr>
<tr class="memdesc:a53bb9e4bd7e6acfc8838f372351d7fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a53bb9e4bd7e6acfc8838f372351d7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805a632075fa2b99892f172b2063e8de" id="r_a805a632075fa2b99892f172b2063e8de"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a805a632075fa2b99892f172b2063e8de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a805a632075fa2b99892f172b2063e8de">readOFF</a> (FILE *off_file, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;N, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;C)</td></tr>
<tr class="memdesc:a805a632075fa2b99892f172b2063e8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a805a632075fa2b99892f172b2063e8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dbe47791345f0dff905ae3515ffd21" id="r_a19dbe47791345f0dff905ae3515ffd21"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </td></tr>
<tr class="memitem:a19dbe47791345f0dff905ae3515ffd21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a19dbe47791345f0dff905ae3515ffd21">readPLY</a> (std::istream &amp;ply_stream, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;UV, Eigen::PlainObjectBase&lt; DerivedVD &gt; &amp;VD, std::vector&lt; std::string &gt; &amp;Vheader, Eigen::PlainObjectBase&lt; DerivedFD &gt; &amp;FD, std::vector&lt; std::string &gt; &amp;Fheader, Eigen::PlainObjectBase&lt; DerivedED &gt; &amp;ED, std::vector&lt; std::string &gt; &amp;Eheader, std::vector&lt; std::string &gt; &amp;comments)</td></tr>
<tr class="memdesc:a19dbe47791345f0dff905ae3515ffd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read triangular mesh from ply file, filling in vertex positions, normals and texture coordinates, if available also read additional properties associated with vertex,faces and edges and file comments.  <br /></td></tr>
<tr class="separator:a19dbe47791345f0dff905ae3515ffd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9d95305b4c4ad23b0ae936bf8ebe28" id="r_a2d9d95305b4c4ad23b0ae936bf8ebe28"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </td></tr>
<tr class="memitem:a2d9d95305b4c4ad23b0ae936bf8ebe28"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2d9d95305b4c4ad23b0ae936bf8ebe28">readPLY</a> (const std::string &amp;ply_file, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;UV, Eigen::PlainObjectBase&lt; DerivedVD &gt; &amp;VD, std::vector&lt; std::string &gt; &amp;VDheader, Eigen::PlainObjectBase&lt; DerivedFD &gt; &amp;FD, std::vector&lt; std::string &gt; &amp;FDheader, Eigen::PlainObjectBase&lt; DerivedED &gt; &amp;ED, std::vector&lt; std::string &gt; &amp;EDheader, std::vector&lt; std::string &gt; &amp;comments)</td></tr>
<tr class="memdesc:a2d9d95305b4c4ad23b0ae936bf8ebe28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2d9d95305b4c4ad23b0ae936bf8ebe28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82ecbf00ab1917446d26d4aaed0c79f" id="r_aa82ecbf00ab1917446d26d4aaed0c79f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedUV , typename DerivedVD &gt; </td></tr>
<tr class="memitem:aa82ecbf00ab1917446d26d4aaed0c79f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa82ecbf00ab1917446d26d4aaed0c79f">readPLY</a> (const std::string &amp;filename, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;UV, Eigen::PlainObjectBase&lt; DerivedVD &gt; &amp;VD, std::vector&lt; std::string &gt; &amp;Vheader)</td></tr>
<tr class="memdesc:aa82ecbf00ab1917446d26d4aaed0c79f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa82ecbf00ab1917446d26d4aaed0c79f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500ef30b39ed4e46a12342238fddd1ea" id="r_a500ef30b39ed4e46a12342238fddd1ea"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV &gt; </td></tr>
<tr class="memitem:a500ef30b39ed4e46a12342238fddd1ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a500ef30b39ed4e46a12342238fddd1ea">readPLY</a> (const std::string &amp;filename, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;UV)</td></tr>
<tr class="memdesc:a500ef30b39ed4e46a12342238fddd1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a500ef30b39ed4e46a12342238fddd1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45ac576aa1e4ed7721b0a00e5d12c1" id="r_aab45ac576aa1e4ed7721b0a00e5d12c1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:aab45ac576aa1e4ed7721b0a00e5d12c1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aab45ac576aa1e4ed7721b0a00e5d12c1">readPLY</a> (const std::string &amp;filename, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:aab45ac576aa1e4ed7721b0a00e5d12c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aab45ac576aa1e4ed7721b0a00e5d12c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18adc6f5870ec2806992a65719834abd" id="r_a18adc6f5870ec2806992a65719834abd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </td></tr>
<tr class="memitem:a18adc6f5870ec2806992a65719834abd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a18adc6f5870ec2806992a65719834abd">readPLY</a> (const std::string &amp;filename, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E)</td></tr>
<tr class="memdesc:a18adc6f5870ec2806992a65719834abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a18adc6f5870ec2806992a65719834abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0ed58390b96d5981b908b62103c250" id="r_a0c0ed58390b96d5981b908b62103c250"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a0c0ed58390b96d5981b908b62103c250"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0c0ed58390b96d5981b908b62103c250">readPLY</a> (FILE *fp, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a0c0ed58390b96d5981b908b62103c250"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0c0ed58390b96d5981b908b62103c250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e874916eb50201727b290cc48fbaac" id="r_aa1e874916eb50201727b290cc48fbaac"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:aa1e874916eb50201727b290cc48fbaac"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa1e874916eb50201727b290cc48fbaac">readSTL</a> (std::istream &amp;input, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:aa1e874916eb50201727b290cc48fbaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a mesh from an ascii/binary stl file.  <br /></td></tr>
<tr class="separator:aa1e874916eb50201727b290cc48fbaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3c654bf8fde8ab6f7b55c515b11bea" id="r_a1b3c654bf8fde8ab6f7b55c515b11bea"><td class="memTemplParams" colspan="2">template&lt;typename TypeV , typename TypeF , typename TypeN &gt; </td></tr>
<tr class="memitem:a1b3c654bf8fde8ab6f7b55c515b11bea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1b3c654bf8fde8ab6f7b55c515b11bea">readSTL</a> (std::istream &amp;input, std::vector&lt; std::array&lt; TypeV, 3 &gt; &gt; &amp;V, std::vector&lt; std::array&lt; TypeF, 3 &gt; &gt; &amp;F, std::vector&lt; std::array&lt; TypeN, 3 &gt; &gt; &amp;N)</td></tr>
<tr class="memdesc:a1b3c654bf8fde8ab6f7b55c515b11bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1b3c654bf8fde8ab6f7b55c515b11bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d360f2f2694afebd1e62cee1551de4" id="r_aa7d360f2f2694afebd1e62cee1551de4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:aa7d360f2f2694afebd1e62cee1551de4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa7d360f2f2694afebd1e62cee1551de4">readSTL</a> (FILE *fp, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:aa7d360f2f2694afebd1e62cee1551de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa7d360f2f2694afebd1e62cee1551de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2ff313a45b1882bc42711ef59518ea" id="r_a0e2ff313a45b1882bc42711ef59518ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0e2ff313a45b1882bc42711ef59518ea">readTGF</a> (const std::string tgf_filename, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;C, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;E, std::vector&lt; int &gt; &amp;P, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;BE, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;CE, std::vector&lt; std::vector&lt; int &gt; &gt; &amp;PE)</td></tr>
<tr class="memdesc:a0e2ff313a45b1882bc42711ef59518ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a graph from a .tgf file.  <br /></td></tr>
<tr class="separator:a0e2ff313a45b1882bc42711ef59518ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a753ab8f368313c20aa9d6aa98841c" id="r_a86a753ab8f368313c20aa9d6aa98841c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a86a753ab8f368313c20aa9d6aa98841c">readTGF</a> (const std::string tgf_filename, Eigen::MatrixXd &amp;C, Eigen::MatrixXi &amp;E, Eigen::VectorXi &amp;P, Eigen::MatrixXi &amp;BE, Eigen::MatrixXi &amp;CE, Eigen::MatrixXi &amp;PE)</td></tr>
<tr class="memdesc:a86a753ab8f368313c20aa9d6aa98841c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a86a753ab8f368313c20aa9d6aa98841c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfc64e83ab4d2cd4fb8a6e31d4403d6" id="r_a2cfc64e83ab4d2cd4fb8a6e31d4403d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2cfc64e83ab4d2cd4fb8a6e31d4403d6">readTGF</a> (const std::string tgf_filename, Eigen::MatrixXd &amp;C, Eigen::MatrixXi &amp;E)</td></tr>
<tr class="memdesc:a2cfc64e83ab4d2cd4fb8a6e31d4403d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2cfc64e83ab4d2cd4fb8a6e31d4403d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480b2999b4d8ec50dcfa86d790f7b9d0" id="r_a480b2999b4d8ec50dcfa86d790f7b9d0"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a480b2999b4d8ec50dcfa86d790f7b9d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a480b2999b4d8ec50dcfa86d790f7b9d0">readWRL</a> (const std::string wrl_file_name, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a480b2999b4d8ec50dcfa86d790f7b9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a mesh from an ascii wrl file, filling in vertex positions and face indices of the first model.  <br /></td></tr>
<tr class="separator:a480b2999b4d8ec50dcfa86d790f7b9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ea20362e20a0f75e389904a2957ed2" id="r_a90ea20362e20a0f75e389904a2957ed2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a90ea20362e20a0f75e389904a2957ed2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a90ea20362e20a0f75e389904a2957ed2">readWRL</a> (FILE *wrl_file, std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a90ea20362e20a0f75e389904a2957ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a90ea20362e20a0f75e389904a2957ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af757c8be2caaeaf804de6240cc6ffa7f" id="r_af757c8be2caaeaf804de6240cc6ffa7f"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename Func , typename DerivedB &gt; </td></tr>
<tr class="memitem:af757c8be2caaeaf804de6240cc6ffa7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af757c8be2caaeaf804de6240cc6ffa7f">redux</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, const Func &amp;func, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:af757c8be2caaeaf804de6240cc6ffa7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform reductions on the rows or columns of a SparseMatrix.  <br /></td></tr>
<tr class="separator:af757c8be2caaeaf804de6240cc6ffa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492e4e2a6bc227fe67a79b0110d4c8de" id="r_a492e4e2a6bc227fe67a79b0110d4c8de"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedU , typename DerivedG , typename DerivedJ , typename BCtype , typename DerivedSU , typename DerivedL &gt; </td></tr>
<tr class="memitem:a492e4e2a6bc227fe67a79b0110d4c8de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a492e4e2a6bc227fe67a79b0110d4c8de">remesh_along_isoline</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar val, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedSU &gt; &amp;SU, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::SparseMatrix&lt; BCtype &gt; &amp;BC, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:a492e4e2a6bc227fe67a79b0110d4c8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a triangle mesh and a scalar field, remesh so that a given isovalue of the scalar field follows (new) edges of the output mesh.  <br /></td></tr>
<tr class="separator:a492e4e2a6bc227fe67a79b0110d4c8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7057971dd3f4cb240c6598b5ee52eaff" id="r_a7057971dd3f4cb240c6598b5ee52eaff"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedS , typename DerivedG , typename DerivedJ , typename BCtype , typename DerivedSU , typename DerivedL &gt; </td></tr>
<tr class="memitem:a7057971dd3f4cb240c6598b5ee52eaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7057971dd3f4cb240c6598b5ee52eaff">remesh_along_isoline</a> (const int n, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, const typename DerivedS::Scalar val, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedSU &gt; &amp;SU, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::SparseMatrix&lt; BCtype &gt; &amp;BC, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:a7057971dd3f4cb240c6598b5ee52eaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7057971dd3f4cb240c6598b5ee52eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4684c8d485a5cd367751c6bb92e8b415" id="r_a4684c8d485a5cd367751c6bb92e8b415"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedSV , typename DerivedSVI , typename DerivedSVJ &gt; </td></tr>
<tr class="memitem:a4684c8d485a5cd367751c6bb92e8b415"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4684c8d485a5cd367751c6bb92e8b415">remove_duplicate_vertices</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const double epsilon, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;SVI, Eigen::PlainObjectBase&lt; DerivedSVJ &gt; &amp;SVJ)</td></tr>
<tr class="memdesc:a4684c8d485a5cd367751c6bb92e8b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate vertices upto a uniqueness tolerance (epsilon)  <br /></td></tr>
<tr class="separator:a4684c8d485a5cd367751c6bb92e8b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2865c2682b8f7cda67db377ca026619" id="r_ae2865c2682b8f7cda67db377ca026619"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedSV , typename DerivedSVI , typename DerivedSVJ , typename DerivedSF &gt; </td></tr>
<tr class="memitem:ae2865c2682b8f7cda67db377ca026619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae2865c2682b8f7cda67db377ca026619">remove_duplicate_vertices</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const double epsilon, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;SVI, Eigen::PlainObjectBase&lt; DerivedSVJ &gt; &amp;SVJ, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF)</td></tr>
<tr class="memdesc:ae2865c2682b8f7cda67db377ca026619"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae2865c2682b8f7cda67db377ca026619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d51bedab2b1bb46c40334e6d59035bc" id="r_a8d51bedab2b1bb46c40334e6d59035bc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF , typename DerivedI , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a8d51bedab2b1bb46c40334e6d59035bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8d51bedab2b1bb46c40334e6d59035bc">remove_unreferenced</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;NV, Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;NF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a8d51bedab2b1bb46c40334e6d59035bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove unreferenced vertices from V, updating F accordingly.  <br /></td></tr>
<tr class="separator:a8d51bedab2b1bb46c40334e6d59035bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84fd84522be8f2e70fa6ef154849f3c1" id="r_a84fd84522be8f2e70fa6ef154849f3c1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a84fd84522be8f2e70fa6ef154849f3c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a84fd84522be8f2e70fa6ef154849f3c1">remove_unreferenced</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;NV, Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;NF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a84fd84522be8f2e70fa6ef154849f3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a84fd84522be8f2e70fa6ef154849f3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afd2f60ecc2994c7f37deecac94dc80" id="r_a6afd2f60ecc2994c7f37deecac94dc80"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedI , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a6afd2f60ecc2994c7f37deecac94dc80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6afd2f60ecc2994c7f37deecac94dc80">remove_unreferenced</a> (const size_t n, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a6afd2f60ecc2994c7f37deecac94dc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6afd2f60ecc2994c7f37deecac94dc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35357b4f4e8dbf29c3fad77850fb957" id="r_ad35357b4f4e8dbf29c3fad77850fb957"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad35357b4f4e8dbf29c3fad77850fb957"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad35357b4f4e8dbf29c3fad77850fb957">repdiag</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;A, const int d, Eigen::SparseMatrix&lt; T &gt; &amp;B)</td></tr>
<tr class="memdesc:ad35357b4f4e8dbf29c3fad77850fb957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat a matrix along the diagonal a certain number of times, so that if A is a m by n matrix and we want to repeat along the diagonal d times, we get a m*d by n*d matrix B such that: B( (k*m+1):(k*m+1+m-1), (k*n+1):(k*n+1+n-1)) = A for k from 0 to d-1.  <br /></td></tr>
<tr class="separator:ad35357b4f4e8dbf29c3fad77850fb957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4425112c9b09eccba5935d7390228b8f" id="r_a4425112c9b09eccba5935d7390228b8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4425112c9b09eccba5935d7390228b8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4425112c9b09eccba5935d7390228b8f">repdiag</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;A, const int d, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;B)</td></tr>
<tr class="memdesc:a4425112c9b09eccba5935d7390228b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4425112c9b09eccba5935d7390228b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da20ed25cb6630b40cb666c4f0153fb" id="r_a8da20ed25cb6630b40cb666c4f0153fb"><td class="memTemplParams" colspan="2">template&lt;class Mat &gt; </td></tr>
<tr class="memitem:a8da20ed25cb6630b40cb666c4f0153fb"><td class="memTemplItemLeft" align="right" valign="top">Mat&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8da20ed25cb6630b40cb666c4f0153fb">repdiag</a> (const Mat &amp;A, const int d)</td></tr>
<tr class="memdesc:a8da20ed25cb6630b40cb666c4f0153fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a8da20ed25cb6630b40cb666c4f0153fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22441a0a5c291b8fd51ee68e5817c38" id="r_af22441a0a5c291b8fd51ee68e5817c38"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:af22441a0a5c291b8fd51ee68e5817c38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af22441a0a5c291b8fd51ee68e5817c38">repmat</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const int r, const int c, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:af22441a0a5c291b8fd51ee68e5817c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate and tile a matrix.  <br /></td></tr>
<tr class="separator:af22441a0a5c291b8fd51ee68e5817c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60f3cce9962403250a40b72d322e7c3" id="r_ab60f3cce9962403250a40b72d322e7c3"><td class="memTemplParams" colspan="2">template&lt;typename T , int majorType&gt; </td></tr>
<tr class="memitem:ab60f3cce9962403250a40b72d322e7c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab60f3cce9962403250a40b72d322e7c3">repmat</a> (const Eigen::SparseMatrix&lt; T, majorType &gt; &amp;A, const int r, const int c, Eigen::SparseMatrix&lt; T, majorType &gt; &amp;B)</td></tr>
<tr class="memdesc:ab60f3cce9962403250a40b72d322e7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab60f3cce9962403250a40b72d322e7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadc5b485c5ab4b8719143b79e9458b2" id="r_aaadc5b485c5ab4b8719143b79e9458b2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF1 , typename DerivedF2 , typename DerivedJ &gt; </td></tr>
<tr class="memitem:aaadc5b485c5ab4b8719143b79e9458b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aaadc5b485c5ab4b8719143b79e9458b2">resolve_duplicated_faces</a> (const Eigen::MatrixBase&lt; DerivedF1 &gt; &amp;F1, Eigen::PlainObjectBase&lt; DerivedF2 &gt; &amp;F2, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:aaadc5b485c5ab4b8719143b79e9458b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve duplicated faces according to the following rules per unique face:  <br /></td></tr>
<tr class="separator:aaadc5b485c5ab4b8719143b79e9458b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c02b0853de3739e4fcfe1a39591826" id="r_ad9c02b0853de3739e4fcfe1a39591826"><td class="memTemplParams" colspan="2">template&lt;typename R , typename H &gt; </td></tr>
<tr class="memitem:ad9c02b0853de3739e4fcfe1a39591826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad9c02b0853de3739e4fcfe1a39591826">rgb_to_hsv</a> (const R *rgb, H *hsv)</td></tr>
<tr class="memdesc:ad9c02b0853de3739e4fcfe1a39591826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert RGB to HSV.  <br /></td></tr>
<tr class="separator:ad9c02b0853de3739e4fcfe1a39591826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffa1e3139c0b53002dfc44fa70bb3de" id="r_a2ffa1e3139c0b53002dfc44fa70bb3de"><td class="memTemplParams" colspan="2">template&lt;typename DerivedR , typename DerivedH &gt; </td></tr>
<tr class="memitem:a2ffa1e3139c0b53002dfc44fa70bb3de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2ffa1e3139c0b53002dfc44fa70bb3de">rgb_to_hsv</a> (const Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedH &gt; &amp;H)</td></tr>
<tr class="memdesc:a2ffa1e3139c0b53002dfc44fa70bb3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2ffa1e3139c0b53002dfc44fa70bb3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b76e4f79b4040f8b327696d8120ac6" id="r_ad9b76e4f79b4040f8b327696d8120ac6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedP , typename DerivedN , typename DerivedR , typename Derivedt &gt; </td></tr>
<tr class="memitem:ad9b76e4f79b4040f8b327696d8120ac6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad9b76e4f79b4040f8b327696d8120ac6">rigid_alignment</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;t)</td></tr>
<tr class="memdesc:ad9b76e4f79b4040f8b327696d8120ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the rigid transformation that best aligns the 3D points X to their corresponding points P with associated normals N.  <br /></td></tr>
<tr class="separator:ad9b76e4f79b4040f8b327696d8120ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a4c70fcd75b8cb889db416e1412838" id="r_ad3a4c70fcd75b8cb889db416e1412838"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:ad3a4c70fcd75b8cb889db416e1412838"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad3a4c70fcd75b8cb889db416e1412838">rotate_by_quat</a> (const Q_type *v, const Q_type *q, Q_type *out)</td></tr>
<tr class="memdesc:ad3a4c70fcd75b8cb889db416e1412838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute rotation of a given vector/point by a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w.  <br /></td></tr>
<tr class="separator:ad3a4c70fcd75b8cb889db416e1412838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6346e87eb125dbf3922a86b2430cd66" id="r_ac6346e87eb125dbf3922a86b2430cd66"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac6346e87eb125dbf3922a86b2430cd66">rotate_vectors</a> (const Eigen::MatrixXd &amp;V, const Eigen::VectorXd &amp;A, const Eigen::MatrixXd &amp;B1, const Eigen::MatrixXd &amp;B2)</td></tr>
<tr class="memdesc:ac6346e87eb125dbf3922a86b2430cd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate the vectors V by A radians on the tangent plane spanned by B1 and B2.  <br /></td></tr>
<tr class="separator:ac6346e87eb125dbf3922a86b2430cd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8d4e651144f2c59335a8050526d3a2" id="r_a9d8d4e651144f2c59335a8050526d3a2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9d8d4e651144f2c59335a8050526d3a2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9d8d4e651144f2c59335a8050526d3a2">rotation_matrix_from_directions</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; v0, const Eigen::Matrix&lt; Scalar, 3, 1 &gt; v1)</td></tr>
<tr class="memdesc:a9d8d4e651144f2c59335a8050526d3a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given 2 vectors centered on origin calculate the rotation matrix from first to the second.  <br /></td></tr>
<tr class="separator:a9d8d4e651144f2c59335a8050526d3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02094b6dc03417864b855a494010674" id="r_ae02094b6dc03417864b855a494010674"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX &gt; </td></tr>
<tr class="memitem:ae02094b6dc03417864b855a494010674"><td class="memTemplItemLeft" align="right" valign="top">DerivedX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae02094b6dc03417864b855a494010674">round</a> (const DerivedX r)</td></tr>
<tr class="memdesc:ae02094b6dc03417864b855a494010674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a scalar value.  <br /></td></tr>
<tr class="separator:ae02094b6dc03417864b855a494010674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b570d716cfd4d32ff22a5ec6b1d14b" id="r_a97b570d716cfd4d32ff22a5ec6b1d14b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a97b570d716cfd4d32ff22a5ec6b1d14b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a97b570d716cfd4d32ff22a5ec6b1d14b">round</a> (const Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;X, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a97b570d716cfd4d32ff22a5ec6b1d14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round a given matrix to nearest integers.  <br /></td></tr>
<tr class="separator:a97b570d716cfd4d32ff22a5ec6b1d14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa793427dc212ca586bf37babf9459e" id="r_a7fa793427dc212ca586bf37babf9459e"><td class="memTemplParams" colspan="2">template&lt;class Row , class Mat &gt; </td></tr>
<tr class="memitem:a7fa793427dc212ca586bf37babf9459e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7fa793427dc212ca586bf37babf9459e">rows_to_matrix</a> (const std::vector&lt; Row &gt; &amp;V, Mat &amp;M)</td></tr>
<tr class="memdesc:a7fa793427dc212ca586bf37babf9459e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list (std::vector) of row vectors of the same length to a matrix.  <br /></td></tr>
<tr class="separator:a7fa793427dc212ca586bf37babf9459e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d8c4634efb1346c13c78dc765a3550" id="r_a32d8c4634efb1346c13c78dc765a3550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a32d8c4634efb1346c13c78dc765a3550">sample_edges</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;E, const int k, Eigen::MatrixXd &amp;S)</td></tr>
<tr class="memdesc:a32d8c4634efb1346c13c78dc765a3550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute k extra points along each edge in E defined over vertices of V.  <br /></td></tr>
<tr class="separator:a32d8c4634efb1346c13c78dc765a3550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037463f70cf735b53d1205d9f24f8bd3" id="r_a037463f70cf735b53d1205d9f24f8bd3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </td></tr>
<tr class="memitem:a037463f70cf735b53d1205d9f24f8bd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a037463f70cf735b53d1205d9f24f8bd3">scalar_to_cr_vector_gradient</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarG &gt; &amp;G)</td></tr>
<tr class="memdesc:a037463f70cf735b53d1205d9f24f8bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient matrix with hat functions on the right, and vector CR functions on the left.  <br /></td></tr>
<tr class="separator:a037463f70cf735b53d1205d9f24f8bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb08e6f491b4715eb69439e76a9d6829" id="r_adb08e6f491b4715eb69439e76a9d6829"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </td></tr>
<tr class="memitem:adb08e6f491b4715eb69439e76a9d6829"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adb08e6f491b4715eb69439e76a9d6829">scalar_to_cr_vector_gradient</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarG &gt; &amp;G)</td></tr>
<tr class="memdesc:adb08e6f491b4715eb69439e76a9d6829"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:adb08e6f491b4715eb69439e76a9d6829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27653ad9aae1bdd251eeb2b990cb69be" id="r_a27653ad9aae1bdd251eeb2b990cb69be"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DeriveddA , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </td></tr>
<tr class="memitem:a27653ad9aae1bdd251eeb2b990cb69be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a27653ad9aae1bdd251eeb2b990cb69be">scalar_to_cr_vector_gradient_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;dA, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarG &gt; &amp;G)</td></tr>
<tr class="memdesc:a27653ad9aae1bdd251eeb2b990cb69be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a27653ad9aae1bdd251eeb2b990cb69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e243eeab5d04120f9aa5670610e5961" id="r_a9e243eeab5d04120f9aa5670610e5961"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </td></tr>
<tr class="memitem:a9e243eeab5d04120f9aa5670610e5961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9e243eeab5d04120f9aa5670610e5961">scalar_to_cr_vector_gradient_intrinsic</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;l_sq, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;oE, Eigen::SparseMatrix&lt; ScalarG &gt; &amp;G)</td></tr>
<tr class="memdesc:a9e243eeab5d04120f9aa5670610e5961"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="scalar__to__cr__vector__gradient_8h.html">include/igl/scalar_to_cr_vector_gradient.h</a>.  <br /></td></tr>
<tr class="separator:a9e243eeab5d04120f9aa5670610e5961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aea89901f87476263f8973c9ea065e4" id="r_a0aea89901f87476263f8973c9ea065e4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW , typename Deriveda &gt; </td></tr>
<tr class="memitem:a0aea89901f87476263f8973c9ea065e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0aea89901f87476263f8973c9ea065e4">screen_space_selection</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;model, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;proj, const Eigen::MatrixBase&lt; DerivedO &gt; &amp;viewport, const std::vector&lt; Eigen::Matrix&lt; Ltype, 1, 2 &gt; &gt; &amp;L, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; Deriveda &gt; &amp;and_visible)</td></tr>
<tr class="memdesc:a0aea89901f87476263f8973c9ea065e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh, a camera determine which points are inside of a given 2D screen space polygon <b>culling points based on self-occlusion. </b> <br /></td></tr>
<tr class="separator:a0aea89901f87476263f8973c9ea065e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ba56f1ce1b064b681b9c9d1a258bf" id="r_aa76ba56f1ce1b064b681b9c9d1a258bf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW &gt; </td></tr>
<tr class="memitem:aa76ba56f1ce1b064b681b9c9d1a258bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa76ba56f1ce1b064b681b9c9d1a258bf">screen_space_selection</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;model, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;proj, const Eigen::MatrixBase&lt; DerivedO &gt; &amp;viewport, const std::vector&lt; Eigen::Matrix&lt; Ltype, 1, 2 &gt; &gt; &amp;L, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:aa76ba56f1ce1b064b681b9c9d1a258bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh, a camera determine which points are inside of a given 2D screen space polygon.  <br /></td></tr>
<tr class="separator:aa76ba56f1ce1b064b681b9c9d1a258bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad310e7bb193a3ef3e6b0de1b5598799b" id="r_ad310e7bb193a3ef3e6b0de1b5598799b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP , typename DerivedE , typename DerivedW &gt; </td></tr>
<tr class="memitem:ad310e7bb193a3ef3e6b0de1b5598799b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad310e7bb193a3ef3e6b0de1b5598799b">screen_space_selection</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;model, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;proj, const Eigen::MatrixBase&lt; DerivedO &gt; &amp;viewport, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:ad310e7bb193a3ef3e6b0de1b5598799b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh, a camera determine which points are inside of a given 2D screen space polygon.  <br /></td></tr>
<tr class="separator:ad310e7bb193a3ef3e6b0de1b5598799b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac159f8e26c3ca48a403dd1f27d3fd645" id="r_ac159f8e26c3ca48a403dd1f27d3fd645"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedTC , typename DerivedF , typename DerivedFTC , typename Derivedseams , typename Derivedboundaries , typename Derivedfoldovers &gt; </td></tr>
<tr class="memitem:ac159f8e26c3ca48a403dd1f27d3fd645"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac159f8e26c3ca48a403dd1f27d3fd645">seam_edges</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedTC &gt; &amp;TC, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedFTC &gt; &amp;FTC, Eigen::PlainObjectBase&lt; Derivedseams &gt; &amp;seams, Eigen::PlainObjectBase&lt; Derivedboundaries &gt; &amp;boundaries, Eigen::PlainObjectBase&lt; Derivedfoldovers &gt; &amp;foldovers)</td></tr>
<tr class="memdesc:ac159f8e26c3ca48a403dd1f27d3fd645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all UV-space boundaries of a mesh.  <br /></td></tr>
<tr class="separator:ac159f8e26c3ca48a403dd1f27d3fd645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c9b0f32a7605d9de8575ba478e0817" id="r_ab4c9b0f32a7605d9de8575ba478e0817"><td class="memTemplParams" colspan="2">template&lt;typename DerivedSource , typename DerivedDir &gt; </td></tr>
<tr class="memitem:ab4c9b0f32a7605d9de8575ba478e0817"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab4c9b0f32a7605d9de8575ba478e0817">segment_segment_intersect</a> (const Eigen::MatrixBase&lt; DerivedSource &gt; &amp;p, const Eigen::MatrixBase&lt; DerivedDir &gt; &amp;r, const Eigen::MatrixBase&lt; DerivedSource &gt; &amp;q, const Eigen::MatrixBase&lt; DerivedDir &gt; &amp;s, double &amp;t, double &amp;u, double eps=1e-6)</td></tr>
<tr class="memdesc:ab4c9b0f32a7605d9de8575ba478e0817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether two line segments A,B intersect.  <br /></td></tr>
<tr class="separator:ab4c9b0f32a7605d9de8575ba478e0817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212b29890b63152674a53444a2003677" id="r_a212b29890b63152674a53444a2003677"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a212b29890b63152674a53444a2003677"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a212b29890b63152674a53444a2003677">serialize</a> (const T &amp;obj, const std::string &amp;filename)</td></tr>
<tr class="separator:a212b29890b63152674a53444a2003677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bd82ed66c652d0930f6b460886010b" id="r_ab2bd82ed66c652d0930f6b460886010b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2bd82ed66c652d0930f6b460886010b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab2bd82ed66c652d0930f6b460886010b">serialize</a> (const T &amp;obj, const std::string &amp;objectName, const std::string &amp;filename, bool overwrite=false)</td></tr>
<tr class="separator:ab2bd82ed66c652d0930f6b460886010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e1aa7b19e544f9f8d0e5d2872c1b21" id="r_af1e1aa7b19e544f9f8d0e5d2872c1b21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1e1aa7b19e544f9f8d0e5d2872c1b21"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af1e1aa7b19e544f9f8d0e5d2872c1b21">serialize</a> (const T &amp;obj, const std::string &amp;objectName, std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr class="separator:af1e1aa7b19e544f9f8d0e5d2872c1b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61617b81f6b89d6692a31f8d34c6d294" id="r_a61617b81f6b89d6692a31f8d34c6d294"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61617b81f6b89d6692a31f8d34c6d294"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a61617b81f6b89d6692a31f8d34c6d294">deserialize</a> (T &amp;obj, const std::string &amp;filename)</td></tr>
<tr class="separator:a61617b81f6b89d6692a31f8d34c6d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dfda78a1c420b40f80b07d1c3f8b2e" id="r_aa8dfda78a1c420b40f80b07d1c3f8b2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8dfda78a1c420b40f80b07d1c3f8b2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa8dfda78a1c420b40f80b07d1c3f8b2e">deserialize</a> (T &amp;obj, const std::string &amp;objectName, const std::string &amp;filename)</td></tr>
<tr class="separator:aa8dfda78a1c420b40f80b07d1c3f8b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd8043bf43851bafaa6e264162eefce" id="r_a5dd8043bf43851bafaa6e264162eefce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dd8043bf43851bafaa6e264162eefce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5dd8043bf43851bafaa6e264162eefce">deserialize</a> (T &amp;obj, const std::string &amp;objectName, const std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr class="separator:a5dd8043bf43851bafaa6e264162eefce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b7a7a566f0d4a5553987d4d25aedec" id="r_ad1b7a7a566f0d4a5553987d4d25aedec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1b7a7a566f0d4a5553987d4d25aedec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad1b7a7a566f0d4a5553987d4d25aedec">serializer</a> (bool <a class="el" href="namespaceigl.html#a212b29890b63152674a53444a2003677">serialize</a>, T &amp;obj, const std::string &amp;filename)</td></tr>
<tr class="separator:ad1b7a7a566f0d4a5553987d4d25aedec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dba28198b48a2a0432d5c4e640484e4" id="r_a8dba28198b48a2a0432d5c4e640484e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8dba28198b48a2a0432d5c4e640484e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8dba28198b48a2a0432d5c4e640484e4">serializer</a> (bool <a class="el" href="namespaceigl.html#a212b29890b63152674a53444a2003677">serialize</a>, T &amp;obj, const std::string &amp;objectName, const std::string &amp;filename, bool overwrite=false)</td></tr>
<tr class="separator:a8dba28198b48a2a0432d5c4e640484e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28b32c6f34213f61257beff8a2927ca" id="r_af28b32c6f34213f61257beff8a2927ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af28b32c6f34213f61257beff8a2927ca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af28b32c6f34213f61257beff8a2927ca">serializer</a> (bool <a class="el" href="namespaceigl.html#a212b29890b63152674a53444a2003677">serialize</a>, T &amp;obj, const std::string &amp;objectName, std::vector&lt; char &gt; &amp;buffer)</td></tr>
<tr class="separator:af28b32c6f34213f61257beff8a2927ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa51487804e5c3f67e72d4ff8fceb1" id="r_ad9fa51487804e5c3f67e72d4ff8fceb1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedIA &gt; </td></tr>
<tr class="memitem:ad9fa51487804e5c3f67e72d4ff8fceb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad9fa51487804e5c3f67e72d4ff8fceb1">setdiff</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA)</td></tr>
<tr class="memdesc:ad9fa51487804e5c3f67e72d4ff8fceb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set difference of elements of matrices.  <br /></td></tr>
<tr class="separator:ad9fa51487804e5c3f67e72d4ff8fceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925a8ea3a2337a70f7cadc603e7e741e" id="r_a925a8ea3a2337a70f7cadc603e7e741e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedIA , typename DerivedIB &gt; </td></tr>
<tr class="memitem:a925a8ea3a2337a70f7cadc603e7e741e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a925a8ea3a2337a70f7cadc603e7e741e">setunion</a> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, const Eigen::DenseBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIB &gt; &amp;IB)</td></tr>
<tr class="memdesc:a925a8ea3a2337a70f7cadc603e7e741e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of elements of matrices (like matlab's <code>union</code>)  <br /></td></tr>
<tr class="separator:a925a8ea3a2337a70f7cadc603e7e741e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbf23ea4d8a5f3ef6ce4117496fb037" id="r_a9bbf23ea4d8a5f3ef6ce4117496fb037"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedIA , typename DerivedIB &gt; </td></tr>
<tr class="memitem:a9bbf23ea4d8a5f3ef6ce4117496fb037"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9bbf23ea4d8a5f3ef6ce4117496fb037">setxor</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIB &gt; &amp;IB)</td></tr>
<tr class="memdesc:a9bbf23ea4d8a5f3ef6ce4117496fb037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set xor of elements of matrices.  <br /></td></tr>
<tr class="separator:a9bbf23ea4d8a5f3ef6ce4117496fb037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df5a621d40fe169f2138e39b8b81fec" id="r_a3df5a621d40fe169f2138e39b8b81fec"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a3df5a621d40fe169f2138e39b8b81fec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3df5a621d40fe169f2138e39b8b81fec">shape_diameter_function</a> (const std::function&lt; double(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;) &gt; &amp;shoot_ray, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a3df5a621d40fe169f2138e39b8b81fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute shape diamater function per given point.  <br /></td></tr>
<tr class="separator:a3df5a621d40fe169f2138e39b8b81fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982784dfbf6aae442c5e9b0bc3fdcb53" id="r_a982784dfbf6aae442c5e9b0bc3fdcb53"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a982784dfbf6aae442c5e9b0bc3fdcb53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a982784dfbf6aae442c5e9b0bc3fdcb53">shape_diameter_function</a> (const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedV, DIM &gt; &amp;aabb, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a982784dfbf6aae442c5e9b0bc3fdcb53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a982784dfbf6aae442c5e9b0bc3fdcb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e0193f9523e75a450e14e3cf8179fd" id="r_a46e0193f9523e75a450e14e3cf8179fd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a46e0193f9523e75a450e14e3cf8179fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a46e0193f9523e75a450e14e3cf8179fd">shape_diameter_function</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a46e0193f9523e75a450e14e3cf8179fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a46e0193f9523e75a450e14e3cf8179fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725c756cdeba9b4dbc64ab4a50c50cfa" id="r_a725c756cdeba9b4dbc64ab4a50c50cfa"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedS &gt; </td></tr>
<tr class="memitem:a725c756cdeba9b4dbc64ab4a50c50cfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a725c756cdeba9b4dbc64ab4a50c50cfa">shape_diameter_function</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const bool per_face, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="separator:a725c756cdeba9b4dbc64ab4a50c50cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df9db393a5b6b3865e7a10d9d02a31b" id="r_a5df9db393a5b6b3865e7a10d9d02a31b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5df9db393a5b6b3865e7a10d9d02a31b">shapeup_identity_projection</a> (const Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;P, const Eigen::PlainObjectBase&lt; Eigen::VectorXi &gt; &amp;SC, const Eigen::PlainObjectBase&lt; Eigen::MatrixXi &gt; &amp;S, Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;projP)</td></tr>
<tr class="memdesc:a5df9db393a5b6b3865e7a10d9d02a31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This projection does nothing but render points into projP.  <br /></td></tr>
<tr class="separator:a5df9db393a5b6b3865e7a10d9d02a31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaced06a2a1f184dc5bfe8ff1b87d6d0d" id="r_aaced06a2a1f184dc5bfe8ff1b87d6d0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aaced06a2a1f184dc5bfe8ff1b87d6d0d">shapeup_regular_face_projection</a> (const Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;P, const Eigen::PlainObjectBase&lt; Eigen::VectorXi &gt; &amp;SC, const Eigen::PlainObjectBase&lt; Eigen::MatrixXi &gt; &amp;S, Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;projP)</td></tr>
<tr class="memdesc:aaced06a2a1f184dc5bfe8ff1b87d6d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the projection assumes that the sets are vertices of polygons in cyclic order  <br /></td></tr>
<tr class="separator:aaced06a2a1f184dc5bfe8ff1b87d6d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a2c7d2cbbaf046ff244daa6620895" id="r_ad94a2c7d2cbbaf046ff244daa6620895"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedSC , typename DerivedS , typename Derivedw &gt; </td></tr>
<tr class="memitem:ad94a2c7d2cbbaf046ff244daa6620895"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad94a2c7d2cbbaf046ff244daa6620895">shapeup_precomputation</a> (const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedSC &gt; &amp;SC, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;E, const Eigen::PlainObjectBase&lt; DerivedSC &gt; &amp;b, const Eigen::PlainObjectBase&lt; Derivedw &gt; &amp;wShape, const Eigen::PlainObjectBase&lt; Derivedw &gt; &amp;wSmooth, <a class="el" href="structigl_1_1ShapeupData.html">ShapeupData</a> &amp;sudata)</td></tr>
<tr class="memdesc:ad94a2c7d2cbbaf046ff244daa6620895"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function precomputation the necessary matrices for the ShapeUp process, and prefactorizes them.  <br /></td></tr>
<tr class="separator:ad94a2c7d2cbbaf046ff244daa6620895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6baf02654fad9293e1560d71475185" id="r_a9b6baf02654fad9293e1560d71475185"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedSC , typename DerivedS &gt; </td></tr>
<tr class="memitem:a9b6baf02654fad9293e1560d71475185"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b6baf02654fad9293e1560d71475185">shapeup_solve</a> (const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;bc, const std::function&lt; bool(const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;, const Eigen::PlainObjectBase&lt; DerivedSC &gt; &amp;, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;)&gt; &amp;local_projection, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P0, const <a class="el" href="structigl_1_1ShapeupData.html">ShapeupData</a> &amp;sudata, const bool quietIterations, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a9b6baf02654fad9293e1560d71475185"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function solve the shapeup project optimization.  <br /></td></tr>
<tr class="separator:a9b6baf02654fad9293e1560d71475185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1cfc3d745b201faa8129b75d5a3b79" id="r_a0b1cfc3d745b201faa8129b75d5a3b79"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedSE , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2Etype , typename sharptype &gt; </td></tr>
<tr class="memitem:a0b1cfc3d745b201faa8129b75d5a3b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0b1cfc3d745b201faa8129b75d5a3b79">sharp_edges</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedV::Scalar angle, Eigen::PlainObjectBase&lt; DerivedSE &gt; &amp;SE, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, std::vector&lt; std::vector&lt; uE2Etype &gt; &gt; &amp;uE2E, std::vector&lt; sharptype &gt; &amp;sharp)</td></tr>
<tr class="memdesc:a0b1cfc3d745b201faa8129b75d5a3b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mesh, compute sharp edges.  <br /></td></tr>
<tr class="separator:a0b1cfc3d745b201faa8129b75d5a3b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7002429ac13c0e1d678e1e9d9aea99d8" id="r_a7002429ac13c0e1d678e1e9d9aea99d8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedSE &gt; </td></tr>
<tr class="memitem:a7002429ac13c0e1d678e1e9d9aea99d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7002429ac13c0e1d678e1e9d9aea99d8">sharp_edges</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const typename DerivedV::Scalar angle, Eigen::PlainObjectBase&lt; DerivedSE &gt; &amp;SE)</td></tr>
<tr class="memdesc:a7002429ac13c0e1d678e1e9d9aea99d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7002429ac13c0e1d678e1e9d9aea99d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571aed34e627db21360984824ccc7838" id="r_a571aed34e627db21360984824ccc7838"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a571aed34e627db21360984824ccc7838">shortest_edge_and_midpoint</a> (const int e, const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;E, const Eigen::VectorXi &amp;, const Eigen::MatrixXi &amp;, const Eigen::MatrixXi &amp;, double &amp;cost, Eigen::RowVectorXd &amp;p)</td></tr>
<tr class="memdesc:a571aed34e627db21360984824ccc7838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cost and placement function compatible with <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>.  <br /></td></tr>
<tr class="separator:a571aed34e627db21360984824ccc7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da3ad1832aa83542b3dc3a28e1a8e1" id="r_a78da3ad1832aa83542b3dc3a28e1a8e1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedP &gt; </td></tr>
<tr class="memitem:a78da3ad1832aa83542b3dc3a28e1a8e1"><td class="memTemplItemLeft" align="right" valign="top">DerivedA::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a78da3ad1832aa83542b3dc3a28e1a8e1">signed_angle</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:a78da3ad1832aa83542b3dc3a28e1a8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed angle subtended by the oriented 3d triangle (A,B,C) at some point P.  <br /></td></tr>
<tr class="separator:a78da3ad1832aa83542b3dc3a28e1a8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f93a7b569504f70587f81f75fd879" id="r_a094f93a7b569504f70587f81f75fd879"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN &gt; </td></tr>
<tr class="memitem:a094f93a7b569504f70587f81f75fd879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a094f93a7b569504f70587f81f75fd879">signed_distance</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a> sign_type, const typename DerivedV::Scalar lower_bound, const typename DerivedV::Scalar upper_bound, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a094f93a7b569504f70587f81f75fd879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes signed distance to a mesh.  <br /></td></tr>
<tr class="separator:a094f93a7b569504f70587f81f75fd879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9379f935afc42d6fbad6340c07639c54" id="r_a9379f935afc42d6fbad6340c07639c54"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN &gt; </td></tr>
<tr class="memitem:a9379f935afc42d6fbad6340c07639c54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9379f935afc42d6fbad6340c07639c54">signed_distance</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a> sign_type, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:a9379f935afc42d6fbad6340c07639c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9379f935afc42d6fbad6340c07639c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102279423d1d1b649cdf6a74558883dc" id="r_a102279423d1d1b649cdf6a74558883dc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename Derivedq &gt; </td></tr>
<tr class="memitem:a102279423d1d1b649cdf6a74558883dc"><td class="memTemplItemLeft" align="right" valign="top">DerivedV::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a102279423d1d1b649cdf6a74558883dc">signed_distance_pseudonormal</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;VN, const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;EN, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q)</td></tr>
<tr class="memdesc:a102279423d1d1b649cdf6a74558883dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes signed distance to mesh using pseudonormal with precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree and edge/vertice normals.  <br /></td></tr>
<tr class="separator:a102279423d1d1b649cdf6a74558883dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead78bb0215bc26bdb1dafabc8366acd" id="r_aead78bb0215bc26bdb1dafabc8366acd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN &gt; </td></tr>
<tr class="memitem:aead78bb0215bc26bdb1dafabc8366acd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aead78bb0215bc26bdb1dafabc8366acd">signed_distance_pseudonormal</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;VN, const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;EN, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N)</td></tr>
<tr class="memdesc:aead78bb0215bc26bdb1dafabc8366acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a>.  <br /></td></tr>
<tr class="separator:aead78bb0215bc26bdb1dafabc8366acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391b1e9f4f4bc678fac2b8c522ce4331" id="r_a391b1e9f4f4bc678fac2b8c522ce4331"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn &gt; </td></tr>
<tr class="memitem:a391b1e9f4f4bc678fac2b8c522ce4331"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a391b1e9f4f4bc678fac2b8c522ce4331">signed_distance_pseudonormal</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;VN, const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;EN, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, Scalar &amp;s, Scalar &amp;sqrd, int &amp;i, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;n)</td></tr>
<tr class="memdesc:a391b1e9f4f4bc678fac2b8c522ce4331"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a391b1e9f4f4bc678fac2b8c522ce4331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5011d0263ec9b3347530d3d807596671" id="r_a5011d0263ec9b3347530d3d807596671"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE , typename DerivedEN , typename DerivedVN , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn &gt; </td></tr>
<tr class="memitem:a5011d0263ec9b3347530d3d807596671"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5011d0263ec9b3347530d3d807596671">signed_distance_pseudonormal</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 2 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;EN, const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;VN, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, Scalar &amp;s, Scalar &amp;sqrd, int &amp;i, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c, Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;n)</td></tr>
<tr class="memdesc:a5011d0263ec9b3347530d3d807596671"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5011d0263ec9b3347530d3d807596671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75576a9807c547b55f797639412650d6" id="r_a75576a9807c547b55f797639412650d6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedq &gt; </td></tr>
<tr class="memitem:a75576a9807c547b55f797639412650d6"><td class="memTemplItemLeft" align="right" valign="top">DerivedV::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a75576a9807c547b55f797639412650d6">signed_distance_winding_number</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1WindingNumberAABB.html">igl::WindingNumberAABB</a>&lt; Derivedq, DerivedV, DerivedF &gt; &amp;hier, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q)</td></tr>
<tr class="memdesc:a75576a9807c547b55f797639412650d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes signed distance to mesh using winding number with precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a>.  <br /></td></tr>
<tr class="separator:a75576a9807c547b55f797639412650d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad184a41c6d66cebef9a4714a2d59326f" id="r_ad184a41c6d66cebef9a4714a2d59326f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc &gt; </td></tr>
<tr class="memitem:ad184a41c6d66cebef9a4714a2d59326f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad184a41c6d66cebef9a4714a2d59326f">signed_distance_winding_number</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1WindingNumberAABB.html">igl::WindingNumberAABB</a>&lt; Derivedq, DerivedV, DerivedF &gt; &amp;hier, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, Scalar &amp;s, Scalar &amp;sqrd, int &amp;i, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c)</td></tr>
<tr class="memdesc:ad184a41c6d66cebef9a4714a2d59326f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad184a41c6d66cebef9a4714a2d59326f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25f0719d3f6108b4917e1511a4941f5" id="r_af25f0719d3f6108b4917e1511a4941f5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc &gt; </td></tr>
<tr class="memitem:af25f0719d3f6108b4917e1511a4941f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af25f0719d3f6108b4917e1511a4941f5">signed_distance_winding_number</a> (const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 2 &gt; &amp;tree, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, Scalar &amp;s, Scalar &amp;sqrd, int &amp;i, Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;c)</td></tr>
<tr class="memdesc:af25f0719d3f6108b4917e1511a4941f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af25f0719d3f6108b4917e1511a4941f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88918723d512e80456d10a043fa25177" id="r_a88918723d512e80456d10a043fa25177"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS &gt; </td></tr>
<tr class="memitem:a88918723d512e80456d10a043fa25177"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a88918723d512e80456d10a043fa25177">signed_distance_fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const igl::FastWindingNumberBVH &amp;fwn_bvh, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a88918723d512e80456d10a043fa25177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates signed distance at query points P, using fast winding number for sign.  <br /></td></tr>
<tr class="separator:a88918723d512e80456d10a043fa25177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dabf308e8466b0ec192b798fc538eb4" id="r_a0dabf308e8466b0ec192b798fc538eb4"><td class="memTemplParams" colspan="2">template&lt;typename Derivedq , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a0dabf308e8466b0ec192b798fc538eb4"><td class="memTemplItemLeft" align="right" valign="top">DerivedV::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0dabf308e8466b0ec192b798fc538eb4">signed_distance_fast_winding_number</a> (const Eigen::MatrixBase&lt; Derivedq &gt; &amp;q, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;tree, const igl::FastWindingNumberBVH &amp;fwn_bvh)</td></tr>
<tr class="memdesc:a0dabf308e8466b0ec192b798fc538eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates signed distance at query point q, using fast winding number for sign.  <br /></td></tr>
<tr class="separator:a0dabf308e8466b0ec192b798fc538eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3b37a4f86172d30f35d330aed1e7fe" id="r_a4d3b37a4f86172d30f35d330aed1e7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4d3b37a4f86172d30f35d330aed1e7fe">simplify_polyhedron</a> (const Eigen::MatrixXd &amp;OV, const Eigen::MatrixXi &amp;OF, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::VectorXi &amp;J)</td></tr>
<tr class="memdesc:a4d3b37a4f86172d30f35d330aed1e7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify a polyhedron represented as a triangle mesh (OV,OF) by collapsing any edge that doesn't contribute to defining surface's pointset.  <br /></td></tr>
<tr class="separator:a4d3b37a4f86172d30f35d330aed1e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547a8704200d3af48fe92105c15a32ad" id="r_a547a8704200d3af48fe92105c15a32ad"><td class="memTemplParams" colspan="2">template&lt;typename TX , typename TY , typename DerivedR , typename DerivedC &gt; </td></tr>
<tr class="memitem:a547a8704200d3af48fe92105c15a32ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a547a8704200d3af48fe92105c15a32ad">slice</a> (const Eigen::SparseMatrix&lt; TX &gt; &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R, const Eigen::DenseBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; TY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a547a8704200d3af48fe92105c15a32ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negative integer indices.  <br /></td></tr>
<tr class="separator:a547a8704200d3af48fe92105c15a32ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae747d042c40e074264e161b49906216d" id="r_ae747d042c40e074264e161b49906216d"><td class="memTemplParams" colspan="2">template&lt;typename MatX , typename DerivedR , typename MatY &gt; </td></tr>
<tr class="memitem:ae747d042c40e074264e161b49906216d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae747d042c40e074264e161b49906216d">slice</a> (const MatX &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R, const int dim, MatY &amp;Y)</td></tr>
<tr class="memdesc:ae747d042c40e074264e161b49906216d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae747d042c40e074264e161b49906216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05264f934b9cecbac042ef69735b74b" id="r_aa05264f934b9cecbac042ef69735b74b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa05264f934b9cecbac042ef69735b74b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa05264f934b9cecbac042ef69735b74b">slice</a> (const std::vector&lt; T &gt; &amp;X, std::vector&lt; size_t &gt; const &amp;R, std::vector&lt; T &gt; &amp;Y)</td></tr>
<tr class="memdesc:aa05264f934b9cecbac042ef69735b74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa05264f934b9cecbac042ef69735b74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8c4cf15b6f5f8cc16da9405b96be59" id="r_aae8c4cf15b6f5f8cc16da9405b96be59"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedR &gt; </td></tr>
<tr class="memitem:aae8c4cf15b6f5f8cc16da9405b96be59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aae8c4cf15b6f5f8cc16da9405b96be59">slice</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:aae8c4cf15b6f5f8cc16da9405b96be59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aae8c4cf15b6f5f8cc16da9405b96be59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90268d9fb8c64692427036793191a8b7" id="r_a90268d9fb8c64692427036793191a8b7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedR , typename DerivedC , typename DerivedY &gt; </td></tr>
<tr class="memitem:a90268d9fb8c64692427036793191a8b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a90268d9fb8c64692427036793191a8b7">slice</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R, const Eigen::DenseBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a90268d9fb8c64692427036793191a8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a90268d9fb8c64692427036793191a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86abeffa3ef136e9e35057e526618dc8" id="r_a86abeffa3ef136e9e35057e526618dc8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedR &gt; </td></tr>
<tr class="memitem:a86abeffa3ef136e9e35057e526618dc8"><td class="memTemplItemLeft" align="right" valign="top">DerivedX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a86abeffa3ef136e9e35057e526618dc8">slice</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R)</td></tr>
<tr class="memdesc:a86abeffa3ef136e9e35057e526618dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a86abeffa3ef136e9e35057e526618dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5271870d0385781c2236145ee9c3897" id="r_aa5271870d0385781c2236145ee9c3897"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedR &gt; </td></tr>
<tr class="memitem:aa5271870d0385781c2236145ee9c3897"><td class="memTemplItemLeft" align="right" valign="top">DerivedX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa5271870d0385781c2236145ee9c3897">slice</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R, const int dim)</td></tr>
<tr class="memdesc:aa5271870d0385781c2236145ee9c3897"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa5271870d0385781c2236145ee9c3897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473da3d5636834fa6b0510d7a2f97628" id="r_a473da3d5636834fa6b0510d7a2f97628"><td class="memTemplParams" colspan="2">template&lt;typename TX , typename TY , typename DerivedI &gt; </td></tr>
<tr class="memitem:a473da3d5636834fa6b0510d7a2f97628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a473da3d5636834fa6b0510d7a2f97628">slice_cached_precompute</a> (const Eigen::SparseMatrix&lt; TX &gt; &amp;X, const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;R, const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;C, Eigen::MatrixBase&lt; DerivedI &gt; &amp;data, Eigen::SparseMatrix&lt; TY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a473da3d5636834fa6b0510d7a2f97628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negative integer indices.  <br /></td></tr>
<tr class="separator:a473da3d5636834fa6b0510d7a2f97628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192c36479a5f74cfc02aaddd3afa4fea" id="r_a192c36479a5f74cfc02aaddd3afa4fea"><td class="memTemplParams" colspan="2">template&lt;typename TX , typename TY , typename DerivedI &gt; </td></tr>
<tr class="memitem:a192c36479a5f74cfc02aaddd3afa4fea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a192c36479a5f74cfc02aaddd3afa4fea">slice_cached</a> (const Eigen::SparseMatrix&lt; TX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;data, Eigen::SparseMatrix&lt; TY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a192c36479a5f74cfc02aaddd3afa4fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slice X by cached C,R indices into Y.  <br /></td></tr>
<tr class="separator:a192c36479a5f74cfc02aaddd3afa4fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab893d0a94d4eb6a1c5422e7cfe368daf" id="r_ab893d0a94d4eb6a1c5422e7cfe368daf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedR , typename DerivedC &gt; </td></tr>
<tr class="memitem:ab893d0a94d4eb6a1c5422e7cfe368daf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab893d0a94d4eb6a1c5422e7cfe368daf">slice_into</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; T &gt; &amp;Y)</td></tr>
<tr class="memdesc:ab893d0a94d4eb6a1c5422e7cfe368daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like the matlab Y(row_indices,col_indices) = X.  <br /></td></tr>
<tr class="separator:ab893d0a94d4eb6a1c5422e7cfe368daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185ee703c7cf8760af368bcb0861d37f" id="r_a185ee703c7cf8760af368bcb0861d37f"><td class="memTemplParams" colspan="2">template&lt;typename MatX , typename MatY , typename DerivedR &gt; </td></tr>
<tr class="memitem:a185ee703c7cf8760af368bcb0861d37f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a185ee703c7cf8760af368bcb0861d37f">slice_into</a> (const MatX &amp;X, const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const int dim, MatY &amp;Y)</td></tr>
<tr class="memdesc:a185ee703c7cf8760af368bcb0861d37f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a185ee703c7cf8760af368bcb0861d37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce428bb768059c8d6f9563873f8e730" id="r_afce428bb768059c8d6f9563873f8e730"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedC &gt; </td></tr>
<tr class="memitem:afce428bb768059c8d6f9563873f8e730"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afce428bb768059c8d6f9563873f8e730">slice_into</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:afce428bb768059c8d6f9563873f8e730"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:afce428bb768059c8d6f9563873f8e730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b762b3094e33fd5167ca196de49ce" id="r_aa29b762b3094e33fd5167ca196de49ce"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedR , typename DerivedY &gt; </td></tr>
<tr class="memitem:aa29b762b3094e33fd5167ca196de49ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa29b762b3094e33fd5167ca196de49ce">slice_into</a> (const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:aa29b762b3094e33fd5167ca196de49ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa29b762b3094e33fd5167ca196de49ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb30d6061d773254628256682b88b427" id="r_acb30d6061d773254628256682b88b427"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename YType &gt; </td></tr>
<tr class="memitem:acb30d6061d773254628256682b88b427"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acb30d6061d773254628256682b88b427">slice_mask</a> (const Eigen::SparseMatrix&lt; XType &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;C, Eigen::SparseMatrix&lt; YType &gt; &amp;Y)</td></tr>
<tr class="memdesc:acb30d6061d773254628256682b88b427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like the matlab X(row_mask,col_mask) operator, where row_mask, col_mask are non-negative integer indices.  <br /></td></tr>
<tr class="separator:acb30d6061d773254628256682b88b427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6770877236349590d6b4bbc2a6f616ad" id="r_a6770877236349590d6b4bbc2a6f616ad"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename YType &gt; </td></tr>
<tr class="memitem:a6770877236349590d6b4bbc2a6f616ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6770877236349590d6b4bbc2a6f616ad">slice_mask</a> (const Eigen::SparseMatrix&lt; XType &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const int dim, Eigen::SparseMatrix&lt; YType &gt; &amp;Y)</td></tr>
<tr class="memdesc:a6770877236349590d6b4bbc2a6f616ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6770877236349590d6b4bbc2a6f616ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef569f1ee0e9cd71c2cfabd1e27e2f40" id="r_aef569f1ee0e9cd71c2cfabd1e27e2f40"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:aef569f1ee0e9cd71c2cfabd1e27e2f40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aef569f1ee0e9cd71c2cfabd1e27e2f40">slice_mask</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:aef569f1ee0e9cd71c2cfabd1e27e2f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aef569f1ee0e9cd71c2cfabd1e27e2f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab448e84d310f37a2cffd09d50faad326" id="r_ab448e84d310f37a2cffd09d50faad326"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:ab448e84d310f37a2cffd09d50faad326"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab448e84d310f37a2cffd09d50faad326">slice_mask</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const int dim, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="separator:ab448e84d310f37a2cffd09d50faad326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe884ab3e3a80bcea135959a5b9aa831" id="r_afe884ab3e3a80bcea135959a5b9aa831"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX &gt; </td></tr>
<tr class="memitem:afe884ab3e3a80bcea135959a5b9aa831"><td class="memTemplItemLeft" align="right" valign="top">DerivedX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afe884ab3e3a80bcea135959a5b9aa831">slice_mask</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;C)</td></tr>
<tr class="memdesc:afe884ab3e3a80bcea135959a5b9aa831"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:afe884ab3e3a80bcea135959a5b9aa831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4dd189219e52c3496a80f36b82cbbce" id="r_ae4dd189219e52c3496a80f36b82cbbce"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX &gt; </td></tr>
<tr class="memitem:ae4dd189219e52c3496a80f36b82cbbce"><td class="memTemplItemLeft" align="right" valign="top">DerivedX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae4dd189219e52c3496a80f36b82cbbce">slice_mask</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const int dim)</td></tr>
<tr class="memdesc:ae4dd189219e52c3496a80f36b82cbbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae4dd189219e52c3496a80f36b82cbbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a1c0b05598d819b78e57f2525f5497" id="r_af8a1c0b05598d819b78e57f2525f5497"><td class="memTemplParams" colspan="2">template&lt;typename TX , typename TY , typename DerivedR , typename DerivedC &gt; </td></tr>
<tr class="memitem:af8a1c0b05598d819b78e57f2525f5497"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af8a1c0b05598d819b78e57f2525f5497">slice_sorted</a> (const Eigen::SparseMatrix&lt; TX &gt; &amp;X, const Eigen::DenseBase&lt; DerivedR &gt; &amp;R, const Eigen::DenseBase&lt; DerivedC &gt; &amp;C, Eigen::SparseMatrix&lt; TY &gt; &amp;Y)</td></tr>
<tr class="memdesc:af8a1c0b05598d819b78e57f2525f5497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negative integer indices.  <br /></td></tr>
<tr class="separator:af8a1c0b05598d819b78e57f2525f5497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b29382a965c510055a154aac6ecde4e" id="r_a4b29382a965c510055a154aac6ecde4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4b29382a965c510055a154aac6ecde4e">slim_precompute</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXd &amp;V_init, <a class="el" href="structigl_1_1SLIMData.html">SLIMData</a> &amp;data, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">MappingEnergyType</a> slim_energy, const Eigen::VectorXi &amp;b, const Eigen::MatrixXd &amp;bc, double soft_p)</td></tr>
<tr class="memdesc:a4b29382a965c510055a154aac6ecde4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute necessary information to start using SLIM.  <br /></td></tr>
<tr class="separator:a4b29382a965c510055a154aac6ecde4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5651f5d9a88f7dc131b6dd3b99f31fdf" id="r_a5651f5d9a88f7dc131b6dd3b99f31fdf"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5651f5d9a88f7dc131b6dd3b99f31fdf">slim_solve</a> (<a class="el" href="structigl_1_1SLIMData.html">SLIMData</a> &amp;data, int iter_num)</td></tr>
<tr class="memdesc:a5651f5d9a88f7dc131b6dd3b99f31fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run iter_num iterations of SLIM.  <br /></td></tr>
<tr class="separator:a5651f5d9a88f7dc131b6dd3b99f31fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c86d444aaf4ab498a1466a59775059" id="r_a02c86d444aaf4ab498a1466a59775059"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a02c86d444aaf4ab498a1466a59775059">slim_update_weights_and_closest_rotations_with_jacobians</a> (const Eigen::MatrixXd &amp;Ji, <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">igl::MappingEnergyType</a> slim_energy, double exp_factor, Eigen::MatrixXd &amp;W, Eigen::MatrixXd &amp;Ri)</td></tr>
<tr class="memdesc:a02c86d444aaf4ab498a1466a59775059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Routine.  <br /></td></tr>
<tr class="separator:a02c86d444aaf4ab498a1466a59775059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a2368c134ab7daeb5cfb40b5a0e639" id="r_ac1a2368c134ab7daeb5cfb40b5a0e639"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac1a2368c134ab7daeb5cfb40b5a0e639">slim_buildA</a> (const Eigen::SparseMatrix&lt; double &gt; &amp;Dx, const Eigen::SparseMatrix&lt; double &gt; &amp;Dy, const Eigen::SparseMatrix&lt; double &gt; &amp;Dz, const Eigen::MatrixXd &amp;W, std::vector&lt; Eigen::Triplet&lt; double &gt; &gt; &amp;IJV)</td></tr>
<tr class="memdesc:ac1a2368c134ab7daeb5cfb40b5a0e639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undocumented function related to SLIM optimization.  <br /></td></tr>
<tr class="separator:ac1a2368c134ab7daeb5cfb40b5a0e639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e220e449787733ece4abbc94f419a" id="r_aef5e220e449787733ece4abbc94f419a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aef5e220e449787733ece4abbc94f419a">smooth_corner_adjacency</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const double corner_threshold_radians, Eigen::VectorXi &amp;CI, Eigen::VectorXi &amp;CC)</td></tr>
<tr class="memdesc:aef5e220e449787733ece4abbc94f419a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the corner-to-face adjacency relationship that can be used for computing crease-aware per-corner normals.  <br /></td></tr>
<tr class="separator:aef5e220e449787733ece4abbc94f419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eedd51ba703a9667e0bc21d6de863d8" id="r_a6eedd51ba703a9667e0bc21d6de863d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6eedd51ba703a9667e0bc21d6de863d8">smooth_corner_adjacency</a> (const Eigen::MatrixXi &amp;FV, const Eigen::MatrixXi &amp;FN, Eigen::VectorXi &amp;CI, Eigen::VectorXi &amp;CC)</td></tr>
<tr class="memdesc:a6eedd51ba703a9667e0bc21d6de863d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the effective corner-to-face adjacency relationship implied by a set of indexed vertex positions (FV) and normals (FV) (e.g., those read in from a .obj file).  <br /></td></tr>
<tr class="separator:a6eedd51ba703a9667e0bc21d6de863d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c65a87d0656aad1a67568ce7fe62505" id="r_a3c65a87d0656aad1a67568ce7fe62505"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD , typename DerivedVI &gt; </td></tr>
<tr class="memitem:a3c65a87d0656aad1a67568ce7fe62505"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3c65a87d0656aad1a67568ce7fe62505">snap_points</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedminD &gt; &amp;minD, Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;VI)</td></tr>
<tr class="memdesc:a3c65a87d0656aad1a67568ce7fe62505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snap list of points C to closest of another list of points V.  <br /></td></tr>
<tr class="separator:a3c65a87d0656aad1a67568ce7fe62505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0456e1ef831df9943ee2f062e8119655" id="r_a0456e1ef831df9943ee2f062e8119655"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD &gt; </td></tr>
<tr class="memitem:a0456e1ef831df9943ee2f062e8119655"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0456e1ef831df9943ee2f062e8119655">snap_points</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedminD &gt; &amp;minD)</td></tr>
<tr class="memdesc:a0456e1ef831df9943ee2f062e8119655"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0456e1ef831df9943ee2f062e8119655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76c38e927f8da17319f7809593f78b0" id="r_aa76c38e927f8da17319f7809593f78b0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC , typename DerivedV , typename DerivedI &gt; </td></tr>
<tr class="memitem:aa76c38e927f8da17319f7809593f78b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa76c38e927f8da17319f7809593f78b0">snap_points</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:aa76c38e927f8da17319f7809593f78b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa76c38e927f8da17319f7809593f78b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2773ac49873440379d546be16bf756e8" id="r_a2773ac49873440379d546be16bf756e8"><td class="memTemplParams" colspan="2">template&lt;typename Scalarq , typename Scalars &gt; </td></tr>
<tr class="memitem:a2773ac49873440379d546be16bf756e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2773ac49873440379d546be16bf756e8">snap_to_canonical_view_quat</a> (const Eigen::Quaternion&lt; Scalarq &gt; &amp;q, const double threshold, Eigen::Quaternion&lt; Scalars &gt; &amp;s)</td></tr>
<tr class="memdesc:a2773ac49873440379d546be16bf756e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snap the quaternion q to the nearest canonical view quaternion.  <br /></td></tr>
<tr class="separator:a2773ac49873440379d546be16bf756e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972274b2ed4c85251899428421619ad5" id="r_a972274b2ed4c85251899428421619ad5"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:a972274b2ed4c85251899428421619ad5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a972274b2ed4c85251899428421619ad5">snap_to_canonical_view_quat</a> (const Q_type *q, const Q_type threshold, Q_type *s)</td></tr>
<tr class="memdesc:a972274b2ed4c85251899428421619ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a972274b2ed4c85251899428421619ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6de4ebdb7f531d96fb57a566e0d121c" id="r_af6de4ebdb7f531d96fb57a566e0d121c"><td class="memTemplParams" colspan="2">template&lt;typename Qtype &gt; </td></tr>
<tr class="memitem:af6de4ebdb7f531d96fb57a566e0d121c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af6de4ebdb7f531d96fb57a566e0d121c">snap_to_fixed_up</a> (const Eigen::Quaternion&lt; Qtype &gt; &amp;q, Eigen::Quaternion&lt; Qtype &gt; &amp;s)</td></tr>
<tr class="memdesc:af6de4ebdb7f531d96fb57a566e0d121c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snap an arbitrary rotation to a rotation resulting from a rotation about the y-axis then the x-axis (maintaining fixed up like two_axis_valuator_fixed_up.)  <br /></td></tr>
<tr class="separator:af6de4ebdb7f531d96fb57a566e0d121c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42833fb0899d755feb35dbf0db24410" id="r_ac42833fb0899d755feb35dbf0db24410"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedP &gt; </td></tr>
<tr class="memitem:ac42833fb0899d755feb35dbf0db24410"><td class="memTemplItemLeft" align="right" valign="top">DerivedA::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac42833fb0899d755feb35dbf0db24410">solid_angle</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P)</td></tr>
<tr class="memdesc:ac42833fb0899d755feb35dbf0db24410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed solid angle subtended by the oriented 3d triangle (A,B,C) at some point P.  <br /></td></tr>
<tr class="separator:ac42833fb0899d755feb35dbf0db24410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea54a5804527aa194785e403870ba7db" id="r_aea54a5804527aa194785e403870ba7db"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </td></tr>
<tr class="memitem:aea54a5804527aa194785e403870ba7db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aea54a5804527aa194785e403870ba7db">sort</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</td></tr>
<tr class="memdesc:aea54a5804527aa194785e403870ba7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the elements of a matrix X along a given dimension like matlabs sort function.  <br /></td></tr>
<tr class="separator:aea54a5804527aa194785e403870ba7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c55dff1cae23221b5570ad7f9c194" id="r_a1b8c55dff1cae23221b5570ad7f9c194"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a1b8c55dff1cae23221b5570ad7f9c194"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1b8c55dff1cae23221b5570ad7f9c194">sort</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a1b8c55dff1cae23221b5570ad7f9c194"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a1b8c55dff1cae23221b5570ad7f9c194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6daca2b874edaf27301a111ed2401" id="r_a4dd6daca2b874edaf27301a111ed2401"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </td></tr>
<tr class="memitem:a4dd6daca2b874edaf27301a111ed2401"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4dd6daca2b874edaf27301a111ed2401">sort_new</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</td></tr>
<tr class="memdesc:a4dd6daca2b874edaf27301a111ed2401"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4dd6daca2b874edaf27301a111ed2401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ad3bd047a94be9c5ad7bf8890dd798" id="r_a61ad3bd047a94be9c5ad7bf8890dd798"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </td></tr>
<tr class="memitem:a61ad3bd047a94be9c5ad7bf8890dd798"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a61ad3bd047a94be9c5ad7bf8890dd798">sort2</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</td></tr>
<tr class="memdesc:a61ad3bd047a94be9c5ad7bf8890dd798"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a61ad3bd047a94be9c5ad7bf8890dd798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfeee50844cf4deac8ad3b473407428" id="r_a6bfeee50844cf4deac8ad3b473407428"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </td></tr>
<tr class="memitem:a6bfeee50844cf4deac8ad3b473407428"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6bfeee50844cf4deac8ad3b473407428">sort3</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</td></tr>
<tr class="memdesc:a6bfeee50844cf4deac8ad3b473407428"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6bfeee50844cf4deac8ad3b473407428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee021e4c406d792e624a3ddbdc5145d" id="r_a5ee021e4c406d792e624a3ddbdc5145d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ee021e4c406d792e624a3ddbdc5145d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5ee021e4c406d792e624a3ddbdc5145d">sort</a> (const std::vector&lt; T &gt; &amp;unsorted, const bool ascending, std::vector&lt; T &gt; &amp;sorted, std::vector&lt; size_t &gt; &amp;index_map)</td></tr>
<tr class="memdesc:a5ee021e4c406d792e624a3ddbdc5145d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like matlab's [Y,I] = SORT(X) for std library vectors.  <br /></td></tr>
<tr class="separator:a5ee021e4c406d792e624a3ddbdc5145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af203a35e46d72618e788c9c02e5f2e0c" id="r_af203a35e46d72618e788c9c02e5f2e0c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedM , typename DerivedR &gt; </td></tr>
<tr class="memitem:af203a35e46d72618e788c9c02e5f2e0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af203a35e46d72618e788c9c02e5f2e0c">sort_angles</a> (const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R)</td></tr>
<tr class="memdesc:af203a35e46d72618e788c9c02e5f2e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort angles in ascending order in a numerically robust way.  <br /></td></tr>
<tr class="separator:af203a35e46d72618e788c9c02e5f2e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a98c41282a4c612da5ad971a4a676" id="r_a1c0a98c41282a4c612da5ad971a4a676"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedMV , typename DerivedP , typename DerivedFF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a1c0a98c41282a4c612da5ad971a4a676"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1c0a98c41282a4c612da5ad971a4a676">sort_triangles</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedMV &gt; &amp;MV, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:a1c0a98c41282a4c612da5ad971a4a676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort triangles by depth (from back to front) using a painter's algorithm.  <br /></td></tr>
<tr class="separator:a1c0a98c41282a4c612da5ad971a4a676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d31a3df6fc3ab3d769b240cc8ca2f5" id="r_ab6d31a3df6fc3ab3d769b240cc8ca2f5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedI &gt; </td></tr>
<tr class="memitem:ab6d31a3df6fc3ab3d769b240cc8ca2f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab6d31a3df6fc3ab3d769b240cc8ca2f5">sort_vectors_ccw</a> (const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;order, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;sorted, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;inv_order)</td></tr>
<tr class="memdesc:ab6d31a3df6fc3ab3d769b240cc8ca2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a set of N coplanar vectors in a ccw order, and returns their order.  <br /></td></tr>
<tr class="separator:ab6d31a3df6fc3ab3d769b240cc8ca2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12fb37ec629691009ae42d926adcb02" id="r_ad12fb37ec629691009ae42d926adcb02"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedI &gt; </td></tr>
<tr class="memitem:ad12fb37ec629691009ae42d926adcb02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad12fb37ec629691009ae42d926adcb02">sort_vectors_ccw</a> (const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;order, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;sorted)</td></tr>
<tr class="memdesc:ad12fb37ec629691009ae42d926adcb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad12fb37ec629691009ae42d926adcb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4fdcbef0f11737a037711a7ebf833c" id="r_a9b4fdcbef0f11737a037711a7ebf833c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedI &gt; </td></tr>
<tr class="memitem:a9b4fdcbef0f11737a037711a7ebf833c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9b4fdcbef0f11737a037711a7ebf833c">sort_vectors_ccw</a> (const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;order, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;inv_order)</td></tr>
<tr class="memdesc:a9b4fdcbef0f11737a037711a7ebf833c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9b4fdcbef0f11737a037711a7ebf833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c139732fd7bcd7379c91befbb35775" id="r_a08c139732fd7bcd7379c91befbb35775"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedI &gt; </td></tr>
<tr class="memitem:a08c139732fd7bcd7379c91befbb35775"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a08c139732fd7bcd7379c91befbb35775">sort_vectors_ccw</a> (const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;order)</td></tr>
<tr class="memdesc:a08c139732fd7bcd7379c91befbb35775"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a08c139732fd7bcd7379c91befbb35775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ac99e9c2a051fdbc1b1c132e8102f8" id="r_af8ac99e9c2a051fdbc1b1c132e8102f8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY , typename DerivedI &gt; </td></tr>
<tr class="memitem:af8ac99e9c2a051fdbc1b1c132e8102f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af8ac99e9c2a051fdbc1b1c132e8102f8">sortrows</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="memdesc:af8ac99e9c2a051fdbc1b1c132e8102f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like matlab's [Y,I] = sortrows(X)  <br /></td></tr>
<tr class="separator:af8ac99e9c2a051fdbc1b1c132e8102f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f276cc65a7f7d0a0929e983028a3169" id="r_a4f276cc65a7f7d0a0929e983028a3169"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedY &gt; </td></tr>
<tr class="memitem:a4f276cc65a7f7d0a0929e983028a3169"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4f276cc65a7f7d0a0929e983028a3169">sortrows</a> (const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y)</td></tr>
<tr class="memdesc:a4f276cc65a7f7d0a0929e983028a3169"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a4f276cc65a7f7d0a0929e983028a3169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0031015feb34d6398264ceac841bc0c" id="r_aa0031015feb34d6398264ceac841bc0c"><td class="memTemplParams" colspan="2">template&lt;class IndexVectorI , class IndexVectorJ , class ValueVector , typename T &gt; </td></tr>
<tr class="memitem:aa0031015feb34d6398264ceac841bc0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa0031015feb34d6398264ceac841bc0c">sparse</a> (const IndexVectorI &amp;I, const IndexVectorJ &amp;J, const ValueVector &amp;V, const size_t m, const size_t n, Eigen::SparseMatrix&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:aa0031015feb34d6398264ceac841bc0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a sparse matrix from list of indices and values (I,J,V), functions like the sparse function in matlab.  <br /></td></tr>
<tr class="separator:aa0031015feb34d6398264ceac841bc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e6cc04971d8a30de15d18272221aa9" id="r_a55e6cc04971d8a30de15d18272221aa9"><td class="memTemplParams" colspan="2">template&lt;class IndexVector , class ValueVector , typename T &gt; </td></tr>
<tr class="memitem:a55e6cc04971d8a30de15d18272221aa9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a55e6cc04971d8a30de15d18272221aa9">sparse</a> (const IndexVector &amp;I, const IndexVector &amp;J, const ValueVector &amp;V, Eigen::SparseMatrix&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:a55e6cc04971d8a30de15d18272221aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a55e6cc04971d8a30de15d18272221aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af79e7e819b442592de8d5db2e5829c" id="r_a1af79e7e819b442592de8d5db2e5829c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedD , typename T &gt; </td></tr>
<tr class="memitem:a1af79e7e819b442592de8d5db2e5829c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1af79e7e819b442592de8d5db2e5829c">sparse</a> (const Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D, Eigen::SparseMatrix&lt; T &gt; &amp;X)</td></tr>
<tr class="memdesc:a1af79e7e819b442592de8d5db2e5829c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a full, dense matrix to a sparse one.  <br /></td></tr>
<tr class="separator:a1af79e7e819b442592de8d5db2e5829c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee96f9beefd8dd12066e82a32b314855" id="r_aee96f9beefd8dd12066e82a32b314855"><td class="memTemplParams" colspan="2">template&lt;typename DerivedD &gt; </td></tr>
<tr class="memitem:aee96f9beefd8dd12066e82a32b314855"><td class="memTemplItemLeft" align="right" valign="top">Eigen::SparseMatrix&lt; typename DerivedD::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aee96f9beefd8dd12066e82a32b314855">sparse</a> (const Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:aee96f9beefd8dd12066e82a32b314855"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aee96f9beefd8dd12066e82a32b314855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac623ce43ac510a2b3374c791984d819c" id="r_ac623ce43ac510a2b3374c791984d819c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedI , typename Scalar &gt; </td></tr>
<tr class="memitem:ac623ce43ac510a2b3374c791984d819c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac623ce43ac510a2b3374c791984d819c">sparse_cached_precompute</a> (const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;J, Eigen::VectorXi &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;X)</td></tr>
<tr class="memdesc:ac623ce43ac510a2b3374c791984d819c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a sparse matrix from list of indices and values (I,J,V), similarly to the sparse function in matlab.  <br /></td></tr>
<tr class="separator:ac623ce43ac510a2b3374c791984d819c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652603bae4d621913f8679441ac6d771" id="r_a652603bae4d621913f8679441ac6d771"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a652603bae4d621913f8679441ac6d771"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a652603bae4d621913f8679441ac6d771">sparse_cached_precompute</a> (const std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt; &amp;triplets, Eigen::VectorXi &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;X)</td></tr>
<tr class="memdesc:a652603bae4d621913f8679441ac6d771"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a652603bae4d621913f8679441ac6d771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff00fedf6ea99985f251a964eb2fe21" id="r_abff00fedf6ea99985f251a964eb2fe21"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abff00fedf6ea99985f251a964eb2fe21"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abff00fedf6ea99985f251a964eb2fe21">sparse_cached</a> (const std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt; &amp;triplets, const Eigen::VectorXi &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;X)</td></tr>
<tr class="memdesc:abff00fedf6ea99985f251a964eb2fe21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a sparse matrix from cached list of data and values.  <br /></td></tr>
<tr class="separator:abff00fedf6ea99985f251a964eb2fe21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2f3d6b20dcda22b4415935b0b4a250" id="r_adb2f3d6b20dcda22b4415935b0b4a250"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename Scalar &gt; </td></tr>
<tr class="memitem:adb2f3d6b20dcda22b4415935b0b4a250"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adb2f3d6b20dcda22b4415935b0b4a250">sparse_cached</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::VectorXi &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;X)</td></tr>
<tr class="memdesc:adb2f3d6b20dcda22b4415935b0b4a250"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:adb2f3d6b20dcda22b4415935b0b4a250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c369ebc42c4e76553730c636d7967d" id="r_ae4c369ebc42c4e76553730c636d7967d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP0 , typename Func , typename DerivedS , typename DerivedV , typename DerivedI &gt; </td></tr>
<tr class="memitem:ae4c369ebc42c4e76553730c636d7967d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae4c369ebc42c4e76553730c636d7967d">sparse_voxel_grid</a> (const Eigen::MatrixBase&lt; DerivedP0 &gt; &amp;p0, const Func &amp;scalarFunc, const double eps, const int expected_number_of_cubes, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;CS, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;CV, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;CI)</td></tr>
<tr class="memdesc:ae4c369ebc42c4e76553730c636d7967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point, p0, on an isosurface, construct a shell of epsilon sized cubes surrounding the surface.  <br /></td></tr>
<tr class="separator:ae4c369ebc42c4e76553730c636d7967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7bca403061433327f7ae13005e190a6" id="r_ab7bca403061433327f7ae13005e190a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7bca403061433327f7ae13005e190a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab7bca403061433327f7ae13005e190a6">speye</a> (const int n, const int m, Eigen::SparseMatrix&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:ab7bca403061433327f7ae13005e190a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an m by n sparse identity matrix like matlab's speye function.  <br /></td></tr>
<tr class="separator:ab7bca403061433327f7ae13005e190a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a506e0e604f1618c56560c1c3238a7" id="r_a99a506e0e604f1618c56560c1c3238a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99a506e0e604f1618c56560c1c3238a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a99a506e0e604f1618c56560c1c3238a7">speye</a> (const int n, Eigen::SparseMatrix&lt; T &gt; &amp;I)</td></tr>
<tr class="memdesc:a99a506e0e604f1618c56560c1c3238a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a99a506e0e604f1618c56560c1c3238a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad087e73516c7afa1370f7b24c1132a36" id="r_ad087e73516c7afa1370f7b24c1132a36"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedSF , typename DerivedSVI &gt; </td></tr>
<tr class="memitem:ad087e73516c7afa1370f7b24c1132a36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad087e73516c7afa1370f7b24c1132a36">split_nonmanifold</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;SVI)</td></tr>
<tr class="memdesc:ad087e73516c7afa1370f7b24c1132a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a non-manifold (or non-orientable) mesh into a orientable manifold mesh possibly with more connected components and geometrically duplicate vertices.  <br /></td></tr>
<tr class="separator:ad087e73516c7afa1370f7b24c1132a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6330810b20e78a8af65cb151d537d6d" id="r_af6330810b20e78a8af65cb151d537d6d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedSV , typename DerivedSF , typename DerivedSVI &gt; </td></tr>
<tr class="memitem:af6330810b20e78a8af65cb151d537d6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af6330810b20e78a8af65cb151d537d6d">split_nonmanifold</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;SV, Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;SF, Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;SVI)</td></tr>
<tr class="memdesc:af6330810b20e78a8af65cb151d537d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af6330810b20e78a8af65cb151d537d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45669ed07ec4ce3c9d9af3c976246bda" id="r_a45669ed07ec4ce3c9d9af3c976246bda"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedL &gt; </td></tr>
<tr class="memitem:a45669ed07ec4ce3c9d9af3c976246bda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a45669ed07ec4ce3c9d9af3c976246bda">squared_edge_lengths</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;L)</td></tr>
<tr class="memdesc:a45669ed07ec4ce3c9d9af3c976246bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a list of squared lengths of edges opposite each index in a face (triangle/tet) list.  <br /></td></tr>
<tr class="separator:a45669ed07ec4ce3c9d9af3c976246bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4750b8f143bb05a426374c4c65b92a" id="r_a8f4750b8f143bb05a426374c4c65b92a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8f4750b8f143bb05a426374c4c65b92a">stdin_to_temp</a> (FILE **temp_file)</td></tr>
<tr class="memdesc:a8f4750b8f143bb05a426374c4c65b92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write stdin/piped input to a temporary file which can than be preprocessed as it is (a normal file).  <br /></td></tr>
<tr class="separator:a8f4750b8f143bb05a426374c4c65b92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43464482f2fd9b2c4b7e2beac12fc522" id="r_a43464482f2fd9b2c4b7e2beac12fc522"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVT , typename DerivedFT , typename Scalar , typename DerivedUE , typename DerivedUT , typename DerivedOT &gt; </td></tr>
<tr class="memitem:a43464482f2fd9b2c4b7e2beac12fc522"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a43464482f2fd9b2c4b7e2beac12fc522">straighten_seams</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedVT &gt; &amp;VT, const Eigen::MatrixBase&lt; DerivedFT &gt; &amp;FT, const Scalar tol, Eigen::PlainObjectBase&lt; DerivedUE &gt; &amp;UE, Eigen::PlainObjectBase&lt; DerivedUT &gt; &amp;UT, Eigen::PlainObjectBase&lt; DerivedOT &gt; &amp;OT)</td></tr>
<tr class="memdesc:a43464482f2fd9b2c4b7e2beac12fc522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a obj-style mesh with (V,F) defining the geometric surface of the mesh and (VT,FT) defining the parameterization/texture-mapping of the mesh in the uv-domain, find all seams and boundaries in the texture-mapping and "straighten" them, remapping vertices along the boundary and in the interior.  <br /></td></tr>
<tr class="separator:a43464482f2fd9b2c4b7e2beac12fc522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a359f88733a83493b68b6f605a5161" id="r_ac4a359f88733a83493b68b6f605a5161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac4a359f88733a83493b68b6f605a5161">starts_with</a> (const std::string &amp;str, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ac4a359f88733a83493b68b6f605a5161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string starts with a given prefix.  <br /></td></tr>
<tr class="separator:ac4a359f88733a83493b68b6f605a5161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e02163e30570e181965fba3609c8b4" id="r_ad5e02163e30570e181965fba3609c8b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad5e02163e30570e181965fba3609c8b4">starts_with</a> (const char *str, const char *prefix)</td></tr>
<tr class="memdesc:ad5e02163e30570e181965fba3609c8b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="string__utils_8h.html">include/igl/string_utils.h</a>.  <br /></td></tr>
<tr class="separator:ad5e02163e30570e181965fba3609c8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf21bb95cf3e8474259c54e4a55ed734" id="r_adf21bb95cf3e8474259c54e4a55ed734"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf21bb95cf3e8474259c54e4a55ed734"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734">sum</a> (const Eigen::SparseMatrix&lt; T &gt; &amp;X, const int dim, Eigen::SparseVector&lt; T &gt; &amp;S)</td></tr>
<tr class="memdesc:adf21bb95cf3e8474259c54e4a55ed734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum the columns or rows of a sparse matrix.  <br /></td></tr>
<tr class="separator:adf21bb95cf3e8474259c54e4a55ed734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bcbac428755ce31717db4079956840b" id="r_a5bcbac428755ce31717db4079956840b"><td class="memTemplParams" colspan="2">template&lt;typename AType , typename DerivedB &gt; </td></tr>
<tr class="memitem:a5bcbac428755ce31717db4079956840b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5bcbac428755ce31717db4079956840b">sum</a> (const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</td></tr>
<tr class="memdesc:a5bcbac428755ce31717db4079956840b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5bcbac428755ce31717db4079956840b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7376c37ca3ec7bb7dc4cf7fdecfe36" id="r_a3b7376c37ca3ec7bb7dc4cf7fdecfe36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b7376c37ca3ec7bb7dc4cf7fdecfe36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3b7376c37ca3ec7bb7dc4cf7fdecfe36">svd3x3</a> (const Eigen::Matrix&lt; T, 3, 3 &gt; &amp;A, Eigen::Matrix&lt; T, 3, 3 &gt; &amp;U, Eigen::Matrix&lt; T, 3, 1 &gt; &amp;S, Eigen::Matrix&lt; T, 3, 3 &gt; &amp;V)</td></tr>
<tr class="memdesc:a3b7376c37ca3ec7bb7dc4cf7fdecfe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Super fast 3x3 SVD according to <a href="http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html">http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html</a> The resulting decomposition is A = U * diag(S[0], S[1], S[2]) * V'.  <br /></td></tr>
<tr class="separator:a3b7376c37ca3ec7bb7dc4cf7fdecfe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4153817f124410a202847cbf878d271b" id="r_a4153817f124410a202847cbf878d271b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4153817f124410a202847cbf878d271b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4153817f124410a202847cbf878d271b">svd3x3_avx</a> (const Eigen::Matrix&lt; T, 3 *8, 3 &gt; &amp;A, Eigen::Matrix&lt; T, 3 *8, 3 &gt; &amp;U, Eigen::Matrix&lt; T, 3 *8, 1 &gt; &amp;S, Eigen::Matrix&lt; T, 3 *8, 3 &gt; &amp;V)</td></tr>
<tr class="memdesc:a4153817f124410a202847cbf878d271b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Super fast 3x3 SVD according to <a href="http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html">http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html</a> This is AVX version of svd3x3 (see <a class="el" href="svd3x3_8h.html">svd3x3.h</a>) which works on 8 matrices at a time These eight matrices are simply stacked in columns, the rest is the same as for svd3x3.  <br /></td></tr>
<tr class="separator:a4153817f124410a202847cbf878d271b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ee73993135205bd97cfc9c8453d68" id="r_ae67ee73993135205bd97cfc9c8453d68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae67ee73993135205bd97cfc9c8453d68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae67ee73993135205bd97cfc9c8453d68">svd3x3_sse</a> (const Eigen::Matrix&lt; T, 3 *4, 3 &gt; &amp;A, Eigen::Matrix&lt; T, 3 *4, 3 &gt; &amp;U, Eigen::Matrix&lt; T, 3 *4, 1 &gt; &amp;S, Eigen::Matrix&lt; T, 3 *4, 3 &gt; &amp;V)</td></tr>
<tr class="separator:ae67ee73993135205bd97cfc9c8453d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525f425d4315f9547a6e82782d7d672b" id="r_a525f425d4315f9547a6e82782d7d672b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a525f425d4315f9547a6e82782d7d672b">swept_volume</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const std::function&lt; Eigen::Affine3d(const double t)&gt; &amp;transform, const size_t steps, const size_t grid_res, const size_t isolevel, Eigen::MatrixXd &amp;SV, Eigen::MatrixXi &amp;SF)</td></tr>
<tr class="memdesc:a525f425d4315f9547a6e82782d7d672b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the surface of the swept volume of a solid object with surface (V,F) mesh under going rigid motion.  <br /></td></tr>
<tr class="separator:a525f425d4315f9547a6e82782d7d672b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0739e2c6e91f7aa950aca9580a90e612" id="r_a0739e2c6e91f7aa950aca9580a90e612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0739e2c6e91f7aa950aca9580a90e612">swept_volume_bounding_box</a> (const size_t &amp;n, const std::function&lt; Eigen::RowVector3d(const size_t vi, const double t)&gt; &amp;V, const size_t &amp;steps, Eigen::AlignedBox3d &amp;box)</td></tr>
<tr class="memdesc:a0739e2c6e91f7aa950aca9580a90e612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an axis-aligned bounding box containing a shape undergoing a motion sampled at <code>steps</code> discrete momements.  <br /></td></tr>
<tr class="separator:a0739e2c6e91f7aa950aca9580a90e612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df37d639d7915a6623d3dd0deecaf8a" id="r_a2df37d639d7915a6623d3dd0deecaf8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2df37d639d7915a6623d3dd0deecaf8a">swept_volume_signed_distance</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const std::function&lt; Eigen::Affine3d(const double t)&gt; &amp;transform, const size_t &amp;steps, const Eigen::MatrixXd &amp;GV, const Eigen::RowVector3i &amp;res, const double h, const double isolevel, const Eigen::VectorXd &amp;S0, Eigen::VectorXd &amp;S)</td></tr>
<tr class="memdesc:a2df37d639d7915a6623d3dd0deecaf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed distance to a sweep surface of a mesh under-going an arbitrary motion V(t) discretely sampled at <code>steps</code>-many moments in time at a grid.  <br /></td></tr>
<tr class="separator:a2df37d639d7915a6623d3dd0deecaf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030deb66b915a2f498701588640ee3a4" id="r_a030deb66b915a2f498701588640ee3a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a030deb66b915a2f498701588640ee3a4">swept_volume_signed_distance</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const std::function&lt; Eigen::Affine3d(const double t)&gt; &amp;transform, const size_t &amp;steps, const Eigen::MatrixXd &amp;GV, const Eigen::RowVector3i &amp;res, const double h, const double isolevel, Eigen::VectorXd &amp;S)</td></tr>
<tr class="memdesc:a030deb66b915a2f498701588640ee3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a030deb66b915a2f498701588640ee3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca626f9c0a1f205b884fc1c6787c6a59" id="r_aca626f9c0a1f205b884fc1c6787c6a59"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aca626f9c0a1f205b884fc1c6787c6a59"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aca626f9c0a1f205b884fc1c6787c6a59">tan_half_angle</a> (const Scalar &amp;a, const Scalar &amp;b, const Scalar &amp;c)</td></tr>
<tr class="memdesc:aca626f9c0a1f205b884fc1c6787c6a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the tangent of half of the angle opposite the side with length a, in a triangle with side lengths (a,b,c).  <br /></td></tr>
<tr class="separator:aca626f9c0a1f205b884fc1c6787c6a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fcd72a6173a2c6d4e4651a706b2911" id="r_ab9fcd72a6173a2c6d4e4651a706b2911"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename DerivedTT , typename DerivedTTi &gt; </td></tr>
<tr class="memitem:ab9fcd72a6173a2c6d4e4651a706b2911"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab9fcd72a6173a2c6d4e4651a706b2911">tet_tet_adjacency</a> (const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;TT, Eigen::PlainObjectBase&lt; DerivedTTi &gt; &amp;TTi)</td></tr>
<tr class="memdesc:ab9fcd72a6173a2c6d4e4651a706b2911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the tet_tet adjacency matrix for a given tet mesh with tets T.  <br /></td></tr>
<tr class="separator:ab9fcd72a6173a2c6d4e4651a706b2911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada72de8eeac466f8cb2a52016a1bd1cf" id="r_ada72de8eeac466f8cb2a52016a1bd1cf"><td class="memTemplParams" colspan="2">template&lt;typename DerivedT , typename DerivedTT &gt; </td></tr>
<tr class="memitem:ada72de8eeac466f8cb2a52016a1bd1cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ada72de8eeac466f8cb2a52016a1bd1cf">tet_tet_adjacency</a> (const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;TT)</td></tr>
<tr class="memdesc:ada72de8eeac466f8cb2a52016a1bd1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ada72de8eeac466f8cb2a52016a1bd1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d82782b314ba8729b05712387f7ec4" id="r_a09d82782b314ba8729b05712387f7ec4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedGV , typename DerivedGT &gt; </td></tr>
<tr class="memitem:a09d82782b314ba8729b05712387f7ec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a09d82782b314ba8729b05712387f7ec4">tetrahedralized_grid</a> (const int nx, const int ny, const int nz, const <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">TetrahedralizedGripType</a> type, Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;GV, Eigen::PlainObjectBase&lt; DerivedGT &gt; &amp;GT)</td></tr>
<tr class="memdesc:a09d82782b314ba8729b05712387f7ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct vertices of a regular grid, suitable for input to <code><a class="el" href="namespaceigl.html#a5512306a29939c7ac8d4ebcef2cd032a" title="Performs the marching tetrahedra algorithm on a tet mesh defined by TV and TT with scalar values defi...">igl::marching_tets</a></code>  <br /></td></tr>
<tr class="separator:a09d82782b314ba8729b05712387f7ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86a7e69f97c1ca839467731e3944441" id="r_ae86a7e69f97c1ca839467731e3944441"><td class="memTemplParams" colspan="2">template&lt;typename Derivedside , typename DerivedGT &gt; </td></tr>
<tr class="memitem:ae86a7e69f97c1ca839467731e3944441"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae86a7e69f97c1ca839467731e3944441">tetrahedralized_grid</a> (const Eigen::MatrixBase&lt; Derivedside &gt; &amp;side, const <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">TetrahedralizedGripType</a> type, Eigen::PlainObjectBase&lt; DerivedGT &gt; &amp;GT)</td></tr>
<tr class="memdesc:ae86a7e69f97c1ca839467731e3944441"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae86a7e69f97c1ca839467731e3944441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1fa0516e3b6395846621d6a79507e8" id="r_a6f1fa0516e3b6395846621d6a79507e8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename VectorIndex , typename DerivedF_filled &gt; </td></tr>
<tr class="memitem:a6f1fa0516e3b6395846621d6a79507e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6f1fa0516e3b6395846621d6a79507e8">topological_hole_fill</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const std::vector&lt; VectorIndex &gt; &amp;holes, Eigen::PlainObjectBase&lt; DerivedF_filled &gt; &amp;F_filled)</td></tr>
<tr class="memdesc:a6f1fa0516e3b6395846621d6a79507e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topological fill hole on a mesh, with one additional vertex each hole Index of new abstract vertices will be F.maxCoeff() + (index of hole)  <br /></td></tr>
<tr class="separator:a6f1fa0516e3b6395846621d6a79507e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c72a7f89ae16b8e5196c4cd37fb2689" id="r_a4c72a7f89ae16b8e5196c4cd37fb2689"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:a4c72a7f89ae16b8e5196c4cd37fb2689"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4c72a7f89ae16b8e5196c4cd37fb2689">trackball</a> (const double w, const double h, const Q_type speed_factor, const double down_mouse_x, const double down_mouse_y, const double mouse_x, const double mouse_y, Q_type *quat)</td></tr>
<tr class="memdesc:a4c72a7f89ae16b8e5196c4cd37fb2689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a trackball drag to identity.  <br /></td></tr>
<tr class="separator:a4c72a7f89ae16b8e5196c4cd37fb2689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c31d9f94cfdba0d5da1b69f4f4d968" id="r_a46c31d9f94cfdba0d5da1b69f4f4d968"><td class="memTemplParams" colspan="2">template&lt;typename Q_type &gt; </td></tr>
<tr class="memitem:a46c31d9f94cfdba0d5da1b69f4f4d968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a46c31d9f94cfdba0d5da1b69f4f4d968">trackball</a> (const double w, const double h, const Q_type speed_factor, const Q_type *down_quat, const double down_mouse_x, const double down_mouse_y, const double mouse_x, const double mouse_y, Q_type *quat)</td></tr>
<tr class="memdesc:a46c31d9f94cfdba0d5da1b69f4f4d968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a trackball drag to a given rotation.  <br /></td></tr>
<tr class="separator:a46c31d9f94cfdba0d5da1b69f4f4d968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9d8f7f6bbca5f24365f3ce5f401f9a" id="r_aaf9d8f7f6bbca5f24365f3ce5f401f9a"><td class="memTemplParams" colspan="2">template&lt;typename Scalardown_quat , typename Scalarquat &gt; </td></tr>
<tr class="memitem:aaf9d8f7f6bbca5f24365f3ce5f401f9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aaf9d8f7f6bbca5f24365f3ce5f401f9a">trackball</a> (const double w, const double h, const double speed_factor, const Eigen::Quaternion&lt; Scalardown_quat &gt; &amp;down_quat, const double down_mouse_x, const double down_mouse_y, const double mouse_x, const double mouse_y, Eigen::Quaternion&lt; Scalarquat &gt; &amp;quat)</td></tr>
<tr class="memdesc:aaf9d8f7f6bbca5f24365f3ce5f401f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aaf9d8f7f6bbca5f24365f3ce5f401f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa327db1af41a1e29e474981b963409" id="r_a5fa327db1af41a1e29e474981b963409"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fa327db1af41a1e29e474981b963409"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5fa327db1af41a1e29e474981b963409">transpose_blocks</a> (const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;A, const size_t k, const size_t dim, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;B)</td></tr>
<tr class="memdesc:a5fa327db1af41a1e29e474981b963409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose blocks of a matrix.  <br /></td></tr>
<tr class="separator:a5fa327db1af41a1e29e474981b963409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62161fdfef57c22542b38d735550b635" id="r_a62161fdfef57c22542b38d735550b635"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP1 , typename DerivedQ1 , typename DerivedR1 , typename DerivedP2 , typename DerivedQ2 , typename DerivedR2 &gt; </td></tr>
<tr class="memitem:a62161fdfef57c22542b38d735550b635"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a62161fdfef57c22542b38d735550b635">tri_tri_overlap_test_3d</a> (const Eigen::MatrixBase&lt; DerivedP1 &gt; &amp;p1, const Eigen::MatrixBase&lt; DerivedQ1 &gt; &amp;q1, const Eigen::MatrixBase&lt; DerivedR1 &gt; &amp;r1, const Eigen::MatrixBase&lt; DerivedP2 &gt; &amp;p2, const Eigen::MatrixBase&lt; DerivedQ2 &gt; &amp;q2, const Eigen::MatrixBase&lt; DerivedR2 &gt; &amp;r2)</td></tr>
<tr class="separator:a62161fdfef57c22542b38d735550b635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ff893a73c2642eeec2692d37aad4d0" id="r_a56ff893a73c2642eeec2692d37aad4d0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP1 , typename DerivedQ1 , typename DerivedR1 , typename DerivedP2 , typename DerivedQ2 , typename DerivedR2 , typename DerivedS , typename DerivedT &gt; </td></tr>
<tr class="memitem:a56ff893a73c2642eeec2692d37aad4d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a56ff893a73c2642eeec2692d37aad4d0">tri_tri_intersection_test_3d</a> (const Eigen::MatrixBase&lt; DerivedP1 &gt; &amp;p1, const Eigen::MatrixBase&lt; DerivedQ1 &gt; &amp;q1, const Eigen::MatrixBase&lt; DerivedR1 &gt; &amp;r1, const Eigen::MatrixBase&lt; DerivedP2 &gt; &amp;p2, const Eigen::MatrixBase&lt; DerivedQ2 &gt; &amp;q2, const Eigen::MatrixBase&lt; DerivedR2 &gt; &amp;r2, bool &amp;coplanar, Eigen::MatrixBase&lt; DerivedS &gt; &amp;source, Eigen::MatrixBase&lt; DerivedT &gt; &amp;target)</td></tr>
<tr class="separator:a56ff893a73c2642eeec2692d37aad4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e80369c0a74cc009ec973dd70fd752" id="r_ac4e80369c0a74cc009ec973dd70fd752"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP1 , typename DerivedQ1 , typename DerivedR1 , typename DerivedP2 , typename DerivedQ2 , typename DerivedR2 &gt; </td></tr>
<tr class="memitem:ac4e80369c0a74cc009ec973dd70fd752"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac4e80369c0a74cc009ec973dd70fd752">tri_tri_overlap_test_2d</a> (const Eigen::MatrixBase&lt; DerivedP1 &gt; &amp;p1, const Eigen::MatrixBase&lt; DerivedQ1 &gt; &amp;q1, const Eigen::MatrixBase&lt; DerivedR1 &gt; &amp;r1, const Eigen::MatrixBase&lt; DerivedP2 &gt; &amp;p2, const Eigen::MatrixBase&lt; DerivedQ2 &gt; &amp;q2, const Eigen::MatrixBase&lt; DerivedR2 &gt; &amp;r2)</td></tr>
<tr class="separator:ac4e80369c0a74cc009ec973dd70fd752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce1a2b984f20466ffc7732ab29501ba" id="r_a9ce1a2b984f20466ffc7732ab29501ba"><td class="memTemplParams" colspan="2">template&lt;typename DerivedE , typename Derivedcap &gt; </td></tr>
<tr class="memitem:a9ce1a2b984f20466ffc7732ab29501ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9ce1a2b984f20466ffc7732ab29501ba">triangle_fan</a> (const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; Derivedcap &gt; &amp;cap)</td></tr>
<tr class="memdesc:a9ce1a2b984f20466ffc7732ab29501ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of faces tessellate all of the "exterior" edges forming another list of.  <br /></td></tr>
<tr class="separator:a9ce1a2b984f20466ffc7732ab29501ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b17a92c69587c651fe1b4d549235a9d" id="r_a6b17a92c69587c651fe1b4d549235a9d"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6b17a92c69587c651fe1b4d549235a9d">triangle_fan</a> (const Eigen::MatrixXi &amp;E)</td></tr>
<tr class="memdesc:a6b17a92c69587c651fe1b4d549235a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6b17a92c69587c651fe1b4d549235a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07b1e4d35569138ffa0d8a874f0e24f" id="r_ae07b1e4d35569138ffa0d8a874f0e24f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedTT , typename DerivedTTi &gt; </td></tr>
<tr class="memitem:ae07b1e4d35569138ffa0d8a874f0e24f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae07b1e4d35569138ffa0d8a874f0e24f">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;TT, Eigen::PlainObjectBase&lt; DerivedTTi &gt; &amp;TTi)</td></tr>
<tr class="memdesc:ae07b1e4d35569138ffa0d8a874f0e24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the triangle-triangle adjacency matrix for a given mesh (V,F).  <br /></td></tr>
<tr class="separator:ae07b1e4d35569138ffa0d8a874f0e24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7210f2492117b1c482907e6a47dbed75" id="r_a7210f2492117b1c482907e6a47dbed75"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedTT &gt; </td></tr>
<tr class="memitem:a7210f2492117b1c482907e6a47dbed75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7210f2492117b1c482907e6a47dbed75">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;TT)</td></tr>
<tr class="memdesc:a7210f2492117b1c482907e6a47dbed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7210f2492117b1c482907e6a47dbed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add74393b2dabd37b8efd0a7c2145372a" id="r_add74393b2dabd37b8efd0a7c2145372a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename TTT_type &gt; </td></tr>
<tr class="memitem:add74393b2dabd37b8efd0a7c2145372a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#add74393b2dabd37b8efd0a7c2145372a">triangle_triangle_adjacency_preprocess</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; TTT_type &gt; &gt; &amp;TTT)</td></tr>
<tr class="memdesc:add74393b2dabd37b8efd0a7c2145372a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preprocessing for triangle_triangle_adjacency.  <br /></td></tr>
<tr class="separator:add74393b2dabd37b8efd0a7c2145372a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cd01351200f4312c4fa5abef9c63a1" id="r_a45cd01351200f4312c4fa5abef9c63a1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename TTT_type , typename DerivedTT &gt; </td></tr>
<tr class="memitem:a45cd01351200f4312c4fa5abef9c63a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a45cd01351200f4312c4fa5abef9c63a1">triangle_triangle_adjacency_extractTT</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; TTT_type &gt; &gt; &amp;TTT, Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;TT)</td></tr>
<tr class="memdesc:a45cd01351200f4312c4fa5abef9c63a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the face adjacencies for triangle_triangle_adjacency.  <br /></td></tr>
<tr class="separator:a45cd01351200f4312c4fa5abef9c63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81887c23c0079fb92f46a517cd42f752" id="r_a81887c23c0079fb92f46a517cd42f752"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename TTT_type , typename DerivedTTi &gt; </td></tr>
<tr class="memitem:a81887c23c0079fb92f46a517cd42f752"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a81887c23c0079fb92f46a517cd42f752">triangle_triangle_adjacency_extractTTi</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; TTT_type &gt; &gt; &amp;TTT, Eigen::PlainObjectBase&lt; DerivedTTi &gt; &amp;TTi)</td></tr>
<tr class="memdesc:a81887c23c0079fb92f46a517cd42f752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the face adjacencies indices for triangle_triangle_adjacency.  <br /></td></tr>
<tr class="separator:a81887c23c0079fb92f46a517cd42f752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e6fd086c1507cb6b02df0b458566cd" id="r_a99e6fd086c1507cb6b02df0b458566cd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename TTIndex , typename TTiIndex &gt; </td></tr>
<tr class="memitem:a99e6fd086c1507cb6b02df0b458566cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a99e6fd086c1507cb6b02df0b458566cd">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;TT, std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;TTi)</td></tr>
<tr class="memdesc:a99e6fd086c1507cb6b02df0b458566cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjacency list version, which works with non-manifold meshes.  <br /></td></tr>
<tr class="separator:a99e6fd086c1507cb6b02df0b458566cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea1a1ba3c8bee980c00db518fb9f443" id="r_a5ea1a1ba3c8bee980c00db518fb9f443"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename TTIndex &gt; </td></tr>
<tr class="memitem:a5ea1a1ba3c8bee980c00db518fb9f443"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5ea1a1ba3c8bee980c00db518fb9f443">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;TT)</td></tr>
<tr class="memdesc:a5ea1a1ba3c8bee980c00db518fb9f443"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5ea1a1ba3c8bee980c00db518fb9f443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad091a40b270aa5030a3dd0909e6402e6" id="r_ad091a40b270aa5030a3dd0909e6402e6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename TTIndex , typename TTiIndex &gt; </td></tr>
<tr class="memitem:ad091a40b270aa5030a3dd0909e6402e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad091a40b270aa5030a3dd0909e6402e6">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const bool construct_TTi, std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;TT, std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;TTi)</td></tr>
<tr class="separator:ad091a40b270aa5030a3dd0909e6402e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab979438c0daba73490363a56fc67f54a" id="r_ab979438c0daba73490363a56fc67f54a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedE , typename DerivedEMAP , typename uE2EType , typename TTIndex , typename TTiIndex &gt; </td></tr>
<tr class="memitem:ab979438c0daba73490363a56fc67f54a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab979438c0daba73490363a56fc67f54a">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, const bool construct_TTi, std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;TT, std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;TTi)</td></tr>
<tr class="memdesc:ab979438c0daba73490363a56fc67f54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab979438c0daba73490363a56fc67f54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc80c379b811624a97c1ed29ba4df0fb" id="r_afc80c379b811624a97c1ed29ba4df0fb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename TTIndex , typename TTiIndex &gt; </td></tr>
<tr class="memitem:afc80c379b811624a97c1ed29ba4df0fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afc80c379b811624a97c1ed29ba4df0fb">triangle_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;uEE, const bool construct_TTi, std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;TT, std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;TTi)</td></tr>
<tr class="memdesc:afc80c379b811624a97c1ed29ba4df0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:afc80c379b811624a97c1ed29ba4df0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67465786e131443ebdb6bdae0aa701f" id="r_ae67465786e131443ebdb6bdae0aa701f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedS , typename DerivedF &gt; </td></tr>
<tr class="memitem:ae67465786e131443ebdb6bdae0aa701f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae67465786e131443ebdb6bdae0aa701f">triangles_from_strip</a> (const Eigen::MatrixBase&lt; DerivedS &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ae67465786e131443ebdb6bdae0aa701f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list of triangles from a stream of indices along a strip.  <br /></td></tr>
<tr class="separator:ae67465786e131443ebdb6bdae0aa701f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be3b842294c1e29d654ace1e4f735ca" id="r_a3be3b842294c1e29d654ace1e4f735ca"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename YType , typename DerivedGV , typename DerivedGF &gt; </td></tr>
<tr class="memitem:a3be3b842294c1e29d654ace1e4f735ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3be3b842294c1e29d654ace1e4f735ca">triangulated_grid</a> (const XType &amp;nx, const YType &amp;ny, Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;GV, Eigen::PlainObjectBase&lt; DerivedGF &gt; &amp;GF)</td></tr>
<tr class="memdesc:a3be3b842294c1e29d654ace1e4f735ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a regular grid of elements (only 2D supported, currently) Vertex position order is compatible with <code><a class="el" href="namespaceigl.html#adfb4bab2b437369dce2059e85836bd9a" title="Construct vertices of a regular grid, suitable for input to igl::marching_cubes">igl::grid</a></code>  <br /></td></tr>
<tr class="separator:a3be3b842294c1e29d654ace1e4f735ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c16be739961936bc5159688a4c7683" id="r_a82c16be739961936bc5159688a4c7683"><td class="memTemplParams" colspan="2">template&lt;typename XType , typename YType , typename DerivedGF &gt; </td></tr>
<tr class="memitem:a82c16be739961936bc5159688a4c7683"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a82c16be739961936bc5159688a4c7683">triangulated_grid</a> (const XType &amp;nx, const YType &amp;ny, Eigen::PlainObjectBase&lt; DerivedGF &gt; &amp;GF)</td></tr>
<tr class="memdesc:a82c16be739961936bc5159688a4c7683"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a82c16be739961936bc5159688a4c7683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd083e49162fe9dfe2e1de54948c89" id="r_a38fd083e49162fe9dfe2e1de54948c89"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV &gt; </td></tr>
<tr class="memitem:a38fd083e49162fe9dfe2e1de54948c89"><td class="memTemplItemLeft" align="right" valign="top">DerivedV::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a38fd083e49162fe9dfe2e1de54948c89">turning_number</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:a38fd083e49162fe9dfe2e1de54948c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the turning number of a closed curve in the plane.  <br /></td></tr>
<tr class="separator:a38fd083e49162fe9dfe2e1de54948c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef42c6f3251414c7485b4d1433a54e4" id="r_aaef42c6f3251414c7485b4d1433a54e4"><td class="memTemplParams" colspan="2">template&lt;typename Scalardown_quat , typename Scalarquat &gt; </td></tr>
<tr class="memitem:aaef42c6f3251414c7485b4d1433a54e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aaef42c6f3251414c7485b4d1433a54e4">two_axis_valuator_fixed_up</a> (const int w, const int h, const double speed, const Eigen::Quaternion&lt; Scalardown_quat &gt; &amp;down_quat, const int down_x, const int down_y, const int mouse_x, const int mouse_y, Eigen::Quaternion&lt; Scalarquat &gt; &amp;quat)</td></tr>
<tr class="memdesc:aaef42c6f3251414c7485b4d1433a54e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a two-axis valuator drag rotation (as seen in Maya/Studio max) to a given rotation.  <br /></td></tr>
<tr class="separator:aaef42c6f3251414c7485b4d1433a54e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653da1c359295934ee69235ad8d43db4" id="r_a653da1c359295934ee69235ad8d43db4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a653da1c359295934ee69235ad8d43db4">uniformly_sample_two_manifold</a> (const Eigen::MatrixXd &amp;W, const Eigen::MatrixXi &amp;F, const int k, const double push, Eigen::MatrixXd &amp;WS)</td></tr>
<tr class="memdesc:a653da1c359295934ee69235ad8d43db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to sample a mesh uniformly with k-points by furthest point relaxation as described in "Fast Automatic Skinning Transformations" [Jacobson et al.  <br /></td></tr>
<tr class="separator:a653da1c359295934ee69235ad8d43db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17a2faf487e7a4ee375842967d6b285" id="r_ad17a2faf487e7a4ee375842967d6b285"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad17a2faf487e7a4ee375842967d6b285">uniformly_sample_two_manifold_at_vertices</a> (const Eigen::MatrixXd &amp;W, const int k, const double push, Eigen::VectorXi &amp;S)</td></tr>
<tr class="memdesc:ad17a2faf487e7a4ee375842967d6b285"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="uniformly__sample__two__manifold_8h.html">include/igl/uniformly_sample_two_manifold.h</a>.  <br /></td></tr>
<tr class="separator:ad17a2faf487e7a4ee375842967d6b285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aa8c440aeb5e9aab5fb79156197153" id="r_a45aa8c440aeb5e9aab5fb79156197153"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45aa8c440aeb5e9aab5fb79156197153"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a45aa8c440aeb5e9aab5fb79156197153">unique</a> (const std::vector&lt; T &gt; &amp;A, std::vector&lt; T &gt; &amp;C, std::vector&lt; size_t &gt; &amp;IA, std::vector&lt; size_t &gt; &amp;IC)</td></tr>
<tr class="memdesc:a45aa8c440aeb5e9aab5fb79156197153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like matlab's [C,IA,IC] = unique(X)  <br /></td></tr>
<tr class="separator:a45aa8c440aeb5e9aab5fb79156197153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97cc0b7a30e7285c6375d63fca2946c" id="r_ae97cc0b7a30e7285c6375d63fca2946c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae97cc0b7a30e7285c6375d63fca2946c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae97cc0b7a30e7285c6375d63fca2946c">unique</a> (const std::vector&lt; T &gt; &amp;A, std::vector&lt; T &gt; &amp;C)</td></tr>
<tr class="memdesc:ae97cc0b7a30e7285c6375d63fca2946c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae97cc0b7a30e7285c6375d63fca2946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715dcc29e1a1beb8b358ebd275765fbb" id="r_a715dcc29e1a1beb8b358ebd275765fbb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedC , typename DerivedIA , typename DerivedIC &gt; </td></tr>
<tr class="memitem:a715dcc29e1a1beb8b358ebd275765fbb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a715dcc29e1a1beb8b358ebd275765fbb">unique</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;IC)</td></tr>
<tr class="memdesc:a715dcc29e1a1beb8b358ebd275765fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a715dcc29e1a1beb8b358ebd275765fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a554daf5ff87c8e4661b250e0078ce" id="r_a03a554daf5ff87c8e4661b250e0078ce"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedC &gt; </td></tr>
<tr class="memitem:a03a554daf5ff87c8e4661b250e0078ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a03a554daf5ff87c8e4661b250e0078ce">unique</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a03a554daf5ff87c8e4661b250e0078ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a03a554daf5ff87c8e4661b250e0078ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec9f63d03451613c1a56df8308fe4b2" id="r_a5ec9f63d03451613c1a56df8308fe4b2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2EType &gt; </td></tr>
<tr class="memitem:a5ec9f63d03451613c1a56df8308fe4b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2">unique_edge_map</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E)</td></tr>
<tr class="memdesc:a5ec9f63d03451613c1a56df8308fe4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct relationships between facet "half"-(or rather "viewed")-edges E to unique edges of the mesh seen as a graph.  <br /></td></tr>
<tr class="separator:a5ec9f63d03451613c1a56df8308fe4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386a94bc8aaf45b2eb84b355d2bff311" id="r_a386a94bc8aaf45b2eb84b355d2bff311"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP &gt; </td></tr>
<tr class="memitem:a386a94bc8aaf45b2eb84b355d2bff311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a386a94bc8aaf45b2eb84b355d2bff311">unique_edge_map</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP)</td></tr>
<tr class="memdesc:a386a94bc8aaf45b2eb84b355d2bff311"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a386a94bc8aaf45b2eb84b355d2bff311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a5bc29088ffa37e630cf9fd0d92c66" id="r_a50a5bc29088ffa37e630cf9fd0d92c66"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE &gt; </td></tr>
<tr class="memitem:a50a5bc29088ffa37e630cf9fd0d92c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a50a5bc29088ffa37e630cf9fd0d92c66">unique_edge_map</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE)</td></tr>
<tr class="memdesc:a50a5bc29088ffa37e630cf9fd0d92c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a50a5bc29088ffa37e630cf9fd0d92c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc1388186f7f12be43df64d7ad45a136" id="r_adc1388186f7f12be43df64d7ad45a136"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedC , typename DerivedIA , typename DerivedIC &gt; </td></tr>
<tr class="memitem:adc1388186f7f12be43df64d7ad45a136"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adc1388186f7f12be43df64d7ad45a136">unique_rows</a> (const Eigen::DenseBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;IC)</td></tr>
<tr class="memdesc:adc1388186f7f12be43df64d7ad45a136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Act like matlab's [C,IA,IC] = unique(X,'rows')  <br /></td></tr>
<tr class="separator:adc1388186f7f12be43df64d7ad45a136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23358af3f14021f32e9d30758f80a9a7" id="r_a23358af3f14021f32e9d30758f80a9a7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedFF , typename DerivedIA , typename DerivedIC &gt; </td></tr>
<tr class="memitem:a23358af3f14021f32e9d30758f80a9a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a23358af3f14021f32e9d30758f80a9a7">unique_simplices</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;IA, Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;IC)</td></tr>
<tr class="memdesc:a23358af3f14021f32e9d30758f80a9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find <em>combinatorially</em> unique simplices in F.  <br /></td></tr>
<tr class="separator:a23358af3f14021f32e9d30758f80a9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ecb806162f1bbe1260c630e8bb941d" id="r_a20ecb806162f1bbe1260c630e8bb941d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedFF &gt; </td></tr>
<tr class="memitem:a20ecb806162f1bbe1260c630e8bb941d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a20ecb806162f1bbe1260c630e8bb941d">unique_simplices</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF)</td></tr>
<tr class="memdesc:a20ecb806162f1bbe1260c630e8bb941d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a20ecb806162f1bbe1260c630e8bb941d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b29a2138c5fa4268400e42b8df04a9" id="r_a04b29a2138c5fa4268400e42b8df04a9"><td class="memTemplParams" colspan="2">template&lt;typename Derivedwin , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Derivedscene &gt; </td></tr>
<tr class="memitem:a04b29a2138c5fa4268400e42b8df04a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a04b29a2138c5fa4268400e42b8df04a9">unproject</a> (const Eigen::MatrixBase&lt; Derivedwin &gt; &amp;win, const Eigen::MatrixBase&lt; Derivedmodel &gt; &amp;model, const Eigen::MatrixBase&lt; Derivedproj &gt; &amp;proj, const Eigen::MatrixBase&lt; Derivedviewport &gt; &amp;viewport, Eigen::PlainObjectBase&lt; Derivedscene &gt; &amp;scene)</td></tr>
<tr class="memdesc:a04b29a2138c5fa4268400e42b8df04a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen reimplementation of gluUnproject.  <br /></td></tr>
<tr class="separator:a04b29a2138c5fa4268400e42b8df04a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac545f7c2b0b725169a3785ba8e5bdbc2" id="r_ac545f7c2b0b725169a3785ba8e5bdbc2"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ac545f7c2b0b725169a3785ba8e5bdbc2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac545f7c2b0b725169a3785ba8e5bdbc2">unproject</a> (const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;win, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;model, const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;proj, const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;viewport)</td></tr>
<tr class="memdesc:ac545f7c2b0b725169a3785ba8e5bdbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac545f7c2b0b725169a3785ba8e5bdbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec5b69e885a84437436bde2e86bb09a" id="r_adec5b69e885a84437436bde2e86bb09a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedobj &gt; </td></tr>
<tr class="memitem:adec5b69e885a84437436bde2e86bb09a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adec5b69e885a84437436bde2e86bb09a">unproject_in_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;obj, std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;hits)</td></tr>
<tr class="memdesc:adec5b69e885a84437436bde2e86bb09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position <em>inside</em> a given mesh.  <br /></td></tr>
<tr class="separator:adec5b69e885a84437436bde2e86bb09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fc2d8b2c9e58a5006fe7f8ea6308ec" id="r_a25fc2d8b2c9e58a5006fe7f8ea6308ec"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedobj &gt; </td></tr>
<tr class="memitem:a25fc2d8b2c9e58a5006fe7f8ea6308ec"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a25fc2d8b2c9e58a5006fe7f8ea6308ec">unproject_in_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;obj)</td></tr>
<tr class="memdesc:a25fc2d8b2c9e58a5006fe7f8ea6308ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a25fc2d8b2c9e58a5006fe7f8ea6308ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f5bf3b46d4f04f8189b0a5b489e4bb" id="r_a86f5bf3b46d4f04f8189b0a5b489e4bb"><td class="memTemplParams" colspan="2">template&lt;typename Derivedobj &gt; </td></tr>
<tr class="memitem:a86f5bf3b46d4f04f8189b0a5b489e4bb"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a86f5bf3b46d4f04f8189b0a5b489e4bb">unproject_in_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const std::function&lt; void(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;, std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;) &gt; &amp;shoot_ray, Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;obj, std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;hits)</td></tr>
<tr class="memdesc:a86f5bf3b46d4f04f8189b0a5b489e4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a86f5bf3b46d4f04f8189b0a5b489e4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4df676266aad88e2fad4b43a0777c" id="r_a28d4df676266aad88e2fad4b43a0777c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename Derivedorigin , typename Deriveddir &gt; </td></tr>
<tr class="memitem:a28d4df676266aad88e2fad4b43a0777c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a28d4df676266aad88e2fad4b43a0777c">unproject_on_line</a> (const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;VP, const Eigen::MatrixBase&lt; Derivedorigin &gt; &amp;origin, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;dir, typename DerivedUV::Scalar &amp;t)</td></tr>
<tr class="memdesc:a28d4df676266aad88e2fad4b43a0777c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a screen space point (u,v) and the current projection matrix (e.g.  <br /></td></tr>
<tr class="separator:a28d4df676266aad88e2fad4b43a0777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb8ea814628c47819f95f70ed6ff5d8" id="r_addb8ea814628c47819f95f70ed6ff5d8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename Derivedorigin , typename Deriveddir , typename DerivedZ &gt; </td></tr>
<tr class="memitem:addb8ea814628c47819f95f70ed6ff5d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#addb8ea814628c47819f95f70ed6ff5d8">unproject_on_line</a> (const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;VP, const Eigen::MatrixBase&lt; Derivedorigin &gt; &amp;origin, const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;dir, Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;Z)</td></tr>
<tr class="memdesc:addb8ea814628c47819f95f70ed6ff5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:addb8ea814628c47819f95f70ed6ff5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf2e9896877756fbe8f09c0b051e76d" id="r_a0cf2e9896877756fbe8f09c0b051e76d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename DerivedP , typename DerivedZ &gt; </td></tr>
<tr class="memitem:a0cf2e9896877756fbe8f09c0b051e76d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0cf2e9896877756fbe8f09c0b051e76d">unproject_on_plane</a> (const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedM &gt; &amp;M, const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;VP, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;Z)</td></tr>
<tr class="memdesc:a0cf2e9896877756fbe8f09c0b051e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a screen space point (u,v) and the current projection matrix (e.g.  <br /></td></tr>
<tr class="separator:a0cf2e9896877756fbe8f09c0b051e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbefb4e32e184a299b36f663b23b7b9c" id="r_abbefb4e32e184a299b36f663b23b7b9c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedbc &gt; </td></tr>
<tr class="memitem:abbefb4e32e184a299b36f663b23b7b9c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abbefb4e32e184a299b36f663b23b7b9c">unproject_onto_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, int &amp;fid, Eigen::PlainObjectBase&lt; Derivedbc &gt; &amp;bc)</td></tr>
<tr class="memdesc:abbefb4e32e184a299b36f663b23b7b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position <em>onto</em> a given mesh, if the ray through the given screen location (x,y) <em>hits</em> the mesh.  <br /></td></tr>
<tr class="separator:abbefb4e32e184a299b36f663b23b7b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d029fbc6f770b7dec469f743858d8f" id="r_af4d029fbc6f770b7dec469f743858d8f"><td class="memTemplParams" colspan="2">template&lt;typename Derivedbc &gt; </td></tr>
<tr class="memitem:af4d029fbc6f770b7dec469f743858d8f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af4d029fbc6f770b7dec469f743858d8f">unproject_onto_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const std::function&lt; bool(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;, <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &amp;) &gt; &amp;shoot_ray, int &amp;fid, Eigen::PlainObjectBase&lt; Derivedbc &gt; &amp;bc)</td></tr>
<tr class="memdesc:af4d029fbc6f770b7dec469f743858d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af4d029fbc6f770b7dec469f743858d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171d8ab81ed0ba003408f162c80a5505" id="r_a171d8ab81ed0ba003408f162c80a5505"><td class="memTemplParams" colspan="2">template&lt;typename Derivedpos , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Deriveds , typename Deriveddir &gt; </td></tr>
<tr class="memitem:a171d8ab81ed0ba003408f162c80a5505"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a171d8ab81ed0ba003408f162c80a5505">unproject_ray</a> (const Eigen::MatrixBase&lt; Derivedpos &gt; &amp;pos, const Eigen::MatrixBase&lt; Derivedmodel &gt; &amp;model, const Eigen::MatrixBase&lt; Derivedproj &gt; &amp;proj, const Eigen::MatrixBase&lt; Derivedviewport &gt; &amp;viewport, Eigen::PlainObjectBase&lt; Deriveds &gt; &amp;s, Eigen::PlainObjectBase&lt; Deriveddir &gt; &amp;dir)</td></tr>
<tr class="memdesc:a171d8ab81ed0ba003408f162c80a5505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a ray (source point + direction vector) given a screen space positions (e.g.  <br /></td></tr>
<tr class="separator:a171d8ab81ed0ba003408f162c80a5505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681d80aaa80e594a1983b10aaf6006fd" id="r_a681d80aaa80e594a1983b10aaf6006fd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedU , typename DerivedG , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a681d80aaa80e594a1983b10aaf6006fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a681d80aaa80e594a1983b10aaf6006fd">unzip_corners</a> (const std::vector&lt; std::reference_wrapper&lt; DerivedA &gt; &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;U, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a681d80aaa80e594a1983b10aaf6006fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a triangle mesh where corners of each triangle index different matrices of attributes (e.g.  <br /></td></tr>
<tr class="separator:a681d80aaa80e594a1983b10aaf6006fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7897e133babd19415648e5aaef9cc63a" id="r_a7897e133babd19415648e5aaef9cc63a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename SType , typename DerivedNF &gt; </td></tr>
<tr class="memitem:a7897e133babd19415648e5aaef9cc63a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7897e133babd19415648e5aaef9cc63a">upsample</a> (const int n_verts, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; SType &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;NF)</td></tr>
<tr class="memdesc:a7897e133babd19415648e5aaef9cc63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide without moving vertices: Given the triangle mesh [V, F], where n_verts = V.rows(), computes newV and a sparse matrix S s.t.  <br /></td></tr>
<tr class="separator:a7897e133babd19415648e5aaef9cc63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22564028c3ea860f1dcfb72d48872602" id="r_a22564028c3ea860f1dcfb72d48872602"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF &gt; </td></tr>
<tr class="memitem:a22564028c3ea860f1dcfb72d48872602"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a22564028c3ea860f1dcfb72d48872602">upsample</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;NV, Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;NF, const int number_of_subdivs=1)</td></tr>
<tr class="memdesc:a22564028c3ea860f1dcfb72d48872602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints.  <br /></td></tr>
<tr class="separator:a22564028c3ea860f1dcfb72d48872602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9347f30f3803c2aa656a3b73ed9c02f5" id="r_a9347f30f3803c2aa656a3b73ed9c02f5"><td class="memTemplParams" colspan="2">template&lt;typename MatV , typename MatF &gt; </td></tr>
<tr class="memitem:a9347f30f3803c2aa656a3b73ed9c02f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a9347f30f3803c2aa656a3b73ed9c02f5">upsample</a> (MatV &amp;V, MatF &amp;F, const int number_of_subdivs=1)</td></tr>
<tr class="separator:a9347f30f3803c2aa656a3b73ed9c02f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3e7408bbfe1e7f478d79af1ab05dc0" id="r_a4a3e7408bbfe1e7f478d79af1ab05dc0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename Scalar &gt; </td></tr>
<tr class="memitem:a4a3e7408bbfe1e7f478d79af1ab05dc0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4a3e7408bbfe1e7f478d79af1ab05dc0">vector_area_matrix</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; Scalar &gt; &amp;A)</td></tr>
<tr class="memdesc:a4a3e7408bbfe1e7f478d79af1ab05dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the symmetric area matrix A, s.t.  <br /></td></tr>
<tr class="separator:a4a3e7408bbfe1e7f478d79af1ab05dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1052b6f357eb1bcc4258d45490d866ad" id="r_a1052b6f357eb1bcc4258d45490d866ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1052b6f357eb1bcc4258d45490d866ad">verbose</a> (const char *msg,...)</td></tr>
<tr class="memdesc:a1052b6f357eb1bcc4258d45490d866ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a wrapper for printf, called verbose that functions exactly like printf if VERBOSE is defined and does exactly nothing if VERBOSE is undefined.  <br /></td></tr>
<tr class="separator:a1052b6f357eb1bcc4258d45490d866ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8159118b103ccc116d788259917acdb" id="r_ab8159118b103ccc116d788259917acdb"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedC , typename Derivedcounts &gt; </td></tr>
<tr class="memitem:ab8159118b103ccc116d788259917acdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab8159118b103ccc116d788259917acdb">vertex_components</a> (const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; Derivedcounts &gt; &amp;counts)</td></tr>
<tr class="memdesc:ab8159118b103ccc116d788259917acdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute connected components of a graph represented by an adjacency matrix.  <br /></td></tr>
<tr class="separator:ab8159118b103ccc116d788259917acdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ae9814690f3c0f466cfae73890263" id="r_a669ae9814690f3c0f466cfae73890263"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedC &gt; </td></tr>
<tr class="memitem:a669ae9814690f3c0f466cfae73890263"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a669ae9814690f3c0f466cfae73890263">vertex_components</a> (const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a669ae9814690f3c0f466cfae73890263"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a669ae9814690f3c0f466cfae73890263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfebfe524e61fecdadf7d789ddb9ec9" id="r_a1cfebfe524e61fecdadf7d789ddb9ec9"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a1cfebfe524e61fecdadf7d789ddb9ec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1cfebfe524e61fecdadf7d789ddb9ec9">vertex_components</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a1cfebfe524e61fecdadf7d789ddb9ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the connected components for a mesh given its faces.  <br /></td></tr>
<tr class="separator:a1cfebfe524e61fecdadf7d789ddb9ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdf409439e0498066a620d30db6899" id="r_acabdf409439e0498066a620d30db6899"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename VFType , typename VFiType &gt; </td></tr>
<tr class="memitem:acabdf409439e0498066a620d30db6899"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#acabdf409439e0498066a620d30db6899">vertex_triangle_adjacency</a> (const typename DerivedF::Scalar n, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; VFType &gt; &gt; &amp;VF, std::vector&lt; std::vector&lt; VFiType &gt; &gt; &amp;VFi)</td></tr>
<tr class="memdesc:acabdf409439e0498066a620d30db6899"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F)  <br /></td></tr>
<tr class="separator:acabdf409439e0498066a620d30db6899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c886a9ced7765ce3e2f03332bbcf91" id="r_a44c886a9ced7765ce3e2f03332bbcf91"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename IndexType &gt; </td></tr>
<tr class="memitem:a44c886a9ced7765ce3e2f03332bbcf91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a44c886a9ced7765ce3e2f03332bbcf91">vertex_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;VF, std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;VFi)</td></tr>
<tr class="memdesc:a44c886a9ced7765ce3e2f03332bbcf91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a44c886a9ced7765ce3e2f03332bbcf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4082714e403404167543bddf89ba53" id="r_a6e4082714e403404167543bddf89ba53"><td class="memTemplParams" colspan="2">template&lt;typename DerivedF , typename DerivedVF , typename DerivedNI &gt; </td></tr>
<tr class="memitem:a6e4082714e403404167543bddf89ba53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6e4082714e403404167543bddf89ba53">vertex_triangle_adjacency</a> (const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const int n, Eigen::PlainObjectBase&lt; DerivedVF &gt; &amp;VF, Eigen::PlainObjectBase&lt; DerivedNI &gt; &amp;NI)</td></tr>
<tr class="memdesc:a6e4082714e403404167543bddf89ba53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a6e4082714e403404167543bddf89ba53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289cc75429d0c045af9eca70642b8f8a" id="r_a289cc75429d0c045af9eca70642b8f8a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename Derivedvol &gt; </td></tr>
<tr class="memitem:a289cc75429d0c045af9eca70642b8f8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a289cc75429d0c045af9eca70642b8f8a">volume</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, Eigen::PlainObjectBase&lt; Derivedvol &gt; &amp;vol)</td></tr>
<tr class="memdesc:a289cc75429d0c045af9eca70642b8f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute volume for all tets of a given tet mesh (V,T)  <br /></td></tr>
<tr class="separator:a289cc75429d0c045af9eca70642b8f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25567c5af213643fd332e32003e63b4" id="r_ab25567c5af213643fd332e32003e63b4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename Derivedvol &gt; </td></tr>
<tr class="memitem:ab25567c5af213643fd332e32003e63b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab25567c5af213643fd332e32003e63b4">volume</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const Eigen::MatrixBase&lt; DerivedB &gt; &amp;B, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const Eigen::MatrixBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; Derivedvol &gt; &amp;vol)</td></tr>
<tr class="memdesc:ab25567c5af213643fd332e32003e63b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab25567c5af213643fd332e32003e63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ebffa70b6797c8fd0404da673aaf3c" id="r_a89ebffa70b6797c8fd0404da673aaf3c"><td class="memTemplParams" colspan="2">template&lt;typename VecA , typename VecB , typename VecC , typename VecD &gt; </td></tr>
<tr class="memitem:a89ebffa70b6797c8fd0404da673aaf3c"><td class="memTemplItemLeft" align="right" valign="top">VecA::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a89ebffa70b6797c8fd0404da673aaf3c">volume_single</a> (const VecA &amp;a, const VecB &amp;b, const VecC &amp;c, const VecD &amp;d)</td></tr>
<tr class="memdesc:a89ebffa70b6797c8fd0404da673aaf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a89ebffa70b6797c8fd0404da673aaf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da5bd53ebc802822b96aebabbfddfa1" id="r_a0da5bd53ebc802822b96aebabbfddfa1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedL , typename Derivedvol &gt; </td></tr>
<tr class="memitem:a0da5bd53ebc802822b96aebabbfddfa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0da5bd53ebc802822b96aebabbfddfa1">volume</a> (const Eigen::MatrixBase&lt; DerivedL &gt; &amp;L, Eigen::PlainObjectBase&lt; Derivedvol &gt; &amp;vol)</td></tr>
<tr class="memdesc:a0da5bd53ebc802822b96aebabbfddfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0da5bd53ebc802822b96aebabbfddfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd087fd838f29b3d9e50ef45403f2ce" id="r_adbd087fd838f29b3d9e50ef45403f2ce"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename DerivedGV , typename Derivedside &gt; </td></tr>
<tr class="memitem:adbd087fd838f29b3d9e50ef45403f2ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adbd087fd838f29b3d9e50ef45403f2ce">voxel_grid</a> (const Eigen::AlignedBox&lt; Scalar, 3 &gt; &amp;box, const int s, const int pad_count, Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;GV, Eigen::PlainObjectBase&lt; Derivedside &gt; &amp;side)</td></tr>
<tr class="memdesc:adbd087fd838f29b3d9e50ef45403f2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the cell center positions of a regular voxel grid (lattice) made of perfectly square voxels.  <br /></td></tr>
<tr class="separator:adbd087fd838f29b3d9e50ef45403f2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467c3ec21d8d152e2e6aaf04ef8ab1da" id="r_a467c3ec21d8d152e2e6aaf04ef8ab1da"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedGV , typename Derivedside &gt; </td></tr>
<tr class="memitem:a467c3ec21d8d152e2e6aaf04ef8ab1da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a467c3ec21d8d152e2e6aaf04ef8ab1da">voxel_grid</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const typename DerivedV::Scalar offset, const int s, const int pad_count, Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;GV, Eigen::PlainObjectBase&lt; Derivedside &gt; &amp;side)</td></tr>
<tr class="memdesc:a467c3ec21d8d152e2e6aaf04ef8ab1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a467c3ec21d8d152e2e6aaf04ef8ab1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468f01ca961ac9ea78d02b3ecac25bee" id="r_a468f01ca961ac9ea78d02b3ecac25bee"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedO , typename DerivedW &gt; </td></tr>
<tr class="memitem:a468f01ca961ac9ea78d02b3ecac25bee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a468f01ca961ac9ea78d02b3ecac25bee">winding_number</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedO &gt; &amp;O, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a468f01ca961ac9ea78d02b3ecac25bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized winding number at each dim-dimensional query point in O with respect to the oriented one-codimensional mesh (V,F).  <br /></td></tr>
<tr class="separator:a468f01ca961ac9ea78d02b3ecac25bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aab3f308b50dd0cafa361fed13ee213" id="r_a6aab3f308b50dd0cafa361fed13ee213"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedp &gt; </td></tr>
<tr class="memitem:a6aab3f308b50dd0cafa361fed13ee213"><td class="memTemplItemLeft" align="right" valign="top">DerivedV::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6aab3f308b50dd0cafa361fed13ee213">winding_number</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedp &gt; &amp;p)</td></tr>
<tr class="memdesc:a6aab3f308b50dd0cafa361fed13ee213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute winding number of a single point.  <br /></td></tr>
<tr class="separator:a6aab3f308b50dd0cafa361fed13ee213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10e48891b5b843708fd73f095a5f96c" id="r_aa10e48891b5b843708fd73f095a5f96c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:aa10e48891b5b843708fd73f095a5f96c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa10e48891b5b843708fd73f095a5f96c">write_triangle_mesh</a> (const std::string str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding=<a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">FileEncoding::Ascii</a>)</td></tr>
<tr class="memdesc:aa10e48891b5b843708fd73f095a5f96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">write mesh to a file with automatic detection of file format.  <br /></td></tr>
<tr class="separator:aa10e48891b5b843708fd73f095a5f96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b5e18062898bc13278debb80127424" id="r_a95b5e18062898bc13278debb80127424"><td class="memTemplParams" colspan="2">template&lt;typename DerivedWI , typename DerivedP , typename DerivedO &gt; </td></tr>
<tr class="memitem:a95b5e18062898bc13278debb80127424"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a95b5e18062898bc13278debb80127424">writeBF</a> (const std::string &amp;filename, const Eigen::PlainObjectBase&lt; DerivedWI &gt; &amp;WI, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;O)</td></tr>
<tr class="memdesc:a95b5e18062898bc13278debb80127424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a bones forest to a file.  <br /></td></tr>
<tr class="separator:a95b5e18062898bc13278debb80127424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8159d2953cb18953457a90976885ff57" id="r_a8159d2953cb18953457a90976885ff57"><td class="memTemplParams" colspan="2">template&lt;typename DerivedW &gt; </td></tr>
<tr class="memitem:a8159d2953cb18953457a90976885ff57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8159d2953cb18953457a90976885ff57">writeDMAT</a> (const std::string file_name, const Eigen::MatrixBase&lt; DerivedW &gt; &amp;W, const bool ascii=true)</td></tr>
<tr class="memdesc:a8159d2953cb18953457a90976885ff57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a matrix using ascii dmat file type.  <br /></td></tr>
<tr class="separator:a8159d2953cb18953457a90976885ff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f57ac9b3108c7e4e62890786a69337" id="r_a24f57ac9b3108c7e4e62890786a69337"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a24f57ac9b3108c7e4e62890786a69337"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a24f57ac9b3108c7e4e62890786a69337">writeDMAT</a> (const std::string file_name, const std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;W, const bool ascii=true)</td></tr>
<tr class="memdesc:a24f57ac9b3108c7e4e62890786a69337"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a24f57ac9b3108c7e4e62890786a69337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5cabc9f902b654e3a9169855250e7c" id="r_ace5cabc9f902b654e3a9169855250e7c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ace5cabc9f902b654e3a9169855250e7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ace5cabc9f902b654e3a9169855250e7c">writeDMAT</a> (const std::string file_name, const std::vector&lt; Scalar &gt; &amp;W, const bool ascii=true)</td></tr>
<tr class="memdesc:ace5cabc9f902b654e3a9169855250e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ace5cabc9f902b654e3a9169855250e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6b14a1061d9ce7d0ef20880e604186" id="r_a6a6b14a1061d9ce7d0ef20880e604186"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Index &gt; </td></tr>
<tr class="memitem:a6a6b14a1061d9ce7d0ef20880e604186"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a6a6b14a1061d9ce7d0ef20880e604186">writeMESH</a> (const std::string mesh_file_name, const std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;V, const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;T, const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a6a6b14a1061d9ce7d0ef20880e604186"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a tetrahedral volume mesh to a .mesh file  <br /></td></tr>
<tr class="separator:a6a6b14a1061d9ce7d0ef20880e604186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac173c671f0c9f633abe3daa005455507" id="r_ac173c671f0c9f633abe3daa005455507"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedT , typename DerivedF &gt; </td></tr>
<tr class="memitem:ac173c671f0c9f633abe3daa005455507"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ac173c671f0c9f633abe3daa005455507">writeMESH</a> (const std::string str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ac173c671f0c9f633abe3daa005455507"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a tetrahedral volume mesh to a .mesh file  <br /></td></tr>
<tr class="separator:ac173c671f0c9f633abe3daa005455507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df694c52f937d065a10d20c184ddfc4" id="r_a2df694c52f937d065a10d20c184ddfc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2df694c52f937d065a10d20c184ddfc4">writeMSH</a> (const std::string &amp;msh, const Eigen::MatrixXd &amp;X, const Eigen::MatrixXi &amp;Tri, const Eigen::MatrixXi &amp;Tet, const Eigen::MatrixXi &amp;TriTag, const Eigen::MatrixXi &amp;TetTag, const std::vector&lt; std::string &gt; &amp;XFields, const std::vector&lt; Eigen::MatrixXd &gt; &amp;XF, const std::vector&lt; std::string &gt; &amp;EFields, const std::vector&lt; Eigen::MatrixXd &gt; &amp;TriF, const std::vector&lt; Eigen::MatrixXd &gt; &amp;TetF)</td></tr>
<tr class="memdesc:a2df694c52f937d065a10d20c184ddfc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">write triangle surface mesh and tetrahedral volume mesh to .msh file  <br /></td></tr>
<tr class="separator:a2df694c52f937d065a10d20c184ddfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1761a85ec5cdef44ce8104d0ccdc3f" id="r_a1a1761a85ec5cdef44ce8104d0ccdc3f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedCN , typename DerivedFN , typename DerivedTC , typename DerivedFTC &gt; </td></tr>
<tr class="memitem:a1a1761a85ec5cdef44ce8104d0ccdc3f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1a1761a85ec5cdef44ce8104d0ccdc3f">writeOBJ</a> (const std::string str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedCN &gt; &amp;CN, const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;FN, const Eigen::MatrixBase&lt; DerivedTC &gt; &amp;TC, const Eigen::MatrixBase&lt; DerivedFTC &gt; &amp;FTC)</td></tr>
<tr class="memdesc:a1a1761a85ec5cdef44ce8104d0ccdc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a mesh in an ascii obj file.  <br /></td></tr>
<tr class="separator:a1a1761a85ec5cdef44ce8104d0ccdc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad361555ef88be9751c1940298028a4a3" id="r_ad361555ef88be9751c1940298028a4a3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ad361555ef88be9751c1940298028a4a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad361555ef88be9751c1940298028a4a3">writeOBJ</a> (const std::string str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ad361555ef88be9751c1940298028a4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad361555ef88be9751c1940298028a4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acdf796fe0c739fd37989deb859f564" id="r_a5acdf796fe0c739fd37989deb859f564"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename T &gt; </td></tr>
<tr class="memitem:a5acdf796fe0c739fd37989deb859f564"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a5acdf796fe0c739fd37989deb859f564">writeOBJ</a> (const std::string &amp;str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;F)</td></tr>
<tr class="memdesc:a5acdf796fe0c739fd37989deb859f564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a mesh of mixed tris and quads to an ascii obj file.  <br /></td></tr>
<tr class="separator:a5acdf796fe0c739fd37989deb859f564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c26424f96cf3b86305b18dd91dd0c83" id="r_a3c26424f96cf3b86305b18dd91dd0c83"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a3c26424f96cf3b86305b18dd91dd0c83"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3c26424f96cf3b86305b18dd91dd0c83">writeOFF</a> (const std::string str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a3c26424f96cf3b86305b18dd91dd0c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Export geometry and colors-by-vertex to an ascii OFF file.  <br /></td></tr>
<tr class="separator:a3c26424f96cf3b86305b18dd91dd0c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d5937707edc99d534ccab39d14429c" id="r_ab9d5937707edc99d534ccab39d14429c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ab9d5937707edc99d534ccab39d14429c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab9d5937707edc99d534ccab39d14429c">writeOFF</a> (const std::string str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ab9d5937707edc99d534ccab39d14429c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab9d5937707edc99d534ccab39d14429c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75b8abd010b0cc4ce47469b3f855e42" id="r_ad75b8abd010b0cc4ce47469b3f855e42"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </td></tr>
<tr class="memitem:ad75b8abd010b0cc4ce47469b3f855e42"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad75b8abd010b0cc4ce47469b3f855e42">writePLY</a> (std::ostream &amp;ply_stream, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;VD, const std::vector&lt; std::string &gt; &amp;VDheader, const Eigen::MatrixBase&lt; DerivedFD &gt; &amp;FD, const std::vector&lt; std::string &gt; &amp;FDheader, const Eigen::MatrixBase&lt; DerivedED &gt; &amp;ED, const std::vector&lt; std::string &gt; &amp;EDheader, const std::vector&lt; std::string &gt; &amp;comments, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding)</td></tr>
<tr class="memdesc:ad75b8abd010b0cc4ce47469b3f855e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">write triangular mesh to ply file  <br /></td></tr>
<tr class="separator:ad75b8abd010b0cc4ce47469b3f855e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97df6737c8ab9d4d1c9093491d41c2a" id="r_ab97df6737c8ab9d4d1c9093491d41c2a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </td></tr>
<tr class="memitem:ab97df6737c8ab9d4d1c9093491d41c2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab97df6737c8ab9d4d1c9093491d41c2a">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;VD, const std::vector&lt; std::string &gt; &amp;VDheader, const Eigen::MatrixBase&lt; DerivedFD &gt; &amp;FD, const std::vector&lt; std::string &gt; &amp;FDheader, const Eigen::MatrixBase&lt; DerivedED &gt; &amp;ED, const std::vector&lt; std::string &gt; &amp;EDheader, const std::vector&lt; std::string &gt; &amp;comments, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding)</td></tr>
<tr class="memdesc:ab97df6737c8ab9d4d1c9093491d41c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab97df6737c8ab9d4d1c9093491d41c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089a8c3e1a12d0ad0be24eb7b9b35f47" id="r_a089a8c3e1a12d0ad0be24eb7b9b35f47"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a089a8c3e1a12d0ad0be24eb7b9b35f47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a089a8c3e1a12d0ad0be24eb7b9b35f47">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a089a8c3e1a12d0ad0be24eb7b9b35f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a089a8c3e1a12d0ad0be24eb7b9b35f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f47de9a532d3a6d2ccc94267d3806f2" id="r_a0f47de9a532d3a6d2ccc94267d3806f2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </td></tr>
<tr class="memitem:a0f47de9a532d3a6d2ccc94267d3806f2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0f47de9a532d3a6d2ccc94267d3806f2">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;E)</td></tr>
<tr class="memdesc:a0f47de9a532d3a6d2ccc94267d3806f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0f47de9a532d3a6d2ccc94267d3806f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c501124b7b44b6adf81a2a11a1fea2" id="r_a21c501124b7b44b6adf81a2a11a1fea2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedUV &gt; </td></tr>
<tr class="memitem:a21c501124b7b44b6adf81a2a11a1fea2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a21c501124b7b44b6adf81a2a11a1fea2">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV)</td></tr>
<tr class="memdesc:a21c501124b7b44b6adf81a2a11a1fea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a21c501124b7b44b6adf81a2a11a1fea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263e6503e126ed829c6a3e3e9c188110" id="r_a263e6503e126ed829c6a3e3e9c188110"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV &gt; </td></tr>
<tr class="memitem:a263e6503e126ed829c6a3e3e9c188110"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a263e6503e126ed829c6a3e3e9c188110">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV)</td></tr>
<tr class="memdesc:a263e6503e126ed829c6a3e3e9c188110"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a263e6503e126ed829c6a3e3e9c188110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe192d7895221e908003d65ab544d24f" id="r_abe192d7895221e908003d65ab544d24f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:abe192d7895221e908003d65ab544d24f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abe192d7895221e908003d65ab544d24f">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding)</td></tr>
<tr class="memdesc:abe192d7895221e908003d65ab544d24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abe192d7895221e908003d65ab544d24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689ca1568cfbecb2d29a1c37d6f38e7b" id="r_a689ca1568cfbecb2d29a1c37d6f38e7b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </td></tr>
<tr class="memitem:a689ca1568cfbecb2d29a1c37d6f38e7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a689ca1568cfbecb2d29a1c37d6f38e7b">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding)</td></tr>
<tr class="memdesc:a689ca1568cfbecb2d29a1c37d6f38e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a689ca1568cfbecb2d29a1c37d6f38e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7f6c3884f0355670c8fcdb36923671" id="r_a0c7f6c3884f0355670c8fcdb36923671"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedUV , typename DerivedVD &gt; </td></tr>
<tr class="memitem:a0c7f6c3884f0355670c8fcdb36923671"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0c7f6c3884f0355670c8fcdb36923671">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;VD=Eigen::MatrixXd(0, 0), const std::vector&lt; std::string &gt; &amp;VDheader={}, const std::vector&lt; std::string &gt; &amp;comments={})</td></tr>
<tr class="memdesc:a0c7f6c3884f0355670c8fcdb36923671"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0c7f6c3884f0355670c8fcdb36923671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedef9e44fe11f235719d619185e404b7" id="r_aedef9e44fe11f235719d619185e404b7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD &gt; </td></tr>
<tr class="memitem:aedef9e44fe11f235719d619185e404b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aedef9e44fe11f235719d619185e404b7">writePLY</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;UV, const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;VD=Eigen::MatrixXd(0, 0), const std::vector&lt; std::string &gt; &amp;VDheader={}, const std::vector&lt; std::string &gt; &amp;comments={})</td></tr>
<tr class="memdesc:aedef9e44fe11f235719d619185e404b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aedef9e44fe11f235719d619185e404b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07adddd7239a8b049f1383c09d78d245" id="r_a07adddd7239a8b049f1383c09d78d245"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </td></tr>
<tr class="memitem:a07adddd7239a8b049f1383c09d78d245"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a07adddd7239a8b049f1383c09d78d245">writeSTL</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding=<a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">FileEncoding::Ascii</a>)</td></tr>
<tr class="memdesc:a07adddd7239a8b049f1383c09d78d245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a mesh to an stl file.  <br /></td></tr>
<tr class="separator:a07adddd7239a8b049f1383c09d78d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c6477f242f1c28b713fc41205f21db" id="r_a13c6477f242f1c28b713fc41205f21db"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a13c6477f242f1c28b713fc41205f21db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a13c6477f242f1c28b713fc41205f21db">writeSTL</a> (const std::string &amp;filename, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a> encoding=<a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">FileEncoding::Ascii</a>)</td></tr>
<tr class="memdesc:a13c6477f242f1c28b713fc41205f21db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a13c6477f242f1c28b713fc41205f21db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98f5c58b4e2db831a37794d14e68190" id="r_ae98f5c58b4e2db831a37794d14e68190"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ae98f5c58b4e2db831a37794d14e68190">writeTGF</a> (const std::string tgf_filename, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;C, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;E)</td></tr>
<tr class="memdesc:ae98f5c58b4e2db831a37794d14e68190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a graph to a .tgf file.  <br /></td></tr>
<tr class="separator:ae98f5c58b4e2db831a37794d14e68190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217cf16c6a0be84701d89c49b3337ff4" id="r_a217cf16c6a0be84701d89c49b3337ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a217cf16c6a0be84701d89c49b3337ff4">writeTGF</a> (const std::string tgf_filename, const Eigen::MatrixXd &amp;C, const Eigen::MatrixXi &amp;E)</td></tr>
<tr class="memdesc:a217cf16c6a0be84701d89c49b3337ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a217cf16c6a0be84701d89c49b3337ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfecc2999b584fe90aa57e9e6538ddd" id="r_a0cfecc2999b584fe90aa57e9e6538ddd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a0cfecc2999b584fe90aa57e9e6538ddd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a0cfecc2999b584fe90aa57e9e6538ddd">writeWRL</a> (const std::string &amp;str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a0cfecc2999b584fe90aa57e9e6538ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write mesh to a .wrl file.  <br /></td></tr>
<tr class="separator:a0cfecc2999b584fe90aa57e9e6538ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315f62cc42f483bf2651f05eb1fd6d71" id="r_a315f62cc42f483bf2651f05eb1fd6d71"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:a315f62cc42f483bf2651f05eb1fd6d71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a315f62cc42f483bf2651f05eb1fd6d71">writeWRL</a> (const std::string &amp;str, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a315f62cc42f483bf2651f05eb1fd6d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a315f62cc42f483bf2651f05eb1fd6d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4132693fc82720d3e947c09aad236d96" id="r_a4132693fc82720d3e947c09aad236d96"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4132693fc82720d3e947c09aad236d96">IDENTITY_QUAT_F</a> [4] = {0,0,0,1}</td></tr>
<tr class="separator:a4132693fc82720d3e947c09aad236d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1c639c804d4e91dc1ffb424c5caf37" id="r_afc1c639c804d4e91dc1ffb424c5caf37"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#afc1c639c804d4e91dc1ffb424c5caf37">XY_PLANE_QUAT_F</a> [4] = {0,0,0,1}</td></tr>
<tr class="separator:afc1c639c804d4e91dc1ffb424c5caf37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4ae9044c47ccad908df3775523d731" id="r_adf4ae9044c47ccad908df3775523d731"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adf4ae9044c47ccad908df3775523d731">XZ_PLANE_QUAT_F</a> [4] = {-<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>,0,0,<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>}</td></tr>
<tr class="separator:adf4ae9044c47ccad908df3775523d731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd154ccb32e580426fe71c29fccf45e8" id="r_abd154ccb32e580426fe71c29fccf45e8"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abd154ccb32e580426fe71c29fccf45e8">YZ_PLANE_QUAT_F</a> [4] = {-0.5,-0.5,-0.5,0.5}</td></tr>
<tr class="separator:abd154ccb32e580426fe71c29fccf45e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16914177d382aa61d647d2bdac2f61a" id="r_ab16914177d382aa61d647d2bdac2f61a"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab16914177d382aa61d647d2bdac2f61a">CANONICAL_VIEW_QUAT_F</a> [][4]</td></tr>
<tr class="separator:ab16914177d382aa61d647d2bdac2f61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d25a0a671a74bdb8bea35d6dc482d66" id="r_a4d25a0a671a74bdb8bea35d6dc482d66"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4d25a0a671a74bdb8bea35d6dc482d66">IDENTITY_QUAT_D</a> [4] = {0,0,0,1}</td></tr>
<tr class="separator:a4d25a0a671a74bdb8bea35d6dc482d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0bd2386fb8512b5fccf9abaab47952" id="r_a1e0bd2386fb8512b5fccf9abaab47952"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1e0bd2386fb8512b5fccf9abaab47952">XY_PLANE_QUAT_D</a> [4] = {0,0,0,1}</td></tr>
<tr class="separator:a1e0bd2386fb8512b5fccf9abaab47952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83519a14c0cfc4eb50105894232e10a4" id="r_a83519a14c0cfc4eb50105894232e10a4"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a83519a14c0cfc4eb50105894232e10a4">XZ_PLANE_QUAT_D</a> [4] = {-<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>,0,0,<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>}</td></tr>
<tr class="separator:a83519a14c0cfc4eb50105894232e10a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec963f40812a8ab05b4b6b370fce4cfd" id="r_aec963f40812a8ab05b4b6b370fce4cfd"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aec963f40812a8ab05b4b6b370fce4cfd">YZ_PLANE_QUAT_D</a> [4] = {-0.5,-0.5,-0.5,0.5}</td></tr>
<tr class="separator:aec963f40812a8ab05b4b6b370fce4cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe2a3410b25f28096dcde690d7df743" id="r_abbe2a3410b25f28096dcde690d7df743"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#abbe2a3410b25f28096dcde690d7df743">CANONICAL_VIEW_QUAT_D</a> [][4]</td></tr>
<tr class="separator:abbe2a3410b25f28096dcde690d7df743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959bd85cf0ed1b59e3a9ad857c953604" id="r_a959bd85cf0ed1b59e3a9ad857c953604"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a959bd85cf0ed1b59e3a9ad857c953604">DOUBLE_EPS</a> = 1.0e-14</td></tr>
<tr class="memdesc:a959bd85cf0ed1b59e3a9ad857c953604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard value for double epsilon.  <br /></td></tr>
<tr class="separator:a959bd85cf0ed1b59e3a9ad857c953604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c4eb25dcc0beddf9732c13704a07b7" id="r_ab4c4eb25dcc0beddf9732c13704a07b7"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ab4c4eb25dcc0beddf9732c13704a07b7">DOUBLE_EPS_SQ</a> = 1.0e-28</td></tr>
<tr class="memdesc:ab4c4eb25dcc0beddf9732c13704a07b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard value for double epsilon²  <br /></td></tr>
<tr class="separator:ab4c4eb25dcc0beddf9732c13704a07b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7184cb6e2f319e3c31a0e1f5bc90354d" id="r_a7184cb6e2f319e3c31a0e1f5bc90354d"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a7184cb6e2f319e3c31a0e1f5bc90354d">FLOAT_EPS</a> = 1.0e-7f</td></tr>
<tr class="memdesc:a7184cb6e2f319e3c31a0e1f5bc90354d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard value for single epsilon.  <br /></td></tr>
<tr class="separator:a7184cb6e2f319e3c31a0e1f5bc90354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529be4dc6f96c94adc21d8480d9d9bbf" id="r_a529be4dc6f96c94adc21d8480d9d9bbf"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a529be4dc6f96c94adc21d8480d9d9bbf">FLOAT_EPS_SQ</a> = 1.0e-14f</td></tr>
<tr class="memdesc:a529be4dc6f96c94adc21d8480d9d9bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard value for single epsilon²  <br /></td></tr>
<tr class="separator:a529be4dc6f96c94adc21d8480d9d9bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2719a5fd20a68136038b7132136e74bf" id="r_a2719a5fd20a68136038b7132136e74bf"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2719a5fd20a68136038b7132136e74bf">GOLD_AMBIENT</a> [4] = { 51.0/255.0, 43.0/255.0,33.3/255.0,1.0f }</td></tr>
<tr class="separator:a2719a5fd20a68136038b7132136e74bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8589d6f0c07c7387258e004cfade2567" id="r_a8589d6f0c07c7387258e004cfade2567"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8589d6f0c07c7387258e004cfade2567">GOLD_DIFFUSE</a> [4] = { 255.0/255.0,228.0/255.0,58.0/255.0,1.0f }</td></tr>
<tr class="separator:a8589d6f0c07c7387258e004cfade2567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63110eff6fbd6ded60fc3c4a004c1ac3" id="r_a63110eff6fbd6ded60fc3c4a004c1ac3"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a63110eff6fbd6ded60fc3c4a004c1ac3">GOLD_SPECULAR</a> [4] = { 255.0/255.0,235.0/255.0,80.0/255.0,1.0f }</td></tr>
<tr class="separator:a63110eff6fbd6ded60fc3c4a004c1ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cea9492c40178a4255d810a81b27abb" id="r_a2cea9492c40178a4255d810a81b27abb"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2cea9492c40178a4255d810a81b27abb">SILVER_AMBIENT</a> [4] = { 0.2f, 0.2f, 0.2f, 1.0f }</td></tr>
<tr class="separator:a2cea9492c40178a4255d810a81b27abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285eccdcab39b99b34da071d0e811328" id="r_a285eccdcab39b99b34da071d0e811328"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a285eccdcab39b99b34da071d0e811328">SILVER_DIFFUSE</a> [4] = { 1.0f, 1.0f, 1.0f, 1.0f }</td></tr>
<tr class="separator:a285eccdcab39b99b34da071d0e811328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde55f12f19663cc168932e3cbaa1033" id="r_adde55f12f19663cc168932e3cbaa1033"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#adde55f12f19663cc168932e3cbaa1033">SILVER_SPECULAR</a> [4] = { 1.0f, 1.0f, 1.0f, 1.0f }</td></tr>
<tr class="separator:adde55f12f19663cc168932e3cbaa1033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f327ea1271a24126e5b54b58137207" id="r_a41f327ea1271a24126e5b54b58137207"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a41f327ea1271a24126e5b54b58137207">CYAN_AMBIENT</a> [4] = { 59.0/255.0, 68.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:a41f327ea1271a24126e5b54b58137207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91b40d8001ba8a6732b57ea544e3cff" id="r_aa91b40d8001ba8a6732b57ea544e3cff"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa91b40d8001ba8a6732b57ea544e3cff">CYAN_DIFFUSE</a> [4] = { 94.0/255.0,185.0/255.0,238.0/255.0,1.0f }</td></tr>
<tr class="separator:aa91b40d8001ba8a6732b57ea544e3cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa44781d95faf982b844c0aa39b3138" id="r_a2aa44781d95faf982b844c0aa39b3138"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2aa44781d95faf982b844c0aa39b3138">CYAN_SPECULAR</a> [4] = { 163.0/255.0,221.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:a2aa44781d95faf982b844c0aa39b3138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35121926b4786e30ae17f9f96c2657c6" id="r_a35121926b4786e30ae17f9f96c2657c6"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a35121926b4786e30ae17f9f96c2657c6">DENIS_PURPLE_DIFFUSE</a> [4] = { 80.0/255.0,64.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:a35121926b4786e30ae17f9f96c2657c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d9148951bd2c269433253e37bdb5fa" id="r_a31d9148951bd2c269433253e37bdb5fa"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a31d9148951bd2c269433253e37bdb5fa">LADISLAV_ORANGE_DIFFUSE</a> [4] = {1.0f, 125.0f / 255.0f, 19.0f / 255.0f, 0.0f}</td></tr>
<tr class="separator:a31d9148951bd2c269433253e37bdb5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef7cc70cc21ec016debd929ca40cb25" id="r_a3ef7cc70cc21ec016debd929ca40cb25"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3ef7cc70cc21ec016debd929ca40cb25">FAST_GREEN_DIFFUSE</a> [4] = { 113.0f/255.0f, 239.0f/255.0f, 46.0f/255.0f, 1.0f}</td></tr>
<tr class="separator:a3ef7cc70cc21ec016debd929ca40cb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d07e97190e3d6eb57c438d929fd9f7" id="r_af6d07e97190e3d6eb57c438d929fd9f7"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af6d07e97190e3d6eb57c438d929fd9f7">FAST_RED_DIFFUSE</a> [4] = { 255.0f/255.0f, 65.0f/255.0f, 46.0f/255.0f, 1.0f}</td></tr>
<tr class="separator:af6d07e97190e3d6eb57c438d929fd9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c3adfdf58bb4b9041258ed528419d8" id="r_a81c3adfdf58bb4b9041258ed528419d8"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a81c3adfdf58bb4b9041258ed528419d8">FAST_BLUE_DIFFUSE</a> [4] = { 106.0f/255.0f, 106.0f/255.0f, 255.0f/255.0f, 1.0f}</td></tr>
<tr class="separator:a81c3adfdf58bb4b9041258ed528419d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8c0ec0db4f21074319658ec9cda122" id="r_a1a8c0ec0db4f21074319658ec9cda122"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a1a8c0ec0db4f21074319658ec9cda122">FAST_GRAY_DIFFUSE</a> [4] = { 150.0f/255.0f, 150.0f/255.0f, 150.0f/255.0f, 1.0f}</td></tr>
<tr class="separator:a1a8c0ec0db4f21074319658ec9cda122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bdfa6acbe2c64f29cbd31426c86bfb" id="r_a42bdfa6acbe2c64f29cbd31426c86bfb"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a42bdfa6acbe2c64f29cbd31426c86bfb">WHITE</a> [4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:a42bdfa6acbe2c64f29cbd31426c86bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9827caee2da38a16d2578ad87c18b8" id="r_aba9827caee2da38a16d2578ad87c18b8"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aba9827caee2da38a16d2578ad87c18b8">BLACK</a> [4] = { 0.0/255.0,0.0/255.0,0.0/255.0,1.0f }</td></tr>
<tr class="separator:aba9827caee2da38a16d2578ad87c18b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ace1077f98e7c25d1b590afc21001d4" id="r_a4ace1077f98e7c25d1b590afc21001d4"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a4ace1077f98e7c25d1b590afc21001d4">WHITE_AMBIENT</a> [4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:a4ace1077f98e7c25d1b590afc21001d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af258223de150eac4510266bce6c15adc" id="r_af258223de150eac4510266bce6c15adc"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af258223de150eac4510266bce6c15adc">WHITE_DIFFUSE</a> [4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:af258223de150eac4510266bce6c15adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83f669c0c7352ed86d6991e28616eed" id="r_aa83f669c0c7352ed86d6991e28616eed"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa83f669c0c7352ed86d6991e28616eed">WHITE_SPECULAR</a> [4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td></tr>
<tr class="separator:aa83f669c0c7352ed86d6991e28616eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d653f310491c5eeea8199df41a8506b" id="r_a8d653f310491c5eeea8199df41a8506b"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a8d653f310491c5eeea8199df41a8506b">BBW_POINT_COLOR</a> [4] = {239./255.,213./255.,46./255.,255.0/255.0}</td></tr>
<tr class="separator:a8d653f310491c5eeea8199df41a8506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a441cf01da7bb4f7455fa87831cc862" id="r_a2a441cf01da7bb4f7455fa87831cc862"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a2a441cf01da7bb4f7455fa87831cc862">BBW_LINE_COLOR</a> [4] = {106./255.,106./255.,255./255.,255./255.}</td></tr>
<tr class="separator:a2a441cf01da7bb4f7455fa87831cc862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3443568d1ef02dea80982a3df4bbfec1" id="r_a3443568d1ef02dea80982a3df4bbfec1"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3443568d1ef02dea80982a3df4bbfec1">MIDNIGHT_BLUE_DIFFUSE</a> [4] = { 21.0f/255.0f, 27.0f/255.0f, 84.0f/255.0f, 1.0f}</td></tr>
<tr class="separator:a3443568d1ef02dea80982a3df4bbfec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c277b6c43132159685619ae7e56d38" id="r_aa9c277b6c43132159685619ae7e56d38"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aa9c277b6c43132159685619ae7e56d38">EASTER_RED_DIFFUSE</a> [4] = {0.603922,0.494118f,0.603922f,1.0f}</td></tr>
<tr class="separator:aa9c277b6c43132159685619ae7e56d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16c584a27f3dcfaa597e5864861931f" id="r_af16c584a27f3dcfaa597e5864861931f"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af16c584a27f3dcfaa597e5864861931f">WN_OPEN_BOUNDARY_COLOR</a> [4] = {154./255.,0./255.,0./255.,1.0f}</td></tr>
<tr class="separator:af16c584a27f3dcfaa597e5864861931f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147760067e19822d9de2d3386c607b6e" id="r_a147760067e19822d9de2d3386c607b6e"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a147760067e19822d9de2d3386c607b6e">WN_NON_MANIFOLD_EDGE_COLOR</a> [4] = {201./255., 51./255.,255./255.,1.0f}</td></tr>
<tr class="separator:a147760067e19822d9de2d3386c607b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417e9fcd5135f9dfc60524331328b9d8" id="r_a417e9fcd5135f9dfc60524331328b9d8"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a417e9fcd5135f9dfc60524331328b9d8">CHAR_ONE</a> = 1</td></tr>
<tr class="memdesc:a417e9fcd5135f9dfc60524331328b9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Often one needs a reference to a dummy variable containing one as its value, for example when using AntTweakBar's TwSetParam( "3D View", "opened", TW_PARAM_INT32, 1, &amp;INT_ONE);.  <br /></td></tr>
<tr class="separator:a417e9fcd5135f9dfc60524331328b9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bf1ec6ed30256c1043772e67394b33" id="r_a13bf1ec6ed30256c1043772e67394b33"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a13bf1ec6ed30256c1043772e67394b33">INT_ONE</a> = 1</td></tr>
<tr class="separator:a13bf1ec6ed30256c1043772e67394b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57884543ce9ab8f3b3b1f9ffbef9a977" id="r_a57884543ce9ab8f3b3b1f9ffbef9a977"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a57884543ce9ab8f3b3b1f9ffbef9a977">UNSIGNED_INT_ONE</a> = 1</td></tr>
<tr class="separator:a57884543ce9ab8f3b3b1f9ffbef9a977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b4ffb0ea045dc3cd8a516ba072090" id="r_ad63b4ffb0ea045dc3cd8a516ba072090"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad63b4ffb0ea045dc3cd8a516ba072090">DOUBLE_ONE</a> = 1</td></tr>
<tr class="separator:ad63b4ffb0ea045dc3cd8a516ba072090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ed44be1be4ade1ba7a4e7b382085db" id="r_af7ed44be1be4ade1ba7a4e7b382085db"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af7ed44be1be4ade1ba7a4e7b382085db">FLOAT_ONE</a> = 1</td></tr>
<tr class="separator:af7ed44be1be4ade1ba7a4e7b382085db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c65fcb2a063b19e572a9d982b5dcdc" id="r_af3c65fcb2a063b19e572a9d982b5dcdc"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af3c65fcb2a063b19e572a9d982b5dcdc">PI</a> = 3.1415926535897932384626433832795</td></tr>
<tr class="memdesc:af3c65fcb2a063b19e572a9d982b5dcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">π  <br /></td></tr>
<tr class="separator:af3c65fcb2a063b19e572a9d982b5dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d712ab3a824b8712b6f228dc8242cf" id="r_a89d712ab3a824b8712b6f228dc8242cf"><td class="memItemLeft" align="right" valign="top">const char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a89d712ab3a824b8712b6f228dc8242cf">CHAR_ZERO</a> = 0</td></tr>
<tr class="separator:a89d712ab3a824b8712b6f228dc8242cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26002c6ec8c14b1b4a7acc5db59b1e4" id="r_ad26002c6ec8c14b1b4a7acc5db59b1e4"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#ad26002c6ec8c14b1b4a7acc5db59b1e4">INT_ZERO</a> = 0</td></tr>
<tr class="separator:ad26002c6ec8c14b1b4a7acc5db59b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d956292d4f64a8ce6b1e1d92a9f9d24" id="r_a3d956292d4f64a8ce6b1e1d92a9f9d24"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#a3d956292d4f64a8ce6b1e1d92a9f9d24">UNSIGNED_INT_ZERO</a> = 0</td></tr>
<tr class="separator:a3d956292d4f64a8ce6b1e1d92a9f9d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cef568dc365b5b596341a5b7f06867" id="r_af1cef568dc365b5b596341a5b7f06867"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#af1cef568dc365b5b596341a5b7f06867">DOUBLE_ZERO</a> = 0</td></tr>
<tr class="separator:af1cef568dc365b5b596341a5b7f06867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3a0ea947dabbe9fc09e7e8da909613" id="r_aec3a0ea947dabbe9fc09e7e8da909613"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl.html#aec3a0ea947dabbe9fc09e7e8da909613">FLOAT_ZERO</a> = 0</td></tr>
<tr class="separator:aec3a0ea947dabbe9fc09e7e8da909613"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="af967096efcc39e806f0c2b374e2ccc5f" name="af967096efcc39e806f0c2b374e2ccc5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af967096efcc39e806f0c2b374e2ccc5f">&#9670;&#160;</a></span>decimate_cost_and_placement_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">igl::decimate_cost_and_placement_callback</a> = typedef std::function&lt;void( const int , const Eigen::MatrixXd &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , double &amp; , Eigen::RowVectorXd &amp; )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function handle used to control the cost of each edge collapse in <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>. </p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of edge to be collapsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions, lesser index of E(e,:) will be set to midpoint of edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost</td><td>cost of collapsing edge e </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>placement of merged vertex resulting from collapse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64c8b006ed52af02a20d1664722a94b3" name="a64c8b006ed52af02a20d1664722a94b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c8b006ed52af02a20d1664722a94b3">&#9670;&#160;</a></span>decimate_stopping_condition_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">igl::decimate_stopping_condition_callback</a> = typedef std::function&lt;bool( const Eigen::MatrixXd &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt;double,int,int&gt; &gt; &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXd &amp; , const int , const int , const int , const int , const int )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function handle used to control whether the queue processing in <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a> should stop. </p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions, lesser index of E(e,:) will be set to midpoint of edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "
    e=(j-&gt;i)
@param [in] EI  #E by 2 list of edge flap corners (see above).
@param [in] Q  queue containing pairs of costs and edge indices and insertion "time"
@param [in] EQ  #E list of "time" of last time pushed into Q </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#E by dim list of stored placements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of attempted collapsed edge. Set to -1 if Q is empty or contains only infinite cost edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e1</td><td>index into E of edge collpased on left. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e2</td><td>index into E of edge collpased on right. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>index into F of face collpased on left. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>index into F of face collpased on right. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether to stop </dd></dl>

</div>
</div>
<a id="af695d0b4a424387592b06f466a86088e" name="af695d0b4a424387592b06f466a86088e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af695d0b4a424387592b06f466a86088e">&#9670;&#160;</a></span>decimate_pre_collapse_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">igl::decimate_pre_collapse_callback</a> = typedef std::function&lt;bool( const Eigen::MatrixXd &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt;double,int,int&gt; &gt; &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXd &amp; , const int )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function handle called just before <code>collapse_edge</code> is attempted. </p>
<p>If this function returns false then the collapse is aborted.</p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions, lesser index of E(e,:) will be set to midpoint of edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>queue containing pairs of costs and edge indices and insertion "time" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EQ</td><td>#E list of "time" of last time pushed into Q </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#E by dim list of stored placements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of attempted collapsed edge. Set to -1 if Q is empty or contains only infinite cost edges. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if collapse should be carried out </dd></dl>

</div>
</div>
<a id="a16fd55ae4f3085d4ed4d3c6bff008426" name="a16fd55ae4f3085d4ed4d3c6bff008426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16fd55ae4f3085d4ed4d3c6bff008426">&#9670;&#160;</a></span>decimate_post_collapse_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">igl::decimate_post_collapse_callback</a> = typedef std::function&lt;void( const Eigen::MatrixXd &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXi &amp; , const Eigen::MatrixXi &amp; , const <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt;double,int,int&gt; &gt; &amp; , const Eigen::VectorXi &amp; , const Eigen::MatrixXd &amp; , const int , const int , const int , const int , const int , const bool )&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function handle called just after <code>collapse_edge</code> is attempted. </p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions, lesser index of E(e,:) will be set to midpoint of edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>queue containing pairs of costs and edge indices and insertion "time" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EQ</td><td>#E list of "time" of last time pushed into Q </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#E by dim list of stored placements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of attempted collapsed edge. Set to -1 if Q is empty or contains only infinite cost edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e1</td><td>index into E of edge collpased on left. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e2</td><td>index into E of edge collpased on right. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>index into F of face collpased on left. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>index into F of face collpased on right. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">collapsed</td><td>whether collapse actual took place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60bbc303acee156af52ab587c4680502" name="a60bbc303acee156af52ab587c4680502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bbc303acee156af52ab587c4680502">&#9670;&#160;</a></span>DEFAULT_URBG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#a60bbc303acee156af52ab587c4680502">igl::DEFAULT_URBG</a> = typedef std::mt19937</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd3e0aca98df4cd1576aecb262342dbf" name="acd3e0aca98df4cd1576aecb262342dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd3e0aca98df4cd1576aecb262342dbf">&#9670;&#160;</a></span>min_heap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a> = typedef std::priority_queue&lt; T, std::vector&lt;T &gt;, std::greater&lt;T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Templated min heap (reverses sort order of std::priority_queue) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2b7710824b3b35bfcda5dd2d5c723f5" name="af2b7710824b3b35bfcda5dd2d5c723f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b7710824b3b35bfcda5dd2d5c723f5">&#9670;&#160;</a></span>shapeup_projection_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl.html#af2b7710824b3b35bfcda5dd2d5c723f5">igl::shapeup_projection_function</a> = typedef std::function&lt; bool( const Eigen::PlainObjectBase&lt;Eigen::MatrixXd&gt;&amp;, const Eigen::PlainObjectBase&lt;Eigen::VectorXi&gt;&amp;, const Eigen::PlainObjectBase&lt;Eigen::MatrixXi&gt;&amp;, Eigen::PlainObjectBase&lt;Eigen::MatrixXd&gt;&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Every function here defines a local projection for ShapeUp, and must have the following structure to qualify: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 set of points, either the initial solution, or from previous iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SC</td><td>#Set by 1 cardinalities of sets in S </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#Sets by max(SC) independent sets where the local projection applies. Values beyond column SC(i)-1 in row S(i,:) are "don't care" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projP</td><td>#S by 3*max(SC) in format xyzxyzxyz, where the projected points correspond to each set in S in the same order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value appears to be ignored</dd></dl>
<p><a class="el" href="shapeup_8h.html">include/igl/shapeup.h</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afcbc9001656cf2d4cc135602618c97e5" name="afcbc9001656cf2d4cc135602618c97e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbc9001656cf2d4cc135602618c97e5">&#9670;&#160;</a></span>ARAPEnergyType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">igl::ARAPEnergyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum for choosing ARAP energy type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afcbc9001656cf2d4cc135602618c97e5a97e873f2663a9aceb16484fb07de5ff5" name="afcbc9001656cf2d4cc135602618c97e5a97e873f2663a9aceb16484fb07de5ff5"></a>ARAP_ENERGY_TYPE_SPOKES&#160;</td><td class="fielddoc"><p>"As-rigid-as-possible Surface Modeling" by [Sorkine and Alexa 2007], rotations defined at vertices affecting incident edges, default </p>
</td></tr>
<tr><td class="fieldname"><a id="afcbc9001656cf2d4cc135602618c97e5a5f5f83bb36e2e299284c9a95ed2ff961" name="afcbc9001656cf2d4cc135602618c97e5a5f5f83bb36e2e299284c9a95ed2ff961"></a>ARAP_ENERGY_TYPE_SPOKES_AND_RIMS&#160;</td><td class="fielddoc"><p>Adapted version of "As-rigid-as-possible Surface Modeling" by [Sorkine and Alexa 2007] presented in section 4.2 of or "A simple geometric model
    for elastic deformation" by [Chao et al. 2010], rotations defined at vertices affecting incident edges and opposite edges. </p>
</td></tr>
<tr><td class="fieldname"><a id="afcbc9001656cf2d4cc135602618c97e5af2f155e8dfb975ad92b08f029e49a150" name="afcbc9001656cf2d4cc135602618c97e5af2f155e8dfb975ad92b08f029e49a150"></a>ARAP_ENERGY_TYPE_ELEMENTS&#160;</td><td class="fielddoc"><p>"A local-global approach to mesh parameterization" by [Liu et al. 2010] or "A simple geometric model for elastic deformation" by [Chao et al. 2010], rotations defined at elements (triangles or tets) <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="afcbc9001656cf2d4cc135602618c97e5a0ab35acc294ac22e4f4d125fce81bb2e" name="afcbc9001656cf2d4cc135602618c97e5a0ab35acc294ac22e4f4d125fce81bb2e"></a>ARAP_ENERGY_TYPE_DEFAULT&#160;</td><td class="fielddoc"><p>Choose one automatically: spokes and rims for surfaces, elements for planar meshes and tets (not fully supported) </p>
</td></tr>
<tr><td class="fieldname"><a id="afcbc9001656cf2d4cc135602618c97e5a9a04adfc9ec2f8a964e26ee1e79e192d" name="afcbc9001656cf2d4cc135602618c97e5a9a04adfc9ec2f8a964e26ee1e79e192d"></a>NUM_ARAP_ENERGY_TYPES&#160;</td><td class="fielddoc"><p>Total number of types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1b823cd12b22dd7d7c16b36223e68dea" name="a1b823cd12b22dd7d7c16b36223e68dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b823cd12b22dd7d7c16b36223e68dea">&#9670;&#160;</a></span>ColorMapType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">igl::ColorMapType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaa6825c15830b7858ad1cae2b2ca8fdf04" name="a1b823cd12b22dd7d7c16b36223e68deaa6825c15830b7858ad1cae2b2ca8fdf04"></a>COLOR_MAP_TYPE_INFERNO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaab42bc8bb5154a66ce55adfc8a55ca23b" name="a1b823cd12b22dd7d7c16b36223e68deaab42bc8bb5154a66ce55adfc8a55ca23b"></a>COLOR_MAP_TYPE_JET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaa2f48b6200837d4a9504dc985d9555a43" name="a1b823cd12b22dd7d7c16b36223e68deaa2f48b6200837d4a9504dc985d9555a43"></a>COLOR_MAP_TYPE_MAGMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaa34771169730e68f97bd795796088a1bd" name="a1b823cd12b22dd7d7c16b36223e68deaa34771169730e68f97bd795796088a1bd"></a>COLOR_MAP_TYPE_PARULA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaa02ba4c2ca7ae86203e286cc7e7681be8" name="a1b823cd12b22dd7d7c16b36223e68deaa02ba4c2ca7ae86203e286cc7e7681be8"></a>COLOR_MAP_TYPE_PLASMA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaac0949b6bec17c57dae985f9945f0ba87" name="a1b823cd12b22dd7d7c16b36223e68deaac0949b6bec17c57dae985f9945f0ba87"></a>COLOR_MAP_TYPE_VIRIDIS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaa215964e6083ae591d01d8fc75696b7e4" name="a1b823cd12b22dd7d7c16b36223e68deaa215964e6083ae591d01d8fc75696b7e4"></a>COLOR_MAP_TYPE_TURBO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1b823cd12b22dd7d7c16b36223e68deaa6fe9ac780033d4a02584149c2079171f" name="a1b823cd12b22dd7d7c16b36223e68deaa6fe9ac780033d4a02584149c2079171f"></a>NUM_COLOR_MAP_TYPES&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a39bb96a0597986315dc20d78ba46a50d" name="a39bb96a0597986315dc20d78ba46a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bb96a0597986315dc20d78ba46a50d">&#9670;&#160;</a></span>EigsType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50d">igl::EigsType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of eigen values to extract. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39bb96a0597986315dc20d78ba46a50da2b8b23d6ed6bab31827ce232b5c4b753" name="a39bb96a0597986315dc20d78ba46a50da2b8b23d6ed6bab31827ce232b5c4b753"></a>EIGS_TYPE_SM&#160;</td><td class="fielddoc"><p>Smallest magnitude eigen values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39bb96a0597986315dc20d78ba46a50daea338bf4c5326fb6e1534be0d2d8c3ff" name="a39bb96a0597986315dc20d78ba46a50daea338bf4c5326fb6e1534be0d2d8c3ff"></a>EIGS_TYPE_LM&#160;</td><td class="fielddoc"><p>Largest magnitude eigen values. </p>
</td></tr>
<tr><td class="fieldname"><a id="a39bb96a0597986315dc20d78ba46a50dad803c6fe03f39ed4ef76376e6ba1d2c2" name="a39bb96a0597986315dc20d78ba46a50dad803c6fe03f39ed4ef76376e6ba1d2c2"></a>NUM_EIGS_TYPES&#160;</td><td class="fielddoc"><p>Total number of types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a85ec0330094fed10f10bb12010bbcdbf" name="a85ec0330094fed10f10bb12010bbcdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ec0330094fed10f10bb12010bbcdbf">&#9670;&#160;</a></span>FileEncoding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">igl::FileEncoding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>File encoding types for writing files. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85ec0330094fed10f10bb12010bbcdbfa6ce976e8f061b2b5cfe4d0c50c3405dd" name="a85ec0330094fed10f10bb12010bbcdbfa6ce976e8f061b2b5cfe4d0c50c3405dd"></a>Binary&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31" name="a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31"></a>Ascii&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a69c0d149c7cb41a263f858b695eeb988" name="a69c0d149c7cb41a263f858b695eeb988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c0d149c7cb41a263f858b695eeb988">&#9670;&#160;</a></span>BrushType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceigl.html#a69c0d149c7cb41a263f858b695eeb988">igl::BrushType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kelvinlets brush type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69c0d149c7cb41a263f858b695eeb988a8695c57e30e957161af26fe52d8a5826" name="a69c0d149c7cb41a263f858b695eeb988a8695c57e30e957161af26fe52d8a5826"></a>GRAB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a69c0d149c7cb41a263f858b695eeb988a127ea1d20becc4dba06d9d152db0c2e5" name="a69c0d149c7cb41a263f858b695eeb988a127ea1d20becc4dba06d9d152db0c2e5"></a>SCALE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a69c0d149c7cb41a263f858b695eeb988a7d503f3470adcef7d9b24cdfa82ea1c1" name="a69c0d149c7cb41a263f858b695eeb988a7d503f3470adcef7d9b24cdfa82ea1c1"></a>TWIST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a69c0d149c7cb41a263f858b695eeb988a1519953796ab374eeab96e42a849ed19" name="a69c0d149c7cb41a263f858b695eeb988a1519953796ab374eeab96e42a849ed19"></a>PINCH&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a79904ddf7fe8d79169b339cf43f9e739" name="a79904ddf7fe8d79169b339cf43f9e739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79904ddf7fe8d79169b339cf43f9e739">&#9670;&#160;</a></span>MappingEnergyType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">igl::MappingEnergyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Energy Types used for Parameterization/Mapping. </p>
<p>Refer to SLIM [Rabinovich et al. 2017] for more details </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739ad4c5e62ae2264ce291d4d66fa3603d72" name="a79904ddf7fe8d79169b339cf43f9e739ad4c5e62ae2264ce291d4d66fa3603d72"></a>ARAP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739ac7e97754f63944f8a1abcd0157df2c24" name="a79904ddf7fe8d79169b339cf43f9e739ac7e97754f63944f8a1abcd0157df2c24"></a>LOG_ARAP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739a4aaaa0e435526b23bf5f26cfbb5c03b9" name="a79904ddf7fe8d79169b339cf43f9e739a4aaaa0e435526b23bf5f26cfbb5c03b9"></a>SYMMETRIC_DIRICHLET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739a83bccae0282cd84b5ae8c0d260ae7243" name="a79904ddf7fe8d79169b339cf43f9e739a83bccae0282cd84b5ae8c0d260ae7243"></a>CONFORMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739a26c394b5336e61022324d35b9c070a9b" name="a79904ddf7fe8d79169b339cf43f9e739a26c394b5336e61022324d35b9c070a9b"></a>EXP_CONFORMAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739a265347b4667fbc30a911bb0be708072f" name="a79904ddf7fe8d79169b339cf43f9e739a265347b4667fbc30a911bb0be708072f"></a>EXP_SYMMETRIC_DIRICHLET&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a79904ddf7fe8d79169b339cf43f9e739abcbff3ae074247ae8998591317528163" name="a79904ddf7fe8d79169b339cf43f9e739abcbff3ae074247ae8998591317528163"></a>NUM_SLIM_ENERGY_TYPES&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8ed02513847d2f3fdb8c74dcbe55bb90" name="a8ed02513847d2f3fdb8c74dcbe55bb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ed02513847d2f3fdb8c74dcbe55bb90">&#9670;&#160;</a></span>MassMatrixType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">igl::MassMatrixType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of mass matrix. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8ed02513847d2f3fdb8c74dcbe55bb90ad236264764d4f478ccb31c36be553483" name="a8ed02513847d2f3fdb8c74dcbe55bb90ad236264764d4f478ccb31c36be553483"></a>MASSMATRIX_TYPE_BARYCENTRIC&#160;</td><td class="fielddoc"><p>Lumping area of each element to corner vertices in equal parts. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8ed02513847d2f3fdb8c74dcbe55bb90a8e91d83387a6cdc5e1c58d3249ed8484" name="a8ed02513847d2f3fdb8c74dcbe55bb90a8e91d83387a6cdc5e1c58d3249ed8484"></a>MASSMATRIX_TYPE_VORONOI&#160;</td><td class="fielddoc"><p>Lumping area by Voronoi dual area (clamped to be positive according to Meyer et al. </p>
<p>2003) </p>
</td></tr>
<tr><td class="fieldname"><a id="a8ed02513847d2f3fdb8c74dcbe55bb90aa3067b3f2630f50a9806bf46b60e6fb7" name="a8ed02513847d2f3fdb8c74dcbe55bb90aa3067b3f2630f50a9806bf46b60e6fb7"></a>MASSMATRIX_TYPE_FULL&#160;</td><td class="fielddoc"><p>Full (non-diagonal mass matrix) for piecewise linear functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8ed02513847d2f3fdb8c74dcbe55bb90a69f57abe461a4a62943a5c38cbbf22f0" name="a8ed02513847d2f3fdb8c74dcbe55bb90a69f57abe461a4a62943a5c38cbbf22f0"></a>MASSMATRIX_TYPE_DEFAULT&#160;</td><td class="fielddoc"><p>Use MASSMATRIX_TYPE_VORONOI for triangles and MASSMATRIX_TYPE_BARYCENTRIC for tetrahedra. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8ed02513847d2f3fdb8c74dcbe55bb90a90c5b05e42d20ca21fd5849e64bae2ae" name="a8ed02513847d2f3fdb8c74dcbe55bb90a90c5b05e42d20ca21fd5849e64bae2ae"></a>NUM_MASSMATRIX_TYPES&#160;</td><td class="fielddoc"><p>Total number of mass matrix types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a16cc7fd8778cd880be528227e0318b9f" name="a16cc7fd8778cd880be528227e0318b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cc7fd8778cd880be528227e0318b9f">&#9670;&#160;</a></span>MeshBooleanType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">igl::MeshBooleanType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Boolean operation types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056" name="a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056"></a>MESH_BOOLEAN_TYPE_UNION&#160;</td><td class="fielddoc"><p>A ∪ B. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34" name="a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34"></a>MESH_BOOLEAN_TYPE_INTERSECT&#160;</td><td class="fielddoc"><p>A ∩ B. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80" name="a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80"></a>MESH_BOOLEAN_TYPE_MINUS&#160;</td><td class="fielddoc"><p>A \ B. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b" name="a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b"></a>MESH_BOOLEAN_TYPE_XOR&#160;</td><td class="fielddoc"><p>A ⊕ B. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708" name="a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708"></a>MESH_BOOLEAN_TYPE_RESOLVE&#160;</td><td class="fielddoc"><p>Resolve intersections without removing any non-coplanar faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16cc7fd8778cd880be528227e0318b9fadbaeed658c3fa4c89de4dc951cb9cff9" name="a16cc7fd8778cd880be528227e0318b9fadbaeed658c3fa4c89de4dc951cb9cff9"></a>NUM_MESH_BOOLEAN_TYPES&#160;</td><td class="fielddoc"><p>Total number of Boolean options. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6483aa681000a106ae0973fc53b2d2e8" name="a6483aa681000a106ae0973fc53b2d2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6483aa681000a106ae0973fc53b2d2e8">&#9670;&#160;</a></span>NormalType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a6483aa681000a106ae0973fc53b2d2e8">igl::NormalType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of mesh normal computation method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6483aa681000a106ae0973fc53b2d2e8af907c6f40997626d2c36a67963c8431d" name="a6483aa681000a106ae0973fc53b2d2e8af907c6f40997626d2c36a67963c8431d"></a>PER_VERTEX_NORMALS&#160;</td><td class="fielddoc"><p>Normals computed per vertex based on incident faces. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6483aa681000a106ae0973fc53b2d2e8a17cf07533db59fd90e513a7d89d40664" name="a6483aa681000a106ae0973fc53b2d2e8a17cf07533db59fd90e513a7d89d40664"></a>PER_FACE_NORMALS&#160;</td><td class="fielddoc"><p>Normals computed per face. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6483aa681000a106ae0973fc53b2d2e8a5c44ccab7f461834b6ecc16928196627" name="a6483aa681000a106ae0973fc53b2d2e8a5c44ccab7f461834b6ecc16928196627"></a>PER_CORNER_NORMALS&#160;</td><td class="fielddoc"><p>Normals computed per corner (aka wedge) based on incident faces without sharp edge. </p>
</td></tr>
</table>

</div>
</div>
<a id="a347183daf701cad3537c990f8ce0cf55" name="a347183daf701cad3537c990f8ce0cf55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347183daf701cad3537c990f8ce0cf55">&#9670;&#160;</a></span>PerEdgeNormalsWeightingType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">igl::PerEdgeNormalsWeightingType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighting schemes for per edge normals. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a347183daf701cad3537c990f8ce0cf55a832e9d6bd24abeb23b15bc815c888fe9" name="a347183daf701cad3537c990f8ce0cf55a832e9d6bd24abeb23b15bc815c888fe9"></a>PER_EDGE_NORMALS_WEIGHTING_TYPE_UNIFORM&#160;</td><td class="fielddoc"><p>Incident face normals have uniform influence on edge normal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a347183daf701cad3537c990f8ce0cf55a2822a9a485d6d667e1fc7eb6a9e3788c" name="a347183daf701cad3537c990f8ce0cf55a2822a9a485d6d667e1fc7eb6a9e3788c"></a>PER_EDGE_NORMALS_WEIGHTING_TYPE_AREA&#160;</td><td class="fielddoc"><p>Incident face normals are averaged weighted by area. </p>
</td></tr>
<tr><td class="fieldname"><a id="a347183daf701cad3537c990f8ce0cf55a545aa62c3fac5887f2a8a939af47395c" name="a347183daf701cad3537c990f8ce0cf55a545aa62c3fac5887f2a8a939af47395c"></a>PER_EDGE_NORMALS_WEIGHTING_TYPE_DEFAULT&#160;</td><td class="fielddoc"><p>Area weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a347183daf701cad3537c990f8ce0cf55a163eb96bb83248476c499a06d08c7630" name="a347183daf701cad3537c990f8ce0cf55a163eb96bb83248476c499a06d08c7630"></a>NUM_PER_EDGE_NORMALS_WEIGHTING_TYPE&#160;</td><td class="fielddoc"><p>Total number of weighting types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9bd1d9465ddaaed7691194b99b3b9f94" name="a9bd1d9465ddaaed7691194b99b3b9f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd1d9465ddaaed7691194b99b3b9f94">&#9670;&#160;</a></span>PerVertexNormalsWeightingType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">igl::PerVertexNormalsWeightingType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighting schemes for computing per-vertex normals. </p>
<dl class="section note"><dt>Note</dt><dd>It would be nice to support more or all of the methods here: "A comparison of algorithms for vertex normal computation" </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9bd1d9465ddaaed7691194b99b3b9f94a221b3f6444f4194512508cce2c89d605" name="a9bd1d9465ddaaed7691194b99b3b9f94a221b3f6444f4194512508cce2c89d605"></a>PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM&#160;</td><td class="fielddoc"><p>Incident face normals have uniform influence on vertex normal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9bd1d9465ddaaed7691194b99b3b9f94a6f6afda8e7e65ddb0214f4bf4fe9d714" name="a9bd1d9465ddaaed7691194b99b3b9f94a6f6afda8e7e65ddb0214f4bf4fe9d714"></a>PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA&#160;</td><td class="fielddoc"><p>Incident face normals are averaged weighted by area. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9bd1d9465ddaaed7691194b99b3b9f94a3929a73f6d85de3ab2e7f61c4c569f8d" name="a9bd1d9465ddaaed7691194b99b3b9f94a3929a73f6d85de3ab2e7f61c4c569f8d"></a>PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE&#160;</td><td class="fielddoc"><p>Incident face normals are averaged weighted by incident angle of vertex. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9bd1d9465ddaaed7691194b99b3b9f94a8384f77b5ce9bc68e6ed0c9dac5520f8" name="a9bd1d9465ddaaed7691194b99b3b9f94a8384f77b5ce9bc68e6ed0c9dac5520f8"></a>PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT&#160;</td><td class="fielddoc"><p>Area weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9bd1d9465ddaaed7691194b99b3b9f94ae39893168b9c7f1fb96cbe18aabcaf90" name="a9bd1d9465ddaaed7691194b99b3b9f94ae39893168b9c7f1fb96cbe18aabcaf90"></a>NUM_PER_VERTEX_NORMALS_WEIGHTING_TYPE&#160;</td><td class="fielddoc"><p>Total number of weighting types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a92ae0e8cefa226a1e493b33684b0b02e" name="a92ae0e8cefa226a1e493b33684b0b02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ae0e8cefa226a1e493b33684b0b02e">&#9670;&#160;</a></span>SignedDistanceType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">igl::SignedDistanceType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of signing a distance field. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a92ae0e8cefa226a1e493b33684b0b02eac0557ab91e577c1b1f918891b6b3a9ce" name="a92ae0e8cefa226a1e493b33684b0b02eac0557ab91e577c1b1f918891b6b3a9ce"></a>SIGNED_DISTANCE_TYPE_PSEUDONORMAL&#160;</td><td class="fielddoc"><p>Use fast pseudo-normal test [Bærentzen &amp; Aanæs 2005]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a92ae0e8cefa226a1e493b33684b0b02ea2d092ad20bad8b2e4d6b015e0f64d5c8" name="a92ae0e8cefa226a1e493b33684b0b02ea2d092ad20bad8b2e4d6b015e0f64d5c8"></a>SIGNED_DISTANCE_TYPE_WINDING_NUMBER&#160;</td><td class="fielddoc"><p>Use winding number [Jacobson, Kavan Sorking-Hornug 2013]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a92ae0e8cefa226a1e493b33684b0b02ea53947827c1a799002057e5dc4ffe3a6e" name="a92ae0e8cefa226a1e493b33684b0b02ea53947827c1a799002057e5dc4ffe3a6e"></a>SIGNED_DISTANCE_TYPE_DEFAULT&#160;</td><td class="fielddoc"><p>Default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a92ae0e8cefa226a1e493b33684b0b02ea3455ee3fba0a6898acccb895b94003ae" name="a92ae0e8cefa226a1e493b33684b0b02ea3455ee3fba0a6898acccb895b94003ae"></a>SIGNED_DISTANCE_TYPE_UNSIGNED&#160;</td><td class="fielddoc"><p>Unsigned (absolute value) </p>
</td></tr>
<tr><td class="fieldname"><a id="a92ae0e8cefa226a1e493b33684b0b02ea840c3ff04b4ec159043f1c6168ad383d" name="a92ae0e8cefa226a1e493b33684b0b02ea840c3ff04b4ec159043f1c6168ad383d"></a>SIGNED_DISTANCE_TYPE_FAST_WINDING_NUMBER&#160;</td><td class="fielddoc"><p>Use Fast winding number [Barill, Dickson, Schmidt, Levin, Jacobson 2018]. </p>
</td></tr>
<tr><td class="fieldname"><a id="a92ae0e8cefa226a1e493b33684b0b02ea5ba484850e00fd63057bf36e540ffe57" name="a92ae0e8cefa226a1e493b33684b0b02ea5ba484850e00fd63057bf36e540ffe57"></a>NUM_SIGNED_DISTANCE_TYPE&#160;</td><td class="fielddoc"><p>Total number of signed distance types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9b754bfef0dda338efc49cbf1fb6cfc2" name="a9b754bfef0dda338efc49cbf1fb6cfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b754bfef0dda338efc49cbf1fb6cfc2">&#9670;&#160;</a></span>SolverStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2">igl::SolverStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solver status type used by min_quad_with_fixed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9b754bfef0dda338efc49cbf1fb6cfc2aefd03ba8a40ae92dd30b9608543d723a" name="a9b754bfef0dda338efc49cbf1fb6cfc2aefd03ba8a40ae92dd30b9608543d723a"></a>SOLVER_STATUS_CONVERGED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b754bfef0dda338efc49cbf1fb6cfc2a59f8eece563fe4ae6e55c2363f349322" name="a9b754bfef0dda338efc49cbf1fb6cfc2a59f8eece563fe4ae6e55c2363f349322"></a>SOLVER_STATUS_MAX_ITER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b754bfef0dda338efc49cbf1fb6cfc2aea9aaec839ab7074d95b32649f9a7ccc" name="a9b754bfef0dda338efc49cbf1fb6cfc2aea9aaec839ab7074d95b32649f9a7ccc"></a>SOLVER_STATUS_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b754bfef0dda338efc49cbf1fb6cfc2aea329543d3b14ae5d7df63289014df41" name="a9b754bfef0dda338efc49cbf1fb6cfc2aea329543d3b14ae5d7df63289014df41"></a>NUM_SOLVER_STATUSES&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac3bae8c76c2714f3cce8b651ae93fae2" name="ac3bae8c76c2714f3cce8b651ae93fae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bae8c76c2714f3cce8b651ae93fae2">&#9670;&#160;</a></span>TetrahedralizedGripType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">igl::TetrahedralizedGripType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of tetrahedralizations of a cubical cell. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac3bae8c76c2714f3cce8b651ae93fae2a6c9f3915cd235c5f5d9ec1f849c4f45a" name="ac3bae8c76c2714f3cce8b651ae93fae2a6c9f3915cd235c5f5d9ec1f849c4f45a"></a>TETRAHEDRALIZED_GRID_TYPE_5&#160;</td><td class="fielddoc"><p>1 cube → 5 tets </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3bae8c76c2714f3cce8b651ae93fae2a0f009090a25fab927bfc17ed8c95ccf7" name="ac3bae8c76c2714f3cce8b651ae93fae2a0f009090a25fab927bfc17ed8c95ccf7"></a>TETRAHEDRALIZED_GRID_TYPE_6_ROTATIONAL&#160;</td><td class="fielddoc"><p>1 cube → 6 tets with rotatonal symmetry </p>
</td></tr>
<tr><td class="fieldname"><a id="ac3bae8c76c2714f3cce8b651ae93fae2a4945d263c917ea6178567ad57cedddd6" name="ac3bae8c76c2714f3cce8b651ae93fae2a4945d263c917ea6178567ad57cedddd6"></a>NUM_TETRAHEDRALIZED_GRID_TYPE&#160;</td><td class="fielddoc"><p>Total number of tetrahedralization types. </p>
</td></tr>
</table>

</div>
</div>
<a id="a509f63ef3c5ff8b238920eb0fe3ceecf" name="a509f63ef3c5ff8b238920eb0fe3ceecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509f63ef3c5ff8b238920eb0fe3ceecf">&#9670;&#160;</a></span>WindingNumberMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl.html#a509f63ef3c5ff8b238920eb0fe3ceecf">igl::WindingNumberMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a509f63ef3c5ff8b238920eb0fe3ceecfaa10945b526da7066079013ebe7efa315" name="a509f63ef3c5ff8b238920eb0fe3ceecfaa10945b526da7066079013ebe7efa315"></a>EXACT_WINDING_NUMBER_METHOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a509f63ef3c5ff8b238920eb0fe3ceecfa0d9a88899ed0568e9ea92020c2202c90" name="a509f63ef3c5ff8b238920eb0fe3ceecfa0d9a88899ed0568e9ea92020c2202c90"></a>APPROX_SIMPLE_WINDING_NUMBER_METHOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a509f63ef3c5ff8b238920eb0fe3ceecfa8a0f3017839d2e66a55fabbd269bff19" name="a509f63ef3c5ff8b238920eb0fe3ceecfa8a0f3017839d2e66a55fabbd269bff19"></a>APPROX_CACHE_WINDING_NUMBER_METHOD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a509f63ef3c5ff8b238920eb0fe3ceecfa3d5ef75b451374bbaa7aecc358a66558" name="a509f63ef3c5ff8b238920eb0fe3ceecfa3d5ef75b451374bbaa7aecc358a66558"></a>NUM_WINDING_NUMBER_METHODS&#160;</td><td class="fielddoc"><p>Number of winding number methods. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a8012b0115ea55d7e1ef308d01a37d65c" name="a8012b0115ea55d7e1ef308d01a37d65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8012b0115ea55d7e1ef308d01a37d65c">&#9670;&#160;</a></span>accumarray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedV , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::accumarray </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate values in V using subscripts in S. </p>
<p>Like Matlab's accumarray.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#S list of subscripts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V list of values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>max(subs)+1 list of accumulated values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6380cf19be5242826791dfb3b26b113" name="aa6380cf19be5242826791dfb3b26b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6380cf19be5242826791dfb3b26b113">&#9670;&#160;</a></span>accumarray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::accumarray </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedA::Scalar&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accumulate constant value <code>V</code> using subscripts in S. </p>
<p>Like Matlab's accumarray.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#S list of subscripts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>single value used for all </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>max(subs)+1 list of accumulated values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebbfd2ea11fa90111a31666f48cc5f00" name="aebbfd2ea11fa90111a31666f48cc5f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbfd2ea11fa90111a31666f48cc5f00">&#9670;&#160;</a></span>active_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AT , typename DerivedB , typename Derivedknown , typename DerivedY , typename AeqT , typename DerivedBeq , typename AieqT , typename DerivedBieq , typename Derivedlx , typename Derivedux , typename DerivedZ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl.html#a9b754bfef0dda338efc49cbf1fb6cfc2">igl::SolverStatus</a> igl::active_set </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedknown &gt; &amp;&#160;</td>
          <td class="paramname"><em>known</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AeqT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedBeq &gt; &amp;&#160;</td>
          <td class="paramname"><em>Beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AieqT &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aieq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedBieq &gt; &amp;&#160;</td>
          <td class="paramname"><em>Bieq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedlx &gt; &amp;&#160;</td>
          <td class="paramname"><em>lx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedux &gt; &amp;&#160;</td>
          <td class="paramname"><em>ux</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1active__set__params.html">igl::active_set_params</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize convex quadratic energy subject to linear inequality constraints. </p>
<pre class="fragment">min ½ Zᵀ A Z + Zᵀ B + constant
 Z
subject to
       Aeq Z = Beq
       Aieq Z &lt;= Bieq
       lx &lt;= Z &lt;= ux
       Z(known) = Y
</pre><p> that Z(known) = Y, optionally also subject to the constraints Aeq*Z = Beq, and further optionally subject to the linear inequality constraints that Aieq*Z &lt;= Bieq and constant inequality constraints lx &lt;= x &lt;= ux</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>n by n matrix of quadratic coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>n by 1 column of linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known</td><td>list of indices to known rows in Z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>list of fixed values corresponding to known rows in Z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aeq</td><td>meq by n list of linear equality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Beq</td><td>meq by 1 list of linear equality constraint constant values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aieq</td><td>mieq by n list of linear inequality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Bieq</td><td>mieq by 1 list of linear inequality constraint constant values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lx</td><td>n by 1 list of lower bounds [] implies -Inf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ux</td><td>n by 1 list of upper bounds [] implies Inf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>struct of additional parameters (see below) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td>if not empty, is taken to be an n by 1 list of initial guess values. Set to solution on output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Benchmark: For a harmonic solve on a mesh with 325K facets, matlab 2.2 secs, <a class="el" href="min__quad__with__fixed_8h.html">igl/min_quad_with_fixed.h</a> 7.1 secs</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>rows of [Aeq;Aieq] <b>must</b> be linearly independent. Should be using QR decomposition otherwise: <a href="https://v8doc.sas.com/sashtml/ormp/chap5/sect32.htm">https://v8doc.sas.com/sashtml/ormp/chap5/sect32.htm</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This solver is fairly experimental. It works reasonably well for bbw problems but doesn't generalize well to other problems. NASOQ and OSQP are better general purpose solvers. </dd></dl>

</div>
</div>
<a id="a4c905c0e9124bb38a79769497fa9b48b" name="a4c905c0e9124bb38a79769497fa9b48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c905c0e9124bb38a79769497fa9b48b">&#9670;&#160;</a></span>adjacency_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename IndexVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::adjacency_list </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; IndexVector &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the graph adjacency list of a given mesh (V,F) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>vector&lt;vector&lt;T&gt; &gt; containing at row i the adjacent vertices of vertex i </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sorted</td><td>flag that indicates if the list should be sorted counter-clockwise. Input assumed to be manifold.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Mesh in (V,F)</span></div>
<div class="line">vector&lt;vector&lt;double&gt; &gt; A;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a4c905c0e9124bb38a79769497fa9b48b">adjacency_list</a>(F,A);</div>
<div class="ttc" id="anamespaceigl_html_a4c905c0e9124bb38a79769497fa9b48b"><div class="ttname"><a href="namespaceigl.html#a4c905c0e9124bb38a79769497fa9b48b">igl::adjacency_list</a></div><div class="ttdeci">void adjacency_list(const Eigen::MatrixBase&lt; Index &gt; &amp;F, std::vector&lt; std::vector&lt; IndexVector &gt; &gt; &amp;A, bool sorted=false)</div><div class="ttdoc">Constructs the graph adjacency list of a given mesh (V,F)</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735" title="Constructs the graph adjacency matrix of a given mesh (V,F)">adjacency_matrix</a> <a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee" title="Constructs a list of unique edges represented in a given mesh (V,F)">edges</a>, <a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a>, diag </dd></dl>

</div>
</div>
<a id="a3b938bdb46eece91f62ab35a1e152a61" name="a3b938bdb46eece91f62ab35a1e152a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b938bdb46eece91f62ab35a1e152a61">&#9670;&#160;</a></span>adjacency_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::adjacency_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the graph adjacency list of a given <em>polygon</em> mesh (V,F) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F list of polygon face index lists </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>vector&lt;vector&lt;T&gt; &gt; containing at row i the adjacent vertices of vertex i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a705a8f51137d1dd807bbe517c0567735" name="a705a8f51137d1dd807bbe517c0567735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705a8f51137d1dd807bbe517c0567735">&#9670;&#160;</a></span>adjacency_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::adjacency_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the graph adjacency matrix of a given mesh (V,F) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like <code>int</code> or <code>double</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh simplices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>max(F)+1 by max(F)+1 adjacency matrix, each row i corresponding to V(i,:)</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md1"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="comment">// Mesh in (V,F)</span></div>
<div class="line">Eigen::SparseMatrix&lt;double&gt; A;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735">adjacency_matrix</a>(F,A);</div>
<div class="line"><span class="comment">// sum each row </span></div>
<div class="line">SparseVector&lt;double&gt; Asum;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734">sum</a>(A,1,Asum);</div>
<div class="line"><span class="comment">// Convert row sums into diagonal of sparse matrix</span></div>
<div class="line">SparseMatrix&lt;double&gt; Adiag;</div>
<div class="line">diag(Asum,Adiag);</div>
<div class="line"><span class="comment">// Build uniform laplacian</span></div>
<div class="line">SparseMatrix&lt;double&gt; U;</div>
<div class="line">U = A-Adiag;</div>
<div class="ttc" id="anamespaceigl_html_a705a8f51137d1dd807bbe517c0567735"><div class="ttname"><a href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735">igl::adjacency_matrix</a></div><div class="ttdeci">void adjacency_matrix(const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::SparseMatrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Constructs the graph adjacency matrix of a given mesh (V,F)</div></div>
<div class="ttc" id="anamespaceigl_html_adf21bb95cf3e8474259c54e4a55ed734"><div class="ttname"><a href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734">igl::sum</a></div><div class="ttdeci">void sum(const Eigen::SparseMatrix&lt; T &gt; &amp;X, const int dim, Eigen::SparseVector&lt; T &gt; &amp;S)</div><div class="ttdoc">Sum the columns or rows of a sparse matrix.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee" title="Constructs a list of unique edges represented in a given mesh (V,F)">edges</a>, <a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a>, diag </dd></dl>

</div>
</div>
<a id="a9b6ba9089b88d1e5ba18a153462c750c" name="a9b6ba9089b88d1e5ba18a153462c750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6ba9089b88d1e5ba18a153462c750c">&#9670;&#160;</a></span>adjacency_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedI , typename DerivedC , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::adjacency_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an vertex adjacency for a polygon mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>max(I)+1 by max(I)+1 adjacency matrix, each row i corresponding to V(i,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf8bd73fedf2cafd491f61084874c2cc" name="abf8bd73fedf2cafd491f61084874c2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf8bd73fedf2cafd491f61084874c2cc">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::all </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether all values are logically true along a dimension. </p>
<dl class="section note"><dt>Note</dt><dd>For Dense matrices use: A.rowwise().<a class="el" href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc" title="Check whether all values are logically true along a dimension.">all()</a> or A.colwise().<a class="el" href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc" title="Check whether all values are logically true along a dimension.">all()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to check for all (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>n-long vector (if dim == 1) or m-long vector (if dim == 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad119e257b19a34797c3c9af92d7cc56b" name="ad119e257b19a34797c3c9af92d7cc56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad119e257b19a34797c3c9af92d7cc56b">&#9670;&#160;</a></span>all_pairs_distances()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::all_pairs_distances </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute distances between each point i in V and point j in U. </p>
<pre class="fragment">D = all_pairs_distances(V,U)
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">matrix</td><td>class like MatrixXd </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>#U by dim list of points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">squared</td><td>whether to return squared distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#V by #U matrix of distances, where D(i,j) gives the distance or squareed distance between V(i,:) and U(j,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc5e79a82d06f353e2cc7364bb63d6ec" name="acc5e79a82d06f353e2cc7364bb63d6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5e79a82d06f353e2cc7364bb63d6ec">&#9670;&#160;</a></span>ambient_occlusion() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ambient_occlusion </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>shoot_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ambient occlusion per given point using ray-mesh intersection function handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shoot_ray</td><td>function handle that outputs hits of a given ray against a mesh (embedded in function handles as captured variable/data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of origin normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>number of samples to use (e.g., 1000) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e5409ff272904057655baa541161f63" name="a8e5409ff272904057655baa541161f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5409ff272904057655baa541161f63">&#9670;&#160;</a></span>ambient_occlusion() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ambient_occlusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedV, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ambient occlusion per given point for mesh (V,F) with precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of origin normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>number of samples to use (e.g., 1000) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9892f183be30982954280fde853dd8f3" name="a9892f183be30982954280fde853dd8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9892f183be30982954280fde853dd8f3">&#9670;&#160;</a></span>ambient_occlusion() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ambient_occlusion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ambient occlusion per given point for mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of origin normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>number of samples to use (e.g., 1000) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2267549a29a1b490b0b2f56b6ec84ef6" name="a2267549a29a1b490b0b2f56b6ec84ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2267549a29a1b490b0b2f56b6ec84ef6">&#9670;&#160;</a></span>angular_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::angular_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaterniond &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaterniond &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The "angular distance" between two unit quaternions is the angle of the smallest rotation (treated as an Axis and Angle) that takes A to B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>unit quaternion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>unit quaternion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>angular distance </dd></dl>

</div>
</div>
<a id="a8b265abd1563e69c5b980e38f0eff3b9" name="a8b265abd1563e69c5b980e38f0eff3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b265abd1563e69c5b980e38f0eff3b9">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::any </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether any values are logically true along a dimension. </p>
<dl class="section note"><dt>Note</dt><dd>Dense matrices use: A.rowwise().<a class="el" href="namespaceigl.html#a8b265abd1563e69c5b980e38f0eff3b9" title="Check whether any values are logically true along a dimension.">any()</a> or A.colwise().<a class="el" href="namespaceigl.html#a8b265abd1563e69c5b980e38f0eff3b9" title="Check whether any values are logically true along a dimension.">any()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to check for any (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>n-long vector (if dim == 1) or m-long vector (if dim == 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48e5f486e14127dc6eb9013a7dc312bd" name="a48e5f486e14127dc6eb9013a7dc312bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e5f486e14127dc6eb9013a7dc312bd">&#9670;&#160;</a></span>arap_precomputation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedb &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::arap_precomputation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1ARAPData.html">ARAPData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute necessary information to start using an ARAP deformation using local-global solver as described in "As-rigid-as-possible surface
modeling" [Sorkine and Alexa 2007]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of triangle|tet indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b list of "boundary" fixed vertex indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>struct containing necessary precomputation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether initialization succeeded</dd></dl>
<p><a class="el" href="arap_8h.html">include/igl/arap.h</a> </p>

</div>
</div>
<a id="a62a45ef9782fe4b54d7487a8b3bb45e9" name="a62a45ef9782fe4b54d7487a8b3bb45e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a45ef9782fe4b54d7487a8b3bb45e9">&#9670;&#160;</a></span>arap_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedbc , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::arap_solve </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1ARAPData.html">ARAPData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conduct arap solve. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by dim list of boundary conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>struct containing necessary precomputation and parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">U</td><td>#V by dim initial guess</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="arap_8h.html">include/igl/arap.h</a></p>
<dl class="section note"><dt>Note</dt><dd>While the libigl guidelines require outputs to be of type PlainObjectBase so that the user does not need to worry about allocating memory for the output, in this case, the user is required to give an initial guess and hence fix the size of the problem domain. Taking a reference to MatrixBase in this case thus allows the user to provide e.g. a map to the position data, allowing seamless interoperability with user-defined datastructures without requiring a copy. </dd></dl>

</div>
</div>
<a id="a26233fdaaff7c535c5cf9e54d58f6f80" name="a26233fdaaff7c535c5cf9e54d58f6f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26233fdaaff7c535c5cf9e54d58f6f80">&#9670;&#160;</a></span>arap_dof_precomputation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LbsMatrixType , typename SSCALAR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::arap_dof_precomputation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LbsMatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a>&lt; LbsMatrixType, SSCALAR &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precomputes the system to optimize for "Fast Automatic Skinning
Transformations" [Jacobson et al. 2012] skinning degrees of freedom optimization using as-rigid-as-possible energy. </p>
<p>This consists of building constructor matrices (to compute covariance matrices from transformations and to build the poisson solve right hand side from rotation matrix entries) and also prefactoring the poisson system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by {3|4} list of face indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>#V * dim by #handles * dim * (dim+1) matrix such that new_V(:) = LBS(V,W,A) = reshape(M * A,size(V)), where A is a column vectors formed by the entries in each handle's dim by dim+1 transformation matrix. Specifcally, A = reshape(permute(Astack,[3 1 2]),n*dim*(dim+1),1) or A = [Lxx;Lyx;Lxy;Lyy;tx;ty], and likewise for other dim if Astack(:,:,i) is the dim by (dim+1) transformation at handle i handles are ordered according to P then BE (point handles before bone handles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td>#V list of group indices (1 to k) for each vertex, such that vertex i is assigned to group G(i) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>structure containing all necessary precomputation for calling arap_dof_update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#abf08b3e278ea284934baa0d3f6dc4975" title="Construct a matrix that when multiplied against a column of affine transformation entries computes ne...">lbs_matrix_column</a></dd></dl>
<p><a class="el" href="arap__dof_8h.html" title="&quot;Fast Automatic Skinning Transformations&quot; [Jacobson et al. 2012]">include/igl/arap_dof.h</a> </p>

</div>
</div>
<a id="acec31e2faca7eecae08c921a0430d0aa" name="acec31e2faca7eecae08c921a0430d0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec31e2faca7eecae08c921a0430d0aa">&#9670;&#160;</a></span>arap_dof_recomputation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LbsMatrixType , typename SSCALAR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::arap_dof_recomputation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>fixed_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a>&lt; LbsMatrixType, SSCALAR &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should always be called after arap_dof_precomputation, but may be called in between successive calls to arap_dof_update, recomputes precomputation given that there are only changes in free and fixed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fixed_dim</td><td>list of transformation element indices for fixed (or partailly fixed) handles: not necessarily the complement of 'free' NOTE: the constraints for fixed transformations still need to be present in A_eq </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_eq</td><td>dim*#constraint_points by m*dim*(dim+1) matrix of linear equality constraint coefficients. Each row corresponds to a linear constraint, so that A_eq * L = Beq says that the linear transformation entries in the column L should produce the user supplied positional constraints for each handle in Beq. The row A_eq(i*dim+d) corresponds to the constrain on coordinate d of position i </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>structure containing all necessary precomputation for calling arap_dof_update </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#abf08b3e278ea284934baa0d3f6dc4975" title="Construct a matrix that when multiplied against a column of affine transformation entries computes ne...">lbs_matrix_column</a></dd></dl>
<p><a class="el" href="arap__dof_8h.html" title="&quot;Fast Automatic Skinning Transformations&quot; [Jacobson et al. 2012]">include/igl/arap_dof.h</a> </p>

</div>
</div>
<a id="a31279c751ae3a7d24bc56dd4c8029d1e" name="a31279c751ae3a7d24bc56dd4c8029d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31279c751ae3a7d24bc56dd4c8029d1e">&#9670;&#160;</a></span>arap_dof_update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LbsMatrixType , typename SSCALAR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::arap_dof_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structigl_1_1ArapDOFData.html">ArapDOFData</a>&lt; LbsMatrixType, SSCALAR &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B_eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>L0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimizes the transformations attached to each weight function based on precomputed system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>precomputation data struct output from arap_dof_precomputation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Beq</td><td>dim*#constraint_points constraint values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L0</td><td>#handles * dim * dim+1 list of initial guess transformation entries, also holds fixed transformation entries for fixed handles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iters</td><td>maximum number of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>stopping criteria parameter. If variables (linear transformation matrix entries) change by less than 'tol' the optimization terminates, 0.75 (weak tolerance) 0.0 (extreme tolerance) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#handles * dim * dim+1 list of final optimized transformation entries, allowed to be the same as L</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="arap__dof_8h.html" title="&quot;Fast Automatic Skinning Transformations&quot; [Jacobson et al. 2012]">include/igl/arap_dof.h</a> </p>

</div>
</div>
<a id="ae1324ec871ee5fe0f3d6fa9b461ced93" name="ae1324ec871ee5fe0f3d6fa9b461ced93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1324ec871ee5fe0f3d6fa9b461ced93">&#9670;&#160;</a></span>arap_linear_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF , typename MatK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::arap_linear_block </td>
          <td>(</td>
          <td class="paramtype">const MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">igl::ARAPEnergyType</a>&#160;</td>
          <td class="paramname"><em>energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatK &amp;&#160;</td>
          <td class="paramname"><em>Kd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a block of the matrix which constructs the linear terms of a given arap energy. </p>
<p>When treating rotations as knowns (arranged in a column) then this constructs Kd of K such that the linear portion of the energy is as a column: </p><pre class="fragment">  K * R = [Kx Z  ... Ky Z  ... 
           Z  Kx ... Z  Ky ... 
           ... ]
</pre><p> These blocks are also used to build the "covariance scatter matrices". Here we want to build a scatter matrix that multiplies against positions (treated as known) producing covariance matrices to fit each rotation. Notice that in the case of the RHS of the poisson solve the rotations are known and the positions unknown, and vice versa for rotation fitting. These linear block just relate the rotations to the positions, linearly in each.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatV</td><td>vertex position matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">MatF</td><td>face index matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">Scalar</td><td>e.g. double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of initial domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by #simplex size list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>coordinate of linear constructor to build </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">energy</td><td>ARAPEnergyType enum value defining which energy is being used. See <a class="el" href="ARAPEnergyType_8h.html">ARAPEnergyType.h</a> for valid options and explanations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kd</td><td>#V by #V/#F block of the linear constructor matrix corresponding to coordinate d</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5" title="Enum for choosing ARAP energy type.">ARAPEnergyType</a> </dd></dl>

</div>
</div>
<a id="ad13e109be700043c1228c300bac31daf" name="ad13e109be700043c1228c300bac31daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13e109be700043c1228c300bac31daf">&#9670;&#160;</a></span>arap_linear_block_spokes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF , typename MatK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::arap_linear_block_spokes </td>
          <td>(</td>
          <td class="paramtype">const MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatK &amp;&#160;</td>
          <td class="paramname"><em>Kd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a block of the matrix which constructs the linear terms for spokes energy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatV</td><td>vertex position matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">MatF</td><td>face index matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">Scalar</td><td>e.g. double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of initial domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by #simplex size list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>coordinate of linear constructor to build (0 index) See <a class="el" href="ARAPEnergyType_8h.html">ARAPEnergyType.h</a> for valid options and explanations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kd</td><td>#V by #V block of the linear constructor matrix corresponding to coordinate d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7280d256cac58af8c0dceb1e0ab487ca" name="a7280d256cac58af8c0dceb1e0ab487ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7280d256cac58af8c0dceb1e0ab487ca">&#9670;&#160;</a></span>arap_linear_block_spokes_and_rims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF , typename MatK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::arap_linear_block_spokes_and_rims </td>
          <td>(</td>
          <td class="paramtype">const MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatK &amp;&#160;</td>
          <td class="paramname"><em>Kd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a block of the matrix which constructs the linear terms for spokes and rims energy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatV</td><td>vertex position matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">MatF</td><td>face index matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">Scalar</td><td>e.g. double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of initial domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by #simplex size list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>coordinate of linear constructor to build (0 index) See <a class="el" href="ARAPEnergyType_8h.html">ARAPEnergyType.h</a> for valid options and explanations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kd</td><td>#V by #V block of the linear constructor matrix corresponding to coordinate d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af81355594a143ab2601ce468536c0112" name="af81355594a143ab2601ce468536c0112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81355594a143ab2601ce468536c0112">&#9670;&#160;</a></span>arap_linear_block_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF , typename MatK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::arap_linear_block_elements </td>
          <td>(</td>
          <td class="paramtype">const MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatK &amp;&#160;</td>
          <td class="paramname"><em>Kd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a block of the matrix which constructs the linear terms for per element energy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatV</td><td>vertex position matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">MatF</td><td>face index matrix, e.g. Eigen::MatrixXd </td></tr>
    <tr><td class="paramname">Scalar</td><td>e.g. double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of initial domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by #simplex size list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>coordinate of linear constructor to build (0 index) See <a class="el" href="ARAPEnergyType_8h.html">ARAPEnergyType.h</a> for valid options and explanations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Kd</td><td>#V by #F block of the linear constructor matrix corresponding to coordinate d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02a8f8a4c016647d6f9c823ae3e32eaa" name="a02a8f8a4c016647d6f9c823ae3e32eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a8f8a4c016647d6f9c823ae3e32eaa">&#9670;&#160;</a></span>arap_rhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::arap_rhs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">igl::ARAPEnergyType</a>&#160;</td>
          <td class="paramname"><em>energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseCompressedBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Right-hand side constructor of global poisson solve for various Arap energies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by Vdim list of initial domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension being used at solve time. For deformation usually dim = V.cols(), for surface parameterization V.cols() = 3 and dim = 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">energy</td><td><a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5" title="Enum for choosing ARAP energy type.">igl::ARAPEnergyType</a> enum value defining which energy is being used. See igl::ARAPEnergyType.h for valid options and explanations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#V*dim by #(F|V)*dim*dim matrix such that: b = K * reshape(permute(R,[3 1 2]),size(V|F,1)*size(V,2)*size(V,2),1);</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ae1324ec871ee5fe0f3d6fa9b461ced93" title="Constructs a block of the matrix which constructs the linear terms of a given arap energy.">arap_linear_block</a> </dd></dl>

</div>
</div>
<a id="a2fde5a5b34007efccb521fd4f571f153" name="a2fde5a5b34007efccb521fd4f571f153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fde5a5b34007efccb521fd4f571f153">&#9670;&#160;</a></span>AtA_cached_precompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::AtA_cached_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1AtA__cached__data.html">AtA_cached_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>AtA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes At * W * A, where A is sparse and W is diagonal. </p>
<p>Divides the construction in two phases, one for fixing the sparsity pattern, and one to populate it with values. Compared to evaluating it directly, this version is slower for the first time (since it requires a precomputation), but faster to the subsequent evaluations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m x n sparse matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>stores the precomputed sparsity pattern, data.W contains the optional diagonal weights (stored as a dense vector). If W is not provided, it is replaced by the identity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AtA</td><td>m by m matrix computed as AtA * W * A</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md3"></a>
Example:</h4>
<div class="fragment"><div class="line">AtA_data = <a class="code hl_struct" href="structigl_1_1AtA__cached__data.html">igl::AtA_cached_data</a>();</div>
<div class="line">AtA_data.W = W;</div>
<div class="line"><span class="keywordflow">if</span> (s.AtA.rows() == 0)</div>
<div class="line">  <a class="code hl_function" href="namespaceigl.html#a2fde5a5b34007efccb521fd4f571f153">igl::AtA_cached_precompute</a>(s.A,s.AtA_data,s.AtA);</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">  <a class="code hl_function" href="namespaceigl.html#ac62e1e593efb31faa3ecb727695f3e53">igl::AtA_cached</a>(s.A,s.AtA_data,s.AtA);</div>
<div class="ttc" id="anamespaceigl_html_a2fde5a5b34007efccb521fd4f571f153"><div class="ttname"><a href="namespaceigl.html#a2fde5a5b34007efccb521fd4f571f153">igl::AtA_cached_precompute</a></div><div class="ttdeci">void AtA_cached_precompute(const Eigen::SparseMatrix&lt; Scalar &gt; &amp;A, AtA_cached_data &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;AtA)</div><div class="ttdoc">Computes At * W * A, where A is sparse and W is diagonal.</div></div>
<div class="ttc" id="anamespaceigl_html_ac62e1e593efb31faa3ecb727695f3e53"><div class="ttname"><a href="namespaceigl.html#ac62e1e593efb31faa3ecb727695f3e53">igl::AtA_cached</a></div><div class="ttdeci">void AtA_cached(const Eigen::SparseMatrix&lt; Scalar &gt; &amp;A, const AtA_cached_data &amp;data, Eigen::SparseMatrix&lt; Scalar &gt; &amp;AtA)</div><div class="ttdoc">Computes At * W * A, where A is sparse and W is diagonal precomputed into data.</div></div>
<div class="ttc" id="astructigl_1_1AtA__cached__data_html"><div class="ttname"><a href="structigl_1_1AtA__cached__data.html">igl::AtA_cached_data</a></div><div class="ttdoc">Hold precomputed data for AtA_cached.</div><div class="ttdef"><b>Definition</b> AtA_cached.h:18</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac62e1e593efb31faa3ecb727695f3e53" name="ac62e1e593efb31faa3ecb727695f3e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62e1e593efb31faa3ecb727695f3e53">&#9670;&#160;</a></span>AtA_cached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::AtA_cached </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1AtA__cached__data.html">AtA_cached_data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>AtA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes At * W * A, where A is sparse and W is diagonal precomputed into data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m x n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>stores the precomputed sparsity pattern, data.W contains the optional diagonal weights (stored as a dense vector). If W is not provided, it is replaced by the identity. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">AtA</td><td>m by m matrix computed as AtA * W * A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cb9891e472fd984b8e86dfc5b7a279c" name="a7cb9891e472fd984b8e86dfc5b7a279c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb9891e472fd984b8e86dfc5b7a279c">&#9670;&#160;</a></span>average_from_edges_onto_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DerivedoE , typename DeriveduE , typename DeriveduV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::average_from_edges_onto_vertices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduV &gt; &amp;&#160;</td>
          <td class="paramname"><em>uV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a scalar field defined on edges to vertices by averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 triangle mesh connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 3 mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#E by 3 orientation as generated by orient_halfedges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#E by 1 list of scalars </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uV</td><td>#V by 1 list of scalar defined on vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ae76f879f4715d4a8596d28f12bc7161d" title="Orients halfedges for a triangle mesh, assigning them to a unique edge.">orient_halfedges</a> </dd></dl>

</div>
</div>
<a id="ac457ea2c4e31fec1d7a3855fefb0260d" name="ac457ea2c4e31fec1d7a3855fefb0260d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac457ea2c4e31fec1d7a3855fefb0260d">&#9670;&#160;</a></span>average_onto_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedS , typename DerivedSF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::average_onto_faces </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a scalar field defined on vertices to faces by averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by ss list of simples/faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#V by dim list of per-vertex values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SF</td><td>#F by dim list of per-face values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac14f50dc6ec911af71c62d6c187fe3c2" name="ac14f50dc6ec911af71c62d6c187fe3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14f50dc6ec911af71c62d6c187fe3c2">&#9670;&#160;</a></span>average_onto_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedSV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::average_onto_vertices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move a scalar field defined on faces to vertices by averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#F by 1 scalar field defined on faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SV</td><td>#V by 1 scalar field defined on vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fc598da20b66905a5f3edb6f985cfb1" name="a2fc598da20b66905a5f3edb6f985cfb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc598da20b66905a5f3edb6f985cfb1">&#9670;&#160;</a></span>avg_edge_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double igl::avg_edge_length </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average edge length for the given triangle mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived from vertex positions matrix type: i.e. MatrixXd </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived from face indices matrix type: i.e. MatrixXi </td></tr>
    <tr><td class="paramname">DerivedL</td><td>derived from edge lengths matrix type: i.e. MatrixXd </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of mesh faces (must be simplex) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>average edge length</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735" title="Constructs the graph adjacency matrix of a given mesh (V,F)">adjacency_matrix</a> </dd></dl>

</div>
</div>
<a id="af6bab06e3533fb4130d508453175889f" name="af6bab06e3533fb4130d508453175889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6bab06e3533fb4130d508453175889f">&#9670;&#160;</a></span>axis_angle_to_quat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::axis_angle_to_quat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert axis angle representation of a rotation to a quaternion. </p>
<p>A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w),</p>
<p>such that q = x*i + y*j + z*k + w </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>3d vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>pointer to new quaternion</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a952c606ce07c40eb966cd5e55874f92d" name="a952c606ce07c40eb966cd5e55874f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952c606ce07c40eb966cd5e55874f92d">&#9670;&#160;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedBC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::barycenter </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBC &gt; &amp;&#160;</td>
          <td class="paramname"><em>BC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the barycenter of every simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x dim matrix of vertex coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x simplex_size matrix of indices of simplex corners into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BC</td><td>#F x dim matrix of 3d vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4b111b83aabbda680af965294681b5b" name="ad4b111b83aabbda680af965294681b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b111b83aabbda680af965294681b5b">&#9670;&#160;</a></span>barycentric_coordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::barycentric_coordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute barycentric coordinates of each point in a corresponding tetrahedron. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 Query points in 3d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#P by 3 Tet corners in 3d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#P by 3 Tet corners in 3d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#P by 3 Tet corners in 3d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>#P by 3 Tet corners in 3d </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#P by 4 list of barycentric coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a603159f2a82b981f00ca10be97d62e" name="a8a603159f2a82b981f00ca10be97d62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a603159f2a82b981f00ca10be97d62e">&#9670;&#160;</a></span>barycentric_coordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::barycentric_coordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute barycentric coordinates in a triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by dim Query points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#P by dim Triangle corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#P by dim Triangle corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#P by dim Triangle corners </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#P by 3 list of barycentric coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2d34543d4673ecc638e11d0340f7c38" name="ac2d34543d4673ecc638e11d0340f7c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d34543d4673ecc638e11d0340f7c38">&#9670;&#160;</a></span>barycentric_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedD , typename DerivedF , typename DerivedB , typename DerivedI , typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::barycentric_interpolation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data on a triangle mesh using barycentric coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>#D by dim list of per-vertex data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#X by 3 list of barycentric corodinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#X list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>#X by dim list of interpolated data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa32f08d2b80c8d69515001b7d6347e82" name="aa32f08d2b80c8d69515001b7d6347e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32f08d2b80c8d69515001b7d6347e82">&#9670;&#160;</a></span>basename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::basename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract basename of file path (like PHP's basename). </p>
<p>E.g., /etc/sudoers.d → sudoers.d</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>string containing input path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing basename (see php's basename)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#aef1ff1d390be65861384b6ff764ebe09" title="Function like PHP&#39;s dirname: /etc/passwd --&gt; /etc,.">dirname</a>, <a class="el" href="namespaceigl.html#a541dccb34e02684e3d43966fca86bdaf" title="Function like PHP&#39;s pathinfo to return information about path.">pathinfo</a> </dd></dl>

</div>
</div>
<a id="a33e3dc749c63b65a87635a309d322e9c" name="a33e3dc749c63b65a87635a309d322e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e3dc749c63b65a87635a309d322e9c">&#9670;&#160;</a></span>bbw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedEle , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::bbw </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedEle &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classigl_1_1BBWData.html">BBWData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Bounded Biharmonic Weights on a given domain (V,Ele) with a given set of boundary conditions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived type of eigen matrix for V (e.g. MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived type of eigen matrix for F (e.g. MatrixXi) </td></tr>
    <tr><td class="paramname">Derivedb</td><td>derived type of eigen matrix for b (e.g. VectorXi) </td></tr>
    <tr><td class="paramname">Derivedbc</td><td>derived type of eigen matrix for bc (e.g. MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedW</td><td>derived type of eigen matrix for W (e.g. MatrixXd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ele</td><td>#Elements by simplex-size list of element indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b boundary indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by #W list of boundary values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>object containing options, initial guess --&gt; solution and results </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by #W list of <em>unnormalized</em> weights to normalize use igl::normalize_row_sums(W,W); </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a id="ae5227bd6077c6a709c20789e5c0d70cd" name="ae5227bd6077c6a709c20789e5c0d70cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5227bd6077c6a709c20789e5c0d70cd">&#9670;&#160;</a></span>bezier() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bezier </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial Bezier Curve at single parameter value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of Bezier control points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>evaluation parameter within [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>1 by dim output point <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0860a64b8a1678d63bea76c8b1999c78" name="a0860a64b8a1678d63bea76c8b1999c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0860a64b8a1678d63bea76c8b1999c78">&#9670;&#160;</a></span>bezier() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bezier </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial Bezier Curve at many parameter values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of Bezier control points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T evaluation parameters within [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#T by dim output points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4be736f827b4ba341d4b2cb40f21f844" name="a4be736f827b4ba341d4b2cb40f21f844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be736f827b4ba341d4b2cb40f21f844">&#9670;&#160;</a></span>bezier() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VMat , typename DerivedT , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bezier </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; VMat &gt; &amp;&#160;</td>
          <td class="paramname"><em>spline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a polynomial Bezier spline with a fixed parameter set for each sub-curve. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VMat</td><td>type of matrix of each list of control points </td></tr>
    <tr><td class="paramname">DerivedT</td><td>Derived type of evaluation parameters </td></tr>
    <tr><td class="paramname">DerivedP</td><td>Derived type of output points </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">spline</td><td>#curves list of lists of Bezier control points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T evaluation parameters within [0,1] to use for each spline </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#curves*#T by dim output points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b1dcc1386b54083fe6a2b70c7b7225" name="a75b1dcc1386b54083fe6a2b70c7b7225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1dcc1386b54083fe6a2b70c7b7225">&#9670;&#160;</a></span>bfs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedD , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bfs </td>
          <td>(</td>
          <td class="paramtype">const AType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse a <b>directed</b> graph represented by an adjacency list using. </p>
<p>breadth first search; outputs Eigen types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#V list of adjacency lists or #V by #V adjacency matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>starting node (index into A) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#V list of indices into rows of A in the order in which graph nodes are discovered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#V list of indices into rows of A of predecessor in resulting spanning tree {-1 indicates root/not discovered), order corresponds to V <b>not</b> D. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ed9474cc5d1478971346be27092d3a2" name="a9ed9474cc5d1478971346be27092d3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed9474cc5d1478971346be27092d3a2">&#9670;&#160;</a></span>bfs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DType , typename PType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bfs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; AType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DType &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PType &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse a <b>directed</b> graph represented by an adjacency list using. </p>
<p>breadth first search; inputs adjacency lists, outputs lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#V list of adjacency lists <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>starting node (index into A) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#V list of indices into rows of A in the order in which graph nodes are discovered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#V list of indices into rows of A of predecessor in resulting spanning tree {-1 indicates root/not discovered), order corresponds to V <b>not</b> D. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3199a27a3e8403ef457e2a7b56f338f3" name="a3199a27a3e8403ef457e2a7b56f338f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3199a27a3e8403ef457e2a7b56f338f3">&#9670;&#160;</a></span>bfs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DType , typename PType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bfs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DType &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PType &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8b9225d219645e80e01f409b151e7cc1" name="a8b9225d219645e80e01f409b151e7cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9225d219645e80e01f409b151e7cc1">&#9670;&#160;</a></span>bfs_orient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedFF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bfs_orient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consistently orient faces in orientable patches using BFS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#F by 3 list of faces (OK if same as F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F list of component ids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0ba6f8afae42bb09f687fe9a518ee94" name="aa0ba6f8afae42bb09f687fe9a518ee94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ba6f8afae42bb09f687fe9a518ee94">&#9670;&#160;</a></span>biharmonic_coordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename SType , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::biharmonic_coordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute "discrete biharmonic generalized barycentric coordinates" as described in "Linear Subspace Design for Real-Time Shape Deformation" [Wang et al. </p>
<p>2015]. Not to be confused with "Bounded Biharmonic Weights
for Real-Time Deformation" [Jacobson et al. 2011] or "Biharmonic
Coordinates" (2D complex barycentric coordinates) [Weber et al. 2012]. These weights minimize a discrete version of the squared Laplacian energy subject to positional interpolation constraints at selected vertices (point handles) and transformation interpolation constraints at regions (region handles).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SType</td><td>should be a simple index type e.g. <code>int</code>,<code>size_t</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T by dim+1 list of / triangle indices into V if dim=2 \ tetrahedron indices into V if dim=3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#point-handles+#region-handles list of lists of selected vertices for each handle. Point handles should have singleton lists and region handles should have lists of size at least dim+1 (and these points should be in general position). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by #points-handles+(#region-handles * dim+1) matrix of weights so that columns correspond to each handles generalized barycentric coordinates (for point-handles) or animation space weights (for region handles). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only on success</dd></dl>
<h4><a class="anchor" id="autotoc_md4"></a>
Example:</h4>
<div class="fragment"><div class="line">MatrixXd W;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#aa0ba6f8afae42bb09f687fe9a518ee94">igl::biharmonic_coordinates</a>(V,F,S,W);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">size_t</span> dim = T.cols()-1;</div>
<div class="line">MatrixXd H(W.cols(),dim);</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> c = 0;</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> h = 0;h&lt;S.size();h++)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(S[h].size()==1)</div>
<div class="line">    {</div>
<div class="line">      H.row(c++) = V.block(S[h][0],0,1,dim);</div>
<div class="line">    }<span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      H.block(c,0,dim+1,dim).setIdentity();</div>
<div class="line">      c+=dim+1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">assert( (V-(W*H)).array().maxCoeff() &lt; 1e-7 );</div>
<div class="ttc" id="anamespaceigl_html_aa0ba6f8afae42bb09f687fe9a518ee94"><div class="ttname"><a href="namespaceigl.html#aa0ba6f8afae42bb09f687fe9a518ee94">igl::biharmonic_coordinates</a></div><div class="ttdeci">bool biharmonic_coordinates(const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedT &gt; &amp;T, const std::vector&lt; std::vector&lt; SType &gt; &gt; &amp;S, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</div><div class="ttdoc">Compute &quot;discrete biharmonic generalized barycentric coordinates&quot; as described in &quot;Linear Subspace De...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abb917f3b67e2fe53d03e8a2c98b6a276" name="abb917f3b67e2fe53d03e8a2c98b6a276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb917f3b67e2fe53d03e8a2c98b6a276">&#9670;&#160;</a></span>biharmonic_coordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename SType , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::biharmonic_coordinates </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; SType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power of Laplacian (experimental) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6867e7d0b5a7f134059e8205e6e16cc9" name="a6867e7d0b5a7f134059e8205e6e16cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6867e7d0b5a7f134059e8205e6e16cc9">&#9670;&#160;</a></span>bijective_composite_harmonic_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::bijective_composite_harmonic_mapping </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a injective planar mapping of a triangulated polygon (V,F) subjected to boundary conditions (b,bc). </p>
<p>The mapping should be bijective in the sense that no triangles' areas become negative (this assumes they started positive). This mapping is computed by "composing" harmonic mappings between incremental morphs of the boundary conditions. This is a bit like a discrete version of "Bijective Composite Mean Value Mappings" [Schneider et al. 2013] but with a discrete harmonic map (cf. harmonic coordinates) instead of mean value coordinates. This is inspired by "Embedding a
triangular graph within a given boundary" [Xu et al. 2011].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of triangle mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b list of boundary indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by 2 list of boundary conditions corresponding to b </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#V by 2 list of output mesh vertex locations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if U contains a successful bijectie mapping </dd></dl>

</div>
</div>
<a id="a7ef34b7c5ad3903df6e31eb7d57bc6aa" name="a7ef34b7c5ad3903df6e31eb7d57bc6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef34b7c5ad3903df6e31eb7d57bc6aa">&#9670;&#160;</a></span>bijective_composite_harmonic_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::bijective_composite_harmonic_mapping </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>min_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_inner_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>test_for_flips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_steps</td><td>minimum number of steps to take from V(b,:) to bc </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_steps</td><td>minimum number of steps to take from V(b,:) to bc (if max_steps == min_steps then no further number of steps will be tried) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_inner_iters</td><td>number of iterations of harmonic solves to run after for each morph step (to try to push flips back in) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">test_for_flips</td><td>whether to check if flips occurred (and trigger more steps). if test_for_flips = false then this function always returns true </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72b12780a4ac9de89f929034ab464726" name="a72b12780a4ac9de89f929034ab464726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b12780a4ac9de89f929034ab464726">&#9670;&#160;</a></span>blkdiag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::blkdiag </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::SparseMatrix&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of matrices place them along the diagonal as blocks of the output matrix. </p>
<p>Like matlab's blkdiag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>list of matrices {A,B, ...} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>A.rows()+B.rows()+... by A.cols()+B.cols()+... block diagonal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ad5f624eb7c4015b813215c87880eb54d" title="Perform concatenation of a two sparse matrices along a single dimension If dim == 1,...">cat</a>, <a class="el" href="namespaceigl.html#ad35357b4f4e8dbf29c3fad77850fb957" title="Repeat a matrix along the diagonal a certain number of times, so that if A is a m by n matrix and we ...">repdiag</a> </dd></dl>

</div>
</div>
<a id="a137f77a6ebc0d59e4f7f3f43e862274e" name="a137f77a6ebc0d59e4f7f3f43e862274e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137f77a6ebc0d59e4f7f3f43e862274e">&#9670;&#160;</a></span>blkdiag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::blkdiag </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af6fdfaea612ac6f626571df84ba43dd0" name="af6fdfaea612ac6f626571df84ba43dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fdfaea612ac6f626571df84ba43dd0">&#9670;&#160;</a></span>blue_noise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedB , typename DerivedFI , typename DerivedP , typename URBG  = DEFAULT_URBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::blue_noise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;&#160;</td>
          <td class="paramname"><em>FI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>urbg</em> = <code><a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Fast Poisson Disk Sampling in Arbitrary Dimensions" [Bridson 2007]. </p>
<p>For very dense samplings this is faster than (up to 2x) cyCodeBase's implementation of "Sample Elimination for Generating Poisson Disk Sample
Sets" [Yuksel 2015]. YMMV</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>Poisson disk radius (evaluated according to Euclidean distance on V) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>#P by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FI</td><td>#P list of indices into F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#P by dim list of sample positions. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">urbg</td><td>An instance of UnformRandomBitGenerator (e.g., <code>std::minstd_rand(0)</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a1fc88d96c492e3bf962501af8bea413e" title="Randomly sample a mesh (V,F) n times.">random_points_on_mesh</a> </dd></dl>

</div>
</div>
<a id="af9bff7fe392542fa173e6665ddaf7a21" name="af9bff7fe392542fa173e6665ddaf7a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bff7fe392542fa173e6665ddaf7a21">&#9670;&#160;</a></span>bone_parents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedBE , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bone_parents </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedBE &gt; &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover "parent" bones from directed graph representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">BE</td><td>#BE by 2 list of directed bone edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#BE by 1 list of parent indices into BE, -1 means root. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366cd5eb6c56116ad697c23065fb8b40" name="a366cd5eb6c56116ad697c23065fb8b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366cd5eb6c56116ad697c23065fb8b40">&#9670;&#160;</a></span>boundary_conditions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::boundary_conditions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>CE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>CF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute boundary conditions for automatic weights computation. </p>
<p>This function expects that the given mesh (V,Ele) has sufficient samples (vertices) exactly at point handle locations and exactly along bone and cage edges/faces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of domain vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ele</td><td>#Ele by simplex-size list of simplex indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C by dim list of handle positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 1 list of point handle indices into C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BE</td><td>#BE by 2 list of bone edge indices into C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CE</td><td>#CE by 2 list of cage edge indices into <em>P</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CF</td><td>#CF by 3 list of (triangular) cage face indices into <em>P</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>#b list of boundary indices (indices into V of vertices which have known, fixed values) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bc</td><td>#b by #weights list of known/fixed values for boundary vertices (notice the #b != #weights in general because #b will include all the intermediary samples along each bone, etc.. The ordering of the weights corresponds to [P;BE] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if boundary conditions are suspicious: P and BE are empty bc is empty some column of bc doesn't have a 0 (assuming bc has &gt;1 columns) some column of bc doesn't have a 1 (assuming bc has &gt;1 columns) </dd></dl>

</div>
</div>
<a id="aa7d8c6202cbd9be61850e58d65fd3096" name="aa7d8c6202cbd9be61850e58d65fd3096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d8c6202cbd9be61850e58d65fd3096">&#9670;&#160;</a></span>boundary_facets() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename DerivedF , typename DerivedJ , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::boundary_facets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine boundary faces (edges) of tetrahedra (triangles) stored in T (analogous to qptoolbox's <code>outline</code> and <code>boundary_faces</code>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>list of boundary faces, n by 3 (2), where n is the number of boundary faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>list of indices into T, n by 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>list of indices revealing across from which vertex is this facet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68133ab0b5aaff2f739a42c49f769512" name="a68133ab0b5aaff2f739a42c49f769512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68133ab0b5aaff2f739a42c49f769512">&#9670;&#160;</a></span>boundary_facets() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::boundary_facets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine boundary faces (edges) of tetrahedra (triangles) stored in T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>list of boundary faces, n by 3 (2), where n is the number of boundary faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfd8cee60db0ccd9448521c2c828430d" name="adfd8cee60db0ccd9448521c2c828430d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd8cee60db0ccd9448521c2c828430d">&#9670;&#160;</a></span>boundary_facets() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename Ret &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Ret igl::boundary_facets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine boundary faces (edges) of tetrahedra (triangles) stored in T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of boundary faces, n by 3 (2), where n is the number of boundary faces </dd></dl>

</div>
</div>
<a id="a782f0e0282464889f69540a72db9e88b" name="a782f0e0282464889f69540a72db9e88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782f0e0282464889f69540a72db9e88b">&#9670;&#160;</a></span>boundary_facets() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerT , typename IntegerF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::boundary_facets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IntegerT &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; IntegerF &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine boundary faces (edges) of tetrahedra (triangles) stored in T; inputs and outputs lists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>tetrahedron (triangle) index list, m by 4 (3), where m is the number of tetrahedra </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>list of boundary faces, n by 3 (2), where n is the number of boundary faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb06d6406b52700028680b4b2c727700" name="adb06d6406b52700028680b4b2c727700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb06d6406b52700028680b4b2c727700">&#9670;&#160;</a></span>boundary_loop() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::boundary_loop </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute list of ordered boundary loops for a manifold mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>index type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>list of loops where L[i] = ordered list of boundary vertices in loop i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21468e50560667302d1637ed6895b29a" name="a21468e50560667302d1637ed6895b29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21468e50560667302d1637ed6895b29a">&#9670;&#160;</a></span>boundary_loop() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::boundary_loop </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>index type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>ordered list of boundary vertices of longest boundary loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82fec963303eda50e7dec22793b756d8" name="a82fec963303eda50e7dec22793b756d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82fec963303eda50e7dec22793b756d8">&#9670;&#160;</a></span>boundary_loop() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::boundary_loop </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ordered boundary loops for a manifold mesh and return the longest loop in terms of vertices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>index type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>ordered list of boundary vertices of longest boundary loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3dc35283c38c7712366f3b0f9dd09a7" name="ad3dc35283c38c7712366f3b0f9dd09a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3dc35283c38c7712366f3b0f9dd09a7">&#9670;&#160;</a></span>bounding_box() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedBV , typename DerivedBF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bounding_box </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBV &gt; &amp;&#160;</td>
          <td class="paramname"><em>BV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a triangle mesh of the bounding box of a given list of vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of rest domain positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BV</td><td>2^dim by dim list of bounding box corners positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td>#BF by dim list of simplex facets <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42a1ef8fd908031e5b30d1aba9614cb7" name="a42a1ef8fd908031e5b30d1aba9614cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a1ef8fd908031e5b30d1aba9614cb7">&#9670;&#160;</a></span>bounding_box() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedBV , typename DerivedBF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::bounding_box </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBV &gt; &amp;&#160;</td>
          <td class="paramname"><em>BV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac1efbdec1a5c13888e2ec44b70c100a" name="aac1efbdec1a5c13888e2ec44b70c100a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1efbdec1a5c13888e2ec44b70c100a">&#9670;&#160;</a></span>bounding_box_diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::bounding_box_diagonal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the length of the diagonal of a given meshes axis-aligned bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex/point positions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of bounding box diagonal </dd></dl>

</div>
</div>
<a id="ab03aa82f1ac2c783bc64cbc9b869531e" name="ab03aa82f1ac2c783bc64cbc9b869531e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03aa82f1ac2c783bc64cbc9b869531e">&#9670;&#160;</a></span>CANONICAL_VIEW_QUAT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Q_type igl::CANONICAL_VIEW_QUAT </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ac4840ccfe1570de9ff6efc2fba06a5" name="a9ac4840ccfe1570de9ff6efc2fba06a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac4840ccfe1570de9ff6efc2fba06a5">&#9670;&#160;</a></span>CANONICAL_VIEW_QUAT&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespaceigl.html#ab03aa82f1ac2c783bc64cbc9b869531e">igl::CANONICAL_VIEW_QUAT</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a834139f67af87775d3524a90be997edc" name="a834139f67af87775d3524a90be997edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834139f67af87775d3524a90be997edc">&#9670;&#160;</a></span>CANONICAL_VIEW_QUAT&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespaceigl.html#ab03aa82f1ac2c783bc64cbc9b869531e">igl::CANONICAL_VIEW_QUAT</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5f624eb7c4015b813215c87880eb54d" name="ad5f624eb7c4015b813215c87880eb54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f624eb7c4015b813215c87880eb54d">&#9670;&#160;</a></span>cat() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cat </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform concatenation of a two <em>sparse</em> matrices along a single dimension If dim == 1, then C = [A;B]; If dim == 2 then C = [A B]. </p>
<p>This is an attempt to act like matlab's cat function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>scalar data type for sparse matrices like double or int </td></tr>
    <tr><td class="paramname">Mat</td><td>matrix type for all matrices (e.g. MatrixXd, SparseMatrix) </td></tr>
    <tr><td class="paramname">MatC</td><td>matrix type for output matrix (e.g. MatrixXd) needs to support resize </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to concatenate, 1 or 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0834acd824362d58a9a06710cde2e964" name="a0834acd824362d58a9a06710cde2e964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0834acd824362d58a9a06710cde2e964">&#9670;&#160;</a></span>cat() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , class MatC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cat </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatC &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform concatenation of a two <em>dense</em> matrices along a single dimension If dim == 1, then C = [A;B]; If dim == 2 then C = [A B]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to concatenate, 1 or 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>output matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If you're using Dense matrices you might be better off using the &lt;&lt; operator </dd></dl>

</div>
</div>
<a id="a203a47235dd090370a7dccffd385002f" name="a203a47235dd090370a7dccffd385002f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203a47235dd090370a7dccffd385002f">&#9670;&#160;</a></span>cat() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat igl::cat </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform concatenation of a two <em>dense</em> matrices along a single dimension If dim == 1, then C = [A;B]; If dim == 2 then C = [A B]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to concatenate, 1 or 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>C output matrix</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you're using Dense matrices you might be better off using the &lt;&lt; operator </dd></dl>

</div>
</div>
<a id="a2b1d04cfbdfdbb8a94fa5712aa9b868e" name="a2b1d04cfbdfdbb8a94fa5712aa9b868e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1d04cfbdfdbb8a94fa5712aa9b868e">&#9670;&#160;</a></span>cat() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cat </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Mat &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate a "matrix" of sub-blocks C = [A0;A1;A2;...;An] where Ai = [A[i][0] A[i][1] ... A[i][m]];. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>a list of list of matrices (sizes must be compatibile) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13402260035cb13a7110a755ae31c487" name="a13402260035cb13a7110a755ae31c487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13402260035cb13a7110a755ae31c487">&#9670;&#160;</a></span>cat() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cat </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate a std::vector of matrices along the specified dimension. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to concatenate, 1 or 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>std::vector of eigen matrices. Must have identical # cols if dim == 1 or rows if dim == 2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>output matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afacaeba967f62ca7f67bfddf604fd60f" name="afacaeba967f62ca7f67bfddf604fd60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacaeba967f62ca7f67bfddf604fd60f">&#9670;&#160;</a></span>ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ceil </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ceil a given matrix to nearest integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix of scalars </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n matrix of ceiled integers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaa0102450153380ae5ecdb948352556" name="adaa0102450153380ae5ecdb948352556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa0102450153380ae5ecdb948352556">&#9670;&#160;</a></span>centroid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedc , typename Derivedvol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::centroid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Derivedvol &amp;&#160;</td>
          <td class="paramname"><em>vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the centroid and enclosed volume of a closed mesh using a surface integral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of rest domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>dim vector of centroid coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vol</td><td>total volume of solid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b05ef9da68218494452d38460a07835" name="a3b05ef9da68218494452d38460a07835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b05ef9da68218494452d38460a07835">&#9670;&#160;</a></span>centroid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::centroid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad2779ad7549dc5da4bed4c7042e2f780" name="ad2779ad7549dc5da4bed4c7042e2f780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2779ad7549dc5da4bed4c7042e2f780">&#9670;&#160;</a></span>circulation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; igl::circulation </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ccw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of faces around the end point of an edge. </p>
<p>Assumes data-structures are built from an edge-manifold <b>closed</b> mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of edge to circulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccw</td><td>whether to <em>continue</em> in ccw direction of edge (circulate around E(e,1)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of faces touched by circulation (in cyclically order).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a984c604c49a10f557933850d8c8e2a76" title="Determine &quot;edge flaps&quot;: two faces on either side of a unique edge (assumes edge-manifold mesh)">edge_flaps</a> </dd></dl>

</div>
</div>
<a id="a0491f8d6a5d5bd769ab23851f43bb2e0" name="a0491f8d6a5d5bd769ab23851f43bb2e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0491f8d6a5d5bd769ab23851f43bb2e0">&#9670;&#160;</a></span>circulation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::circulation </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ccw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>vN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of faces around the end point of an edge. </p>
<p>Assumes data-structures are built from an edge-manifold <b>closed</b> mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramtype"></td><td class="paramname">e</td><td>index into E of edge to circulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramtype"></td><td class="paramname">ccw</td><td>whether to <em>continue</em> in ccw direction of edge (circulate around E(e,1)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramtype"></td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramtype"></td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramtype"></td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramtype"></td><td class="paramname">vN</td><td>list of of faces touched by circulation (in cyclically order).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a984c604c49a10f557933850d8c8e2a76" title="Determine &quot;edge flaps&quot;: two faces on either side of a unique edge (assumes edge-manifold mesh)">edge_flaps</a> </dd></dl>

</div>
</div>
<a id="a904a58ea245b35cce0feec144140e368" name="a904a58ea245b35cce0feec144140e368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904a58ea245b35cce0feec144140e368">&#9670;&#160;</a></span>circulation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::circulation </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ccw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return list of faces around the end point of an edge. </p>
<p>Assumes data-structures are built from an edge-manifold <b>closed</b> mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of edge to circulate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ccw</td><td>whether to <em>continue</em> in ccw direction of edge (circulate around E(e,1)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) "
    e=(j-&gt;i)
@param [in] EI  #E by 2 list of edge flap corners (see above).
@param [out] Nv  #Nv list of "next" vertex indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nf</td><td>#Nf list of face indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a984c604c49a10f557933850d8c8e2a76" title="Determine &quot;edge flaps&quot;: two faces on either side of a unique edge (assumes edge-manifold mesh)">edge_flaps</a> </dd></dl>

</div>
</div>
<a id="a8d3ed506f1a1d753e1c342b42f008170" name="a8d3ed506f1a1d753e1c342b42f008170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3ed506f1a1d753e1c342b42f008170">&#9670;&#160;</a></span>circumradius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::circumradius </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the circumradius of each triangle in a mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>#F list of circumradius </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8e3cfdf30adcadd5172a4f0b862bf59" name="aa8e3cfdf30adcadd5172a4f0b862bf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e3cfdf30adcadd5172a4f0b862bf59">&#9670;&#160;</a></span>collapse_edge() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to collapse a given edge of a mesh. </p>
<p>Assumes (V,F) is a closed manifold mesh (except for previously collapsed faces which should be set to: [IGL_COLLAPSE_EDGE_NULL IGL_COLLAPSE_EDGE_NULL IGL_COLLAPSE_EDGE_NULL]. Collapses exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other). This is implemented in a way that it can be repeatedly called until satisfaction and then the garbage in F can be collected by removing NULL faces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of edge to try to collapse. E(e,:) = [s d] or [d s] so that s&lt;d, then d is collapsed to s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>dim list of vertex position where to place merged vertex [mesh inputs] </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V by dim list of vertex positions, lesser index of E(e,:) will be set to midpoint of edge. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). [mesh inputs] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e1</td><td>index into E of edge collpased on left </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e2</td><td>index into E of edge collpased on right </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f1</td><td>index into F of face collpased on left </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f2</td><td>index into F of face collpased on right </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if edge was collapsed </dd></dl>

</div>
</div>
<a id="a2382e1bd40b951c6f6c14da9773f2fea" name="a2382e1bd40b951c6f6c14da9773f2fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2382e1bd40b951c6f6c14da9773f2fea">&#9670;&#160;</a></span>collapse_edge() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nsv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nsf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ndv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ndf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nsv</td><td>#Nsv vertex circulation around s (see circulation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nsf</td><td>#Nsf face circulation around s </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ndv</td><td>#Ndv vertex circulation around d </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ndf</td><td>#Ndf face circulation around d </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43afe015e0827032a90d6a916c223b2f" name="a43afe015e0827032a90d6a916c223b2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43afe015e0827032a90d6a916c223b2f">&#9670;&#160;</a></span>collapse_edge() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a943c00b18c9d77e42372a02ac5429bd0" name="a943c00b18c9d77e42372a02ac5429bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943c00b18c9d77e42372a02ac5429bd0">&#9670;&#160;</a></span>collapse_edge() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>pre_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>post_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>e2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse least-cost edge from a priority queue and update queue. </p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cost_and_placement</td><td>function computing cost of collapsing an edge and 3d position where it should be placed: cost_and_placement(V,F,E,EMAP,EF,EI,cost,placement); <b>If the edges is collapsed</b> then this function will be called on all edges of all faces previously incident on the endpoints of the collapsed edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pre_collapse</td><td>callback called with index of edge whose collapse is about to be attempted. This function should return whether to <b>proceed</b> with the collapse: returning true means "yes, try to collapse", returning false means "No, consider this edge 'uncollapsable', behave
    as if collapse_edge(e) returned false.
@param [in] post_collapse  callback called with index of edge whose collapse was
    just attempted and a flag revealing whether this was successful.
@param [in,out] V  #V by dim list of vertex positions, lesser index of E(e,:) will be set
    to midpoint of edge.
@param [in,out] F  #F by 3 list of face indices into V.
@param [in,out] E  #E by 2 list of edge indices into V.
@param [in,out] EMAP #F*3 list of indices into E, mapping each directed edge to unique
    unique edge in E
@param [in,out] EF  #E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of
    F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1)
    e=(j-&gt;i)
@param [in,out] EI  #E by 2 list of edge flap corners (see above).
@param [in] Q  queue containing pairs of costs and edge indices and insertion "time"
@param [in] EQ  #E list of "time" of last time pushed into Q </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#E by dim list of stored placements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e</td><td>index into E of attempted collapsed edge. Set to -1 if Q is empty or contains only infinite cost edges. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e1</td><td>index into E of edge collpased on left. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">e2</td><td>index into E of edge collpased on right. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f1</td><td>index into F of face collpased on left. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f2</td><td>index into F of face collpased on right. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a134e573db7b2488d9118ebcf88419f62" name="a134e573db7b2488d9118ebcf88419f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134e573db7b2488d9118ebcf88419f62">&#9670;&#160;</a></span>collapse_edge() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a16f5c61d84a3d91b0e701df01c97c26c" name="a16f5c61d84a3d91b0e701df01c97c26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f5c61d84a3d91b0e701df01c97c26c">&#9670;&#160;</a></span>collapse_edge() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::collapse_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>pre_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>post_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#acd3e0aca98df4cd1576aecb262342dbf">igl::min_heap</a>&lt; std::tuple&lt; double, int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6b31209f04c3bbfb3e3e54836c60d21f" name="a6b31209f04c3bbfb3e3e54836c60d21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b31209f04c3bbfb3e3e54836c60d21f">&#9670;&#160;</a></span>collapse_small_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::collapse_small_triangles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>FF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a triangle mesh (V,F) compute a new mesh (VV,FF) which contains the original faces and vertices of (V,F) except any small triangles have been removed via collapse. </p>
<p>We are <em>not</em> following the rules in "Mesh Optimization" [Hoppe et al] Section 4.2. But for our purposes we don't care about this criteria.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>epsilon for smallest allowed area treated as fraction of squared bounding box diagonal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#FF by 3 list of triangle indices into V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b87a97bec71e27b622eadb0ba9314ea" name="a3b87a97bec71e27b622eadb0ba9314ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b87a97bec71e27b622eadb0ba9314ea">&#9670;&#160;</a></span>colon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename S , typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colon </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const H&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colon operator like matlab's colon operator. </p>
<p>Enumerates values between low and hi with step step.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>should be a eigen matrix primitive type like int or double </td></tr>
    <tr><td class="paramname">S</td><td>should be a eigen matrix primitive type like int or double </td></tr>
    <tr><td class="paramname">H</td><td>should be a eigen matrix primitive type like int or double </td></tr>
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>starting value if step is valid then this is <em>always</em> the first element of I </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>step difference between sequential elements returned in I, remember this will be cast to template T at compile time. If low&lt;hi then step must be positive. If low&gt;hi then step must be negative. Otherwise I will be set to empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>ending value, if (hi-low)step is zero then this will be the last element in I. If step is positive there will be no elements greater than hi, vice versa if hi&lt;low </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>list of values from low to hi with step size step</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This should be potentially replaced with eigen's <a class="el" href="namespaceigl.html#ae8a4579279c09a298a5988c18f215d33" title="Replacement for Eigen::DenseBase::LinSpaced.">LinSpaced()</a> function</dd></dl>
<p>If step = 1, it's about 5 times faster to use: X = Eigen::VectorXi::LinSpaced(n,0,n-1); than X = <a class="el" href="namespaceigl.html#a3b87a97bec71e27b622eadb0ba9314ea" title="Colon operator like matlab&#39;s colon operator.">igl::colon&lt;int&gt;</a>(0,n-1); </p>

</div>
</div>
<a id="af0e3b6d9995f83e6e09df72c562f7dec" name="af0e3b6d9995f83e6e09df72c562f7dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e3b6d9995f83e6e09df72c562f7dec">&#9670;&#160;</a></span>colon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename H , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colon </td>
          <td>(</td>
          <td class="paramtype">const L&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const H&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Colon operator like matlab's colon operator. </p>
<p>Enumerates values between low and hi with unit step.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">L</td><td>should be a eigen matrix primitive type like int or double </td></tr>
    <tr><td class="paramname">H</td><td>should be a eigen matrix primitive type like int or double </td></tr>
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>starting value if step is valid then this is <em>always</em> the first element of I </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">step</td><td>step difference between sequential elements returned in I, remember this will be cast to template T at compile time. If low&lt;hi then step must be positive. If low&gt;hi then step must be negative. Otherwise I will be set to empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hi</td><td>ending value, if (hi-low)step is zero then this will be the last element in I. If step is positive there will be no elements greater than hi, vice versa if hi&lt;low </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>list of values from low to hi with step size step </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcbc9102801940ac0f884e2749ac1113" name="afcbc9102801940ac0f884e2749ac1113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbc9102801940ac0f884e2749ac1113">&#9670;&#160;</a></span>colormap() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colormap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a>&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute [r,g,b] values of the selected colormap for a given factor f between 0 and 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>colormap enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>factor determining color value as if 0 was min and 1 was max </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>red, green, blue value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b414ed243eb5c329d25492c74f0047a" name="a2b414ed243eb5c329d25492c74f0047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b414ed243eb5c329d25492c74f0047a">&#9670;&#160;</a></span>colormap() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colormap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a>&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute [r,g,b] values of the selected colormap for a given factor f between 0 and 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>colormap enum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>factor determining color value as if 0 was min and 1 was max </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>red value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>green value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>blue value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab39d4724e45beaa1e1f8562f0e5e54fd" name="ab39d4724e45beaa1e1f8562f0e5e54fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab39d4724e45beaa1e1f8562f0e5e54fd">&#9670;&#160;</a></span>colormap() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colormap </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>palette</em>[256][3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute [r,g,b] values of the colormap palette for a given factor f between 0 and 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">palette</td><td>256 by 3 array of color values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_in</td><td>factor determining color value as if 0 was min and 1 was max </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>red value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">g</td><td>green value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>blue value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3ae915229f4fed51bf2f7df5850aa5b" name="ab3ae915229f4fed51bf2f7df5850aa5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ae915229f4fed51bf2f7df5850aa5b">&#9670;&#160;</a></span>colormap() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedZ , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colormap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a>&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute [r,g,b] values of the colormap palette for a given factors between 0 and 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cm</td><td>selected colormap palette to interpolate from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>#Z list of factors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>whether to normalize Z to be tightly between [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C by 3 list of rgb colors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50d9c681c034e001a790a6c31555d429" name="a50d9c681c034e001a790a6c31555d429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d9c681c034e001a790a6c31555d429">&#9670;&#160;</a></span>colormap() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedZ , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::colormap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a1b823cd12b22dd7d7c16b36223e68dea">ColorMapType</a>&#160;</td>
          <td class="paramname"><em>cm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute [r,g,b] values of the colormap palette for a given factors between <code>min_Z</code> and <code>max_Z</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cm</td><td>selected colormap palette to interpolate from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>#Z list of factors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_z</td><td>value at "0" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_z</td><td>value at "1" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C by 3 list of rgb colors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a012bb449a5e1b088fd42ed4eb801391a" name="a012bb449a5e1b088fd42ed4eb801391a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012bb449a5e1b088fd42ed4eb801391a">&#9670;&#160;</a></span>column_to_quats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::column_to_quats </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>de-"Columnize" a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>n*4-long list of coefficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vQ</td><td>n-long list of quaternions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if n%4!=0 </dd></dl>

</div>
</div>
<a id="a2ae4ea0e51288d468b77d2303f7b60e5" name="a2ae4ea0e51288d468b77d2303f7b60e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae4ea0e51288d468b77d2303f7b60e5">&#9670;&#160;</a></span>columnize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::columnize </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Columnize" a stack of block matrices. </p>
<p>If A = [A1,A2,A3,...,Ak] with each A* an m by n block then this produces the column vector whose entries are B(j*m*k+i*k+b) = A(i,b*n+j); or if A = [A1;A2;...;Ak] then B(j*m*k+i*k+b) = A(i+b*m,j);</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m*k by n (dim: 1) or m by n*k (dim: 2) eigen Matrix of type T values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of blocks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension in which blocks are stacked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>m*n*k eigen vector of type T values,</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a5fa327db1af41a1e29e474981b963409" title="Transpose blocks of a matrix.">transpose_blocks</a> </dd></dl>

</div>
</div>
<a id="a42d3578aca0da0bea74041ca2b239c1d" name="a42d3578aca0da0bea74041ca2b239c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d3578aca0da0bea74041ca2b239c1d">&#9670;&#160;</a></span>comb_cross_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::comb_cross_field </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 4 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1in</td><td>#F by 3 eigen Matrix of the first per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD2in</td><td>#F by 3 eigen Matrix of the second per face cross field vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD1out</td><td>#F by 3 eigen Matrix of the first combed cross field vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD2out</td><td>#F by 3 eigen Matrix of the second combed cross field vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406fa0cb0c3fafe5a7b06e31ba757329" name="a406fa0cb0c3fafe5a7b06e31ba757329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406fa0cb0c3fafe5a7b06e31ba757329">&#9670;&#160;</a></span>comb_frame_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::comb_frame_field </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>BIS1_combed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>BIS2_combed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1_combed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2_combed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes principal matchings of the vectors of a frame field across face edges, and generates a combed frame field defined on the mesh faces. </p>
<p>This makes use of a combed cross field generated by combing the field created by the bisectors of the frame field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 4 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1</td><td>#F by 3 eigen Matrix of the first per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD2</td><td>#F by 3 eigen Matrix of the second per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BIS1_combed</td><td>#F by 3 eigen Matrix of the first combed bisector field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BIS2_combed</td><td>#F by 3 eigen Matrix of the second combed bisector field vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD1_combed</td><td>#F by 3 eigen Matrix of the first combed cross field vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD2_combed</td><td>#F by 3 eigen Matrix of the second combed cross field vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a702a263c5565f41ca8e4585619b746f7" name="a702a263c5565f41ca8e4585619b746f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702a263c5565f41ca8e4585619b746f7">&#9670;&#160;</a></span>comb_line_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::comb_line_field </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes principal matchings of the vectors of a cross field across face edges, and generates a combed cross field defined on the mesh faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 4 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1in</td><td>#F by 3 eigen Matrix of the first per face cross field vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD1out</td><td>#F by 3 eigen Matrix of the first combed cross field vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add396b23f15d16510156bfa839f58661" name="add396b23f15d16510156bfa839f58661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add396b23f15d16510156bfa839f58661">&#9670;&#160;</a></span>combine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVV , typename DerivedFF , typename DerivedV , typename DerivedF , typename DerivedVsizes , typename DerivedFsizes &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::combine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVsizes &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vsizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFsizes &gt; &amp;&#160;</td>
          <td class="paramname"><em>Fsizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate k meshes into a single &gt;=k connected component mesh with a single vertex list and face list. </p>
<p>Similar to Maya's Combine operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VV</td><td>k-long list of lists of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FF</td><td>k-long list of lists of mesh face indices so that FF[i] indexes VV[i] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>VV[0].rows()+...+VV[k-1].rows() by VV[0].cols() list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>FF[0].rows()+...+FF[k-1].rows() by FF[0].cols() list of mesh faces indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vsizes</td><td>k list so that Vsizes(i) is the #vertices in the ith input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Fsizes</td><td>k list so that Fsizes(i) is the #faces in the ith input</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md5"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="comment">// Suppose you have mesh A (VA,FA) and mesh B (VB,FB)</span></div>
<div class="line">igl::combine&lt;Eigen::MatrixXd,Eigen::MatrixXi&gt;({VA,VB},{FA,FB},V,F);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a75f28ec0548f636eb6dc9551eca554bc" name="a75f28ec0548f636eb6dc9551eca554bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f28ec0548f636eb6dc9551eca554bc">&#9670;&#160;</a></span>combine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVV , typename DerivedFF , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::combine </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab190df5efbd072173791f9ae36b0c58c" name="ab190df5efbd072173791f9ae36b0c58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab190df5efbd072173791f9ae36b0c58c">&#9670;&#160;</a></span>compute_frame_field_bisectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::compute_frame_field_bisectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>BIS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>BIS2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute bisectors of a frame field defined on mesh faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B1</td><td>#F by 3 eigen Matrix of face (triangle) base vector 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B2</td><td>#F by 3 eigen Matrix of face (triangle) base vector 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1</td><td>#F by 3 eigen Matrix of the first per face frame field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD2</td><td>#F by 3 eigen Matrix of the second per face frame field vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BIS1</td><td>#F by 3 eigen Matrix of the first per face frame field bisector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BIS2</td><td>#F by 3 eigen Matrix of the second per face frame field bisector</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a062b8f100ec84d5b9dfc68558f6e3e0b" name="a062b8f100ec84d5b9dfc68558f6e3e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062b8f100ec84d5b9dfc68558f6e3e0b">&#9670;&#160;</a></span>compute_frame_field_bisectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::compute_frame_field_bisectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>BIS1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>BIS2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6c8cf9368d76d69d41ea95bc5b4fd13b" name="a6c8cf9368d76d69d41ea95bc5b4fd13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8cf9368d76d69d41ea95bc5b4fd13b">&#9670;&#160;</a></span>connect_boundary_to_infinity() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedFO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::connect_boundary_to_infinity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFO &gt; &amp;&#160;</td>
          <td class="paramname"><em>FO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect all boundary edges to a fictitious point at infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into some V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FO</td><td>#F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abb409818f72dece08eaa0c0f71d5b2e9" name="abb409818f72dece08eaa0c0f71d5b2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb409818f72dece08eaa0c0f71d5b2e9">&#9670;&#160;</a></span>connect_boundary_to_infinity() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedFO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::connect_boundary_to_infinity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedF::Scalar&#160;</td>
          <td class="paramname"><em>inf_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFO &gt; &amp;&#160;</td>
          <td class="paramname"><em>FO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect all boundary edges to a fictitious point at infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into some V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inf_index</td><td>index of point at infinity (usually V.rows() or F.maxCoeff()) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FO</td><td>#F+#O by 3 list of face indices into [V;inf inf inf], original F are guaranteed to come first. If (V,F) was a manifold mesh, now it is closed with a possibly non-manifold vertex at infinity (but it will be edge-manifold). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d651ddb82e5e25cc25fbab3813190da" name="a1d651ddb82e5e25cc25fbab3813190da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d651ddb82e5e25cc25fbab3813190da">&#9670;&#160;</a></span>connect_boundary_to_infinity() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVO , typename DerivedFO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::connect_boundary_to_infinity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVO &gt; &amp;&#160;</td>
          <td class="paramname"><em>VO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFO &gt; &amp;&#160;</td>
          <td class="paramname"><em>FO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect all boundary edges to a fictitious point at infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into some V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VO</td><td>#V+1 by 3 list of vertex positions, original V are guaranteed to come first. Last point is inf, inf, inf </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FO</td><td>#F+#O by 3 list of face indices into VO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad493c0508f1454ae875031906899d4de" name="ad493c0508f1454ae875031906899d4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad493c0508f1454ae875031906899d4de">&#9670;&#160;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Atype , typename DerivedC , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::connected_components </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Atype &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the connected components of a graph described by the input adjacency matrix (similar to MATLAB's graphconncomp or gptoolbox's conncomp, but A is transposed for unsymmetric graphs). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by #A adjacency matrix (treated as describing an directed graph) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#A list of component indices into [0,#K-1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#K list of sizes of each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of connected components </dd></dl>

</div>
</div>
<a id="acbfe6ae19ab6f94e36b3d92be1159fe9" name="acbfe6ae19ab6f94e36b3d92be1159fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbfe6ae19ab6f94e36b3d92be1159fe9">&#9670;&#160;</a></span>cotmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cotmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,F). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived type of eigen matrix for V (e.g. derived from MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived type of eigen matrix for F (e.g. derived from MatrixXi) </td></tr>
    <tr><td class="paramname">Scalar</td><td>scalar type for eigen sparse matrix (e.g. double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh elements (triangles or tetrahedra) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#V by #V cotangent matrix, each row i corresponding to V(i,:)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735" title="Constructs the graph adjacency matrix of a given mesh (V,F)">adjacency_matrix</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This Laplacian uses the convention that diagonal entries are <b>minus</b> the sum of off-diagonal entries. The diagonal entries are therefore in general negative and the matrix is <b>negative</b> semi-definite (immediately, -L is <b>positive</b> semi-definite) </dd></dl>

</div>
</div>
<a id="a42d5463d31cf82b23668e9680975301a" name="a42d5463d31cf82b23668e9680975301a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d5463d31cf82b23668e9680975301a">&#9670;&#160;</a></span>cotmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cotmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cotangent Laplacian (and mass matrix) for polygon meshes according to "Polygon Laplacian Made Simple" [Bunge et al. 2020]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#V by #V polygon Laplacian made simple matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#V by #V mass matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#V+#polygons by #V prolongation operator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c5e7ebbe20f12078dc576d644935f83" name="a4c5e7ebbe20f12078dc576d644935f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5e7ebbe20f12078dc576d644935f83">&#9670;&#160;</a></span>cotmatrix_entries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cotmatrix_entries </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cotmatrix contributions (cotangents) of each angle in mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of rest domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by {3|4} list of {triangle|tetrahedra} indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F by 3 list of 1/2*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] or C #F by 6 list of 1/6*cotangents of dihedral angles*edge lengths for tets, columns along edges [1,2],[2,0],[0,1],[3,0],[3,1],[3,2]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a> </dd></dl>

</div>
</div>
<a id="a01189493d30a0e8a2cbd6e053641545f" name="a01189493d30a0e8a2cbd6e053641545f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01189493d30a0e8a2cbd6e053641545f">&#9670;&#160;</a></span>cotmatrix_entries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cotmatrix_entries </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the cotmatrix contributions (cotangents) of each angle in mesh with edge lengths (l) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#F by 3 list of triangle edge lengths (see edge_lengths) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F by 3 list of 1/2*cotangents corresponding angles for triangles, columns correspond to edges [1,2],[2,0],[0,1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a> </dd></dl>

</div>
</div>
<a id="ae47d4dd3239dba392f54b8dc3f62e8dd" name="ae47d4dd3239dba392f54b8dc3f62e8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae47d4dd3239dba392f54b8dc3f62e8dd">&#9670;&#160;</a></span>cotmatrix_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cotmatrix_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh with faces F and edge lengths l. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#F by 3 list of (half-)edge lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into some (not necessarily determined/embedable) list of vertex positions V. It is assumed #V == F.maxCoeff()+1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#V by #V sparse Laplacian matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a>, <a class="el" href="namespaceigl.html#a6173f608f5bae73866cc21f0159562dc" title="Computes the discrete cotangent Laplacian of a mesh after converting it into its intrinsic Delaunay t...">intrinsic_delaunay_cotmatrix</a> </dd></dl>

</div>
</div>
<a id="a83819bb842f4bc4c8af21a98e1db44b3" name="a83819bb842f4bc4c8af21a98e1db44b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83819bb842f4bc4c8af21a98e1db44b3">&#9670;&#160;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename SType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::count </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; XType &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; SType &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of non-zeros in the columns or rows of a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to sum (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>n-long <em>sparse</em> vector (if dim == 1) or m-long sparse vector (if dim == 2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your looking for dense matrix matlab like sum for eigen matrics just use: M.colwise().<a class="el" href="namespaceigl.html#a83819bb842f4bc4c8af21a98e1db44b3" title="Count the number of non-zeros in the columns or rows of a sparse matrix.">count()</a> or M.rowwise().<a class="el" href="namespaceigl.html#a83819bb842f4bc4c8af21a98e1db44b3" title="Count the number of non-zeros in the columns or rows of a sparse matrix.">count()</a> </dd></dl>

</div>
</div>
<a id="a91399ecb01f4828dbe0b5d3e9c51a73b" name="a91399ecb01f4828dbe0b5d3e9c51a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91399ecb01f4828dbe0b5d3e9c51a73b">&#9670;&#160;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::count </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; XType &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Outputs a dense vector. </p>

</div>
</div>
<a id="a566bead6b8810ca47f10d8e0b184c2ab" name="a566bead6b8810ca47f10d8e0b184c2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566bead6b8810ca47f10d8e0b184c2ab">&#9670;&#160;</a></span>covariance_scatter_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::covariance_scatter_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5">ARAPEnergyType</a>&#160;</td>
          <td class="paramname"><em>energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>CSM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the covariance scatter matrix for a given arap energy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by Vdim list of initial domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">energy</td><td>ARAPEnergyType enum value defining which energy is being used. See <a class="el" href="ARAPEnergyType_8h.html">ARAPEnergyType.h</a> for valid options and explanations. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CSM</td><td>dim*#V/#F by dim*#V sparse matrix containing special laplacians along the diagonal so that when multiplied by V gives covariance matrix elements, can be used to speed up covariance matrix computation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ae1324ec871ee5fe0f3d6fa9b461ced93" title="Constructs a block of the matrix which constructs the linear terms of a given arap energy.">arap_linear_block</a>, arap, <a class="el" href="namespaceigl.html#afcbc9001656cf2d4cc135602618c97e5" title="Enum for choosing ARAP energy type.">ARAPEnergyType</a> </dd></dl>

</div>
</div>
<a id="a9a8762cbd164779fc2b875dd73ab70d0" name="a9a8762cbd164779fc2b875dd73ab70d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8762cbd164779fc2b875dd73ab70d0">&#9670;&#160;</a></span>cr_vector_curvature_correction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_curvature_correction </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the vector Crouzeix-Raviart curvature correction term of Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. </p>
<p>"A Smoothness Energy without Boundary Distortion for
 Curved Surfaces", but using the basis functions by Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "A Simple Discretization of the Vector Dirichlet Energy"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 4 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient_halfedges. will be computed if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>2*|HE| by 2*|HE| computed curvature correction matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeca2a3d390d85a9432843e481cc1b2ca" name="aeca2a3d390d85a9432843e481cc1b2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca2a3d390d85a9432843e481cc1b2ca">&#9670;&#160;</a></span>cr_vector_curvature_correction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_curvature_correction </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p><code>E</code> and <code>oE</code> are computed and output. </p>

</div>
</div>
<a id="a8e4ef6fb71a86a0dc23499f0d2859578" name="a8e4ef6fb71a86a0dc23499f0d2859578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4ef6fb71a86a0dc23499f0d2859578">&#9670;&#160;</a></span>cr_vector_curvature_correction_intrinsic() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename Derivedtheta , typename Derivedkappa , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_curvature_correction_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedtheta &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedkappa &gt; &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>intrinsic version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l_sq</td><td>#F by 3 list of squared edge lengths of each halfedge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>#F by 3 list of the tip angles at each halfedge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kappa</td><td>#V by 1 list of the Gaussian curvature at each vertex</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="cr__vector__curvature__correction_8h.html">include/igl/cr_vector_curvature_correction.h</a> </p>

</div>
</div>
<a id="a9522053349c7920e8399af8da638720d" name="a9522053349c7920e8399af8da638720d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9522053349c7920e8399af8da638720d">&#9670;&#160;</a></span>cr_vector_curvature_correction_intrinsic() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_curvature_correction_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="cr__vector__curvature__correction_8h.html">include/igl/cr_vector_curvature_correction.h</a>. </p>

</div>
</div>
<a id="a27d76cb9c1bfa1cc13c9bc19f4bcbdc8" name="a27d76cb9c1bfa1cc13c9bc19f4bcbdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27d76cb9c1bfa1cc13c9bc19f4bcbdc8">&#9670;&#160;</a></span>cr_vector_curvature_correction_intrinsic() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename Derivedtheta , typename DerivedE , typename DerivedOE , typename ScalarK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_curvature_correction_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedtheta &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="cr__vector__curvature__correction_8h.html">include/igl/cr_vector_curvature_correction.h</a>. </p>

</div>
</div>
<a id="ad3b4cd87c1b79a3e8220217907e2f92d" name="ad3b4cd87c1b79a3e8220217907e2f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b4cd87c1b79a3e8220217907e2f92d">&#9670;&#160;</a></span>cr_vector_laplacian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the CR vector Laplacian matrix. </p>
<p>See Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "A Simple Discretization of the Vector Dirichlet Energy"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient_halfedges. will be computed if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>2*|HE| by 2*|HE| computed Laplacian matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc88ca84e384cf6d28d2fc8a0f9bebf" name="a6cc88ca84e384cf6d28d2fc8a0f9bebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc88ca84e384cf6d28d2fc8a0f9bebf">&#9670;&#160;</a></span>cr_vector_laplacian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_laplacian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p><code>E</code> and <code>oE</code> are computed and output. </p>

</div>
</div>
<a id="a7a2c2b7f03004fbcca3d3fa8f4fef60f" name="a7a2c2b7f03004fbcca3d3fa8f4fef60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2c2b7f03004fbcca3d3fa8f4fef60f">&#9670;&#160;</a></span>cr_vector_laplacian_intrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DeriveddA , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_laplacian_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>intrinsic version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l_sq</td><td>#F by 3 list of squared edge lengths of each halfedge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>#F list of double areas</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="cr__vector__laplacian_8h.html">include/igl/cr_vector_laplacian.h</a> </p>

</div>
</div>
<a id="a74c1a4348f8eeba501dac71ffe89a71c" name="a74c1a4348f8eeba501dac71ffe89a71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c1a4348f8eeba501dac71ffe89a71c">&#9670;&#160;</a></span>cr_vector_laplacian_intrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_laplacian_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="cr__vector__laplacian_8h.html">include/igl/cr_vector_laplacian.h</a>. </p>

</div>
</div>
<a id="adb956da2f2c2355242b2c267b86d8fea" name="adb956da2f2c2355242b2c267b86d8fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb956da2f2c2355242b2c267b86d8fea">&#9670;&#160;</a></span>cr_vector_mass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_mass </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the CR vector mass matrix, using an arrangement of all parallel degrees of freedom first, and all perpendicular degrees of freedom next. </p>
<p>See Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "A Simple Discretization of the Vector Dirichlet Energy"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>2*|HE| by 2*|HE| computed Mass matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2dabc69504695d2ad3ea01676bf9353" name="ab2dabc69504695d2ad3ea01676bf9353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2dabc69504695d2ad3ea01676bf9353">&#9670;&#160;</a></span>cr_vector_mass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename ScalarM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_mass </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p><code>E</code> are (possibly?) computed and output. </p>

</div>
</div>
<a id="a10ed1159cd7e63e2d4993c501085be42" name="a10ed1159cd7e63e2d4993c501085be42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ed1159cd7e63e2d4993c501085be42">&#9670;&#160;</a></span>cr_vector_mass_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DeriveddA , typename DerivedE , typename ScalarM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cr_vector_mass_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>intrinsic version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>#F list of double areas</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="cr__vector__mass_8h.html">include/igl/cr_vector_mass.h</a> </p>

</div>
</div>
<a id="a8eb65039a597811fba7c59d41d039b4c" name="a8eb65039a597811fba7c59d41d039b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb65039a597811fba7c59d41d039b4c">&#9670;&#160;</a></span>cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::cross </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cross product; out = cross(a,b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>left 3d vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>right 3d vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result 3d vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4887506ff673ad3a57ca0697dda4d029" name="a4887506ff673ad3a57ca0697dda4d029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4887506ff673ad3a57ca0697dda4d029">&#9670;&#160;</a></span>cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cross </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes rowwise cross product C = cross(A,B,2);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by 3 list of row-vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#A by 3 list of row-vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#A by 3 list of row-vectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a916e1792b25fb32f0554288f22dcaa21" name="a916e1792b25fb32f0554288f22dcaa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916e1792b25fb32f0554288f22dcaa21">&#9670;&#160;</a></span>cross_field_mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cross_field_mismatch </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isCombed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>mismatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces. </p>
<p>The integer mismatch is a multiple of pi/2 that transforms the cross on one side of the edge to the cross on the other side. It represents the deviation from a Lie connection across the edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1</td><td>#F by 3 eigen Matrix of the first per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD2</td><td>#F by 3 eigen Matrix of the second per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCombed</td><td>boolean, specifying whether the field is combed (i.e. matching has been precomputed. If not, the field is combed first. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mismatch</td><td>#F by 3 eigen Matrix containing the integer mismatch of the cross field across all face edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a528d6ff188e05af669e3369a40562268" name="a528d6ff188e05af669e3369a40562268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528d6ff188e05af669e3369a40562268">&#9670;&#160;</a></span>crouzeix_raviart_cotmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename LT , typename DerivedE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::crouzeix_raviart_cotmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; LT &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Crouzeix-Raviart cotangent stiffness matrix. </p>
<p>See for example "Discrete Quadratic Curvature Energies" [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/4 list of triangle/tetrahedron indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#E by #E edge/face-based diagonal cotangent matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2/3 list of edges/faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#F*3/4 list of indices mapping allE to E</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a1e1d2b58df45ae7555c3719963bb39d6" title="CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where M(e,e) is just the sum of ...">crouzeix_raviart_massmatrix</a> </dd></dl>

</div>
</div>
<a id="a0cba460e00e27a7947e2d7d7d569ec04" name="a0cba460e00e27a7947e2d7d7d569ec04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cba460e00e27a7947e2d7d7d569ec04">&#9670;&#160;</a></span>crouzeix_raviart_cotmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedEMAP , typename LT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::crouzeix_raviart_cotmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; LT &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Crouzeix-Raviart cotangent stiffness matrix. </p>
<p>See for example "Discrete Quadratic Curvature Energies" [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/4 list of triangle/tetrahedron indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2/3 list of edges/faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3/4 list of indices mapping allE to E </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#E by #E edge/face-based diagonal cotangent matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a1e1d2b58df45ae7555c3719963bb39d6" title="CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where M(e,e) is just the sum of ...">crouzeix_raviart_massmatrix</a> </dd></dl>

</div>
</div>
<a id="a1e1d2b58df45ae7555c3719963bb39d6" name="a1e1d2b58df45ae7555c3719963bb39d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1d2b58df45ae7555c3719963bb39d6">&#9670;&#160;</a></span>crouzeix_raviart_massmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::crouzeix_raviart_massmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e. </p>
<p>See for example "Discrete Quadratic Curvature Energies" [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/4 list of triangle/tetrahedron indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#E by #E edge/face-based diagonal mass matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2/3 list of edges/faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#F*3/4 list of indices mapping allE to E</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a528d6ff188e05af669e3369a40562268" title="Compute the Crouzeix-Raviart cotangent stiffness matrix.">crouzeix_raviart_cotmatrix</a> </dd></dl>

</div>
</div>
<a id="a4fbcad6ddce4e7c8f209f87f5deb5f81" name="a4fbcad6ddce4e7c8f209f87f5deb5f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbcad6ddce4e7c8f209f87f5deb5f81">&#9670;&#160;</a></span>crouzeix_raviart_massmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MT , typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::crouzeix_raviart_massmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; MT &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CROUZEIX_RAVIART_MASSMATRIX Compute the Crouzeix-Raviart mass matrix where M(e,e) is just the sum of the areas of the triangles on either side of an edge e. </p>
<p>See for example "Discrete Quadratic Curvature Energies" [Wardetzky, Bergou, Harmon, Zorin, Grinspun 2007]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/4 list of triangle/tetrahedron indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2/3 list of edges/faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3/4 list of indices mapping allE to E </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#E by #E edge/face-based diagonal mass matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a528d6ff188e05af669e3369a40562268" title="Compute the Crouzeix-Raviart cotangent stiffness matrix.">crouzeix_raviart_cotmatrix</a> </dd></dl>

</div>
</div>
<a id="a8115269b075eef2f1c35db347806319d" name="a8115269b075eef2f1c35db347806319d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8115269b075eef2f1c35db347806319d">&#9670;&#160;</a></span>cumprod()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cumprod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a cumulative product of the columns of X, like matlab's <code>cumprod</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedX</td><td>Type of matrix X </td></tr>
    <tr><td class="paramname">DerivedY</td><td>Type of matrix Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n Matrix to be cumulatively multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension to take cumulative product (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n Matrix containing cumulative product. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ad6bf440539af2b6aa5b38ce6d8f4ec" name="a6ad6bf440539af2b6aa5b38ce6d8f4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad6bf440539af2b6aa5b38ce6d8f4ec">&#9670;&#160;</a></span>cumsum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cumsum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a cumulative sum of the columns of X, like matlab's <code>cumsum</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedX</td><td>Type of matrix X </td></tr>
    <tr><td class="paramname">DerivedY</td><td>Type of matrix Y </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n Matrix to be cumulatively summed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension to take cumulative sum (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n Matrix containing cumulative sum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a717f5ffd3d4bc3771bdd7e2e2786bb95" name="a717f5ffd3d4bc3771bdd7e2e2786bb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a717f5ffd3d4bc3771bdd7e2e2786bb95">&#9670;&#160;</a></span>cumsum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cumsum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>zero_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a cumulative sum of the columns of [0;X]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n Matrix to be cumulatively summed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension to take cumulative sum (1 or 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zero_prefix</td><td>whether to use zero prefix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>if zero_prefix == false m by n Matrix containing cumulative sum else m+1 by n Matrix containing cumulative sum if dim=1 or m by n+1 Matrix containing cumulative sum if dim=2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf8191d83bb2517d430b625c5416988b" name="adf8191d83bb2517d430b625c5416988b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8191d83bb2517d430b625c5416988b">&#9670;&#160;</a></span>curved_hessian_energy() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename ScalarQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::curved_hessian_energy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the curved Hessian energy using the Crouzeix-Raviart discretization. </p>
<p>See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "A Smoothness Energy without Boundary Distortion for Curved Surfaces"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V Hessian energy matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a805b9c22927ea42f1756d0094e373f9f" name="a805b9c22927ea42f1756d0094e373f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805b9c22927ea42f1756d0094e373f9f">&#9670;&#160;</a></span>curved_hessian_energy() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::curved_hessian_energy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the curved Hessian energy using the Crouzeix-Raviart discretization. </p>
<p>See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "A Smoothness Energy without Boundary Distortion for Curved Surfaces"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V Hessian energy matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22ef8866a2a9dee7c48ba52640e2d1f0" name="a22ef8866a2a9dee7c48ba52640e2d1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ef8866a2a9dee7c48ba52640e2d1f0">&#9670;&#160;</a></span>curved_hessian_energy() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::curved_hessian_energy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the curved Hessian energy using the Crouzeix-Raviart discretization. </p>
<p>See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "A Smoothness Energy without Boundary Distortion for Curved Surfaces"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V Hessian energy matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf2f70635c7e74512f3a00c9fbf0175f" name="adf2f70635c7e74512f3a00c9fbf0175f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2f70635c7e74512f3a00c9fbf0175f">&#9670;&#160;</a></span>curved_hessian_energy_intrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::curved_hessian_energy_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the curved Hessian energy using the Crouzeix-Raviart discretization. </p>
<p>See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "A Smoothness Energy without Boundary Distortion for Curved Surfaces"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l_sq</td><td>#F by 3 list of squared edge lengths of each halfedge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient_halfedges. will be computed if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V Hessian energy matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ee4e11b54bb3477734d8f83e33c01c7" name="a6ee4e11b54bb3477734d8f83e33c01c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee4e11b54bb3477734d8f83e33c01c7">&#9670;&#160;</a></span>curved_hessian_energy_intrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DeriveddA , typename DerivedE , typename DerivedOE , typename ScalarQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::curved_hessian_energy_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the curved Hessian energy using the Crouzeix-Raviart discretization. </p>
<p>See Oded Stein, Alec Jacobson, Max Wardetzky, Eitan Grinspun, 2020. "A Smoothness Energy without Boundary Distortion for Curved Surfaces"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l_sq</td><td>#F by 3 list of squared edge lengths of each halfedge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>#F list of double areas </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient_halfedges. will be computed if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V Hessian energy matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3221b56ac51e76ede2f88111bd099e2c" name="a3221b56ac51e76ede2f88111bd099e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3221b56ac51e76ede2f88111bd099e2c">&#9670;&#160;</a></span>cut_mesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cut_mesh </td>
          <td>(</td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes mesh is edge-manifold.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V by 3 list of the vertex positions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 list of the faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cuts</td><td>#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#V by 1 list of the map between Vn to original V index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a4e732845de9d7f23536e1e6afe4a12" name="a9a4e732845de9d7f23536e1e6afe4a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4e732845de9d7f23536e1e6afe4a12">&#9670;&#160;</a></span>cut_mesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFF , typename DerivedFFi , typename DerivedC , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cut_mesh </td>
          <td>(</td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedFFi &gt; &amp;&#160;</td>
          <td class="paramname"><em>FFi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes mesh is edge-manifold.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V by 3 list of the vertex positions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 list of the faces </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FF</td><td>#F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">FFi</td><td>#F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#V by 1 list of the map between Vn to original V index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ae07b1e4d35569138ffa0d8a874f0e24f" title="Constructs the triangle-triangle adjacency matrix for a given mesh (V,F).">triangle_triangle_adjacency</a> </dd></dl>

</div>
</div>
<a id="ab4c53d1e5c547015ed9a3a31941c9e80" name="ab4c53d1e5c547015ed9a3a31941c9e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c53d1e5c547015ed9a3a31941c9e80">&#9670;&#160;</a></span>cut_mesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cut_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>Fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes mesh is edge-manifold. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V by 3 list of the vertex positions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 list of the faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cuts</td><td>#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vn</td><td>#V by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Fn</td><td>#F by 3 list of the faces of the cut mesh(must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a073f4b026cc266fb9d229b0063139681" name="a073f4b026cc266fb9d229b0063139681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073f4b026cc266fb9d229b0063139681">&#9670;&#160;</a></span>cut_mesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cut_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>Fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh that has the cuts at its boundary. </p>
<dl class="section note"><dt>Note</dt><dd>Assumes mesh is edge-manifold. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V by 3 list of the vertex positions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 list of the faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cuts</td><td>#F by 3 list of boolean flags, indicating the edges that need to be cut (has 1 at the face edges that are to be cut, 0 otherwise) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vn</td><td>#V by 3 list of the vertex positions of the cut mesh. This matrix will be similar to the original vertices except some rows will be duplicated. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Fn</td><td>#F by 3 list of the faces of the cut mesh(must be triangles). This matrix will be similar to the original face matrix except some indices will be redirected to point to the newly duplicated vertices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#V by 1 list of the map between Vn to original V index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a719fb78367f00bac1b9ef47dacead128" name="a719fb78367f00bac1b9ef47dacead128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719fb78367f00bac1b9ef47dacead128">&#9670;&#160;</a></span>cut_mesh_from_singularities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cut_mesh_from_singularities </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>MMatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>seams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh (V,F) and the integer mismatch of a cross field per edge (mismatch), finds the cut_graph connecting the singularities (seams) and the degree of the singularities singularity_index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mismatch</td><td>#F by 3 list of per corner integer mismatch </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seams</td><td>#F by 3 list of per corner booleans that denotes if an edge is a seam or not </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace2b58d7048e2871ef70de6761fe10f2" name="ace2b58d7048e2871ef70de6761fe10f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2b58d7048e2871ef70de6761fe10f2">&#9670;&#160;</a></span>cut_to_disk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cut_to_disk </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a triangle mesh, computes a set of edge cuts sufficient to carve the mesh into a topological disk, without disconnecting any connected components. </p>
<p>Nothing else about the cuts (including number, total length, or smoothness) is guaranteed to be optimal.</p>
<p>Simply-connected components without boundary (topological spheres) are left untouched (delete any edge if you really want a disk). All other connected components are cut into disks. Meshes with boundary are supported; boundary edges will be included as cuts.</p>
<p>The cut mesh itself can be materialized using <a class="el" href="namespaceigl.html#a3221b56ac51e76ede2f88111bd099e2c" title="Given a mesh and a list of edges that are to be cut, the function generates a new disk-topology mesh ...">cut_mesh()</a>.</p>
<p>Implements the triangle-deletion approach described by Gu et al's "Geometry Images."</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Index</td><td>Integrable type large enough to represent the total number of faces and edges in the surface represented by F, and all entries of F. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of the faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cuts</td><td>List of cuts. Each cut is a sequence of vertex indices (where pairs of consecutive vertices share a face), is simple, and is either a closed loop (in which the first and last indices are identical) or an open curve. Cuts are edge-disjoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab77a363af4a0fcf59e15409bd8a09fc4" name="ab77a363af4a0fcf59e15409bd8a09fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77a363af4a0fcf59e15409bd8a09fc4">&#9670;&#160;</a></span>cylinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::cylinder </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>axis_devisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>height_devisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a triangle mesh of a cylinder (without caps) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis_devisions</td><td>number of vertices <em>around the cylinder</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height_devisions</td><td>number of vertices <em>up the cylinder</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73748b03f3e779d764d30d920653aba6" name="a73748b03f3e779d764d30d920653aba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73748b03f3e779d764d30d920653aba6">&#9670;&#160;</a></span>dated_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::dated_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the given file to a new file with the same basename in <code>dir</code> directory with the current date and time as a suffix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src_path</td><td>path to source file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>directory of destination file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the copy was successful</dd></dl>
<h4><a class="anchor" id="autotoc_md8"></a>
Example:</h4>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceigl.html#a73748b03f3e779d764d30d920653aba6">dated_copy</a>(<span class="stringliteral">&quot;/path/to/foo&quot;</span>,<span class="stringliteral">&quot;/bar/&quot;</span>);</div>
<div class="line"><span class="comment">// copies /path/to/foo to /bar/foo-2013-12-12T18-10-56</span></div>
<div class="ttc" id="anamespaceigl_html_a73748b03f3e779d764d30d920653aba6"><div class="ttname"><a href="namespaceigl.html#a73748b03f3e779d764d30d920653aba6">igl::dated_copy</a></div><div class="ttdeci">bool dated_copy(const std::string &amp;src_path, const std::string &amp;dir)</div><div class="ttdoc">Copy the given file to a new file with the same basename in dir directory with the current date and t...</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad50bddf10510ab0ef1bda0bb11641fef" name="ad50bddf10510ab0ef1bda0bb11641fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50bddf10510ab0ef1bda0bb11641fef">&#9670;&#160;</a></span>dated_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::dated_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Uses current working directory. </p>

</div>
</div>
<a id="a48e2a2c1ae537d160f7767a230be66b3" name="a48e2a2c1ae537d160f7767a230be66b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e2a2c1ae537d160f7767a230be66b3">&#9670;&#160;</a></span>decimate() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::decimate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of faces is achieved. </p>
<p>This uses default edge cost and merged vertex placement functions {edge length, edge midpoint}.</p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">include/igl/decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_m</td><td>desired number of output faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#U by dim list of output vertex posistions (can be same ref as V) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of output face indices into U (can be same ref as G) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G list of indices into F of birth face </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#U list of indices into V of birth vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if m was reached (otherwise #G &gt; m) </dd></dl>

</div>
</div>
<a id="a012dde4236352501b14abc42b746906e" name="a012dde4236352501b14abc42b746906e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012dde4236352501b14abc42b746906e">&#9670;&#160;</a></span>decimate() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::decimate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a61885a8ab4cc1e4ed8ed1fba6e42ecb6" name="a61885a8ab4cc1e4ed8ed1fba6e42ecb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61885a8ab4cc1e4ed8ed1fba6e42ecb6">&#9670;&#160;</a></span>decimate() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::decimate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>stopping_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>pre_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>post_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapses edges of a <b>closed manifold mesh</b> (V,F) using user defined callbacks in a priority queue. </p>
<p>Functions control the cost and placement of each collapse the stopping criteria for queue processing and the callbacks for pre and post collapse operations. See the first implementation in decimate.cpp for an example of how to deal with open/non-manifold meshes and how to adjust cost and placement functions accordingly.</p>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">include/igl/decimate.h</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cost_and_placement</td><td>function computing cost of collapsing an edge and 3d position where it should be placed: cost_and_placement(V,F,E,EMAP,EF,EI,cost,placement); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stopping_condition</td><td>function returning whether to stop collapsing edges based on current state. Guaranteed to be called after <em>successfully</em> collapsing edge e removing edges (e,e1,e2) and faces (f1,f2): bool should_stop = stopping_condition(V,F,E,EMAP,EF,EI,Q,Qit,C,e,e1,e2,f1,f2); </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pre_collapse</td><td>callback called with index of edge whose collapse is about to be attempted (see collapse_edge) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">post_collapse</td><td>callback called with index of edge whose collapse was just attempted and a flag revealing whether this was successful (see collapse_edge) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#U by dim list of output vertex posistions (can be same ref as V) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of output face indices into U (can be same ref as G) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G list of indices into F of birth face </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#U list of indices into V of birth vertices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if m was reached (otherwise #G &gt; m)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a6c8cf9368d76d69d41ea95bc5b4fd13b" title="Connect all boundary edges to a fictitious point at infinity.">connect_boundary_to_infinity</a></dd></dl>

</div>
</div>
<a id="a8e383abbd367d0ed68c602a7ae7ea2f7" name="a8e383abbd367d0ed68c602a7ae7ea2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e383abbd367d0ed68c602a7ae7ea2f7">&#9670;&#160;</a></span>decimate() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::decimate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>stopping_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>pre_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>post_collapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa716c4de65ed56fd9f9968f9d79ee657" name="aa716c4de65ed56fd9f9968f9d79ee657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa716c4de65ed56fd9f9968f9d79ee657">&#9670;&#160;</a></span>decimate() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::decimate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>stopping_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a199e2a88dcf8d16e8b0244d20e4743c1" name="a199e2a88dcf8d16e8b0244d20e4743c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199e2a88dcf8d16e8b0244d20e4743c1">&#9670;&#160;</a></span>decimate_trivial_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::decimate_trivial_callbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#af695d0b4a424387592b06f466a86088e">decimate_pre_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>always_try</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a16fd55ae4f3085d4ed4d3c6bff008426">decimate_post_collapse_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>never_care</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to build trivial pre and post collapse actions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">always_try</td><td>function that always returns true (always attempt the next edge collapse) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">never_care</td><td>fuction that is always a no-op (never have a post collapse response) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa03c54b4a3c8a07853528d49455f4fcc" name="aa03c54b4a3c8a07853528d49455f4fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03c54b4a3c8a07853528d49455f4fcc">&#9670;&#160;</a></span>default_num_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int igl::default_num_threads </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>force_num_threads</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default number of threads used in libigl. </p>
<p>The value returned by the first call to this function is cached. The following strategy is used to determine the default number of threads:</p><ol type="1">
<li>User-provided argument force_num_threads if != 0.</li>
<li>Environment variable IGL_NUM_THREADS if &gt; 0.</li>
<li>Hardware concurrency if != 0.</li>
<li>A fallback value of 8 is used otherwise.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>It is safe to call this method from multiple threads.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">force_num_threads</td><td>User-provided default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Default number of threads. </dd></dl>

</div>
</div>
<a id="a5819845b8bcf251d5e25bc93bf425e35" name="a5819845b8bcf251d5e25bc93bf425e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5819845b8bcf251d5e25bc93bf425e35">&#9670;&#160;</a></span>deform_skeleton() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::deform_skeleton </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Affine3d, Eigen::aligned_allocator&lt; Eigen::Affine3d &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>CT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BET</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deform a skeleton. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C by 3 list of joint positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BE</td><td>#BE by 2 list of bone edge indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vA</td><td>#BE list of bone transformations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CT</td><td>#BE*2 by 3 list of deformed joint positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BET</td><td>#BE by 2 list of bone edge indices (maintains order) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a473e4f58cfd34838b53114e315604728" name="a473e4f58cfd34838b53114e315604728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473e4f58cfd34838b53114e315604728">&#9670;&#160;</a></span>deform_skeleton() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::deform_skeleton </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>CT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BET</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#BE*4 by 3 list of stacked transformation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad85b334c412de101ce6003dabbd6ad70" name="ad85b334c412de101ce6003dabbd6ad70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85b334c412de101ce6003dabbd6ad70">&#9670;&#160;</a></span>delaunay_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename Orient2D , typename InCircle , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::delaunay_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Orient2D&#160;</td>
          <td class="paramname"><em>orient2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InCircle&#160;</td>
          <td class="paramname"><em>incircle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in 2D, return a Delaunay triangulation of these points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orient2D</td><td>A functor such that orient2D(pa, pb, pc) returns 1 if pa,pb,pc forms a conterclockwise triangle. -1 if pa,pb,pc forms a clockwise triangle. 0 if pa,pb,pc are collinear. where the argument pa,pb,pc are of type Scalar[2]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">incircle</td><td>A functor such that incircle(pa, pb, pc, pd) returns 1 if pd is on the positive size of circumcirle of (pa,pb,pc) -1 if pd is on the positive size of circumcirle of (pa,pb,pc) 0 if pd is cocircular with pa, pb, pc. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 of faces in Delaunay triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bed0a54e4a3d573a8ca709f613d2b8c" name="a9bed0a54e4a3d573a8ca709f613d2b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bed0a54e4a3d573a8ca709f613d2b8c">&#9670;&#160;</a></span>dfs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedD , typename DerivedP , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dfs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; AType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse a <b>directed</b> graph represented by an adjacency list using depth first search. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#V list of adjacency lists </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>starting node (index into A) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#V list of indices into rows of A in the order in which graph nodes are discovered. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#V list of indices into rows of A of predecessor in resulting spanning tree {-1 indicates root/not discovered), order corresponds to V <b>not</b> D. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#V list of indices into rows of A in order that nodes are "closed" (all descendants have been discovered) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95618dab6ef7c11351e352297c2d77fc" name="a95618dab6ef7c11351e352297c2d77fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95618dab6ef7c11351e352297c2d77fc">&#9670;&#160;</a></span>dfs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DType , typename PType , typename CType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dfs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; AType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; DType &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PType &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CType &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae1d2eff20a5c7b15bbe61a1d53eadc9b" name="ae1d2eff20a5c7b15bbe61a1d53eadc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1d2eff20a5c7b15bbe61a1d53eadc9b">&#9670;&#160;</a></span>dihedral_angles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename Derivedtheta , typename Derivedcos_theta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dihedral_angles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedtheta &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedcos_theta &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute dihedral angles for all tets of a given tet mesh (V,T). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#V by 4 list of tet indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">theta</td><td>#T by 6 list of dihedral angles (in radians) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cos_theta</td><td>#T by 6 list of cosine of dihedral angles (in radians) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8fd16e614bedafbd69fa739a29a7622" name="af8fd16e614bedafbd69fa739a29a7622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8fd16e614bedafbd69fa739a29a7622">&#9670;&#160;</a></span>dihedral_angles_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename DerivedA , typename Derivedtheta , typename Derivedcos_theta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dihedral_angles_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedtheta &gt; &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedcos_theta &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Intrinsic version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#L by 6 list of edge lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by 4 list of face areas </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b06e5e2a37a01b6648acb209437f78" name="a16b06e5e2a37a01b6648acb209437f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b06e5e2a37a01b6648acb209437f78">&#9670;&#160;</a></span>dijkstra() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename DerivedD , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::dijkstra </td>
          <td>(</td>
          <td class="paramtype">const IndexType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dijkstra's algorithm for vertex-weighted shortest paths, with multiple targets. </p>
<p>Adapted from <a href="http://rosettacode.org/wiki/Dijkstra%27s_algorithm">http://rosettacode.org/wiki/Dijkstra%27s_algorithm</a> .</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>index of source vertex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">targets</td><td>target vector set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VV</td><td>#V list of lists of incident vertices (adjacency list), e.g. as returned by <a class="el" href="namespaceigl.html#a4c905c0e9124bb38a79769497fa9b48b" title="Constructs the graph adjacency list of a given mesh (V,F)">igl::adjacency_list</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>#V list of scalar vertex weights </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">min_distance</td><td>#V by 1 list of the minimum distances from source to all vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">previous</td><td>#V by 1 list of the previous visited vertices (for each vertex) - used for backtracking </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a2bd7c3c9affbdcd476b68cfe36a41d" name="a5a2bd7c3c9affbdcd476b68cfe36a41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2bd7c3c9affbdcd476b68cfe36a41d">&#9670;&#160;</a></span>dijkstra() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename DerivedV , typename DerivedD , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::dijkstra </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad95f2745c0d523d9b1b8d7b7ef2707b9" name="ad95f2745c0d523d9b1b8d7b7ef2707b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95f2745c0d523d9b1b8d7b7ef2707b9">&#9670;&#160;</a></span>dijkstra() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename DerivedD , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::dijkstra </td>
          <td>(</td>
          <td class="paramtype">const IndexType &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>targets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a574a508288788ba1c5a7c8c2adbd0c33" name="a574a508288788ba1c5a7c8c2adbd0c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574a508288788ba1c5a7c8c2adbd0c33">&#9670;&#160;</a></span>dijkstra() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dijkstra </td>
          <td>(</td>
          <td class="paramtype">const IndexType &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>previous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Backtracking after Dijkstra's algorithm, to find shortest path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>vertex to which we want the shortest path (from same source as above) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">previous</td><td>#V by 1 list of the previous visited vertices (for each vertex) - result of Dijkstra's algorithm </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">path</td><td>#P by 1 list of vertex indices in the shortest path from vertex to source </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24aaa9b2bd870165bee8f9c18c826496" name="a24aaa9b2bd870165bee8f9c18c826496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aaa9b2bd870165bee8f9c18c826496">&#9670;&#160;</a></span>direct_delta_mush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedOmega , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::direct_delta_mush </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Affine3d, Eigen::aligned_allocator&lt; Eigen::Affine3d &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOmega &gt; &amp;&#160;</td>
          <td class="paramname"><em>Omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes Direct Delta Mush Skinning (Variant 0) from "Direct Delta Mush
Skinning and Variants". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of rest pose vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T list of bone pose transformations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Omega</td><td>#V by #T*10 list of precomputated matrix values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#V by 3 list of output vertex positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48dbae56ef5784518387be01caf9bb5c" name="a48dbae56ef5784518387be01caf9bb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48dbae56ef5784518387be01caf9bb5c">&#9670;&#160;</a></span>direct_delta_mush_precomputation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedW , typename DerivedOmega &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::direct_delta_mush_precomputation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOmega &gt; &amp;&#160;</td>
          <td class="paramname"><em>Omega</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precomputation for Direct Delta Mush Skinning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of rest pose vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#V by #Edges list of weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>number of smoothing iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>rotation smoothing step size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kappa</td><td>translation smoothness step size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>translation smoothness blending weight </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Omega</td><td>#V by #T*10 list of precomputated matrix values</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="direct__delta__mush_8h.html">include/igl/direct_delta_mush.h</a> </p>

</div>
</div>
<a id="a72a57e1816cf4b6448d72f2f98b5e071" name="a72a57e1816cf4b6448d72f2f98b5e071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a57e1816cf4b6448d72f2f98b5e071">&#9670;&#160;</a></span>directed_edge_orientations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::directed_edge_orientations </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine rotations that take each edge from the x-axis to its given rest orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C by 3 list of edge vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of directed edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#E list of quaternions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8de9b7859fbf82291598bae63e47550" name="af8de9b7859fbf82291598bae63e47550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8de9b7859fbf82291598bae63e47550">&#9670;&#160;</a></span>directed_edge_parents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedE , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::directed_edge_parents </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recover "parents" (preceding edges) in a tree given just directed edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of directed edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#E list of parent indices into E (-1) means root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef1ff1d390be65861384b6ff764ebe09" name="aef1ff1d390be65861384b6ff764ebe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1ff1d390be65861384b6ff764ebe09">&#9670;&#160;</a></span>dirname()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::dirname </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function like PHP's dirname: /etc/passwd --&gt; /etc,. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>string containing input path </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing dirname (see php's dirname)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#aa32f08d2b80c8d69515001b7d6347e82" title="Extract basename of file path (like PHP&#39;s basename).">basename</a>, <a class="el" href="namespaceigl.html#a541dccb34e02684e3d43966fca86bdaf" title="Function like PHP&#39;s pathinfo to return information about path.">pathinfo</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function will have undefined behavior if <b>file names</b> in the path contain \ and / characters. This function interprets \ and / as file path separators. </dd></dl>

</div>
</div>
<a id="a3bdaab27eb4626ff5685a3a4f9347b6a" name="a3bdaab27eb4626ff5685a3a4f9347b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdaab27eb4626ff5685a3a4f9347b6a">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::dot </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes out = dot(a,b) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>left 3d vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>right 3d vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scalar dot product </dd></dl>

</div>
</div>
<a id="a23322b4cdcba5a31a7e95dc0a29b83f1" name="a23322b4cdcba5a31a7e95dc0a29b83f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23322b4cdcba5a31a7e95dc0a29b83f1">&#9670;&#160;</a></span>dot_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedV igl::dot_row </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the dot product between each row of A and B. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived from vertex positions matrix type: i.e. MatrixXd </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>eigen matrix r by c </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>eigen matrix r by c </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>a column vector with r entries that contains the dot product of each corresponding row of A and B</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Unfortunately, Eigen does not support <code>A.rowwise().dot(B.rowwise())</code> so this function is a wrapper around the less obvious and less convenient <code>(A.array() * B.array()).rowwise().<a class="el" href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734" title="Sum the columns or rows of a sparse matrix.">sum()</a></code>. </dd></dl>

</div>
</div>
<a id="a7bae61a0f8a1bbe72e7832381c9beca5" name="a7bae61a0f8a1bbe72e7832381c9beca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bae61a0f8a1bbe72e7832381c9beca5">&#9670;&#160;</a></span>doublearea() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DeriveddblA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::doublearea </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dblA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes twice the area for each input triangle or quad. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived type of eigen matrix for V (e.g. derived from MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived type of eigen matrix for F (e.g. derived from MatrixXi) </td></tr>
    <tr><td class="paramname">DeriveddblA</td><td>derived type of eigen matrix for dblA (e.g. derived from MatrixXd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh faces (must be triangles or quads) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dblA</td><td>#F list of triangle[quad] double areas (SIGNED only for 2D input)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb2512ac1588eb6929dee61b2fb70955" name="adb2512ac1588eb6929dee61b2fb70955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2512ac1588eb6929dee61b2fb70955">&#9670;&#160;</a></span>doublearea() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::doublearea </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the twice the signed area of a each triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#F by dim list of triangle corner positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#F by dim list of triangle corner positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#F by dim list of triangle corner positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#F list of triangle double areas </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aace08ffa72a43a1758a45fe097625aef" name="aace08ffa72a43a1758a45fe097625aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace08ffa72a43a1758a45fe097625aef">&#9670;&#160;</a></span>doublearea_single()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedA::Scalar igl::doublearea_single </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the twice the signed area of a single triangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>triangle corner position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>triangle corner position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>triangle corner position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2*signed area of triangle</dd></dl>
<p><a class="el" href="doublearea_8h.html">include/igl/doublearea.h</a> </p>

</div>
</div>
<a id="aa4f3fcc3d502d79e4617250e0ea85ef6" name="aa4f3fcc3d502d79e4617250e0ea85ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f3fcc3d502d79e4617250e0ea85ef6">&#9670;&#160;</a></span>doublearea() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DeriveddblA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::doublearea </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derivedl::Scalar&#160;</td>
          <td class="paramname"><em>nan_replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dblA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute twice the area of each intrinsic triangle in a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#F by dim list of edge lengths using for triangles, columns correspond to edges 23,31,12 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nan_replacement</td><td>what value should be used for triangles whose given edge lengths do not obey the triangle inequality. These may be very wrong (e.g., [100 1 1]) or may be nearly degenerate triangles whose floating point side length computation leads to breach of the triangle inequality. One may wish to set this parameter to 0 if side lengths l are <em>known</em> to come from a valid embedding (e.g., some mesh (V,F)). In that case, the only circumstance the triangle inequality is broken is when the triangle is nearly degenerate and floating point error dominates: hence replacing with zero is reasonable. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dblA</td><td>#F list of triangle double areas </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fcad7016d7021778f7ec4ff91cec557" name="a0fcad7016d7021778f7ec4ff91cec557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcad7016d7021778f7ec4ff91cec557">&#9670;&#160;</a></span>doublearea() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DeriveddblA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::doublearea </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dblA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>default behavior is to assert on NaNs and leave them in place </p>

</div>
</div>
<a id="a516b190062ec90a40ecce7a721951303" name="a516b190062ec90a40ecce7a721951303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516b190062ec90a40ecce7a721951303">&#9670;&#160;</a></span>doublearea_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DeriveddblA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::doublearea_quad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveddblA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dblA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes twice the area for each input quadrilateral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh faces (must be quadrilaterals) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dblA</td><td>#F list of quadrilateral double areas</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="doublearea_8h.html">include/igl/doublearea.h</a> </p>

</div>
</div>
<a id="ae135ef705d377be39be52549ba816de4" name="ae135ef705d377be39be52549ba816de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae135ef705d377be39be52549ba816de4">&#9670;&#160;</a></span>dqs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedW , typename Q , typename QAlloc , typename T , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dqs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Q, QAlloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>vQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dual quaternion skinning. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of rest positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#W by #C list of weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vQ</td><td>#C list of rotation quaternions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vT</td><td>#C list of translation vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#V by 3 list of new positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac43379fb55c1019ff88c726aacb64b91" name="ac43379fb55c1019ff88c726aacb64b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43379fb55c1019ff88c726aacb64b91">&#9670;&#160;</a></span>dual_contouring() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dual_contouring </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; typename DerivedV::Scalar(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt;(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>min_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>max_corner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constrained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>root_finding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dual contouring to extract a pure quad mesh from differentiable implicit function using a dense grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function returning &gt;0 outside, &lt;0 inside and =0 on the surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_grad</td><td>function returning ∇f/‖∇f‖ </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_corner</td><td>position of primal grid vertex at minimum corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_corner</td><td>position of primal grid vertex at maximum corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>number of vertices on x side of primal grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>number of vertices on y side of primal grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>number of vertices on z side of primal grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constrained</td><td>whether to force dual vertices to lie strictly inside corresponding primal cell (prevents self-intersections at cost of surface quality; marginally slower) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangles</td><td>whether to output four triangles instead of one quad per crossing edge (quad mesh usually looks fine) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_finding</td><td>whether to use root finding to identify crossing point on each edge (improves quality a lot at cost of performance). If false, use linear interpolation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of outputs vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#Q by 4 (or 3 if triangles=true) face indices into rows of V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab912fd8e785a570ce48146acf3c84597" name="ab912fd8e785a570ce48146acf3c84597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab912fd8e785a570ce48146acf3c84597">&#9670;&#160;</a></span>dual_contouring() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedGf , typename DerivedGV , typename DerivedV , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dual_contouring </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; typename DerivedV::Scalar(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt;(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGf &gt; &amp;&#160;</td>
          <td class="paramname"><em>Gf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constrained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>root_finding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Gf</td><td>nx*ny*nz list of function values so that Gf(k) = f(GV.row(k)) (only needs to be accurate near f=0 and correct sign elsewhere) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GV</td><td>nx*ny*nz list of grid positions so that the x,y,z grid position is at GV.row(x+nx*(y+z*ny)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab25bc6339ed9e928df2fcb7bd20ef7e" name="aab25bc6339ed9e928df2fcb7bd20ef7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab25bc6339ed9e928df2fcb7bd20ef7e">&#9670;&#160;</a></span>dual_contouring() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedGf , typename DerivedGV , typename DerivedGI , typename DerivedV , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::dual_contouring </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; typename DerivedV::Scalar(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt;(const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f_grad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; typename DerivedV::Scalar, 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGf &gt; &amp;&#160;</td>
          <td class="paramname"><em>Gf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGI &gt; &amp;&#160;</td>
          <td class="paramname"><em>GI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constrained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>root_finding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Sparse voxel grid</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Gf</td><td>#GV list of corresponding f values. If using root finding then only the sign needs to be correct. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GV</td><td>#GV by 3 list of sparse grid positions referenced by GI </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GI</td><td>#GI by 2 list of edge indices into rows of GV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a484fcecc222d6c50ff16fe61ff820a80" name="a484fcecc222d6c50ff16fe61ff820a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484fcecc222d6c50ff16fe61ff820a80">&#9670;&#160;</a></span>ears()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Derivedear , typename Derivedear_opp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ears </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedear &gt; &amp;&#160;</td>
          <td class="paramname"><em>ear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedear_opp &gt; &amp;&#160;</td>
          <td class="paramname"><em>ear_opp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all ears (faces with two boundary edges) in a given mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle mesh indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ears</td><td><a class="el" href="namespaceigl.html#a484fcecc222d6c50ff16fe61ff820a80" title="Find all ears (faces with two boundary edges) in a given mesh.">ears</a> list of indices into F of ears </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ear_opp</td><td><a class="el" href="namespaceigl.html#a484fcecc222d6c50ff16fe61ff820a80" title="Find all ears (faces with two boundary edges) in a given mesh.">ears</a> list of indices indicating which edge is non-boundary (connecting to flops) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa77cd5878fb81e389480d12080f8679c" name="aa77cd5878fb81e389480d12080f8679c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77cd5878fb81e389480d12080f8679c">&#9670;&#160;</a></span>edge_collapse_is_valid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::edge_collapse_is_valid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology. </p>
<p>Assumes (V,F) is a closed manifold mesh (except for previouslly collapsed faces which should be set to: [IGL_COLLAPSE_EDGE_NULL IGL_COLLAPSE_EDGE_NULL IGL_COLLAPSE_EDGE_NULL].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of edge to try to collapse. E(e,:) = [s d] or [d s] so that s&lt;d, then d is collapsed to s. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if edge collapse is valid </dd></dl>

</div>
</div>
<a id="a4449e689db8a9360f41451ad4980b354" name="a4449e689db8a9360f41451ad4980b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4449e689db8a9360f41451ad4980b354">&#9670;&#160;</a></span>edge_collapse_is_valid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::edge_collapse_is_valid </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nsv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ndv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether collapsing exactly two faces and exactly 3 edges from E (e and one side of each face gets collapsed to the other) will result in a mesh with the same topology. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Nsv</td><td>#Nsv list of "next" vertices circulating around starting vertex of edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ndv</td><td>#Ndv list of "next" vertices circulating around destination vertex of edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Nsv</td><td>(side-effect: sorted by value) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ndv</td><td>(side-effect: sorted by value) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff edge collapse is valid</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ad2779ad7549dc5da4bed4c7042e2f780" title="Return list of faces around the end point of an edge.">circulation</a> </dd></dl>

</div>
</div>
<a id="a0cf37d2a8f8c08387438a60ba3bcb2ca" name="a0cf37d2a8f8c08387438a60ba3bcb2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf37d2a8f8c08387438a60ba3bcb2ca">&#9670;&#160;</a></span>edge_crossings()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeriveduE , typename DerivedS , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_crossings </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; int, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the each point that a scalar field crosses a specified value along an edge of a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#E by 2 list of edge indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#V by 1 list of scalar field values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to check for crossings </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE2I</td><td>#T map from edge index to index in T </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#T by 1 list of parametric coordinates of crossings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a24e807a90c41e3a89ee0171b1518c27d" title="Compute isolines of a scalar field on a triangle mesh.">isolines</a>, <a class="el" href="namespaceigl.html#a616f5985cbb36acb190f207f9dff82df" title="Compute isolines of a scalar field on a triangle mesh intrinsically.">isolines_intrinsic</a> </dd></dl>

</div>
</div>
<a id="a6c1b6d5e7d874099d4260df5291e63e7" name="a6c1b6d5e7d874099d4260df5291e63e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1b6d5e7d874099d4260df5291e63e7">&#9670;&#160;</a></span>edge_exists_near()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeriveduE , typename DerivedEMAP , typename uE2EType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::edge_exists_near </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>uei</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does edge (a,b) exist in the edges of all faces incident on existing unique edge uei. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of unique undirected edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique undirected edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F*3 by 2 list of half-edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>1st end-point of query edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>2nd end-point of query edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uei</td><td>index into uE/uE2E of unique edge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if edge exists near uei.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">unique_edge_map</a> </dd></dl>

</div>
</div>
<a id="a984c604c49a10f557933850d8c8e2a76" name="a984c604c49a10f557933850d8c8e2a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c604c49a10f557933850d8c8e2a76">&#9670;&#160;</a></span>edge_flaps() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_flaps </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine "edge flaps": two faces on either side of a unique edge (assumes edge-manifold mesh) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique unique edge in uE </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">unique_edge_map</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>This seems to be a duplicate of <a class="el" href="edge__topology_8h.html">edge_topology.h</a> <div class="fragment"><div class="line"><a class="code hl_function" href="namespaceigl.html#a182268447e88dbae647fd2971598226a">igl::edge_topology</a>(V,F,etEV,etFE,etEF);</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a984c604c49a10f557933850d8c8e2a76">igl::edge_flaps</a>(F,efE,efEMAP,efEF,efEI);</div>
<div class="line">[~,I] = <a class="code hl_function" href="namespaceigl.html#aea54a5804527aa194785e403870ba7db">sort</a>(efE,2)</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc">all</a>( efE(sub2ind(size(efE),<a class="code hl_function" href="namespaceigl.html#af22441a0a5c291b8fd51ee68e5817c38">repmat</a>(1:size(efE,1),2,1)&#39;,I)) == etEV )</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc">all</a>( efEF(sub2ind(size(efE),<a class="code hl_function" href="namespaceigl.html#af22441a0a5c291b8fd51ee68e5817c38">repmat</a>(1:size(efE,1),2,1)&#39;,I)) == etEF )</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc">all</a>(efEMAP(sub2ind(size(F),<a class="code hl_function" href="namespaceigl.html#af22441a0a5c291b8fd51ee68e5817c38">repmat</a>(1:size(F,1),3,1)&#39;,<a class="code hl_function" href="namespaceigl.html#af22441a0a5c291b8fd51ee68e5817c38">repmat</a>([1 2 3],size(F,1),1))) == etFE(:,[2 3 1]))</div>
<div class="ttc" id="anamespaceigl_html_a182268447e88dbae647fd2971598226a"><div class="ttname"><a href="namespaceigl.html#a182268447e88dbae647fd2971598226a">igl::edge_topology</a></div><div class="ttdeci">void edge_topology(const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;EV, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;FE, Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;EF)</div><div class="ttdoc">Initialize Edges and their topological relations (assumes an edge-manifold mesh).</div></div>
<div class="ttc" id="anamespaceigl_html_a984c604c49a10f557933850d8c8e2a76"><div class="ttname"><a href="namespaceigl.html#a984c604c49a10f557933850d8c8e2a76">igl::edge_flaps</a></div><div class="ttdeci">void edge_flaps(const Eigen::MatrixXi &amp;F, const Eigen::MatrixXi &amp;uE, const Eigen::VectorXi &amp;EMAP, Eigen::MatrixXi &amp;EF, Eigen::MatrixXi &amp;EI)</div><div class="ttdoc">Determine &quot;edge flaps&quot;: two faces on either side of a unique edge (assumes edge-manifold mesh)</div></div>
<div class="ttc" id="anamespaceigl_html_abf8bd73fedf2cafd491f61084874c2cc"><div class="ttname"><a href="namespaceigl.html#abf8bd73fedf2cafd491f61084874c2cc">igl::all</a></div><div class="ttdeci">void all(const Eigen::SparseMatrix&lt; AType &gt; &amp;A, const int dim, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</div><div class="ttdoc">Check whether all values are logically true along a dimension.</div></div>
<div class="ttc" id="anamespaceigl_html_aea54a5804527aa194785e403870ba7db"><div class="ttname"><a href="namespaceigl.html#aea54a5804527aa194785e403870ba7db">igl::sort</a></div><div class="ttdeci">void sort(const Eigen::DenseBase&lt; DerivedX &gt; &amp;X, const int dim, const bool ascending, Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;Y, Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;IX)</div><div class="ttdoc">Sort the elements of a matrix X along a given dimension like matlabs sort function.</div></div>
<div class="ttc" id="anamespaceigl_html_af22441a0a5c291b8fd51ee68e5817c38"><div class="ttname"><a href="namespaceigl.html#af22441a0a5c291b8fd51ee68e5817c38">igl::repmat</a></div><div class="ttdeci">void repmat(const Eigen::MatrixBase&lt; DerivedA &gt; &amp;A, const int r, const int c, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;B)</div><div class="ttdoc">Replicate and tile a matrix.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a00745ad61704fb8a6dc941ebf003f628" name="a00745ad61704fb8a6dc941ebf003f628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00745ad61704fb8a6dc941ebf003f628">&#9670;&#160;</a></span>edge_flaps() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_flaps </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9b2b3d2e2b569256e7704f81859b4d2a" name="a9b2b3d2e2b569256e7704f81859b4d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2b3d2e2b569256e7704f81859b4d2a">&#9670;&#160;</a></span>edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a list of lengths of edges opposite each index in a face (triangle/tet) list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived from vertex positions matrix type: i.e. MatrixXd </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived from face indices matrix type: i.e. MatrixXi </td></tr>
    <tr><td class="paramname">DerivedL</td><td>derived from edge lengths matrix type: i.e. MatrixXd </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>eigen matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by (2|3|4) list of mesh simplex indices into rows of V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#F by {1|3|6} list of edge lengths for edges, column of lengths for triangles, columns correspond to edges [1,2],[2,0],[0,1] for tets, columns correspond to edges [3 0],[3 1],[3 2],[1 2],[2 0],[0 1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98288ab94dfbdf3104687419fe33b704" name="a98288ab94dfbdf3104687419fe33b704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98288ab94dfbdf3104687419fe33b704">&#9670;&#160;</a></span>edge_midpoints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedmps &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_midpoints </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedmps &gt; &amp;&#160;</td>
          <td class="paramname"><em>mps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the midpoints of edges in a triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient_halfedges. will be computed if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mps</td><td>|HE| list of edge midpoints</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ae76f879f4715d4a8596d28f12bc7161d" title="Orients halfedges for a triangle mesh, assigning them to a unique edge.">orient_halfedges</a> </dd></dl>

</div>
</div>
<a id="a182268447e88dbae647fd2971598226a" name="a182268447e88dbae647fd2971598226a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182268447e88dbae647fd2971598226a">&#9670;&#160;</a></span>edge_topology()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_topology </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>EV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>FE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>EF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize Edges and their topological relations (assumes an edge-manifold mesh). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions (unused) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EV</td><td>#Ex2 matrix storing the edge description as pair of indices to vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FE</td><td>#Fx3 matrix storing the Triangle-Edge relation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EF</td><td>#Ex2 matrix storing the Edge-Triangle relation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This seems to be a inferior duplicate of <a class="el" href="edge__flaps_8h.html">edge_flaps.h</a>:<ul>
<li>unused input parameter V</li>
<li>roughly 2x slower than edge_flaps</li>
<li>outputs less information: edge_flaps reveals corner opposite edge</li>
<li>FE uses non-standard and ambiguous order: FE(f,c) is merely an edge incident on corner c of face f. In contrast, edge_flaps's EMAP(f,c) reveals the edge <em>opposite</em> corner c of face f </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aeb415384505882dfd1de98f678d214a2" name="aeb415384505882dfd1de98f678d214a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb415384505882dfd1de98f678d214a2">&#9670;&#160;</a></span>edge_vectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool computePerpendicular = true, typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename DerivedvecParallel , typename DerivedvecPerpendicular &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_vectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedvecParallel &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecParallel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedvecPerpendicular &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecPerpendicular</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the normalized edge vectors for edges in a triangle mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">whether</td><td>to compute edge perpendiculars </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge, as computed with orient_halfedges. will be computed if not provided. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vecParallel</td><td>|HE| list of edge vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vecPerpendicular</td><td>|HE| list of vectors perpendicular to vec </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c252b86d3deff637414b045dce9d271" name="a7c252b86d3deff637414b045dce9d271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c252b86d3deff637414b045dce9d271">&#9670;&#160;</a></span>edge_vectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedoE , typename Derivedvec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edge_vectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedoE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedvec &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0efd6c6b371a55178d53cf0afacf34ee" name="a0efd6c6b371a55178d53cf0afacf34ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efd6c6b371a55178d53cf0afacf34ee">&#9670;&#160;</a></span>edges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a list of unique edges represented in a given mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by (3|4) list of mesh simplex indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2 list of edges in no particular order</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a705a8f51137d1dd807bbe517c0567735" title="Constructs the graph adjacency matrix of a given mesh (V,F)">adjacency_matrix</a> </dd></dl>

</div>
</div>
<a id="aa0ad8afcbeffbd52acd213150ef184cc" name="aa0ad8afcbeffbd52acd213150ef184cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ad8afcbeffbd52acd213150ef184cc">&#9670;&#160;</a></span>edges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedI , typename DerivedC , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a list of unique edges represented in a given polygon mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2 list of edges in no particular order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93abf38f4293f5e3010211137c9a6ea4" name="a93abf38f4293f5e3010211137c9a6ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93abf38f4293f5e3010211137c9a6ea4">&#9670;&#160;</a></span>edges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a list of unique edges represented in a given adjacency matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#V by #V symmetric adjacency matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2 list of edges in no particular order </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfa1bf0ca6473ee9234b38b59c90e800" name="acfa1bf0ca6473ee9234b38b59c90e800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa1bf0ca6473ee9234b38b59c90e800">&#9670;&#160;</a></span>edges_to_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedE , typename DerivedI , typename DerivedJ , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::edges_to_path </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of undirected, unique edges such that all form a single connected compoent with exactly 0 or 2 nodes with valence =1, determine the/a path visiting all nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of undirected edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#E+1 list of nodes in order tracing the chain (loop), if the output is a loop then I(1) == I(end) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#I-1 list of indices into E of edges tracing I </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#I-1 list of indices into columns of E {0,1} so that K(i) means that E(i,K(i)) comes before the other (i.e., E(i,3-K(i)) ). This means that I(i) == E(J(i),K(i)) for i&lt;#I, or I == E(sub2ind(size(E),J([1:end end]),[K;3-K(end)])))) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77bf75e3dc429d5ca9d830c137ac1b1f" name="a77bf75e3dc429d5ca9d830c137ac1b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bf75e3dc429d5ca9d830c137ac1b1f">&#9670;&#160;</a></span>eigs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Atype , typename Btype , typename DerivedU , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::eigs </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Atype &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Btype &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a39bb96a0597986315dc20d78ba46a50d">EigsType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>sU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>sS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the first/last k eigen pairs of the generalized eigen value problem: </p>
<pre class="fragment">A u = s B u
</pre><p> Solutions are approximate and sorted.</p>
<dl class="section note"><dt>Note</dt><dd>Ideally one should use ARPACK and the Eigen unsupported ARPACK module. This implementation does simple, naive power iterations.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1spectra.html#ad3d3fe017e5b3e83eaa8c9e997eceaf5" title="Act like MATLAB&#39;s eigs function.">spectra::eigs</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by #A symmetric matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#A by #A symmetric positive-definite matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of eigen pairs to compute </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>whether to extract from the high or low end </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sU</td><td>#A by k list of sorted eigen vectors (descending) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sS</td><td>k list of sorted eigen values (descending)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>only the 'sm' small magnitude eigen values are well supported </dd></dl>

</div>
</div>
<a id="ad059c2eefaa87bb31a2b03a1787f133d" name="ad059c2eefaa87bb31a2b03a1787f133d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad059c2eefaa87bb31a2b03a1787f133d">&#9670;&#160;</a></span>EPS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S_type igl::EPS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returning EPS for corresponding type. </p>

</div>
</div>
<a id="aba458ce3c4cbdd9d0cbb3c83b3a255c7" name="aba458ce3c4cbdd9d0cbb3c83b3a255c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba458ce3c4cbdd9d0cbb3c83b3a255c7">&#9670;&#160;</a></span>EPS_SQ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename S_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">S_type igl::EPS_SQ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function returning EPS_SQ for corresponding type. </p>

</div>
</div>
<a id="abfc53046d44a2c9f6c3c6e32cb3ae024" name="abfc53046d44a2c9f6c3c6e32cb3ae024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc53046d44a2c9f6c3c6e32cb3ae024">&#9670;&#160;</a></span>EPS&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespaceigl.html#ad059c2eefaa87bb31a2b03a1787f133d">igl::EPS</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d0aed7321fc747f72cd8f680826ed8e" name="a8d0aed7321fc747f72cd8f680826ed8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0aed7321fc747f72cd8f680826ed8e">&#9670;&#160;</a></span>EPS&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespaceigl.html#ad059c2eefaa87bb31a2b03a1787f133d">igl::EPS</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa724bd6d64eb6b639407db5b87f1ac64" name="aa724bd6d64eb6b639407db5b87f1ac64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa724bd6d64eb6b639407db5b87f1ac64">&#9670;&#160;</a></span>EPS_SQ&lt; float &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float <a class="el" href="namespaceigl.html#aba458ce3c4cbdd9d0cbb3c83b3a255c7">igl::EPS_SQ</a>&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e39a8d172ad95e01e3171a06a3a0bac" name="a5e39a8d172ad95e01e3171a06a3a0bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e39a8d172ad95e01e3171a06a3a0bac">&#9670;&#160;</a></span>EPS_SQ&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespaceigl.html#aba458ce3c4cbdd9d0cbb3c83b3a255c7">igl::EPS_SQ</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bda900bb61246ae8c8ec80881cf14c1" name="a4bda900bb61246ae8c8ec80881cf14c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bda900bb61246ae8c8ec80881cf14c1">&#9670;&#160;</a></span>euler_characteristic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::euler_characteristic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Euler characteristic of a given mesh (V,F) </p>
<p>χ = |V| - |E| + |F|</p>
<p>For example,</p><ul>
<li>a single triangle has 3 - 3 + 1 = 1</li>
<li>a tetrahedron has 4 - 6 + 4 = 2</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh faces (must be triangles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An int containing the Euler characteristic</dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is <a href="https://github.com/libigl/libigl/issues/2249#issue-1863608449">some confusion</a> over the standard definition of Euler characteristic. libigl's definition agrees with <a href="https://en.wikipedia.org/wiki/Euler_characteristic">wikipedia</a> and [David Eppstein's proofs](<a href="https://www.ics.uci.edu/~eppstein/junkyard/euler/all.html">https://www.ics.uci.edu/~eppstein/junkyard/euler/all.html</a>). </dd></dl>

</div>
</div>
<a id="addb59555ec8b85d9c5d492f449a24b4b" name="addb59555ec8b85d9c5d492f449a24b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb59555ec8b85d9c5d492f449a24b4b">&#9670;&#160;</a></span>exact_geodesic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVS , typename DerivedFS , typename DerivedVT , typename DerivedFT , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::exact_geodesic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVS &gt; &amp;&#160;</td>
          <td class="paramname"><em>VS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFS &gt; &amp;&#160;</td>
          <td class="paramname"><em>FS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVT &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFT &gt; &amp;&#160;</td>
          <td class="paramname"><em>FT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exact geodesic algorithm for triangular mesh with the implementation from <a href="https://code.google.com/archive/p/geodesic/">https://code.google.com/archive/p/geodesic/</a>, and the algorithm first described by Mitchell, Mount and Papadimitriou in 1987. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of 3D vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VS</td><td>#VS by 1 vector specifying indices of source vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FS</td><td>#FS by 1 vector specifying indices of source faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>#VT by 1 vector specifying indices of target vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FT</td><td>#FT by 1 vector specifying indices of target faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#VT+#FT by 1 vector of geodesic distances of each target w.r.t. the nearest one in the source set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>specifying a face as target/source means its center. </dd></dl>

</div>
</div>
<a id="adb99ccd45b42797c3490bf4dfefe9d02" name="adb99ccd45b42797c3490bf4dfefe9d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb99ccd45b42797c3490bf4dfefe9d02">&#9670;&#160;</a></span>example_fun()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Printable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::example_fun </td>
          <td>(</td>
          <td class="paramtype">const Printable &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an example of a function, it takes a templated parameter and shovels it into cout. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type that supports </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>some input of a Printable type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true for the sake of returning something </dd></dl>

</div>
</div>
<a id="ad617638bca753edfeed7b8cdb65794ad" name="ad617638bca753edfeed7b8cdb65794ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad617638bca753edfeed7b8cdb65794ad">&#9670;&#160;</a></span>exploded_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename DerivedEV , typename DerivedEF , typename DerivedI , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::exploded_view </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEV &gt; &amp;&#160;</td>
          <td class="paramname"><em>EV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEF &gt; &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tet-mesh, create a trivial surface mesh (4 triangles per tet) with each tet scaled individually and translated outward from the mesh's centroid, creating an exploded-view visualization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of tet mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T by 4 list of tet mesh indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>amount to scale each tet indvidually, typically (0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>amount to scale away from mesh's centroid, typically &gt;=1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EV</td><td>#T*4 by 3 list of output mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EF</td><td>#T*4 by 3 list of output triangle indices into rows of EV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#EV list of indices into V revealing birth parent </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#EF list of indices into F revealing birth parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af53e1e0ea4e1632ee9d5b5a6411093e2" name="af53e1e0ea4e1632ee9d5b5a6411093e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53e1e0ea4e1632ee9d5b5a6411093e2">&#9670;&#160;</a></span>extension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::extension </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract file extension from path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>path with an extension (path/to/foo.obj) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>extension without dot (obj)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a541dccb34e02684e3d43966fca86bdaf" title="Function like PHP&#39;s pathinfo to return information about path.">pathinfo</a>, <a class="el" href="namespaceigl.html#aa32f08d2b80c8d69515001b7d6347e82" title="Extract basename of file path (like PHP&#39;s basename).">basename</a>, <a class="el" href="namespaceigl.html#aef1ff1d390be65861384b6ff764ebe09" title="Function like PHP&#39;s dirname: /etc/passwd --&gt; /etc,.">dirname</a> </dd></dl>

</div>
</div>
<a id="a269a81c6ea4fcbc58882d48720e1a4f5" name="a269a81c6ea4fcbc58882d48720e1a4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269a81c6ea4fcbc58882d48720e1a4f5">&#9670;&#160;</a></span>exterior_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::exterior_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines boundary "edges" and also edges with an odd number of occurrences where seeing edge (i,j) counts as +1 and seeing the opposite edge (j,i) counts as -1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of "faces" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by simplex_size-1 list of exterior edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47866518a950145c0151a245889b502f" name="a47866518a950145c0151a245889b502f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47866518a950145c0151a245889b502f">&#9670;&#160;</a></span>exterior_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi igl::exterior_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9b637953696bc3821b0a15ebbd4b5105" name="a9b637953696bc3821b0a15ebbd4b5105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b637953696bc3821b0a15ebbd4b5105">&#9670;&#160;</a></span>extract_manifold_patches() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::extract_manifold_patches </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a set of maximal patches from a given mesh. </p>
<p>A maximal patch is a subset of the input faces that are connected via manifold edges; a patch is as large as possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list representing triangles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices of unique undirected edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumsums of directed edges sharing each unique edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#F*3 list of indices into E (see <code><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">igl::unique_edge_map</a></code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#F list of patch incides. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of manifold patches. </dd></dl>

</div>
</div>
<a id="ac86020caa06983927879da2393cf5095" name="ac86020caa06983927879da2393cf5095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86020caa06983927879da2393cf5095">&#9670;&#160;</a></span>extract_manifold_patches() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedEMAP , typename uE2EType , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::extract_manifold_patches </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a644f27405a7cb3bf6b00a451381e8210" name="a644f27405a7cb3bf6b00a451381e8210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644f27405a7cb3bf6b00a451381e8210">&#9670;&#160;</a></span>extract_manifold_patches() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::extract_manifold_patches </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4f66eca661e45dd9827bf7cae56c61ce" name="a4f66eca661e45dd9827bf7cae56c61ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f66eca661e45dd9827bf7cae56c61ce">&#9670;&#160;</a></span>extract_non_manifold_edge_curves()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedEMAP , typename uE2EType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::extract_non_manifold_edge_curves </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>curves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract non-manifold curves from a given mesh. </p>
<p>A non-manifold curves are a set of connected non-manifold edges that does not touch other non-manifold edges except at the end points. They are also maximal in the sense that they cannot be expanded by including more edges.</p>
<p>Assumes the input mesh have all self-intersection resolved. See igl::cgal::remesh_self_intersection for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list representing triangles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices of unique undirected edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">curves</td><td>An array of arrays of unique edge indices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7de3a366fede697c4cc178a8f36e30e" name="ad7de3a366fede697c4cc178a8f36e30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7de3a366fede697c4cc178a8f36e30e">&#9670;&#160;</a></span>face_areas() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::face_areas </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a list of face areas of faces opposite each index in a tet list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T by 3 list of tet mesh indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#T by 4 list of face areas corresponding to faces opposite vertices 0,1,2,3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7448c2f83363e1920d02fe6bcb12c5eb" name="a7448c2f83363e1920d02fe6bcb12c5eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7448c2f83363e1920d02fe6bcb12c5eb">&#9670;&#160;</a></span>face_areas() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::face_areas </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Compute tet-mesh face areas from edge lengths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#T by 6 list of tet-mesh edge lengths corresponding to edges [3 0],[3 1],[3 2],[1 2],[2 0],[0 1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41c2271033be3dc067310683ec802e22" name="a41c2271033be3dc067310683ec802e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41c2271033be3dc067310683ec802e22">&#9670;&#160;</a></span>face_areas() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::face_areas </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedL::Scalar&#160;</td>
          <td class="paramname"><em>doublearea_nan_replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">doublearea_nan_replacement</td><td>See <a class="el" href="doublearea_8h.html">doublearea.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4885ed7913bafcb653dade6c257a29e" name="aa4885ed7913bafcb653dade6c257a29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4885ed7913bafcb653dade6c257a29e">&#9670;&#160;</a></span>face_occurrences() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerF , typename IntegerC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::face_occurrences </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IntegerF &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; IntegerC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the occurances of each face (row) in a list of face indices (irrespecitive of order) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F list of counts</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>triangles/tets only (where ignoring order still gives simplex) </dd></dl>

</div>
</div>
<a id="a02c8ab57f00492797e93f9da9cf3c63e" name="a02c8ab57f00492797e93f9da9cf3c63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c8ab57f00492797e93f9da9cf3c63e">&#9670;&#160;</a></span>face_occurrences() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::face_occurrences </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af7aa77ffc481c82074bcdd0ae765c090" name="af7aa77ffc481c82074bcdd0ae765c090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7aa77ffc481c82074bcdd0ae765c090">&#9670;&#160;</a></span>faces_first() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF , typename VecI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::faces_first </td>
          <td>(</td>
          <td class="paramtype">const MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>RV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatF &amp;&#160;</td>
          <td class="paramname"><em>RF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecI &amp;&#160;</td>
          <td class="paramname"><em>IM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder vertices so that vertices in face list come before vertices that don't appear in the face list. </p>
<p>This is especially useful if the face list contains only surface faces and you want surface vertices listed before internal vertices</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatV</td><td>matrix for vertex positions, e.g. MatrixXd </td></tr>
    <tr><td class="paramname">MatF</td><td>matrix for face indices, e.g. MatrixXi </td></tr>
    <tr><td class="paramname">VecI</td><td>vector for index map, e.g. VectorXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td># vertices by 3 vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td># faces by 3 list of face indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RV</td><td># vertices by 3 vertex positions, order such that if the jth vertex is some face in F, and the kth vertex is not then j comes before k </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RF</td><td># faces by 3 list of face indices, reindexed to use RV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IM</td><td>#V by 1 list of indices such that: RF = IM(F) and RT = IM(T) and RV(IM,:) = V</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md12"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="comment">// Tet mesh in (V,T,F)</span></div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#af7aa77ffc481c82074bcdd0ae765c090">faces_first</a>(V,F,IM);</div>
<div class="line">T = T.unaryExpr(bind1st(mem_fun( <span class="keyword">static_cast&lt;</span>VectorXi::Scalar&amp;</div>
<div class="line">  (VectorXi::*)(VectorXi::Index)<span class="keyword">&gt;</span>(&amp;VectorXi::operator())),</div>
<div class="line">  &amp;IM)).eval();</div>
<div class="ttc" id="anamespaceigl_html_af7aa77ffc481c82074bcdd0ae765c090"><div class="ttname"><a href="namespaceigl.html#af7aa77ffc481c82074bcdd0ae765c090">igl::faces_first</a></div><div class="ttdeci">void faces_first(const MatV &amp;V, const MatF &amp;F, MatV &amp;RV, MatF &amp;RF, VecI &amp;IM)</div><div class="ttdoc">Reorder vertices so that vertices in face list come before vertices that don't appear in the face lis...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9e44af09a10d6457aa439a6afbb3a6b2" name="a9e44af09a10d6457aa439a6afbb3a6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e44af09a10d6457aa439a6afbb3a6b2">&#9670;&#160;</a></span>faces_first() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF , typename VecI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::faces_first </td>
          <td>(</td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecI &amp;&#160;</td>
          <td class="paramname"><em>IM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab3c84999e29d9e168fe33b0ca7f2b199" name="ab3c84999e29d9e168fe33b0ca7f2b199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c84999e29d9e168fe33b0ca7f2b199">&#9670;&#160;</a></span>facet_adjacency_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Atype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::facet_adjacency_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Atype &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a #F×#F adjacency matrix with A(i,j)&gt;0 indicating that faces i and j share an edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of facets </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#F by #F adjacency matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7823f08d518cb237ee3cb47bb03cdb6d" name="a7823f08d518cb237ee3cb47bb03cdb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7823f08d518cb237ee3cb47bb03cdb6d">&#9670;&#160;</a></span>facet_components() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::facet_components </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connected components of facets based on edge-edge adjacency. </p>
<p>For connected components on vertices see <a class="el" href="namespaceigl.html#ab8159118b103ccc116d788259917acdb" title="Compute connected components of a graph represented by an adjacency matrix.">igl::vertex_components</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F list of connected component ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of connected components </dd></dl>

</div>
</div>
<a id="a0320b3e4f5075ce62360f96080b57a92" name="a0320b3e4f5075ce62360f96080b57a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0320b3e4f5075ce62360f96080b57a92">&#9670;&#160;</a></span>facet_components() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTIndex , typename DerivedC , typename Derivedcounts &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::facet_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedcounts &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TT</td><td>#TT by 3 list of list of adjacency triangles (see <a class="el" href="triangle__triangle__adjacency_8h.html">triangle_triangle_adjacency.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>#C list of number of facets in each components </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772265419ff3f9f3c3716644191fa4ff" name="a772265419ff3f9f3c3716644191fa4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772265419ff3f9f3c3716644191fa4ff">&#9670;&#160;</a></span>false_barycentric_subdivision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::false_barycentric_subdivision </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>FD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refine the mesh by adding the barycenter of each face. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 coordinates of the vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VD</td><td>#V + #F by 3 coordinate of the vertices of the dual mesh The added vertices are added at the end of VD (should not be same references as (V,F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FD</td><td>#F*3 by 3 faces of the dual mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30b7f81580d0eb77cfa387adaa4e9c67" name="a30b7f81580d0eb77cfa387adaa4e9c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b7f81580d0eb77cfa387adaa4e9c67">&#9670;&#160;</a></span>fast_find_intersections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV1 , typename DerivedF1 , typename DerivedV2 , typename DerivedF2 , typename DerivedI , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_find_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersect_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify triangles where two meshes interesect using AABBTree and tri_tri_intersection_test_3d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>#V by 3 list representing vertices on the first mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F1</td><td>#F by 3 list representing triangles on the first mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V2</td><td>#V by 3 list representing vertices on the second mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F2</td><td>#F by 3 list representing triangles on the second mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersect_pairs</td><td>correspondance list of intersecting triangles column 0 - mesh 1, column 1 - mesh2 <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edges</td><td>list of pairs of intersection edges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aad0ee9bfc55573ac2ac722c5d6e6d8bc" title="Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces.">copyleft::cgal::intersect_other</a> </dd></dl>

</div>
</div>
<a id="a768af49174bc1daafe45f9eedda6eb8f" name="a768af49174bc1daafe45f9eedda6eb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768af49174bc1daafe45f9eedda6eb8f">&#9670;&#160;</a></span>fast_find_intersections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV1 , typename DerivedF1 , typename DerivedV2 , typename DerivedF2 , typename DerivedI , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_find_intersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersect_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>- <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree bult from the first mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f1a7f1d5201633025a2ac99846b1b78" name="a2f1a7f1d5201633025a2ac99846b1b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1a7f1d5201633025a2ac99846b1b78">&#9670;&#160;</a></span>fast_find_self_intersections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::fast_find_self_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identify triangles where mesh intersects itself using AABBTree and tri_tri_intersection_test_3d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list representing vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list representing triangles. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">intersect</td><td>#F by 1 indicator that triangle intersects anothe triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edges</td><td>list of pairs of intersection edges </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether any self-interections were found</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7169f4ae2fe2c11f7e878b41aa747fc2" title="Given a triangle mesh (V,F) compute a new mesh (VV,FF) which is the same as (V,F) except that any sel...">copyleft::cgal::remesh_self_intersections</a> </dd></dl>

</div>
</div>
<a id="aa607a0b8a29847a27f3e92685a652d51" name="aa607a0b8a29847a27f3e92685a652d51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa607a0b8a29847a27f3e92685a652d51">&#9670;&#160;</a></span>fast_find_self_intersections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::fast_find_self_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>intersect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af9a50987fefc0df065fb3e2cde90c92e" name="af9a50987fefc0df065fb3e2cde90c92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a50987fefc0df065fb3e2cde90c92e">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename DerivedCH , typename DerivedCM , typename DerivedR , typename DerivedEC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;&#160;</td>
          <td class="paramname"><em>CH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>expansion_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCM &gt; &amp;&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>EC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the precomputation for the fast winding number for point data [Barill et. </p>
<p>al 2018].</p>
<p>Given a set of 3D points P, with normals N, areas A, along with octree data, and an expansion order, we define a taylor series expansion at each octree cell.</p>
<p>The octree data is designed to come from <a class="el" href="namespaceigl.html#a3ff69240d0614e6f4ab20ff15b2f21a4" title="Given a set of 3D points P, generate data structures for a pointerless octree.">igl::octree</a>, and the areas (if not obtained at scan time), may be calculated using <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1240cef3d039ac518baca44025fe1adc" title="Given a 3D set of points P, each with a list of k-nearest-neighbours, estimate the geodesic voronoi a...">igl::copyleft::cgal::point_areas</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of point locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of point normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#P by 1 list of point areas </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_indices</td><td>a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell's points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CH</td><td>#OctreeCells by 8, where the ith row is the indices of the ith octree cell's children </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expansion_order</td><td>the order of the taylor expansion. We support 0,1,2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CM</td><td>#OctreeCells by 3 list of each cell's center of mass </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>#OctreeCells by 1 list of each cell's maximum distance of any point to the center of mass </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EC</td><td>#OctreeCells by #TaylorCoefficients list of expansion coefficients. (Note that #TaylorCoefficients = ∑_{i=1}^{expansion_order} 3^i)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1240cef3d039ac518baca44025fe1adc" title="Given a 3D set of points P, each with a list of k-nearest-neighbours, estimate the geodesic voronoi a...">copyleft::cgal::point_areas</a>, <a class="el" href="namespaceigl.html#a6f2969bd735df2588ce37026375ddefe" title="Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neigh...">knn</a> </dd></dl>

</div>
</div>
<a id="a9f25aa098c2a53832cc8d86022bf0691" name="a9f25aa098c2a53832cc8d86022bf0691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f25aa098c2a53832cc8d86022bf0691">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename Index , typename DerivedCH , typename DerivedCM , typename DerivedR , typename DerivedEC , typename DerivedQ , typename BetaType , typename DerivedWN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;&#160;</td>
          <td class="paramname"><em>CH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCM &gt; &amp;&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>EC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BetaType&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;&#160;</td>
          <td class="paramname"><em>WN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the fast winding number for point data, having already done the the precomputation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of point locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of point normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#P by 1 list of point areas </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_indices</td><td>a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell's points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CH</td><td>#OctreeCells by 8, where the ith row is the indices of the ith octree cell's children </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CM</td><td>#OctreeCells by 3 list of each cell's center of mass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>#OctreeCells by 1 list of each cell's maximum distance of any point to the center of mass </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EC</td><td>#OctreeCells by #TaylorCoefficients list of expansion coefficients. (Note that #TaylorCoefficients = ∑_{i=1}^{expansion_order} 3^i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by 3 list of query points for the winding number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>This is a Barnes-Hut style accuracy term that separates near feild from far field. The higher the beta, the more accurate and slower the evaluation. We reccommend using a beta value of 2. Note that for a beta value ≤ 0, we use the direct evaluation, rather than the fast approximation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WN</td><td>#Q by 1 list of windinng number values at each query point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a397e83be466a676e5e932eb176222024" name="a397e83be466a676e5e932eb176222024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397e83be466a676e5e932eb176222024">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename BetaType , typename DerivedWN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>expansion_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BetaType&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;&#160;</td>
          <td class="paramname"><em>WN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Evaluate the fast winding number for point data without caching the precomputation. </p>

</div>
</div>
<a id="ad8da00864c2893af6726906818520d94" name="ad8da00864c2893af6726906818520d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8da00864c2893af6726906818520d94">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedA , typename DerivedN , typename DerivedQ , typename DerivedWN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;&#160;</td>
          <td class="paramname"><em>WN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab8c8f607d6379a200ca2b06d48a177c7" name="ab8c8f607d6379a200ca2b06d48a177c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c8f607d6379a200ca2b06d48a177c7">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedQ , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute approximate winding number of a triangle soup mesh according to "Fast Winding Numbers for Soups and Clouds" [Barill et al. </p>
<p>2018].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle mesh indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by 3 list of query positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#Q list of winding number values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a903c781c6e83ef8f7cf2f8791a603cff" name="a903c781c6e83ef8f7cf2f8791a603cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903c781c6e83ef8f7cf2f8791a603cff">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FastWindingNumberBVH &amp;&#160;</td>
          <td class="paramname"><em>fwn_bvh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precomputation for computing approximate winding numbers of a triangle soup. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle mesh indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>Taylor series expansion order to use (e.g., 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fwn_bvh</td><td>Precomputed bounding volume hierarchy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82cd97bb9dcfdb31036cb2d61a8feec7" name="a82cd97bb9dcfdb31036cb2d61a8feec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cd97bb9dcfdb31036cb2d61a8feec7">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedQ , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const FastWindingNumberBVH &amp;&#160;</td>
          <td class="paramname"><em>fwn_bvh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>accuracy_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After precomputation, compute winding number at a each of many points in a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fwn_bvh</td><td>Precomputed bounding volume hierarchy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accuracy_scale</td><td>parameter controlling accuracy (e.g., 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by 3 list of query positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#Q list of winding number values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3142103ed9b3cdf64d5a81fbaa34dc4c" name="a3142103ed9b3cdf64d5a81fbaa34dc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3142103ed9b3cdf64d5a81fbaa34dc4c">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derivedp::Scalar igl::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const FastWindingNumberBVH &amp;&#160;</td>
          <td class="paramname"><em>fwn_bvh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>accuracy_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedp &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After precomputation, compute winding number at a single point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fwn_bvh</td><td>Precomputed bounding volume hierarchy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accuracy_scale</td><td>parameter controlling accuracy (e.g., 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>single position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>w winding number of this point </dd></dl>

</div>
</div>
<a id="a740022c998c2a894e28fb49bb7ed4d24" name="a740022c998c2a894e28fb49bb7ed4d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740022c998c2a894e28fb49bb7ed4d24">&#9670;&#160;</a></span>file_contents_as_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::file_contents_as_string </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a files contents as plain text into a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>path to file to be read </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">content</td><td>output string containing contents of the given file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on succes, false on error </dd></dl>

</div>
</div>
<a id="a555b9d7f83d39b3fc2dee6eabb79c0ec" name="a555b9d7f83d39b3fc2dee6eabb79c0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555b9d7f83d39b3fc2dee6eabb79c0ec">&#9670;&#160;</a></span>file_contents_as_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::file_contents_as_string </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a784c417892e831c40ced7805b23be275" name="a784c417892e831c40ced7805b23be275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784c417892e831c40ced7805b23be275">&#9670;&#160;</a></span>file_dialog_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::file_dialog_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file dialog to select a file. </p>
<dl class="section return"><dt>Returns</dt><dd>string with a path to an existing file or empty if no file is selected (on Linux machines, it assumes that Zenity is installed) </dd></dl>

</div>
</div>
<a id="a85f585cff929022ed45d00faee99eea3" name="a85f585cff929022ed45d00faee99eea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f585cff929022ed45d00faee99eea3">&#9670;&#160;</a></span>file_dialog_save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::file_dialog_save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a file dialog to select a file. </p>
<dl class="section return"><dt>Returns</dt><dd>string with a path to a new or existing file or empty if no file is selected (on Linux machines, it assumes that Zenity is installed) </dd></dl>

</div>
</div>
<a id="a63e14036599fdc6d4f6706d26a542e92" name="a63e14036599fdc6d4f6706d26a542e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e14036599fdc6d4f6706d26a542e92">&#9670;&#160;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file or directory exists like PHP's file_exists function: </p>
<p><a href="http://php.net/manual/en/function.file-exists.php">http://php.net/manual/en/function.file-exists.php</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>path to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if file exists and is readable and false if file doesn't exist or <em>is not readable</em> </dd></dl>

</div>
</div>
<a id="ad0ba264f987871035fb7d12de96fccab" name="ad0ba264f987871035fb7d12de96fccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ba264f987871035fb7d12de96fccab">&#9670;&#160;</a></span>find() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DerivedI , typename DerivedJ , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::DenseBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the non-zero entries and there respective indices in a sparse matrix. </p>
<p>Like matlab's [I,J,V] = find(X)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix whose entries are to be found </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>nnz vector of row indices of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>nnz vector of column indices of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>nnz vector of type T non-zeros entries in X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ed5d2d6c493023192c2b2f1c5ed0bf0" name="a7ed5d2d6c493023192c2b2f1c5ed0bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed5d2d6c493023192c2b2f1c5ed0bf0">&#9670;&#160;</a></span>find() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Eigen::Triplet&lt; T &gt; &gt; igl::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2f6c699f94449b23813f0d80df36db8e" name="a2f6c699f94449b23813f0d80df36db8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f6c699f94449b23813f0d80df36db8e">&#9670;&#160;</a></span>find() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedI , typename DerivedJ , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1c874cf1ad179744026898ded3da4ea7" name="a1c874cf1ad179744026898ded3da4ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c874cf1ad179744026898ded3da4ea7">&#9670;&#160;</a></span>find() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>nnz vector of indices into vectorization of X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6758ca13380f9bd099c860aba705d45" name="ab6758ca13380f9bd099c860aba705d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6758ca13380f9bd099c860aba705d45">&#9670;&#160;</a></span>find() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseVector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a35cd54b6c6bf02c39e4caf02782fcfbc" name="a35cd54b6c6bf02c39e4caf02782fcfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cd54b6c6bf02c39e4caf02782fcfbc">&#9670;&#160;</a></span>find() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int RowsAtCompileTime, int MaxRowsAtCompileTime&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; igl::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Array&lt; bool, RowsAtCompileTime, 1, 0, MaxRowsAtCompileTime, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This overload facilitates the use of bool masks for Eigen slicing </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowsAtCompileTime</td><td>number of rows in M at compile time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>indices of true entries in M</dd></dl>
<p><a class="anchor" id="autotoc_md13"></a> </p><h5>Example</h5>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespaceigl.html#acb30d6061d773254628256682b88b427">igl::slice_mask</a>(A,<a class="code hl_function" href="namespaceigl.html#ad0ba264f987871035fb7d12de96fccab">igl::find</a>(M),<a class="code hl_function" href="namespaceigl.html#ad0ba264f987871035fb7d12de96fccab">igl::find</a>(N),B);</div>
<div class="line"><span class="comment">// Is the same as</span></div>
<div class="line">B = A(<a class="code hl_function" href="namespaceigl.html#ad0ba264f987871035fb7d12de96fccab">igl::find</a>(M),<a class="code hl_function" href="namespaceigl.html#ad0ba264f987871035fb7d12de96fccab">igl::find</a>(N));</div>
<div class="ttc" id="anamespaceigl_html_acb30d6061d773254628256682b88b427"><div class="ttname"><a href="namespaceigl.html#acb30d6061d773254628256682b88b427">igl::slice_mask</a></div><div class="ttdeci">void slice_mask(const Eigen::SparseMatrix&lt; XType &gt; &amp;X, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;R, const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;C, Eigen::SparseMatrix&lt; YType &gt; &amp;Y)</div><div class="ttdoc">Act like the matlab X(row_mask,col_mask) operator, where row_mask, col_mask are non-negative integer ...</div></div>
<div class="ttc" id="anamespaceigl_html_ad0ba264f987871035fb7d12de96fccab"><div class="ttname"><a href="namespaceigl.html#ad0ba264f987871035fb7d12de96fccab">igl::find</a></div><div class="ttdeci">void find(const Eigen::SparseMatrix&lt; T &gt; &amp;X, Eigen::DenseBase&lt; DerivedI &gt; &amp;I, Eigen::DenseBase&lt; DerivedJ &gt; &amp;J, Eigen::DenseBase&lt; DerivedV &gt; &amp;V)</div><div class="ttdoc">Find the non-zero entries and there respective indices in a sparse matrix.</div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acb30d6061d773254628256682b88b427" title="Act like the matlab X(row_mask,col_mask) operator, where row_mask, col_mask are non-negative integer ...">slice_mask</a> </dd></dl>

</div>
</div>
<a id="abb0edb6d4f1aed375b757bdc5c273246" name="abb0edb6d4f1aed375b757bdc5c273246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0edb6d4f1aed375b757bdc5c273246">&#9670;&#160;</a></span>find_cross_field_singularities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find_cross_field_singularities </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>mismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>isSingularity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>singularityIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes singularities of a cross field, assumed combed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mismatch</td><td>#F by 3 eigen Matrix containing the integer mismatch of the cross field across all face edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isSingularity</td><td>#V by 1 boolean eigen Vector indicating the presence of a singularity on a vertex </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">singularityIndex</td><td>#V by 1 integer eigen Vector containing the singularity indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6081a94201c4aee0d64d44fb108b82b3" name="a6081a94201c4aee0d64d44fb108b82b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6081a94201c4aee0d64d44fb108b82b3">&#9670;&#160;</a></span>find_cross_field_singularities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find_cross_field_singularities </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>isSingularity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>singularityIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isCombed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper that calculates the mismatch if it is not provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1</td><td>#F by 3 eigen Matrix of the first per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD2</td><td>#F by 3 eigen Matrix of the second per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCombed</td><td>boolean indicating whether the cross field is combed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the field in PD1 and PD2 MUST BE combed (see <a class="el" href="namespaceigl.html#a42d3578aca0da0bea74041ca2b239c1d" title="Computes principal matchings of the vectors of a cross field across face edges, and generates a combe...">igl::comb_cross_field</a>). </dd></dl>

</div>
</div>
<a id="a805390aaedf0c7993e52697b46e85be8" name="a805390aaedf0c7993e52697b46e85be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805390aaedf0c7993e52697b46e85be8">&#9670;&#160;</a></span>find_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::find_zero </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first zero (whether implicit or explicitly stored) in the rows/columns of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to check for any (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>n-long vector (if dim == 1) {m means no zeros found} or m-long vector (if dim == 2) {n means no zeros found} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e61e6506e142c21944010806e350df3" name="a7e61e6506e142c21944010806e350df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e61e6506e142c21944010806e350df3">&#9670;&#160;</a></span>fit_cubic_bezier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::fit_cubic_bezier </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a cubic bezier spline (G1 continuous) to an ordered list of input points in any dimension, according to "An algorithm for automatically
fitting digitized curves" [Schneider 1990]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>#d by dim list of points along a curve to be fit with a cubic bezier spline (should probably be roughly uniformly spaced). If d(0)==d(end), then will treat as a closed curve. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>maximum squared distance allowed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cubics</td><td>#cubics list of 4 by dim lists of cubic control points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30fbe8999a386dbd7193683db1ed7ea7" name="a30fbe8999a386dbd7193683db1ed7ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fbe8999a386dbd7193683db1ed7ea7">&#9670;&#160;</a></span>fit_cubic_bezier_substring()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::fit_cubic_bezier_substring </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>tHat1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>tHat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_split</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive helper function for fit_cubic_bezier. </p>
<p><a class="el" href="fit__cubic__bezier_8h.html">include/igl/fit_cubic_bezier.h</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>index of first point in d of substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>index of last point in d of substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tHat1</td><td>tangent to use at beginning of spline </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tHat2</td><td>tangent to use at end of spline </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">error</td><td>see above </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force_split</td><td>whether to force a split (i.e., force a recursive call) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cubics</td><td>running list of cubics so far </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cubics</td><td>running list of cubics so far (new cubics appended) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade7e5fc6b5fac0540a715a429d1196da" name="ade7e5fc6b5fac0540a715a429d1196da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7e5fc6b5fac0540a715a429d1196da">&#9670;&#160;</a></span>fit_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::fit_plane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVector3d &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVector3d &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit a plane to a point cloud. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#Vx3 matrix. The 3D point cloud, one row for each vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>1x3 Vector. The normal of the fitted plane. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>1x3 Vector. A point that lies in the fitted plane.</td></tr>
  </table>
  </dd>
</dl>
<p>From <a href="http://missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html">http://missingbytes.blogspot.com/2012/06/fitting-plane-to-point-cloud.html</a> </p>

</div>
</div>
<a id="aab9cbb962b540c16acdca0c7d168345d" name="aab9cbb962b540c16acdca0c7d168345d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9cbb962b540c16acdca0c7d168345d">&#9670;&#160;</a></span>fit_rotations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fit_rotations </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>single_precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input mesh and new positions find rotations for every covariance matrix in a stack of covariance matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>nr*dim by dim stack of covariance matrices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">single_precision</td><td>whether to use single precision (faster) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>dim by dim * nr list of rotations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This seems to be implemented in Eigen/Geometry: Eigen::umeyama </dd></dl>

</div>
</div>
<a id="ac84591b34ac42f8f958c015edabec2d6" name="ac84591b34ac42f8f958c015edabec2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84591b34ac42f8f958c015edabec2d6">&#9670;&#160;</a></span>fit_rotations_planar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::fit_rotations_planar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an input mesh and new positions find 2D rotations for every vertex that best maps its one ring to the new one ring. </p>
<p><a class="el" href="fit__rotations_8h.html">include/igl/fit_rotations.h</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>nr*dim by dim stack of covariance matrices, third column and every third row will be ignored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>dim by dim * nr list of rotations, third row and third column of each rotation will just be identity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63ab7ae87908c83fc544443d41b87e5" name="ae63ab7ae87908c83fc544443d41b87e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63ab7ae87908c83fc544443d41b87e5">&#9670;&#160;</a></span>flip_avoiding_line_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::flip_avoiding_line_search </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>cur_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>dst_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(Eigen::MatrixXd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cur_energy</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A bisection line search for a mesh based energy that avoids triangle flips as suggested in "Bijective Parameterization with Free Boundaries" (Smith J. </p>
<p>and Schaefer S., 2015).</p>
<p>The user specifies an initial vertices position (that has no flips) and target one (that my have flipped triangles). This method first computes the largest step in direction of the destination vertices that does not incur flips, and then minimizes a given energy using this maximal step and a bisection linesearch (see <a class="el" href="namespaceigl.html#a9145bd261a2cf691294d8104c99a4ab9" title="Implement a bisection linesearch to minimize a mesh-based energy on vertices given at &#39;x&#39; at a search...">igl::line_search</a>).</p>
<p>Supports both triangle and tet meshes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/4 list of mesh faces or tets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cur_v</td><td>#V by dim list of variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dst_v</td><td>#V by dim list of target vertices. This mesh may have flipped triangles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">energy</td><td>A function to compute the mesh-based energy (return an energy that is bigger than 0) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cur_energy(OPTIONAL)</td><td>The energy at the given point. Helps save redundant computations. This is optional. If not specified, the function will compute it. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cur_v</td><td>#V by dim list of variables at the new location </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the energy at the new point </dd></dl>

</div>
</div>
<a id="ac891db77f570329431e6c333c3d08b26" name="ac891db77f570329431e6c333c3d08b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac891db77f570329431e6c333c3d08b26">&#9670;&#160;</a></span>flip_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2EType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::flip_edge </td>
          <td>(</td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>uei</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip an edge in a triangle mesh. </p>
<p>The edge specified by uei must have exactly <b>two</b> adjacent faces. Violation will result in exception. Another warning: edge flipping could convert manifold mesh into non-manifold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 list of triangles. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E</td><td>#F*3 by 2 list of all of directed edges </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uE</td><td>#uE by 2 list of unique undirected edges </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique undirected edge </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ue</td><td>index into uE the edge to be flipped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f82175bae9b6801c8c9012785317f2a" name="a6f82175bae9b6801c8c9012785317f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f82175bae9b6801c8c9012785317f2a">&#9670;&#160;</a></span>flipped_triangles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::flipped_triangles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the ids of the flipped triangles of the mesh V,F in the UV mapping uv. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>#flipped list of containing the indices into F of the flipped triangles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20a1df627820c7b21a02a7ec429af4e7" name="a20a1df627820c7b21a02a7ec429af4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a1df627820c7b21a02a7ec429af4e7">&#9670;&#160;</a></span>flipped_triangles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi igl::flipped_triangles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac512b1b084fa118f737ffc49db7a5ba6" name="ac512b1b084fa118f737ffc49db7a5ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac512b1b084fa118f737ffc49db7a5ba6">&#9670;&#160;</a></span>flood_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedres , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::flood_fill </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedres &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 3D array with sparse non-nan (number?) data fill in the NaNs via flood fill. </p>
<p>This should ensure that, e.g., if data near 0 always has a band (surface) of numbered and signed data, then components of nans will be correctly signed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>3-long list of dimensions of grid </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">S</td><td>res(0)*res(1)*res(2) list of scalar values (with (many) nans), flood fill data in place </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b113177cc099be08ae55cad66b4dcb" name="a52b113177cc099be08ae55cad66b4dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b113177cc099be08ae55cad66b4dcb">&#9670;&#160;</a></span>floor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::floor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Floor a given matrix to nearest integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix of scalars </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n matrix of floored integers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09311547ed4f12bee75c2631d2d19bfd" name="a09311547ed4f12bee75c2631d2d19bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09311547ed4f12bee75c2631d2d19bfd">&#9670;&#160;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void igl::for_each </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FOR_EACH Call a given function for each non-zero (i.e., explicit value might actually be ==0) in a Sparse Matrix A <em>in order (of storage)</em>. </p>
<p>This is useless unless func has <em>side-effects</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function handle with prototype "compatible with" <code>void (Index i, Index j, Scalar &amp; v)</code>. Return values will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>std::for_each </dd></dl>

</div>
</div>
<a id="a99ebd81ebaff178e507beedf87766722" name="a99ebd81ebaff178e507beedf87766722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ebd81ebaff178e507beedf87766722">&#9670;&#160;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void igl::for_each </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a583ee685a22b43577be16d088b6d3f29" name="a583ee685a22b43577be16d088b6d3f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583ee685a22b43577be16d088b6d3f29">&#9670;&#160;</a></span>forward_kinematics() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::forward_kinematics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>vT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a skeleton and a set of relative bone rotations compute absolute rigid transformations for each bone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C by dim list of joint positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BE</td><td>#BE by 2 list of bone edge indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#BE list of parent indices into BE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dQ</td><td>#BE list of relative rotations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dT</td><td>#BE list of relative translations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vQ</td><td>#BE list of absolute rotations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vT</td><td>#BE list of absolute translations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4346a6b4e9b7d07955fe6ab59399e82e" name="a4346a6b4e9b7d07955fe6ab59399e82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4346a6b4e9b7d07955fe6ab59399e82e">&#9670;&#160;</a></span>forward_kinematics() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::forward_kinematics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>vT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>assuming each dT[i] == {0,0,0} </p>

</div>
</div>
<a id="a9be847e42a2d294cdb9014c5b04d5649" name="a9be847e42a2d294cdb9014c5b04d5649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be847e42a2d294cdb9014c5b04d5649">&#9670;&#160;</a></span>forward_kinematics() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::forward_kinematics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Vector3d &gt; &amp;&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#BE*(dim+1) by dim stack of transposed transformation matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adedacc380a9c0e97fcb830413a407aee" name="adedacc380a9c0e97fcb830413a407aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedacc380a9c0e97fcb830413a407aee">&#9670;&#160;</a></span>forward_kinematics() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::forward_kinematics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>dQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2da75428de04db095ad2b8c01861d9e7" name="a2da75428de04db095ad2b8c01861d9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da75428de04db095ad2b8c01861d9e7">&#9670;&#160;</a></span>frame_field_deformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::frame_field_deformer </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>FF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>FF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>FF1_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>FF2_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>perturb_initial_guess</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deform a mesh to transform the given per-face frame field to be as close as possible to a cross field, in the least square sense. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 coordinates of the vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FF1</td><td>#F by 3 first representative vector of the frame field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FF2</td><td>#F by 3 second representative vector of the frame field </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V_d</td><td>#V? by 3 deformed, first representative vector?? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF1_d</td><td>#F by 3 deformed, first representative vector?? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF2_d</td><td>#F by 3 deformed, first representative vector?? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iterations</td><td>number of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>laplacian regularization parameter 0=no regularization 1=full regularization </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perturb_initial_guess</td><td>whether to perturb the initial guess </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b1822be03089dbefc97ae0274f7f744" name="a9b1822be03089dbefc97ae0274f7f744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1822be03089dbefc97ae0274f7f744">&#9670;&#160;</a></span>frame_to_cross_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::frame_to_cross_field </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>FF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>FF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a frame field into its closest cross field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 coordinates of the vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FF1</td><td>#F by 3 the first representative vector of the frame field (up to permutation and sign) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FF2</td><td>#F by 3 the second representative vector of the frame field (up to permutation and sign) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>#F by 3 representative vector of the closest cross field </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd2f248b52f9534c49484e76be8aa0bc" name="acd2f248b52f9534c49484e76be8aa0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2f248b52f9534c49484e76be8aa0bc">&#9670;&#160;</a></span>frustum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::frustum </td>
          <td>(</td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>nearVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>farVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the deprecated glFrustum function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>coordinate of left vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>coordinate of right vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>coordinate of bottom vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>coordinate of top vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nearVal</td><td>distance to near plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">farVal</td><td>distance to far plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>4x4 perspective matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad31a0406b0fb32f5345361442c0e85c9" name="ad31a0406b0fb32f5345361442c0e85c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31a0406b0fb32f5345361442c0e85c9">&#9670;&#160;</a></span>gaussian_curvature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::gaussian_curvature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the 2π minus the sum of interior angles at each vertex. </p>
<p>For interior vertices of a manifold mesh this corresponds to the local integral gaussian curvature ("angle deficit", without averaging by local area). For boundary vertices, this quantity is not so meaninful. FWIW, adding π to the output for boundary vertices would produce local integral geodesic curvature along the boundary curve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#V by 1 eigen Matrix of discrete gaussian curvature values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23d8ca74669cc6ed33b89020ee4f9b2e" name="a23d8ca74669cc6ed33b89020ee4f9b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d8ca74669cc6ed33b89020ee4f9b2e">&#9670;&#160;</a></span>generate_default_urbg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl.html#a60bbc303acee156af52ab587c4680502">DEFAULT_URBG</a> igl::generate_default_urbg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14a7a848b8b1eb296b5c8b80efc05efc" name="a14a7a848b8b1eb296b5c8b80efc05efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a7a848b8b1eb296b5c8b80efc05efc">&#9670;&#160;</a></span>get_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::get_seconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current time in seconds. </p>
<dl class="section return"><dt>Returns</dt><dd>the current time in seconds since epoch</dd></dl>
<h4><a class="anchor" id="autotoc_md14"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; tictoc = []()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">double</span> t_start = <a class="code hl_function" href="namespaceigl.html#a14a7a848b8b1eb296b5c8b80efc05efc">igl::get_seconds</a>();</div>
<div class="line">  <span class="keywordtype">double</span> diff = <a class="code hl_function" href="namespaceigl.html#a14a7a848b8b1eb296b5c8b80efc05efc">igl::get_seconds</a>()-t_start;</div>
<div class="line">  t_start += diff;</div>
<div class="line">  <span class="keywordflow">return</span> diff;</div>
<div class="line">};</div>
<div class="line">tictoc();</div>
<div class="line">... <span class="comment">// part 1</span></div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;part 1: &quot;</span>&lt;&lt;tictoc()&lt;&lt;endl;</div>
<div class="line">... <span class="comment">// part 2</span></div>
<div class="line">cout&lt;&lt;<span class="stringliteral">&quot;part 2: &quot;</span>&lt;&lt;tictoc()&lt;&lt;endl;</div>
<div class="line">... <span class="comment">// etc</span></div>
<div class="ttc" id="anamespaceigl_html_a14a7a848b8b1eb296b5c8b80efc05efc"><div class="ttname"><a href="namespaceigl.html#a14a7a848b8b1eb296b5c8b80efc05efc">igl::get_seconds</a></div><div class="ttdeci">double get_seconds()</div><div class="ttdoc">Current time in seconds.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="afc61afb5c46c76e8be9fcca2e4783d53" name="afc61afb5c46c76e8be9fcca2e4783d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc61afb5c46c76e8be9fcca2e4783d53">&#9670;&#160;</a></span>grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::grad </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; typename DerivedV::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uniform</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gradient operator on a triangle mesh. </p>
<p>Gradient of a scalar function defined on piecewise linear elements (mesh) is constant on each triangle [tetrahedron] i,j,k: grad(Xijk) = (Xj-Xi) * (Vi - Vk)^R90 / 2A + (Xk-Xi) * (Vj - Vi)^R90 / 2A where Xi is the scalar value at vertex i, Vi is the 3D position of vertex i, and A is the area of triangle (i,j,k). ^R90 represent a rotation of 90 degrees</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#vertices by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#faces by 3 list of mesh face indices [or a #faces by 4 list of tetrahedral indices] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#faces*dim by #V Gradient operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uniform</td><td>boolean (default false) - Use a uniform mesh instead of the vertices V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae277a1d4cf02f1612ad3c7bb47fc93f7" name="ae277a1d4cf02f1612ad3c7bb47fc93f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae277a1d4cf02f1612ad3c7bb47fc93f7">&#9670;&#160;</a></span>grad_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedF , typename Gtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::grad_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Gtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an intrinsic gradient operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#F by 3 list of edge lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into some vertex list V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#F*2 by #V gradient matrix: G=[Gx;Gy] where x runs along the 23 edge and y runs in the counter-clockwise 90° rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfb4bab2b437369dce2059e85836bd9a" name="adfb4bab2b437369dce2059e85836bd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb4bab2b437369dce2059e85836bd9a">&#9670;&#160;</a></span>grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedres , typename DerivedGV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::grid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedres &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct vertices of a regular grid, suitable for input to <code><a class="el" href="namespaceigl.html#a3e677970b7188cac95bc9f93181f2ed7" title="Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh ...">igl::marching_cubes</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>#res list of number of vertices along each dimension filling a unit #res-cube </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GV</td><td>res.array().prod() by #res list of mesh vertex positions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a3be3b842294c1e29d654ace1e4f735ca" title="Create a regular grid of elements (only 2D supported, currently) Vertex position order is compatible ...">triangulated_grid</a>, <a class="el" href="namespaceigl.html#acb165fc9bf550b7a4248ef3e4750c7b5">quad_grid</a> </dd></dl>

</div>
</div>
<a id="a9a189dbba012d12c812bb7b0970b4ab9" name="a9a189dbba012d12c812bb7b0970b4ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a189dbba012d12c812bb7b0970b4ab9">&#9670;&#160;</a></span>grid_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar igl::grid_search </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Scalar(DerivedX &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivedX &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global optimization via grid search. </p>
<p>Solve the problem:</p>
<p>minimize f(x) subject to lb ≤ x ≤ ub</p>
<p>by exhaustive grid search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function to minimize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LB</td><td>#X vector of finite lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>#X vector of finite upper bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#X vector of number of steps for each variable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>#X optimal parameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(X) </dd></dl>

</div>
</div>
<a id="af3d530c8efa1612e1bb3aa180064451d" name="af3d530c8efa1612e1bb3aa180064451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d530c8efa1612e1bb3aa180064451d">&#9670;&#160;</a></span>group_sum_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::group_sum_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a matrix A such that A*V computes the sum of vertices in each group specified by G. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td>#V list of group indices (0 to k-1) for each vertex, such that vertex i is assigned to group G(i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>#groups, good choice is max(G)+1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#groups by #V sparse matrix such that A*V = group_sums </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ef361caeca0b62001b9d59df11b5c06" name="a3ef361caeca0b62001b9d59df11b5c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef361caeca0b62001b9d59df11b5c06">&#9670;&#160;</a></span>group_sum_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::group_sum_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a229749fb9c004cc9a77f83a4c1881adb" name="a229749fb9c004cc9a77f83a4c1881adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229749fb9c004cc9a77f83a4c1881adb">&#9670;&#160;</a></span>guess_extension() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::guess_extension </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>guess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a file pointer at the beginning of a "mesh" file, try to guess the extension of the file format it comes from. </p>
<p>The file pointer is rewound on return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fp</td><td>file pointer, rewound after </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">guess</td><td>extension as string. One of "mesh",{"obj"},"off","ply","stl", or "wrl" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab79410fbbb723767aecc21edcc5941cb" name="ab79410fbbb723767aecc21edcc5941cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79410fbbb723767aecc21edcc5941cb">&#9670;&#160;</a></span>guess_extension() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::guess_extension </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5ade90c5c56252e2c88f4452996c50a0" name="a5ade90c5c56252e2c88f4452996c50a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ade90c5c56252e2c88f4452996c50a0">&#9670;&#160;</a></span>harmonic() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::harmonic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute k-harmonic weight functions "coordinates". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of element indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b boundary indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by #W list of boundary values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power of harmonic operation (1: harmonic, 2: biharmonic, etc) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by #W list of weights </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3baf24e87966423e7c6dac58f40c406" name="ac3baf24e87966423e7c6dac58f40c406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3baf24e87966423e7c6dac58f40c406">&#9670;&#160;</a></span>harmonic() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::harmonic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Compute harmonic map using uniform laplacian operator </p>

</div>
</div>
<a id="a720d55d920ca7659102fd8dd267e7936" name="a720d55d920ca7659102fd8dd267e7936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720d55d920ca7659102fd8dd267e7936">&#9670;&#160;</a></span>harmonic() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename DerivedM , typename Derivedb , typename Derivedbc , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::harmonic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Compute a harmonic map using a given Laplacian and mass matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#V by #V discrete (integrated) Laplacian <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>#V by #V mass matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba39f8e29962d636cfae080188ec1da7" name="aba39f8e29962d636cfae080188ec1da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba39f8e29962d636cfae080188ec1da7">&#9670;&#160;</a></span>harmonic() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename DerivedM , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::harmonic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivedQ &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build the discrete k-harmonic operator (computing integrated quantities). </p>
<p>That is, if the k-harmonic PDE is Q x = 0, then this minimizes x' Q x</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#V by #V discrete (integrated) Laplacian <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>#V by #V mass matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>power of harmonic operation (1: harmonic, 2: biharmonic, etc) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V discrete (integrated) k-Laplacian <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accdfdc1795f3cd0fbf66aeb3ca316604" name="accdfdc1795f3cd0fbf66aeb3ca316604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdfdc1795f3cd0fbf66aeb3ca316604">&#9670;&#160;</a></span>harmonic() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::harmonic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivedQ &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of element indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a073322f93d4fd2e161868d738abdfc09" name="a073322f93d4fd2e161868d738abdfc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073322f93d4fd2e161868d738abdfc09">&#9670;&#160;</a></span>harwell_boeing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::harwell_boeing </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the matrix to Compressed sparse column (CSC or CCS) format, also known as Harwell Boeing format. </p>
<p>As described: <a href="http://netlib.org/linalg/html_templates/node92.html">http://netlib.org/linalg/html_templates/node92.html</a> or <a href="http://en.wikipedia.org/wiki/Sparse_matrix">http://en.wikipedia.org/wiki/Sparse_matrix</a> #Compressed_sparse_column_.28CSC_or_CCS.29 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type of sparse matrix like double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>sparse m by n matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_rows</td><td>number of rows </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>non-zero values, row indices running fastest, size(V) = nnz </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>row indices corresponding to vals, size(R) = nnz </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>index in vals of first entry in each column, size(C) = num_cols+1</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>All indices and pointers are 0-based </dd></dl>

</div>
</div>
<a id="a64901d7f496bd1cccbccceddbc091603" name="a64901d7f496bd1cccbccceddbc091603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64901d7f496bd1cccbccceddbc091603">&#9670;&#160;</a></span>hausdorff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hausdorff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Hausdorff distance between mesh (VA,FA) and mesh (VB,FB). </p>
<p>This is the</p>
<p>d(A,B) = max ( max min d(a,b) , max min d(b,a) ) a∈A b∈B b∈B a∈A</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td>#VA by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FA</td><td>#FA by 3 list of face indices into VA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td>#VB by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FB</td><td>#FB by 3 list of face indices into VB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>hausdorff distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de06347c75f90acb8cc0114c7249e58" name="a3de06347c75f90acb8cc0114c7249e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de06347c75f90acb8cc0114c7249e58">&#9670;&#160;</a></span>hausdorff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hausdorff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Scalar(const Scalar &amp;, const Scalar &amp;, const Scalar &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>dist_to_B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.g., mesh, triangle soup) given by a distance function handle (dist_to_B). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of corner positions so that V.row(i) is the position of the ith corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dist_to_B</td><td>function taking the x,y,z coordinate of a query position and outputting the closest-point distance to some point-set B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>lower bound on Hausdorff distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>upper bound on Hausdorff distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="affbddd3e363a529044cd4bd848b278f4" name="affbddd3e363a529044cd4bd848b278f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbddd3e363a529044cd4bd848b278f4">&#9670;&#160;</a></span>heat_geodesics_precompute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::heat_geodesics_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Precompute factorized solvers for computing a fast approximation of geodesic distances on a mesh (V,F). </p>
<p>[Crane et al. 2013]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>precomputation data (see heat_geodesics_solve)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="heat__geodesics_8h.html">include/igl/heat_geodesics.h</a> </p>

</div>
</div>
<a id="a12efa6b8fc863b52dd131d478a456802" name="a12efa6b8fc863b52dd131d478a456802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12efa6b8fc863b52dd131d478a456802">&#9670;&#160;</a></span>heat_geodesics_precompute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::heat_geodesics_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>"heat" parameter (smaller --&gt; more accurate, less stable)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="heat__geodesics_8h.html">include/igl/heat_geodesics.h</a> </p>

</div>
</div>
<a id="ae558cd690e05ad2e41caa655251e23c4" name="ae558cd690e05ad2e41caa655251e23c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae558cd690e05ad2e41caa655251e23c4">&#9670;&#160;</a></span>heat_geodesics_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Derivedgamma , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::heat_geodesics_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structigl_1_1HeatGeodesicsData.html">HeatGeodesicsData</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedgamma &gt; &amp;&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute fast approximate geodesic distances using precomputed data from a set of selected source vertices (gamma). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>precomputation data (see heat_geodesics_precompute) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>#gamma list of indices into V of source vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#V list of distances to gamma</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="heat__geodesics_8h.html">include/igl/heat_geodesics.h</a> </p>

</div>
</div>
<a id="a8e6dbdaae94657379ac8491942082d20" name="a8e6dbdaae94657379ac8491942082d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6dbdaae94657379ac8491942082d20">&#9670;&#160;</a></span>hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hessian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the finite element Hessian matrix as described in <a href="https://arxiv.org/abs/1707.04348">https://arxiv.org/abs/1707.04348</a>, Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) The interior vertices are NOT set to zero yet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td>dim²⋅::V by #V Hessian matrix, each column i corresponding to V(i,:)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#adf8191d83bb2517d430b625c5416988b" title="Computes the curved Hessian energy using the Crouzeix-Raviart discretization.">curved_hessian_energy</a>, <a class="el" href="namespaceigl.html#a5d3d292215a6020d9e70cd7cfdd29ec1" title="Constructs the Hessian energy matrix using mixed FEM as described in https://arxiv....">hessian_energy</a> </dd></dl>

</div>
</div>
<a id="a5d3d292215a6020d9e70cd7cfdd29ec1" name="a5d3d292215a6020d9e70cd7cfdd29ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3d292215a6020d9e70cd7cfdd29ec1">&#9670;&#160;</a></span>hessian_energy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hessian_energy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the Hessian energy matrix using mixed FEM as described in <a href="https://arxiv.org/abs/1707.04348">https://arxiv.org/abs/1707.04348</a> Natural Boundary Conditions for Smoothing in Geometry Processing (Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#V by #V Hessian energy matrix, each row/column i corresponding to V(i,:)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a8e6dbdaae94657379ac8491942082d20" title="Constructs the finite element Hessian matrix as described in https://arxiv.org/abs/1707....">hessian</a>, <a class="el" href="namespaceigl.html#adf8191d83bb2517d430b625c5416988b" title="Computes the curved Hessian energy using the Crouzeix-Raviart discretization.">curved_hessian_energy</a> </dd></dl>

</div>
</div>
<a id="a7e66c7ad3404c4e5a43a2ecaf1c21819" name="a7e66c7ad3404c4e5a43a2ecaf1c21819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e66c7ad3404c4e5a43a2ecaf1c21819">&#9670;&#160;</a></span>histc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedE , typename DerivedN , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::histc </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count occurrences of values in X between consecutive entries in E. </p>
<p>Like matlab's histc. O(n+m*log(n))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m-long Vector of values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>n-long Monotonically increasing vector of edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>n-long vector where N(k) reveals how many values in X fall between E(k) &lt;= X &lt; E(k+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>m-long vector of bin ids so that B(j) = k if E(k) &lt;= X(j) &lt; E(k+1). B(j) = -1 if X(j) is outside of E. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af74c4ce0e45c4fc1ab9e958c93ef4437" name="af74c4ce0e45c4fc1ab9e958c93ef4437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74c4ce0e45c4fc1ab9e958c93ef4437">&#9670;&#160;</a></span>histc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedE , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::histc </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Truly O(m*log(n)) </p>

</div>
</div>
<a id="a946a214630848d43ddc7df74e00f4d57" name="a946a214630848d43ddc7df74e00f4d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946a214630848d43ddc7df74e00f4d57">&#9670;&#160;</a></span>histc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::histc </td>
          <td>(</td>
          <td class="paramtype">const typename DerivedE::Scalar &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedE::Index &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Scalar search wrapper </p>

</div>
</div>
<a id="a840674ca4222700909ca8197e27800a5" name="a840674ca4222700909ca8197e27800a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840674ca4222700909ca8197e27800a5">&#9670;&#160;</a></span>hsv_to_rgb() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hsv_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>hsv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert RGB to HSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hsv</td><td>with<ul>
<li>h hue value (degrees: [0,360]. Values outside this range will be mapped periodically to [0,360].)</li>
<li>s saturation value ([0,1])</li>
<li>v value value ([0,1]) </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>with:<ul>
<li>r red value ([0,1])</li>
<li>g green value ([0,1])</li>
<li>b blue value ([0,1]) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67a8efe9fd3b48830cd07fd2fb45ece6" name="a67a8efe9fd3b48830cd07fd2fb45ece6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a8efe9fd3b48830cd07fd2fb45ece6">&#9670;&#160;</a></span>hsv_to_rgb() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hsv_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3e2573040155e553e83f6b2098417ed2" name="a3e2573040155e553e83f6b2098417ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2573040155e553e83f6b2098417ed2">&#9670;&#160;</a></span>hsv_to_rgb() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedH , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::hsv_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedH &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>#H by 3 list of hsv values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>#H by 3 list of rgb values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91986768165db4e2fe4f6541db3a100e" name="a91986768165db4e2fe4f6541db3a100e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91986768165db4e2fe4f6541db3a100e">&#9670;&#160;</a></span>icosahedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::icosahedron </td>
          <td>(</td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6a48ea815ed7c6fce66c5fb16643592" name="ae6a48ea815ed7c6fce66c5fb16643592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a48ea815ed7c6fce66c5fb16643592">&#9670;&#160;</a></span>in_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedQ , int DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::in_element </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether each point in a list of points is in the elements of a mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DIM</td><td>dimension of vertices in V (# of columns) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ele</td><td>#Ele by dim+1 list of mesh indices into #V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by dim list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">aabb</td><td>axis-aligned bounding box tree object (see <a class="el" href="AABB_8h.html">AABB.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#Q list of indices into Ele of first containing element (-1 means no containing element) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cc28747ccc281b8790d1ec2a07daf42" name="a1cc28747ccc281b8790d1ec2a07daf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc28747ccc281b8790d1ec2a07daf42">&#9670;&#160;</a></span>in_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedQ , int DIM, typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::in_element </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#Q by #Ele sparse matrix revealing whether each element contains each point: I(q,e) means point q is in element e </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac35f10d1dc8993c19f76b5c2ba6c48e7" name="ac35f10d1dc8993c19f76b5c2ba6c48e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35f10d1dc8993c19f76b5c2ba6c48e7">&#9670;&#160;</a></span>increment_ulp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::increment_ulp </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>inout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment Unit in Last Place of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">inout</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">it</td><td>number of increments </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cba56449805461c9713bc29b8ebcc79" name="a0cba56449805461c9713bc29b8ebcc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cba56449805461c9713bc29b8ebcc79">&#9670;&#160;</a></span>infinite_cost_stopping_condition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::infinite_cost_stopping_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>stopping_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stopping condition function compatible with <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>. </p>
<p>The output function handle will return true if cost of next edge is infinite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cost_and_placement</td><td>handle being used by <a class="el" href="namespaceigl.html#aa8e3cfdf30adcadd5172a4f0b862bf59" title="Attempt to collapse a given edge of a mesh.">igl::collapse_edge</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stopping_condition</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f95773129e4cd1a29171858e1f313b5" name="a6f95773129e4cd1a29171858e1f313b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f95773129e4cd1a29171858e1f313b5">&#9670;&#160;</a></span>infinite_cost_stopping_condition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> igl::infinite_cost_stopping_condition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#af967096efcc39e806f0c2b374e2ccc5f">decimate_cost_and_placement_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cost_and_placement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a461e3490769bd9ac20f48a0179f58b0f" name="a461e3490769bd9ac20f48a0179f58b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461e3490769bd9ac20f48a0179f58b0f">&#9670;&#160;</a></span>inradius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::inradius </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inradius of each triangle in a mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>#F list of inradii </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a748a89868e9e150c9d02736c6f304318" name="a748a89868e9e150c9d02736c6f304318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748a89868e9e150c9d02736c6f304318">&#9670;&#160;</a></span>internal_angles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::internal_angles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute internal angles for a triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim eigen Matrix of mesh vertex nD positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by poly-size eigen Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#F by poly-size eigen Matrix of internal angles for triangles, columns correspond to edges [1,2],[2,0],[0,1]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if poly-size ≠ 3 then dim must equal 3. </dd></dl>

</div>
</div>
<a id="a42cf87a6db6ebff753475465b9e0a6f3" name="a42cf87a6db6ebff753475465b9e0a6f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cf87a6db6ebff753475465b9e0a6f3">&#9670;&#160;</a></span>internal_angles_intrinsic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::internal_angles_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute internal angles for a triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L_sq</td><td>#F by 3 list of squared edge lengths </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#F by poly-size eigen Matrix of internal angles for triangles, columns correspond to edges [1,2],[2,0],[0,1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f72acbb659a5c1d291a4cff36910a87" name="a4f72acbb659a5c1d291a4cff36910a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f72acbb659a5c1d291a4cff36910a87">&#9670;&#160;</a></span>intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::intersect </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the intersect between two sets of coefficients using ==. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>matrix type that implements indexing by global index M(i) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix of coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>matrix of coefficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>matrix of elements appearing in both A and B, C is always resized to have a single column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41a6a9d793818a4836de7c3faa524e26" name="a41a6a9d793818a4836de7c3faa524e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a6a9d793818a4836de7c3faa524e26">&#9670;&#160;</a></span>intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M igl::intersect </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const M &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload </p>

</div>
</div>
<a id="a6173f608f5bae73866cc21f0159562dc" name="a6173f608f5bae73866cc21f0159562dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6173f608f5bae73866cc21f0159562dc">&#9670;&#160;</a></span>intrinsic_delaunay_cotmatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar , typename Derivedl_intrinsic , typename DerivedF_intrinsic &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::intrinsic_delaunay_cotmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedl_intrinsic &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_intrinsic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF_intrinsic &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_intrinsic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the discrete cotangent Laplacian of a mesh after converting it into its intrinsic Delaunay triangulation (see, e.g., [Fisher et al. </p>
<p>2007].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh elements (triangles or tetrahedra) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#V by #V cotangent matrix, each row i corresponding to V(i,:) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l_intrinsic</td><td>#F by 3 list of intrinsic edge-lengths used to compute L </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F_intrinsic</td><td>#F by 3 list of intrinsic face indices used to compute L</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#abf4975f69822136269d681f02b2c3279" title="INTRINSIC_DELAUNAY_TRIANGULATION Flip edges intrinsically until all are &quot;intrinsic Delaunay&quot;.">intrinsic_delaunay_triangulation</a>, <a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a>, <a class="el" href="namespaceigl.html#ae47d4dd3239dba392f54b8dc3f62e8dd" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh with faces F and edge...">cotmatrix_intrinsic</a> </dd></dl>

</div>
</div>
<a id="ab774229e4511d5f186a394c39f813d2f" name="ab774229e4511d5f186a394c39f813d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab774229e4511d5f186a394c39f813d2f">&#9670;&#160;</a></span>intrinsic_delaunay_cotmatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::intrinsic_delaunay_cotmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abf4975f69822136269d681f02b2c3279" name="abf4975f69822136269d681f02b2c3279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4975f69822136269d681f02b2c3279">&#9670;&#160;</a></span>intrinsic_delaunay_triangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl_in , typename DerivedF_in , typename Derivedl , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::intrinsic_delaunay_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl_in &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF_in &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INTRINSIC_DELAUNAY_TRIANGULATION Flip edges <em>intrinsically</em> until all are "intrinsic Delaunay". </p>
<p>See "An algorithm for the construction of intrinsic
delaunay triangulations with applications to digital geometry processing" [Fisher et al. 2007].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l_in</td><td>#F_in by 3 list of edge lengths (see edge_lengths) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_in</td><td>#F_in by 3 list of face indices into some unspecified vertex list V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>#F by 3 list of edge lengths </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of new face indices. Note: Combinatorially F may contain non-manifold edges, duplicate faces and self-loops (e.g., an edge [1,1] or a face [1,1,1]). However, the <em>intrinsic geometry</em> is still well-defined and correct. See [Fisher et al. 2007] Figure 3 and 2nd to last paragraph of 1st page. Since F may be "non-eddge-manifold" in the usual combinatorial sense, it may be useful to call the more verbose overload below if disentangling edges will be necessary later on. Calling unique_edge_map on this F will give a <em>different</em> result than those outputs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a95a946e409259bd08727637f7fd15b74" title="Determine if each edge in the mesh (V,F) is Delaunay.">is_intrinsic_delaunay</a> </dd></dl>

</div>
</div>
<a id="a6c0bd085d3b95f40fe92ef1c75f6ad32" name="a6c0bd085d3b95f40fe92ef1c75f6ad32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0bd085d3b95f40fe92ef1c75f6ad32">&#9670;&#160;</a></span>intrinsic_delaunay_triangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl_in , typename DerivedF_in , typename Derivedl , typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2EType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::intrinsic_delaunay_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl_in &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF_in &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#F*3 by 2 list of all directed edges, such that E.row(f+#F*c) is the </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">edge</td><td>opposite F(f,c) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE</td><td>#uE by 2 list of unique undirected edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">undirected</td><td>edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">unique_edge_map</a> </dd></dl>

</div>
</div>
<a id="ad6fc59b895f5ad4472ca15758fd947b5" name="ad6fc59b895f5ad4472ca15758fd947b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6fc59b895f5ad4472ca15758fd947b5">&#9670;&#160;</a></span>invert_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename MatY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::invert_diag </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatY &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert the diagonal entries of a matrix (if the matrix is a diagonal matrix then this amounts to inverting the matrix) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>an m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>an m by n sparse matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf49f5f7e92069382f5607639d92555" name="addf49f5f7e92069382f5607639d92555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf49f5f7e92069382f5607639d92555">&#9670;&#160;</a></span>is_border_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; igl::is_border_vertex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine vertices on open boundary of a (manifold) mesh with triangle faces F. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of bools revealing whether vertices are on boundary</dd></dl>
<dl class="section note"><dt>Note</dt><dd>assumes mesh is edge manifold </dd></dl>

</div>
</div>
<a id="a39d02bea0e57dce707ada6bc3228d22a" name="a39d02bea0e57dce707ada6bc3228d22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d02bea0e57dce707ada6bc3228d22a">&#9670;&#160;</a></span>is_boundary_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::is_boundary_edge </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine for each edge E if it is a "boundary edge" in F. </p>
<p>Boundary edges are undirected edges which occur only once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>#E list bools. true iff unoriented edge occurs exactly once in F (non-manifold and non-existant edges will be false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2687ea500d0a998cf01ab3ff7456ba25" name="a2687ea500d0a998cf01ab3ff7456ba25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2687ea500d0a998cf01ab3ff7456ba25">&#9670;&#160;</a></span>is_boundary_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DerivedB , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::is_boundary_edge </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2 list of edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#F*3 list of indices mapping allE to E </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8670d8afa68524c4d0e4745faa89efc7" name="a8670d8afa68524c4d0e4745faa89efc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8670d8afa68524c4d0e4745faa89efc7">&#9670;&#160;</a></span>is_delaunay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::is_delaunay </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDetermine if each edge in the mesh (V,F) is Delaunay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangles indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#F by 3 list of bools revealing whether edges corresponding 23 31 12 are locally Delaunay. Boundary edges are by definition Delaunay. Non-Manifold edges are by definition not Delaunay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3e60388b9f45015b2d555acf24b9b4e" name="ae3e60388b9f45015b2d555acf24b9b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e60388b9f45015b2d555acf24b9b4e">&#9670;&#160;</a></span>is_delaunay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename uE2EType , typename InCircle , typename ueiType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_delaunay </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InCircle&#160;</td>
          <td class="paramname"><em>incircle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ueiType&#160;</td>
          <td class="paramname"><em>uei</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangles indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges (see unique_edge_map) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">incircle</td><td>A functor such that incircle(pa, pb, pc, pd) returns 1 if pd is on the positive size of circumcirle of (pa,pb,pc) -1 if pd is on the positive size of circumcirle of (pa,pb,pc) 0 if pd is cocircular with pa, pb, pc. (see delaunay_triangulation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uei</td><td>index into uE2E of edge to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff edge is Delaunay </dd></dl>

</div>
</div>
<a id="acc2105d7b15672349f4662a1c77ea4d5" name="acc2105d7b15672349f4662a1c77ea4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2105d7b15672349f4662a1c77ea4d5">&#9670;&#160;</a></span>is_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the given filename is a directory. </p>
<p>Act like php's is_dir function <a href="http://php.net/manual/en/function.is-dir.php">http://php.net/manual/en/function.is-dir.php</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the file. If filename is a relative filename, it will be checked relative to the current working directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the filename exists and is a directory, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ab086008065bab7abde580f8bdea5d156" name="ab086008065bab7abde580f8bdea5d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab086008065bab7abde580f8bdea5d156">&#9670;&#160;</a></span>is_edge_manifold() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_edge_manifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the mesh is edge-manifold (every edge is incident one one face (boundary) or two oppositely oriented faces). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff all edges are manifold</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#abd0dbef9a4a2738b2c33de0cb6938bfb" title="Check if a mesh is vertex-manifold.">is_vertex_manifold</a> </dd></dl>

</div>
</div>
<a id="a7d04d883ce83ec8376b7eb4f22db6f03" name="a7d04d883ce83ec8376b7eb4f22db6f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d04d883ce83ec8376b7eb4f22db6f03">&#9670;&#160;</a></span>is_edge_manifold() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedBF , typename DerivedE , typename DerivedEMAP , typename DerivedBE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_edge_manifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBE &gt; &amp;&#160;</td>
          <td class="paramname"><em>BE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if mesh is edge-manifold and outputs per-edge info. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td>#F by 3 list of flags revealing if edge opposite corresponding vertex </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is</td><td>non-manifold. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2 list of unique edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>3*#F list of indices of opposite edges in "E" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BE</td><td>#E list of flages whether edge is non-manifold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bd5dfc80e3180cb9f8cfbeb0049c2b5" name="a1bd5dfc80e3180cb9f8cfbeb0049c2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd5dfc80e3180cb9f8cfbeb0049c2b5">&#9670;&#160;</a></span>is_edge_manifold() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedEMAP , typename DerivedBF , typename DerivedBE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_edge_manifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedF::Index&#160;</td>
          <td class="paramname"><em>ne</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBF &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBE &gt; &amp;&#160;</td>
          <td class="paramname"><em>BE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5d660daa58e9ec65ac1756adc4b61454" name="a5d660daa58e9ec65ac1756adc4b61454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d660daa58e9ec65ac1756adc4b61454">&#9670;&#160;</a></span>is_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells whether the given filename is a regular file. </p>
<p>Act like php's is_file function <a href="http://php.net/manual/en/function.is-file.php">http://php.net/manual/en/function.is-file.php</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Path to the file. If filename is a relative filename, it will be checked relative to the current working directory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the filename exists and is a regular file, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="a95a946e409259bd08727637f7fd15b74" name="a95a946e409259bd08727637f7fd15b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a946e409259bd08727637f7fd15b74">&#9670;&#160;</a></span>is_intrinsic_delaunay() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedF , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::is_intrinsic_delaunay </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if each edge in the mesh (V,F) is Delaunay. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#l by dim list of edge lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangles indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#F by 3 list of bools revealing whether edges corresponding 23 31 12 are locally Delaunay. Boundary edges are by definition Delaunay. Non-Manifold edges are by definition not Delaunay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada6b3f9347053522b1fc5da210be1968" name="ada6b3f9347053522b1fc5da210be1968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6b3f9347053522b1fc5da210be1968">&#9670;&#160;</a></span>is_intrinsic_delaunay() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedF , typename uE2EType , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::is_intrinsic_delaunay </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists mapping unique edges to (half-)edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae63e0780a4c5344cbafb31919f77bd0a" name="ae63e0780a4c5344cbafb31919f77bd0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63e0780a4c5344cbafb31919f77bd0a">&#9670;&#160;</a></span>is_intrinsic_delaunay() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename uE2EType , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_intrinsic_delaunay </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>num_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>uei</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a single edge is Delaunay using a provided (extrinsic) incirle test. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#l by dim list of edge lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges (see unique_edge_map) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_faces</td><td>number of faces (==#F) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uei</td><td>index into uE2E of edge to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff edge is Delaunay </dd></dl>

</div>
</div>
<a id="a05f076e50c33c9998c7f9c9559ed36e0" name="a05f076e50c33c9998c7f9c9559ed36e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f076e50c33c9998c7f9c9559ed36e0">&#9670;&#160;</a></span>is_irregular_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; bool &gt; igl::is_irregular_vertex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a vertex is irregular, i.e. </p>
<p>it has more than 6 (triangles) or 4 (quads) incident edges. Vertices on the boundary are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3[4] list of triangle[quads] indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V vector of bools revealing whether vertices are singular </dd></dl>

</div>
</div>
<a id="aedd09a46e564a0d19ae4f97891b95de9" name="aedd09a46e564a0d19ae4f97891b95de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd09a46e564a0d19ae4f97891b95de9">&#9670;&#160;</a></span>is_planar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_planar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a set of points lies on the XY plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a mesh has constant value of 0 in z coordinate</dd></dl>

</div>
</div>
<a id="a036d4412fb94156420eff091457a73b3" name="a036d4412fb94156420eff091457a73b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036d4412fb94156420eff091457a73b3">&#9670;&#160;</a></span>is_readable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_readable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file is reabable like PHP's is_readable function: <a href="http://www.php.net/manual/en/function.is-readable.php">http://www.php.net/manual/en/function.is-readable.php</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>path to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if file exists and is readable and false if file doesn't exist or <em>is not readable</em></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Windows version will not check user or group ids </dd></dl>

</div>
</div>
<a id="ad7968d06fbb2bcb8b64f707ec4b29f87" name="ad7968d06fbb2bcb8b64f707ec4b29f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7968d06fbb2bcb8b64f707ec4b29f87">&#9670;&#160;</a></span>is_sparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_sparse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a matrix A is sparse. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T,DerivedA</td><td>defines scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix in question </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if A is represented with a sparse matrix</dd></dl>

</div>
</div>
<a id="a910c84c58fdea4379d5e0ff34588ffe6" name="a910c84c58fdea4379d5e0ff34588ffe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910c84c58fdea4379d5e0ff34588ffe6">&#9670;&#160;</a></span>is_sparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_sparse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1f40e6e779275ad817df4c8d1ac22aa6" name="a1f40e6e779275ad817df4c8d1ac22aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f40e6e779275ad817df4c8d1ac22aa6">&#9670;&#160;</a></span>is_stl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_stl </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stl_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_ascii</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a file pointer, determine if it contains an .stl file and then rewind it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stl_file</td><td>pointer to file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_ascii</td><td>flag whether stl is ascii </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether stl_file is an .stl file </dd></dl>

</div>
</div>
<a id="a623b66ea2a39ba8c09f3c72599272562" name="a623b66ea2a39ba8c09f3c72599272562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623b66ea2a39ba8c09f3c72599272562">&#9670;&#160;</a></span>is_stl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_stl </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stl_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f840791a21ca650ec1d68910c3ec900" name="a4f840791a21ca650ec1d68910c3ec900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f840791a21ca650ec1d68910c3ec900">&#9670;&#160;</a></span>is_symmetric() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given matrix is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by m matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the matrix is square and symmetric </dd></dl>

</div>
</div>
<a id="a819c37589176cb7dde8fb52796314fc3" name="a819c37589176cb7dde8fb52796314fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819c37589176cb7dde8fb52796314fc3">&#9670;&#160;</a></span>is_symmetric() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AT , typename epsilonT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AT &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const epsilonT&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>threshold on L1 difference between A and A' </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00ac1f26b40979584dfa370cee528d71" name="a00ac1f26b40979584dfa370cee528d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ac1f26b40979584dfa370cee528d71">&#9670;&#160;</a></span>is_symmetric() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abd0dbef9a4a2738b2c33de0cb6938bfb" name="abd0dbef9a4a2738b2c33de0cb6938bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0dbef9a4a2738b2c33de0cb6938bfb">&#9670;&#160;</a></span>is_vertex_manifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_vertex_manifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a mesh is vertex-manifold. </p>
<p>This only checks whether the faces incident on each vertex form exactly one connected component. Vertices incident on non-manifold edges are not consider non-manifold by this function (see <a class="el" href="is__edge__manifold_8h.html">is_edge_manifold.h</a>). Unreferenced verties are considered non-manifold (zero components).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>#V list indicate whether each vertex is locally manifold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether mesh is vertex manifold.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ab086008065bab7abde580f8bdea5d156" title="Check if the mesh is edge-manifold (every edge is incident one one face (boundary) or two oppositely ...">is_edge_manifold</a> </dd></dl>

</div>
</div>
<a id="a081c3e366717287e1be24e695b5b034e" name="a081c3e366717287e1be24e695b5b034e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081c3e366717287e1be24e695b5b034e">&#9670;&#160;</a></span>is_vertex_manifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_vertex_manifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6584dca7db2b1e9f2601973c2609e6c1" name="a6584dca7db2b1e9f2601973c2609e6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6584dca7db2b1e9f2601973c2609e6c1">&#9670;&#160;</a></span>is_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::is_writable </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a file exists <em>and</em> is writable like PHP's is_writable function: <a href="http://www.php.net/manual/en/function.is-writable.php">http://www.php.net/manual/en/function.is-writable.php</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>path to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if file exists and is writable and false if file doesn't exist or <em>is not writable</em></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Windows version will not test group and user id </dd></dl>

</div>
</div>
<a id="a28fb666256b9e2c9aa5bd79cbfb5397b" name="a28fb666256b9e2c9aa5bd79cbfb5397b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fb666256b9e2c9aa5bd79cbfb5397b">&#9670;&#160;</a></span>isdiag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::isdiag </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a given matrix is diagonal: all non-zeros lie on the main diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n sparse matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff and only if the matrix is diagonal. </dd></dl>

</div>
</div>
<a id="a3b1dfc725b9f364c46cc835853c4d154" name="a3b1dfc725b9f364c46cc835853c4d154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1dfc725b9f364c46cc835853c4d154">&#9670;&#160;</a></span>ismember()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedIA , typename DerivedLOCB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ismember </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedLOCB &gt; &amp;&#160;</td>
          <td class="paramname"><em>LOCB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if elements of A exist in elements of B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>ma by na matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>mb by nb matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>ma by na matrix of flags whether corresponding element of A exists in B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LOCB</td><td>ma by na matrix of indices in B locating matching element (-1 if not found), indices assume column major ordering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22eecc8e676dfea634eedb0f1121ed88" name="a22eecc8e676dfea634eedb0f1121ed88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eecc8e676dfea634eedb0f1121ed88">&#9670;&#160;</a></span>ismember_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedIA , typename DerivedLOCB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ismember_rows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedLOCB &gt; &amp;&#160;</td>
          <td class="paramname"><em>LOCB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if row of A exist in rows of B. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>ma by na matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>mb by nb matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>ma by 1 lest of flags whether corresponding element of A exists in B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LOCB</td><td>ma by 1 list matrix of indices in B locating matching element (-1 if not found), indices assume column major ordering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24e807a90c41e3a89ee0171b1518c27d" name="a24e807a90c41e3a89ee0171b1518c27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e807a90c41e3a89ee0171b1518c27d">&#9670;&#160;</a></span>isolines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediV , typename DerivediE , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::isolines </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedvals &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediV &gt; &amp;&#160;</td>
          <td class="paramname"><em>iV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediE &gt; &amp;&#160;</td>
          <td class="paramname"><em>iE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute isolines of a scalar field on a triangle mesh. </p>
<p>Isolines may cross perfectly at vertices. The output should not contain degenerate segments (so long as the input does not contain degenerate faces). The output segments are <em>oriented</em> so that isolines curl counter-clockwise around local maxima (i.e., for 2D scalar fields). Unless an isoline hits a boundary, it should be a closed loop. Isolines may run perfectly along boundaries. Isolines should appear just "above" constants regions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#S by 1 list of per-vertex scalar values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>#vals by 1 list of values to compute isolines for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iV</td><td>#iV by dim list of isoline vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iE</td><td>#iE by 2 list of edge indices into iV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#iE by 1 list of indices into vals indicating which value each segment belongs to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a616f5985cbb36acb190f207f9dff82df" title="Compute isolines of a scalar field on a triangle mesh intrinsically.">isolines_intrinsic</a>, <a class="el" href="namespaceigl.html#a0cf37d2a8f8c08387438a60ba3bcb2ca" title="Compute the each point that a scalar field crosses a specified value along an edge of a mesh.">edge_crossings</a> </dd></dl>

</div>
</div>
<a id="a616f5985cbb36acb190f207f9dff82df" name="a616f5985cbb36acb190f207f9dff82df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616f5985cbb36acb190f207f9dff82df">&#9670;&#160;</a></span>isolines_intrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedS , typename Derivedvals , typename DerivediB , typename DerivediFI , typename DerivediE , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::isolines_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedvals &gt; &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediB &gt; &amp;&#160;</td>
          <td class="paramname"><em>iB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediFI &gt; &amp;&#160;</td>
          <td class="paramname"><em>iFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediE &gt; &amp;&#160;</td>
          <td class="paramname"><em>iE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute isolines of a scalar field on a triangle mesh intrinsically. </p>
<p>See <a class="el" href="isolines_8h.html">isolines.h</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into some V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#S by 1 list of per-vertex scalar values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vals</td><td>#vals by 1 list of values to compute isolines for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iB</td><td>#iB by 3 list of barycentric coordinates so that iV.row(i) = iB(i,0)*V.row(F(iFI(i,0)) + iB(i,1)*V.row(F(iFI(i,1)) + iB(i,2)*V.row(F(iFI(i,2)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iF</td><td>#iB list of triangle indices for each row of iB (all points will either lie on an edge or vertex: an arbitrary incident face will be given). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">iE</td><td>#iE by 2 list of edge indices into iB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#iE by 1 list of indices into vals indicating which value each segment belongs to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a24e807a90c41e3a89ee0171b1518c27d" title="Compute isolines of a scalar field on a triangle mesh.">isolines</a>, <a class="el" href="namespaceigl.html#a0cf37d2a8f8c08387438a60ba3bcb2ca" title="Compute the each point that a scalar field crosses a specified value along an edge of a mesh.">edge_crossings</a> </dd></dl>

</div>
</div>
<a id="a276bde6ae2e23fb1811ec18a353b15be" name="a276bde6ae2e23fb1811ec18a353b15be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276bde6ae2e23fb1811ec18a353b15be">&#9670;&#160;</a></span>isolines_intrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedS , typename DeriveduE , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivediB , typename DerivediFI , typename DerivediE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::isolines_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediB &gt; &amp;&#160;</td>
          <td class="paramname"><em>iB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediFI &gt; &amp;&#160;</td>
          <td class="paramname"><em>iFI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivediE &gt; &amp;&#160;</td>
          <td class="paramname"><em>iE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>scalar value to compute isoline at </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of unique undirected edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+#F*c)) is the unique edge corresponding to E.row(f+#F*c) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumulative counts of directed edges sharing each unique edge so the uEC(i+1)-uEC(i) is the number of directed edges sharing the ith unique edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#E list of indices into E, so that the consecutive segment of indices uEE.segment(uEC(i),uEC(i+1)-uEC(i)) lists all directed edges sharing the ith unique edge.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">unique_edge_map</a> </dd></dl>

</div>
</div>
<a id="ac262ba447b16b5edccade00d31f39722" name="ac262ba447b16b5edccade00d31f39722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac262ba447b16b5edccade00d31f39722">&#9670;&#160;</a></span>isolines_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedCM , typename Derivediso_color , typename DerivedICM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::isolines_map </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCM &gt; &amp;&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivediso_color &gt; &amp;&#160;</td>
          <td class="paramname"><em>iso_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>interval_thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iso_thickness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedICM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ICM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inject a given colormap with evenly spaced isolines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CM</td><td>#CM by 3 list of colors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ico_color</td><td>1 by 3 isoline color </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interval_thickness</td><td>number of times to repeat intervals (original colors) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iso_thickness</td><td>number of times to repeat isoline color (in between intervals) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ICM</td><td>#CM*interval_thickness + (#CM-1)*iso_thickness by 3 list of outputs colors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a807d847189eeb2aa93fb387f81452494" name="a807d847189eeb2aa93fb387f81452494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d847189eeb2aa93fb387f81452494">&#9670;&#160;</a></span>isolines_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedCM , typename DerivedICM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::isolines_map </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCM &gt; &amp;&#160;</td>
          <td class="paramname"><em>CM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedICM &gt; &amp;&#160;</td>
          <td class="paramname"><em>ICM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa7b2dbd6e4ee3d5ca15dd5dce9928453" name="aa7b2dbd6e4ee3d5ca15dd5dce9928453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b2dbd6e4ee3d5ca15dd5dce9928453">&#9670;&#160;</a></span>iterative_closest_point() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVX , typename DerivedFX , typename DerivedVY , typename DerivedFY , typename DerivedR , typename Derivedt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::iterative_closest_point </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVX &gt; &amp;&#160;</td>
          <td class="paramname"><em>VX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFX &gt; &amp;&#160;</td>
          <td class="paramname"><em>FX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVY &gt; &amp;&#160;</td>
          <td class="paramname"><em>VY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFY &gt; &amp;&#160;</td>
          <td class="paramname"><em>FY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve for the rigid transformation that places mesh X onto mesh Y using the iterative closest point method. </p>
<p>In particular, optimize:</p>
<p>min ∫_X inf ‖x*R+t - y‖² dx R∈SO(3) y∈Y t∈R³</p>
<p>Typically optimization strategies include using Gauss Newton ("point-to-plane" linearization) and stochastic descent (sparse random sampling each iteration).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VX</td><td>#VX by 3 list of mesh X vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FX</td><td>#FX by 3 list of mesh X triangle indices into rows of VX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VY</td><td>#VY by 3 list of mesh Y vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FY</td><td>#FY by 3 list of mesh Y triangle indices into rows of VY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>number of random samples to use (larger --&gt; more accurate, but also more suceptible to sticking to local minimum) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>3x3 rotation matrix so that (VX*R+t,FX) ~~ (VY,FY) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>1x3 translation row vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1cd54b56f1bb183ab3898eb0e78949da" name="a1cd54b56f1bb183ab3898eb0e78949da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd54b56f1bb183ab3898eb0e78949da">&#9670;&#160;</a></span>iterative_closest_point() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVX , typename DerivedFX , typename DerivedVY , typename DerivedFY , typename DerivedNY , typename DerivedR , typename Derivedt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::iterative_closest_point </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVX &gt; &amp;&#160;</td>
          <td class="paramname"><em>VX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFX &gt; &amp;&#160;</td>
          <td class="paramname"><em>FX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVY &gt; &amp;&#160;</td>
          <td class="paramname"><em>VY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFY &gt; &amp;&#160;</td>
          <td class="paramname"><em>FY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedVY, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ytree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedNY &gt; &amp;&#160;</td>
          <td class="paramname"><em>NY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ytree</td><td>precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree for accelerating closest point queries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NY</td><td>#FY by 3 list of precomputed unit face normals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86feeac6e40d21e10cc147d82782000a" name="a86feeac6e40d21e10cc147d82782000a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86feeac6e40d21e10cc147d82782000a">&#9670;&#160;</a></span>jet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::jet </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jet colormap like MATLAB's jet. </p>
<dl class="section note"><dt>Note</dt><dd>that we actually use the Turbo colormap instead, since jet is a bad colormap: <a href="https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html">https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html</a></dd></dl>
<p>Wrapper for directly computing [r,g,b] values for a given factor f between 0 and 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>factor determining color value as if 0 was min and 1 was max </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>resulting rgb color<ul>
<li>r red value</li>
<li>g green value</li>
<li>b blue value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b40235bb5881e629930f522e5f3ee1a" name="a7b40235bb5881e629930f522e5f3ee1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b40235bb5881e629930f522e5f3ee1a">&#9670;&#160;</a></span>jet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::jet </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a495fc46dda1dad8354b6aa9f9f146c89" name="a495fc46dda1dad8354b6aa9f9f146c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495fc46dda1dad8354b6aa9f9f146c89">&#9670;&#160;</a></span>jet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedZ , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::jet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>#Z list of factors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>whether to normalize Z to be tightly between [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C by 3 list of rgb colors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ecfd839e37628b61641d0e766eaf12b" name="a5ecfd839e37628b61641d0e766eaf12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecfd839e37628b61641d0e766eaf12b">&#9670;&#160;</a></span>jet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedZ , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::jet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_z</td><td>value at blue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_z</td><td>value at red </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a85e70cd58bcb5ebb5b36ef4a010fde" name="a0a85e70cd58bcb5ebb5b36ef4a010fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a85e70cd58bcb5ebb5b36ef4a010fde">&#9670;&#160;</a></span>kelvinlets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename Derivedx0 , typename Derivedf , typename DerivedF , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::kelvinlets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedx0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedf &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1KelvinletParams.html">KelvinletParams</a>&lt; typename DerivedV::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements Pixar's Regularized Kelvinlets (Pixar Technical Memo #17-03): Sculpting Brushes based on Fundamental Solutions of Elasticity, a technique for real-time physically based volume sculpting of virtual elastic materials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of input points in space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>dim-vector of brush tip </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>dim-vector of brush force (translation) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>dim by dim matrix of brush force matrix (linear) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parameters for the kelvinlet brush like brush radius, scale etc </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>#V by dim list of output points in space </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c092ead172c396770ffeda0fcb56089" name="a2c092ead172c396770ffeda0fcb56089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c092ead172c396770ffeda0fcb56089">&#9670;&#160;</a></span>kkt_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::kkt_inverse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>use_lu_decomposition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the inverse of the KKT matrix of a convex, linear equality constrained quadratic minimization problem. </p>
<p>Systems of the form: </p><pre class="fragment"> / A   Aeqᵀ \  / x \ = / b   \
 \ Aeq    0 /  \ λ /   \ beq /
\_____.______/\__.__/ \___.___/
      M          z        c
</pre><p> Arise, for example, when solve convex, linear equality constrained quadratic minimization problems: </p><pre class="fragment">min ½ xᵀ A x - xᵀb  subject to Aeq x = beq
</pre><p> This function constructs a matrix S such that x = S c solves the system above. That is: </p><pre class="fragment">S = [In 0] M⁻¹

so that 

x = S c
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>n by n matrix of quadratic coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>n by 1 column of linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aeq</td><td>m by n list of linear equality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Beq</td><td>m by 1 list of linear equality constraint constant values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_lu_decomposition</td><td>use lu rather than SVD </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>n by (n + m) "solve" matrix, such that S*[B', Beq'] is a solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error </dd></dl>

</div>
</div>
<a id="a6f2969bd735df2588ce37026375ddefe" name="a6f2969bd735df2588ce37026375ddefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2969bd735df2588ce37026375ddefe">&#9670;&#160;</a></span>knn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename IndexType , typename DerivedCH , typename DerivedCN , typename DerivedW , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::knn </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;&#160;</td>
          <td class="paramname"><em>CH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neighbors for each point in P. </p>
<p>Note that each point is its own neighbor.</p>
<p>The octree data structures used in this function are intended to be the same ones output from <a class="el" href="namespaceigl.html#a3ff69240d0614e6f4ab20ff15b2f21a4" title="Given a set of 3D points P, generate data structures for a pointerless octree.">igl::octree</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of point locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of neighbors to find </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">point_indices</td><td>a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell's points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CH</td><td>#OctreeCells by 8, where the ith row is the indices of the ith octree cell's children </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CN</td><td>#OctreeCells by 3, where the ith row is a 3d row vector representing the position of the ith cell's center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#OctreeCells, a vector where the ith entry is the width of the ith octree cell </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#P by k list of k-nearest-neighbor indices into P </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8937a7fe108b5aa0669d3731c34e281d" name="a8937a7fe108b5aa0669d3731c34e281d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8937a7fe108b5aa0669d3731c34e281d">&#9670;&#160;</a></span>knn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedV , typename IndexType , typename DerivedCH , typename DerivedCN , typename DerivedW , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::knn </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCH &gt; &amp;&#160;</td>
          <td class="paramname"><em>CH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>only neighbors found in V </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of point locations for which may be neighbors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#P by k list of k-nearest-neighbor indices into V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af44b520d132c6b6d1941fe5819f45ae1" name="af44b520d132c6b6d1941fe5819f45ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44b520d132c6b6d1941fe5819f45ae1">&#9670;&#160;</a></span>launch_medit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::launch_medit </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>wait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the tetmesh in (V,T,F) to a temporary file, opens it with medit (forking with a system call) and returns. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>real-value: i.e. from MatrixXd </td></tr>
    <tr><td class="paramname">DerivedT</td><td>integer-value: i.e. from MatrixXi </td></tr>
    <tr><td class="paramname">DerivedF</td><td>integer-value: i.e. from MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T list of tet indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F list of face indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait</td><td>whether to wait for medit process to finish before returning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returned value of system call (probably not useful if wait=false because of the fork) </dd></dl>

</div>
</div>
<a id="a7e6a7f8c0fb33cae88074977a12e12fc" name="a7e6a7f8c0fb33cae88074977a12e12fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6a7f8c0fb33cae88074977a12e12fc">&#9670;&#160;</a></span>lbs_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::lbs_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear blend skinning can be expressed by V' = M * T where V' is a #V by dim matrix of deformed vertex positions (one vertex per row), M is a #V by (dim+1)*#T (composed of weights and rest positions) and T is a #T*(dim+1) by dim matrix of #T stacked transposed transformation matrices. </p>
<p>See equations (1) and (2) in "Fast Automatic Skinning Transformations" [Jacobson et al 2012]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of rest positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#V+ by #T list of weights </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#V by #T*(dim+1)</td></tr>
  </table>
  </dd>
</dl>
<p>In MATLAB: </p><pre class="fragment"> kron(ones(1,size(W,2)),[V ones(size(V,1),1)]).*kron(W,ones(1,size(V,2)+1)) 
</pre> 
</div>
</div>
<a id="abf08b3e278ea284934baa0d3f6dc4975" name="abf08b3e278ea284934baa0d3f6dc4975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf08b3e278ea284934baa0d3f6dc4975">&#9670;&#160;</a></span>lbs_matrix_column() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::lbs_matrix_column </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix that when multiplied against a column of affine transformation entries computes new coordinates of the vertices. </p>
<dl class="section note"><dt>Note</dt><dd>I'm not sure it makes since that the result is stored as a sparse matrix. The number of non-zeros per row <em>is</em> dependent on the number of mesh vertices and handles.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex rest positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#V by #handles list of correspondence weights </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#V * dim by #handles * dim * (dim+1) matrix such that new_V(:) = LBS(V,W,A) = reshape(M * A,size(V)), where A is a column vectors formed by the entries in each handle's dim by dim+1 transformation matrix. Specifcally, A = reshape(permute(Astack,[3 1 2]),n*dim*(dim+1),1) or A = [Lxx;Lyx;Lxy;Lyy;tx;ty], and likewise for other dim if Astack(:,:,i) is the dim by (dim+1) transformation at handle i</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="lbs__matrix_8h.html">include/igl/lbs_matrix.h</a> </p>

</div>
</div>
<a id="aaafa8162de573ea1c1c90b3f4ffad4a7" name="aaafa8162de573ea1c1c90b3f4ffad4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafa8162de573ea1c1c90b3f4ffad4a7">&#9670;&#160;</a></span>lbs_matrix_column() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::lbs_matrix_column </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5f0754d811bd0e0c95fac0317917c255" name="a5f0754d811bd0e0c95fac0317917c255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0754d811bd0e0c95fac0317917c255">&#9670;&#160;</a></span>lbs_matrix_column() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::lbs_matrix_column </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>W as a full matrix of weights (each vertex has #handles weights), a constant number of weights are given for each vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#V by k list of k correspondence weights per vertex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WI</td><td>#V by k list of k correspondence weight indices per vertex. Such that W(j,WI(i)) gives the ith most significant correspondence weight on vertex j </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24aaeb1753decc0b7602a6cb0432458e" name="a24aaeb1753decc0b7602a6cb0432458e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24aaeb1753decc0b7602a6cb0432458e">&#9670;&#160;</a></span>lbs_matrix_column() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::lbs_matrix_column </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7afcff53e324c859c08eaa01e48f4581" name="a7afcff53e324c859c08eaa01e48f4581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7afcff53e324c859c08eaa01e48f4581">&#9670;&#160;</a></span>lexicographic_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename Orient2D , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::lexicographic_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Orient2D&#160;</td>
          <td class="paramname"><em>orient2D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in 2D, return a lexicographic triangulation of these points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orient2D</td><td>A functor such that orient2D(pa, pb, pc) returns 1 if pa,pb,pc forms a conterclockwise triangle. -1 if pa,pb,pc forms a clockwise triangle. 0 if pa,pb,pc are collinear. where the argument pa,pb,pc are of type Scalar[2]. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 of faces in lexicographic triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2365ceb20a3b51fb10c3050cc456e343" name="a2365ceb20a3b51fb10c3050cc456e343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2365ceb20a3b51fb10c3050cc456e343">&#9670;&#160;</a></span>limit_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatF , typename VecL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::limit_faces </td>
          <td>(</td>
          <td class="paramtype">const MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecL &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>exclusive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatF &amp;&#160;</td>
          <td class="paramname"><em>LF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit given faces F to those which contain (only) indices found in L. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatF</td><td>matrix type of faces, matrixXi </td></tr>
    <tr><td class="paramname">VecL</td><td>matrix type of vertex indices, VectorXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#L by 1 list of allowed indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exclusive</td><td>flag specifying whether a face is included only if all its indices are in L, default is false </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LF</td><td>#LF by 3 list of remaining faces after limiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4deb0e936a117ec6c8c973f3d0670770" name="a4deb0e936a117ec6c8c973f3d0670770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4deb0e936a117ec6c8c973f3d0670770">&#9670;&#160;</a></span>line_field_mismatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::line_field_mismatch </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isCombed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>mismatch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the mismatch (integer), at each face edge, of a cross field defined on the mesh faces. </p>
<p>The integer mismatch is a multiple of pi/2 that transforms the cross on one side of the edge to the cross on the other side. It represents the deviation from a Lie connection across the edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD1</td><td>#F by 3 eigen Matrix of the first per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PD2</td><td>#F by 3 eigen Matrix of the second per face cross field vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isCombed</td><td>boolean, specifying whether the field is combed (i.e. matching has been precomputed. If not, the field is combed first. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mismatch</td><td>#F by 3 eigen Matrix containing the integer mismatch of the cross field across all face edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9145bd261a2cf691294d8104c99a4ab9" name="a9145bd261a2cf691294d8104c99a4ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9145bd261a2cf691294d8104c99a4ab9">&#9670;&#160;</a></span>line_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::line_search </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i_step_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; double(Eigen::MatrixXd &amp;)&gt;&#160;</td>
          <td class="paramname"><em>energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cur_energy</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement a bisection linesearch to minimize a mesh-based energy on vertices given at 'x' at a search direction 'd', with initial step size. </p>
<p>Stops when a point with lower energy is found, or after maximal iterations have been reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>#X by dim list of variables </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>#X by dim list of a given search direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i_step_size</td><td>initial step size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">energy</td><td>A function to compute the mesh-based energy (return an energy that is bigger than 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>#X by dim list of variables at the new location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cur_energy(OPTIONAL)</td><td>The energy at the given point. Helps save redundant computations. This is optional. If not specified, the function will compute it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the energy at the new point 'x' </dd></dl>

</div>
</div>
<a id="a2b5853a837850f17eadaff857ad1e463" name="a2b5853a837850f17eadaff857ad1e463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b5853a837850f17eadaff857ad1e463">&#9670;&#160;</a></span>line_segment_in_rectangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::line_segment_in_rectangle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a line segment overlaps with a rectangle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>source point of line segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dest point of line segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first corner of rectangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>opposite corner of rectangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if line segment is at all inside rectangle </dd></dl>

</div>
</div>
<a id="afa9c39cf6f0bef4857b1dc66360e4f52" name="afa9c39cf6f0bef4857b1dc66360e4f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9c39cf6f0bef4857b1dc66360e4f52">&#9670;&#160;</a></span>linprog() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::linprog </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a linear program given in "standard form". </p>
<pre class="fragment"> min  c'x
 s.t. A(    1:k,:) x &lt;= b(1:k)
      A(k+1:end,:) x = b(k+1:end)
   ** x &gt;= 0 **
</pre><p> In contrast to other APIs the entries in b may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>#x list of linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by #x matrix of linear constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#A list of linear constraint right-hand sides </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of inequality constraints as first rows of A,b </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>#x solution vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on failure or detected infeasibility, returns true on termination</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It appears that this implementation does not detect all infeasibile problems (e.g., <a href="https://github.com/libigl/libigl/issues/2051">https://github.com/libigl/libigl/issues/2051</a>). Therefor, it's worth double-checking that the output actually satisfies the constraints even if the return value is <code>true</code>. </dd></dl>

</div>
</div>
<a id="a9455a41cb54a91242fe498354445bd28" name="a9455a41cb54a91242fe498354445bd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9455a41cb54a91242fe498354445bd28">&#9670;&#160;</a></span>linprog() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::linprog </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper in friendlier general form (no implicit bounds on x) </p><pre class="fragment">min  f'x
s.t. A x &lt;= b
     B x = c
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>#x list of linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by #x matrix of linear inequality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#A list of linear constraint right-hand sides </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#B by #x matrix of linear equality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>#B list of linear constraint right-hand sides </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>#x solution vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false on failure or detected infeasibility, returns true on termination </dd></dl>

</div>
</div>
<a id="ae8a4579279c09a298a5988c18f215d33" name="ae8a4579279c09a298a5988c18f215d33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a4579279c09a298a5988c18f215d33">&#9670;&#160;</a></span>LinSpaced()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Derived igl::LinSpaced </td>
          <td>(</td>
          <td class="paramtype">typename Derived::Index&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derived::Scalar &amp;&#160;</td>
          <td class="paramname"><em>high</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replacement for Eigen::DenseBase::LinSpaced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">low</td><td>first element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">high</td><td>last element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of size elements linearly spaced between low and</dd></dl>
<p><a class="el" href="LinSpaced_8h.html" title="This function is not intended to be a permanent function of libigl.">include/igl/LinSpaced.h</a> </p>

</div>
</div>
<a id="a6df6ee5a6c7852f628cefbb8dbb025af" name="a6df6ee5a6c7852f628cefbb8dbb025af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df6ee5a6c7852f628cefbb8dbb025af">&#9670;&#160;</a></span>list_to_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::list_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list (std::vector) of row vectors of the same length to a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type that can be safely cast to type in Mat via '=' </td></tr>
    <tr><td class="paramname">Mat</td><td>Matrix type, must implement: .resize(m,n) .row(i) = Row </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>a m-long list of vectors of size n </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>an m by n matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="ae5fd001a788d43f744d257d305ddb1b3" name="ae5fd001a788d43f744d257d305ddb1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fd001a788d43f744d257d305ddb1b3">&#9670;&#160;</a></span>list_to_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N, typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::list_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::array&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a47b768c6f9bfb5e3e0342cbe32f91110" name="a47b768c6f9bfb5e3e0342cbe32f91110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b768c6f9bfb5e3e0342cbe32f91110">&#9670;&#160;</a></span>list_to_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::list_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Vector version. </p>

</div>
</div>
<a id="a25bb0b08ed4407588cdc107ce3f99b3d" name="a25bb0b08ed4407588cdc107ce3f99b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bb0b08ed4407588cdc107ce3f99b3d">&#9670;&#160;</a></span>list_to_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::list_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of row vectors of <code>n</code> or less to a matrix and pad on the right with <code>padding</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>a m-long list of vectors of size &lt;=n </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">padding</td><td>value to fill in from right for short rows </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>an m by n matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a108a662cae580e5c3459d81435f32e24" name="a108a662cae580e5c3459d81435f32e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108a662cae580e5c3459d81435f32e24">&#9670;&#160;</a></span>local_basis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::local_basis </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>B3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a local orthogonal reference system for each triangle in the given mesh. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived from vertex positions matrix type: i.e. MatrixXd </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived from face indices matrix type: i.e. MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>eigen matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B1</td><td>eigen matrix #F by 3, each vector is tangent to the triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B2</td><td>eigen matrix #F by 3, each vector is tangent to the triangle and perpendicular to B1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B3</td><td>eigen matrix #F by 3, normal of the triangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae46bcc8364a310c7a3bc0ee718b91fb1" name="ae46bcc8364a310c7a3bc0ee718b91fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46bcc8364a310c7a3bc0ee718b91fb1">&#9670;&#160;</a></span>look_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedeye , typename Derivedcenter , typename Derivedup , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::look_at </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedeye &gt; &amp;&#160;</td>
          <td class="paramname"><em>eye</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedcenter &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedup &gt; &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the deprecated gluLookAt function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eye</td><td>3-vector of eye position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">center</td><td>3-vector of center reference point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">up</td><td>3-vector of up vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>4x4 rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea9965bc615b0a851fabf90d37a73320" name="aea9965bc615b0a851fabf90d37a73320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9965bc615b0a851fabf90d37a73320">&#9670;&#160;</a></span>loop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename SType , typename DerivedNF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::loop </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; SType &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the triangle mesh [V, F], where n_verts = V.rows(), computes newV and a sparse matrix S s.t. </p>
<p>[newV, newF] is the subdivided mesh where newV = S*V.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_verts</td><td>an integer (number of mesh vertices) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>an m by 3 matrix of integers of triangle faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>a sparse matrix (will become the subdivision matrix) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newF</td><td>a matrix containing the new faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee95891ee4e9418b27c3fbfa92542784" name="aee95891ee4e9418b27c3fbfa92542784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee95891ee4e9418b27c3fbfa92542784">&#9670;&#160;</a></span>loop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::loop </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;&#160;</td>
          <td class="paramname"><em>NV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>number_of_subdivs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the triangle mesh [V, F], computes number_of_subdivs steps of loop subdivision and outputs the new mesh [newV, newF]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>an n by 3 matrix of vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>an m by 3 matrix of integers of triangle faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NV</td><td>a matrix containing the new vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NF</td><td>a matrix containing the new faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">number_of_subdivs</td><td>an integer that specifies how many subdivision steps to do </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31de2a4d188ef681f7057d0d948edbf1" name="a31de2a4d188ef681f7057d0d948edbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31de2a4d188ef681f7057d0d948edbf1">&#9670;&#160;</a></span>lscm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedV_uv , typename QScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::lscm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV_uv &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_uv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; QScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a Least-squares conformal map parametrization (equivalently derived in "Intrinsic Parameterizations of Surface Meshes" [Desbrun et al. </p>
<p>2002] and "Least Squares Conformal Maps for Automatic Texture Atlas
Generation" [Lévy et al. 2002]), though this implementation follows the derivation in: "Spectral Conformal Parameterization" [Mullen et al. 2008] (note, this does <b>not</b> implement the Eigen-decomposition based method in [Mullen et al. 2008], see below). Input should be a manifold mesh (also no unreferenced vertices) and "boundary" (fixed vertices) <code>b</code> should contain at least two vertices per connected component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b boundary indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by 2 list of boundary values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UV</td><td>#V by 2 list of 2D mesh vertex positions in UV space </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#Vx2 by #Vx2 symmetric positive semi-definite matrix for computing LSCM energy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only on solver success. </dd></dl>

</div>
</div>
<a id="a1c37dc9607d1629ed72cba5af4e64554" name="a1c37dc9607d1629ed72cba5af4e64554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c37dc9607d1629ed72cba5af4e64554">&#9670;&#160;</a></span>lscm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedb , typename Derivedbc , typename DerivedV_uv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::lscm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV_uv &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a378192fe12df93afb032da2706ff5c0a" name="a378192fe12df93afb032da2706ff5c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378192fe12df93afb032da2706ff5c0a">&#9670;&#160;</a></span>lscm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedV_uv &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::lscm </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV_uv &gt; &amp;&#160;</td>
          <td class="paramname"><em>V_uv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Free boundary version. "Spectral Conformal Parameterization" using eigen decomposition; Assumes mesh is a single connected component topologically equivalent to a chunk of the plane. </p>

</div>
</div>
<a id="a1cf5daa1660b341b111456aabafc1f9b" name="a1cf5daa1660b341b111456aabafc1f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf5daa1660b341b111456aabafc1f9b">&#9670;&#160;</a></span>lscm_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename QScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::lscm_hessian </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; QScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a Least-squares conformal map parametrization (equivalently derived in "Intrinsic Parameterizations of Surface Meshes" [Desbrun et al. </p>
<p>2002] and "Least Squares Conformal Maps for Automatic Texture Atlas
Generation" [Lévy et al. 2002]), though this implementation follows the derivation in: "Spectral Conformal Parameterization" [Mullen et al. 2008] (note, this does <b>not</b> implement the Eigen-decomposition based method in [Mullen et al. 2008], which is not equivalent). Input should be a manifold mesh (also no unreferenced vertices) and "boundary" (fixed vertices) <code>b</code> should contain at least two vertices per connected component.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b boundary indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by 2 list of boundary values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UV</td><td>#V by 2 list of 2D mesh vertex positions in UV space </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#Vx2 by #Vx2 symmetric positive semi-definite matrix for computing LSCM energy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only on solver success. </dd></dl>

</div>
</div>
<a id="a8b077eb9a7d351e5b313ff150dc3eabb" name="a8b077eb9a7d351e5b313ff150dc3eabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b077eb9a7d351e5b313ff150dc3eabb">&#9670;&#160;</a></span>map_vertices_to_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::map_vertices_to_circle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>bnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the vertices whose indices are in a given boundary loop (bnd) on the unit circle with spacing proportional to the original boundary edge lengths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#W list of vertex ids </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UV</td><td>#W by 2 list of 2D position on the unit circle for the vertices in b </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a118619cf44f20a0956f9e856707aa2" name="a0a118619cf44f20a0956f9e856707aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a118619cf44f20a0956f9e856707aa2">&#9670;&#160;</a></span>mapping_energy_with_jacobians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::mapping_energy_with_jacobians </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Ji</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>areas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">igl::MappingEnergyType</a>&#160;</td>
          <td class="paramname"><em>slim_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exp_factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the rotation-invariant energy of a mapping (represented in Jacobians and areas) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ji</td><td>#F by 4 (9 if 3D) entries of jacobians </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">areas</td><td>#F by 1 face areas </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slim_energy</td><td>energy type as in <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739" title="Energy Types used for Parameterization/Mapping.">igl::MappingEnergyType</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exp_factor</td><td>see <a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739" title="Energy Types used for Parameterization/Mapping.">igl::MappingEnergyType</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>energy value</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739" title="Energy Types used for Parameterization/Mapping.">MappingEnergyType</a> </dd></dl>

</div>
</div>
<a id="a75c4985a12f6c71116d36492d2f6154d" name="a75c4985a12f6c71116d36492d2f6154d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c4985a12f6c71116d36492d2f6154d">&#9670;&#160;</a></span>march_cube()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedGV , typename Scalar , typename Index , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::march_cube </td>
          <td>(</td>
          <td class="paramtype">const DerivedGV &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 8, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Index, 8, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; int64_t, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>E2V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process a single cube of a marching cubes grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">GV</td><td>#GV by 3 list of grid vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cS</td><td>list of 8 scalar field values at grid corners </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cI</td><td>list of 8 indices of corners into rows of GV </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>level-set value being extracted (often 0) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V by 3 current list of output mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">n</td><td>current number of mesh vertices (i.e., occupied rows in V) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F by 3 current list of output mesh triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">m</td><td>current number of mesh triangles (i.e., occupied rows in F) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">E2V</td><td>current edge (GV_i,GV_j) to vertex (V_k) map</td></tr>
  </table>
  </dd>
</dl>
<p>Side-effects: V,n,F,m,E2V are updated to contain new vertices and faces of any constructed mesh elements </p>

</div>
</div>
<a id="a3e677970b7188cac95bc9f93181f2ed7" name="a3e677970b7188cac95bc9f93181f2ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e677970b7188cac95bc9f93181f2ed7">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedGV , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh defined by vertices and faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>nx*ny*nz list of values at each grid corner i.e. S(x + y*xres + z*xres*yres) for corner (x,y,z) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GV</td><td>nx*ny*nz by 3 array of corresponding grid corner vertex locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>resolutions of the grid in x dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>resolutions of the grid in y dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>resolutions of the grid in z dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>the isovalue of the surface to reconstruct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into rows of V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60d3b30634f77428770f2ae32f34059" name="af60d3b30634f77428770f2ae32f34059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60d3b30634f77428770f2ae32f34059">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedGV , typename DerivedGI , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedGI &gt; &amp;&#160;</td>
          <td class="paramname"><em>GI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Sparse voxel version</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#S list of scalar field values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GV</td><td>#S by 3 list of referenced grid vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GI</td><td>#GI by 8 list of grid corner indices into rows of GV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5512306a29939c7ac8d4ebcef2cd032a" name="a5512306a29939c7ac8d4ebcef2cd032a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5512306a29939c7ac8d4ebcef2cd032a">&#9670;&#160;</a></span>marching_tets() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename DerivedJ , typename BCType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_tets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;&#160;</td>
          <td class="paramname"><em>TV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; BCType &gt; &amp;&#160;</td>
          <td class="paramname"><em>BC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the marching tetrahedra algorithm on a tet mesh defined by TV and TT with scalar values defined at each vertex in TV. </p>
<p>The output is a triangle mesh approximating the isosurface coresponding to the value isovalue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">TV</td><td>#tet_vertices x 3 array &ndash; The vertices of the tetrahedral mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TT</td><td>#tets x 4 array &ndash; The indexes of each tet in the tetrahedral mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#tet_vertices x 1 array &ndash; The values defined on each tet vertex </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>scalar &ndash; The isovalue of the level set we want to compute </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SV</td><td>#SV x 3 array &ndash; The vertices of the output level surface mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SF</td><td>#SF x 3 array &ndash; The face indexes of the output level surface mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#SF list of indices into TT revealing which tet each face comes from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BC</td><td>#SV x #TV list of barycentric coordinates so that SV = BC*TV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa49f489ae12ec4a901418253fcd3f3ed" name="aa49f489ae12ec4a901418253fcd3f3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49f489ae12ec4a901418253fcd3f3ed">&#9670;&#160;</a></span>marching_tets() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename DerivedJ , typename BCType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_tets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;&#160;</td>
          <td class="paramname"><em>TV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; BCType &gt; &amp;&#160;</td>
          <td class="paramname"><em>BC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>assumes isovalue = 0 </p>

</div>
</div>
<a id="a77b74374c21bab647512f658e050cc27" name="a77b74374c21bab647512f658e050cc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b74374c21bab647512f658e050cc27">&#9670;&#160;</a></span>marching_tets() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_tets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;&#160;</td>
          <td class="paramname"><em>TV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac630f9be345647d2008378e9489ea50e" name="ac630f9be345647d2008378e9489ea50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac630f9be345647d2008378e9489ea50e">&#9670;&#160;</a></span>marching_tets() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF , typename BCType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_tets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;&#160;</td>
          <td class="paramname"><em>TV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; BCType &gt; &amp;&#160;</td>
          <td class="paramname"><em>BC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4416636f9a80fb95a7656732a32dbf0f" name="a4416636f9a80fb95a7656732a32dbf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4416636f9a80fb95a7656732a32dbf0f">&#9670;&#160;</a></span>marching_tets() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedTV , typename DerivedTT , typename DerivedS , typename DerivedSV , typename DerivedSF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::marching_tets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTV &gt; &amp;&#160;</td>
          <td class="paramname"><em>TV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a72cf047d8b4df743c47bbbf0ba9dc6e1" name="a72cf047d8b4df743c47bbbf0ba9dc6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cf047d8b4df743c47bbbf0ba9dc6e1">&#9670;&#160;</a></span>massmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::massmatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the mass (area) matrix for a given mesh (V,F). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived type of eigen matrix for V (e.g. derived from MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived type of eigen matrix for F (e.g. derived from MatrixXi) </td></tr>
    <tr><td class="paramname">Scalar</td><td>scalar type for eigen sparse matrix (e.g. double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh elements (triangles or tetrahedra) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>one of the following ints: MASSMATRIX_TYPE_BARYCENTRIC barycentric {default for tetrahedra} MASSMATRIX_TYPE_VORONOI voronoi-hybrid {default for triangles, not implemented for tetrahedra} MASSMATRIX_TYPE_FULL full </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#V by #V mass matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a> </dd></dl>

</div>
</div>
<a id="a4ab669b8ca4aea8ed68a0ba8c58a39bb" name="a4ab669b8ca4aea8ed68a0ba8c58a39bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab669b8ca4aea8ed68a0ba8c58a39bb">&#9670;&#160;</a></span>massmatrix_intrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::massmatrix_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the mass (area) matrix for a given mesh (V,F). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l</td><td>#l by simplex_size list of mesh edge lengths </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh elements (triangles or tetrahedra) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>one of the following ints: MASSMATRIX_TYPE_BARYCENTRIC barycentric MASSMATRIX_TYPE_VORONOI voronoi-hybrid {default} MASSMATRIX_TYPE_FULL full </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>#V by #V mass matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a72cf047d8b4df743c47bbbf0ba9dc6e1" title="Constructs the mass (area) matrix for a given mesh (V,F).">massmatrix</a> </dd></dl>

</div>
</div>
<a id="af2f410b7b17ce4aca5873af755825d76" name="af2f410b7b17ce4aca5873af755825d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f410b7b17ce4aca5873af755825d76">&#9670;&#160;</a></span>massmatrix_intrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedl , typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::massmatrix_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedl &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a8ed02513847d2f3fdb8c74dcbe55bb90">MassMatrixType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of vertices (&gt;= F.maxCoeff()+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae45c197a9b5b63af57d2791909442e41" name="ae45c197a9b5b63af57d2791909442e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45c197a9b5b63af57d2791909442e41">&#9670;&#160;</a></span>mat4_to_quat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::mat4_to_quat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a OpenGL (rotation) matrix to a quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>16-element opengl rotation matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>4-element quaternion (not normalized) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa21c6c4b638d223560312607397b5ba8" name="aa21c6c4b638d223560312607397b5ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa21c6c4b638d223560312607397b5ba8">&#9670;&#160;</a></span>mat3_to_quat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::mat3_to_quat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="afa21880837017adbf621456039ee7682" name="afa21880837017adbf621456039ee7682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa21880837017adbf621456039ee7682">&#9670;&#160;</a></span>MAYA_GREEN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_GREEN </td>
          <td>(</td>
          <td class="paramtype">128./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">242./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4babb52f3f1868081e0cefa0e4f56e07" name="a4babb52f3f1868081e0cefa0e4f56e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4babb52f3f1868081e0cefa0e4f56e07">&#9670;&#160;</a></span>MAYA_YELLOW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_YELLOW </td>
          <td>(</td>
          <td class="paramtype">255./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">247./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">50./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10e550e4712ab9495265314ad14c3372" name="a10e550e4712ab9495265314ad14c3372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e550e4712ab9495265314ad14c3372">&#9670;&#160;</a></span>MAYA_RED()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_RED </td>
          <td>(</td>
          <td class="paramtype">234./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">63./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">52./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a669df861bcae5e90ab84e929012a1007" name="a669df861bcae5e90ab84e929012a1007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669df861bcae5e90ab84e929012a1007">&#9670;&#160;</a></span>MAYA_BLUE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_BLUE </td>
          <td>(</td>
          <td class="paramtype">0./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">73./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">252./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3d3a9a0275b56ed0378893b3e80f0b4" name="af3d3a9a0275b56ed0378893b3e80f0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d3a9a0275b56ed0378893b3e80f0b4">&#9670;&#160;</a></span>MAYA_PURPLE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_PURPLE </td>
          <td>(</td>
          <td class="paramtype">180./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">73./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">200./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2348169281b988537537308cba384db3" name="a2348169281b988537537308cba384db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2348169281b988537537308cba384db3">&#9670;&#160;</a></span>MAYA_VIOLET()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_VIOLET </td>
          <td>(</td>
          <td class="paramtype">31./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">15./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">66./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acf86c730ad8ddf83e5c89d8589047364" name="acf86c730ad8ddf83e5c89d8589047364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf86c730ad8ddf83e5c89d8589047364">&#9670;&#160;</a></span>MAYA_GREY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_GREY </td>
          <td>(</td>
          <td class="paramtype">0.&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0.&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0.&#160;</td>
          <td class="paramname"><em>5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname"><em>0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a362ead03e0717a9a1e39f52996e6f6db" name="a362ead03e0717a9a1e39f52996e6f6db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362ead03e0717a9a1e39f52996e6f6db">&#9670;&#160;</a></span>MAYA_CYAN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_CYAN </td>
          <td>(</td>
          <td class="paramtype">131./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">219./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">252./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a576798d977c56f9ebd4699e1d9693dd3" name="a576798d977c56f9ebd4699e1d9693dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576798d977c56f9ebd4699e1d9693dd3">&#9670;&#160;</a></span>MAYA_SEA_GREEN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::Vector4f igl::MAYA_SEA_GREEN </td>
          <td>(</td>
          <td class="paramtype">70./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">252./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">167./&#160;</td>
          <td class="paramname"><em>255.</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1.&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64d87355c9c3b734e7658eed10bdd764" name="a64d87355c9c3b734e7658eed10bdd764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d87355c9c3b734e7658eed10bdd764">&#9670;&#160;</a></span>matlab_format() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::WithFormat&lt; DerivedM &gt; igl::matlab_format </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a routine to print a matrix using format suitable for pasting into the matlab IDE. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedM</td><td>e.g. derived from MatrixXd </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>some matrix to be formatted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of matrix (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Formatted matrix</dd></dl>
<h4><a class="anchor" id="autotoc_md15"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="comment">// M := [1 2 3;4 5 6];</span></div>
<div class="line">cout&lt;&lt;<a class="code hl_function" href="namespaceigl.html#a6b539a21fb577617710f5fce2046e65b">matlab_format</a>(M)&lt;&lt;endl;</div>
<div class="line"><span class="comment">// Prints:</span></div>
<div class="line"><span class="comment">// [</span></div>
<div class="line"><span class="comment">//   1 2 3</span></div>
<div class="line"><span class="comment">//   4 5 6</span></div>
<div class="line"><span class="comment">// ];</span></div>
<div class="line">cout&lt;&lt;<a class="code hl_function" href="namespaceigl.html#a6b539a21fb577617710f5fce2046e65b">matlab_format</a>(M,<span class="stringliteral">&quot;M&quot;</span>)&lt;&lt;endl;</div>
<div class="line"><span class="comment">// Prints:</span></div>
<div class="line"><span class="comment">// M = [</span></div>
<div class="line"><span class="comment">//   1 2 3</span></div>
<div class="line"><span class="comment">//   4 5 6</span></div>
<div class="line"><span class="comment">// ];</span></div>
<div class="ttc" id="anamespaceigl_html_a6b539a21fb577617710f5fce2046e65b"><div class="ttname"><a href="namespaceigl.html#a6b539a21fb577617710f5fce2046e65b">igl::matlab_format</a></div><div class="ttdeci">Eigen::IOFormat matlab_format()</div><div class="ttdoc">Just build and return the format.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="acc0f1184f42624896cf510cd82ccb6ca" name="acc0f1184f42624896cf510cd82ccb6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0f1184f42624896cf510cd82ccb6ca">&#9670;&#160;</a></span>matlab_format_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::matlab_format_index </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Add +1 to every entry before formatting. </p>

</div>
</div>
<a id="a92ca4e0bd6d85899d88544c29389b048" name="a92ca4e0bd6d85899d88544c29389b048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ca4e0bd6d85899d88544c29389b048">&#9670;&#160;</a></span>matlab_format() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string igl::matlab_format </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same but for sparse matrices. </p>
<p>Print IJV format into an auxiliary variable and then print a call to sparse which will construct the sparse matrix</p>
<h4><a class="anchor" id="autotoc_md16"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="comment">// S := [0 2 3;4 5 0];</span></div>
<div class="line">cout&lt;&lt;<a class="code hl_function" href="namespaceigl.html#a6b539a21fb577617710f5fce2046e65b">matlab_format</a>(S,<span class="stringliteral">&quot;S&quot;</span>)&lt;&lt;endl;</div>
<div class="line"><span class="comment">// Prints:</span></div>
<div class="line"><span class="comment">// SIJV = [</span></div>
<div class="line"><span class="comment">//   2 1 4</span></div>
<div class="line"><span class="comment">//   1 2 2</span></div>
<div class="line"><span class="comment">//   2 2 5</span></div>
<div class="line"><span class="comment">//   1 3 3</span></div>
<div class="line"><span class="comment">// ];</span></div>
<div class="line"><span class="comment">// S = sparse(SIJV(:,1),SIJV(:,2),SIJV(:,3));</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9641504c7ccb6996da7abc34c5ebe6a1" name="a9641504c7ccb6996da7abc34c5ebe6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9641504c7ccb6996da7abc34c5ebe6a1">&#9670;&#160;</a></span>matlab_format() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string igl::matlab_format </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Scalars. </p>

</div>
</div>
<a id="a367414630ebe7f7fe7a243502d57b1ad" name="a367414630ebe7f7fe7a243502d57b1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367414630ebe7f7fe7a243502d57b1ad">&#9670;&#160;</a></span>matlab_format() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string igl::matlab_format </td>
          <td>(</td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6b539a21fb577617710f5fce2046e65b" name="a6b539a21fb577617710f5fce2046e65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b539a21fb577617710f5fce2046e65b">&#9670;&#160;</a></span>matlab_format() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::IOFormat igl::matlab_format </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just build and return the format. </p>
<dl class="section return"><dt>Returns</dt><dd>eigen IOFormat object</dd></dl>
<h4><a class="anchor" id="autotoc_md17"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="comment">// M := [1 2 3;4 5 6];</span></div>
<div class="line">cout&lt;&lt;M.format(<a class="code hl_function" href="namespaceigl.html#a6b539a21fb577617710f5fce2046e65b">matlab_format</a>())&lt;&lt;endl;</div>
<div class="line"><span class="comment">// Prints:</span></div>
<div class="line"><span class="comment">// [</span></div>
<div class="line"><span class="comment">//   1 2 3</span></div>
<div class="line"><span class="comment">//   4 5 6</span></div>
<div class="line"><span class="comment">// ];</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac9d68f355e17a7ba95194bfd46f3ce49" name="ac9d68f355e17a7ba95194bfd46f3ce49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d68f355e17a7ba95194bfd46f3ce49">&#9670;&#160;</a></span>matrix_to_list() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::matrix_to_list </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; typename DerivedM::Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a matrix to a list (std::vector) of row vectors of the same size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat</td><td>Matrix type, must implement: .resize(m,n) .row(i) = Row </td></tr>
    <tr><td class="paramname">T</td><td>type that can be safely cast to type in Mat via '=' </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>an m by n matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>a m-long list of vectors of size n</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a6df6ee5a6c7852f628cefbb8dbb025af" title="Convert a list (std::vector) of row vectors of the same length to a matrix.">list_to_matrix</a> </dd></dl>

</div>
</div>
<a id="adc8c8289cdddc4408bc1e12579de244c" name="adc8c8289cdddc4408bc1e12579de244c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8c8289cdddc4408bc1e12579de244c">&#9670;&#160;</a></span>matrix_to_list() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::matrix_to_list </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename DerivedM::Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a matrix to a list (std::vector) of elements in column-major ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>an m by n matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>an m*n list of elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec3a51cfa07853b2b45e1226672e16da" name="aec3a51cfa07853b2b45e1226672e16da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3a51cfa07853b2b45e1226672e16da">&#9670;&#160;</a></span>matrix_to_list() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; typename DerivedM::Scalar &gt; igl::matrix_to_list </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a406b1c228d9a40c7c25062de5c6e20c9" name="a406b1c228d9a40c7c25062de5c6e20c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406b1c228d9a40c7c25062de5c6e20c9">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedB , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum along dimension dim of a matrix X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to take max </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>n-long vector (if dim == 1) Y m-long vector (if dim == 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>vector the same size as Y containing the indices along dim of minimum entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e2e2d77d83c68427be201b4e3a877a6" name="a5e2e2d77d83c68427be201b4e3a877a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2e2d77d83c68427be201b4e3a877a6">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::max </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a74b5b6981f78cc7519e2ac080f4ec561" name="a74b5b6981f78cc7519e2ac080f4ec561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b5b6981f78cc7519e2ac080f4ec561">&#9670;&#160;</a></span>max_faces_stopping_condition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::max_faces_stopping_condition </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>orig_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> &amp;&#160;</td>
          <td class="paramname"><em>stopping_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stopping condition function compatible with <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>. </p>
<p>The outpute function handle will return true if number of faces is less than max_m</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>reference to working variable initially should be set to current number of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orig_m</td><td>number (size) of original face list <em><b>not</b></em> including any faces added to handle phony boundary faces connecting to point at infinity. For closed meshes it's safe to set this to F.rows() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_m</td><td>maximum number of faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stopping_condition</td><td></td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="decimate_8h.html" title="igl::decimate implements a customizable greedy edge collapser using a priority-queue:">decimate.h</a> for more details </p>

</div>
</div>
<a id="afb31e9c7165119e57a70705383c7275d" name="afb31e9c7165119e57a70705383c7275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb31e9c7165119e57a70705383c7275d">&#9670;&#160;</a></span>max_faces_stopping_condition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl.html#a64c8b006ed52af02a20d1664722a94b3">decimate_stopping_condition_callback</a> igl::max_faces_stopping_condition </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>orign_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad4303b454ca438ac3e09fdc506d431df" name="ad4303b454ca438ac3e09fdc506d431df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4303b454ca438ac3e09fdc506d431df">&#9670;&#160;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::max_size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine max size of lists in a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>some list type object that implements .size() </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>vector of list types T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max .size() found in V, returns -1 if V is empty </dd></dl>

</div>
</div>
<a id="ad73289b6fbba95eacda8174e185dcf9f" name="ad73289b6fbba95eacda8174e185dcf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73289b6fbba95eacda8174e185dcf9f">&#9670;&#160;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename mType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::median </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median of an eigen vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V list of unsorted values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>median of those values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure </dd></dl>

</div>
</div>
<a id="aea356ce5149b60ed9d36e9f7a94db372" name="aea356ce5149b60ed9d36e9f7a94db372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea356ce5149b60ed9d36e9f7a94db372">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedB , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::min </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the minimum along dimension dim of a matrix X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to take min </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>n-long vector (if dim == 1) Y m-long vector (if dim == 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>vector the same size as Y containing the indices along dim of minimum entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b9c8ab934e0d7755a6c90c0fa6486c4" name="a9b9c8ab934e0d7755a6c90c0fa6486c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9c8ab934e0d7755a6c90c0fa6486c4">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::min </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="adc0382628e374a5b92a226ad75ce6b8b" name="adc0382628e374a5b92a226ad75ce6b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0382628e374a5b92a226ad75ce6b8b">&#9670;&#160;</a></span>min_quad_with_fixed_precompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derivedknown &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::min_quad_with_fixed_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedknown &gt; &amp;&#160;</td>
          <td class="paramname"><em>known</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimize a convex quadratic energy subject to fixed value and linear equality constraints. </p>
<p>Problems of the form </p><pre class="fragment">trace( 0.5*Z'*A*Z + Z'*B + constant )
</pre><p> subject to</p>
<p>Z(known,:) = Y, and Aeq*Z = Beq</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>n by n matrix of quadratic coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">known</td><td>list of indices to known rows in Z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>list of fixed values corresponding to known rows in Z </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Aeq</td><td>m by n list of linear equality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>flag specifying whether A(unknown,unknown) is positive definite </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>factorization struct with all necessary information to solve using min_quad_with_fixed_solve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>rows of Aeq <b>should probably</b> be linearly independent. During precomputation, the rows of a Aeq are checked via QR. But in case they're not then resulting probably will no longer be sparse: it will be slow. </dd></dl>

</div>
</div>
<a id="ad6d436a09a132f780d5e503b39499fbb" name="ad6d436a09a132f780d5e503b39499fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d436a09a132f780d5e503b39499fbb">&#9670;&#160;</a></span>min_quad_with_fixed_solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DerivedB , typename DerivedY , typename DerivedBeq , typename DerivedZ , typename Derivedsol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::min_quad_with_fixed_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedBeq &gt; &amp;&#160;</td>
          <td class="paramname"><em>Beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedsol &gt; &amp;&#160;</td>
          <td class="paramname"><em>sol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system previously factored using min_quad_with_fixed_precompute. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of sparse matrix (e.g. double) </td></tr>
    <tr><td class="paramname">DerivedY</td><td>type of Y (e.g. derived from VectorXd or MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedZ</td><td>type of Z (e.g. derived from VectorXd or MatrixXd) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>factorization struct with all necessary precomputation to solve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>n by k column of linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>b by k list of constant fixed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Beq</td><td>m by k list of linear equality constraint constant values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>n by k solution </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sol</td><td>#unknowns+#lagrange by k solution to linear system Returns true on success, false on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5720740af2df4180f61b1731bd5499f" name="ad5720740af2df4180f61b1731bd5499f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5720740af2df4180f61b1731bd5499f">&#9670;&#160;</a></span>min_quad_with_fixed_solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DerivedB , typename DerivedY , typename DerivedBeq , typename DerivedZ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::min_quad_with_fixed_solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structigl_1_1min__quad__with__fixed__data.html">min_quad_with_fixed_data</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedBeq &gt; &amp;&#160;</td>
          <td class="paramname"><em>Beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abcdcf5c62d46412f4b5de5889e51c0d4" name="abcdcf5c62d46412f4b5de5889e51c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdcf5c62d46412f4b5de5889e51c0d4">&#9670;&#160;</a></span>min_quad_with_fixed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Derivedknown , typename DerivedB , typename DerivedY , typename DerivedBeq , typename DerivedZ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::min_quad_with_fixed </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedknown &gt; &amp;&#160;</td>
          <td class="paramname"><em>known</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aeq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedBeq &gt; &amp;&#160;</td>
          <td class="paramname"><em>Beq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>pd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Minimize convex quadratic energy subject to fixed value and linear equality constraints. Without prefactorization. </p>

</div>
</div>
<a id="a897bf8d157d9e2b51b81603c5fd6e099" name="a897bf8d157d9e2b51b81603c5fd6e099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897bf8d157d9e2b51b81603c5fd6e099">&#9670;&#160;</a></span>min_quad_with_fixed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int n, int m, bool Hpd = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, n, 1 &gt; igl::min_quad_with_fixed </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, m, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, m, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dense version optimized for very small, known at compile time sizes. </p>
<p>Still works for Eigen::Dynamic (and then everything needs to be Dynamic).</p>
<p>min_x ½ xᵀ H x + xᵀ f subject to A x = b x(i) = bc(i) iff k(i)==true</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>(e.g., double) </td></tr>
    <tr><td class="paramname">n</td><td>#H or Eigen::Dynamic if not known at compile time </td></tr>
    <tr><td class="paramname">m</td><td>#A or Eigen::Dynamic if not known at compile time </td></tr>
    <tr><td class="paramname">Hpd</td><td>whether H is positive definite (LLT used) or not (QR used) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>#H by #H quadratic coefficients (only lower triangle used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>#H linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>#H list of flags whether to fix value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#H value to fix to (if !k(i) then bc(i) is ignored) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by #H list of linear equality constraint coefficients, must be linearly independent (with self and fixed value constraints) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#A list of linear equality right-hand sides </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#H-long solution x </dd></dl>

</div>
</div>
<a id="a4f2961e370b73126b4896c0f53cc8af4" name="a4f2961e370b73126b4896c0f53cc8af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2961e370b73126b4896c0f53cc8af4">&#9670;&#160;</a></span>min_quad_with_fixed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int n, bool Hpd = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, n, 1 &gt; igl::min_quad_with_fixed </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a810f069896eadc075940d13f7cc22a4f" name="a810f069896eadc075940d13f7cc22a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810f069896eadc075940d13f7cc22a4f">&#9670;&#160;</a></span>min_quad_with_fixed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int n, int kcount, bool Hpd&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, n, 1 &gt; igl::min_quad_with_fixed </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Special wrapper where the number of constrained values (i.e., true values in k) is exposed as a template parameter. Not intended to be called directly. The overhead of calling the overloads above is already minimal. </p>

</div>
</div>
<a id="aea4adc0413c180d649f00d8759cf63b3" name="aea4adc0413c180d649f00d8759cf63b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4adc0413c180d649f00d8759cf63b3">&#9670;&#160;</a></span>min_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::min_size </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine min size of lists in a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>some list type object that implements .size() </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>vector of list types T </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>min .size() found in V, returns -1 if V is empty </dd></dl>

</div>
</div>
<a id="ae574038db202105a0eccec2ef233be57" name="ae574038db202105a0eccec2ef233be57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae574038db202105a0eccec2ef233be57">&#9670;&#160;</a></span>mod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::mod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute elementwise mod: B = A % base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>number to mod against </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>m by n matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0394947bf9e27382711c730186ec631c" name="a0394947bf9e27382711c730186ec631c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0394947bf9e27382711c730186ec631c">&#9670;&#160;</a></span>mod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedA igl::mod </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a037858abb04a677ebd5cdf660de0b0ae" name="a037858abb04a677ebd5cdf660de0b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037858abb04a677ebd5cdf660de0b0ae">&#9670;&#160;</a></span>mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::mode </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes mode of coefficients in a matrix along a given dimension. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n original matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>dension along which to take mode, m or n </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>vector containing mode along dension d, if d==1 then this will be a n-long vector if d==2 then this will be a m-long vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9c8d358cf9fdbac0bd749920e072b84" name="ae9c8d358cf9fdbac0bd749920e072b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c8d358cf9fdbac0bd749920e072b84">&#9670;&#160;</a></span>moments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedm0 , typename Derivedm1 , typename Derivedm2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::moments </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Derivedm0 &amp;&#160;</td>
          <td class="paramname"><em>m0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedm1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedm2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the moments of mass for a solid object bound by a triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of rest domain positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m0</td><td>zeroth moment of mass, total signed volume of solid. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m1</td><td>first moment of mass, center of mass (centroid) times total mass </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">m2</td><td>second moment of mass, moment of inertia with center of mass as reference point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#adaa0102450153380ae5ecdb948352556" title="Computes the centroid and enclosed volume of a closed mesh using a surface integral.">centroid</a> </dd></dl>

</div>
</div>
<a id="a2b6d36d1a68f0978c2b20b1586ccc18f" name="a2b6d36d1a68f0978c2b20b1586ccc18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6d36d1a68f0978c2b20b1586ccc18f">&#9670;&#160;</a></span>mvc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::mvc </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mean value coordinates for a polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x dim list of vertex positions (dim = 2 or dim = 3) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C x dim list of polygon vertex positions in counter-clockwise order (dim = 2 or dim = 3)</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>weights, #V by #C matrix of weights</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a330d1e74582084d2c5d7002ecab40baf" name="a330d1e74582084d2c5d7002ecab40baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330d1e74582084d2c5d7002ecab40baf">&#9670;&#160;</a></span>nchoosek() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double igl::nchoosek </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binomial coefficient. </p>
<p>Like matlab's nchoosek.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>total number elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>size of sub-set to consider </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of k-size combinations out of the set [1,...,n] </dd></dl>

</div>
</div>
<a id="a5aa3a7446d17387b412677075b546ebb" name="a5aa3a7446d17387b412677075b546ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa3a7446d17387b412677075b546ebb">&#9670;&#160;</a></span>nchoosek() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::nchoosek </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>All combinations . </p>
<p>Like matlab's nchoosek.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>n-long vector of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>size of sub-set to consider </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>nchoosek by k long matrix where each row is a unique k-size combination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a368a81066e3790575847edac849c6aa9" name="a368a81066e3790575847edac849c6aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a368a81066e3790575847edac849c6aa9">&#9670;&#160;</a></span>next_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::next_filename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>suffix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the file with the first filename of the form "prefix%0[zeros]dsuffix". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>path to containing dir and filename prefix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zeros</td><td>number of leading zeros as if digit printed with printf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">suffix</td><td>suffix of filename and extension (should include dot) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">next</td><td>path to next file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if found, false if exceeding range in zeros </dd></dl>

</div>
</div>
<a id="af63be3993b067600b578e85bf0fa186a" name="af63be3993b067600b578e85bf0fa186a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63be3993b067600b578e85bf0fa186a">&#9670;&#160;</a></span>normal_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedEle , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::normal_derivative </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>DD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the directional derivative <b>normal</b> to <b>all</b> (half-)edges of a triangle mesh (not just boundary edges). </p>
<p>These are integrated along the edge: they're the per-face constant gradient dot the rotated edge vector (unit rotated edge vector for direction then magnitude for integration).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3|4 list of triangle|tetrahedron indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">DD</td><td>#F*3|4 by #V sparse matrix representing operator to compute directional derivative with respect to each facet of each element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01a8628fb6a1bef5682ad416cfcd0a5e" name="a01a8628fb6a1bef5682ad416cfcd0a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a8628fb6a1bef5682ad416cfcd0a5e">&#9670;&#160;</a></span>normalize_quat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::normalize_quat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>input quaternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result of normalization, allowed to be same as q </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if len(q) &lt; EPS </dd></dl>

</div>
</div>
<a id="a8799fd07216a41e98f6ccaa39aec488f" name="a8799fd07216a41e98f6ccaa39aec488f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8799fd07216a41e98f6ccaa39aec488f">&#9670;&#160;</a></span>null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::null </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a basis for the null space for the given matrix A: the columns of the output N form a basis for the space orthogonal to that spanned by the rows of A. </p>
<p>Like MATLAB's null</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>n by r matrix, where r is the row rank of A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ff69240d0614e6f4ab20ff15b2f21a4" name="a3ff69240d0614e6f4ab20ff15b2f21a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff69240d0614e6f4ab20ff15b2f21a4">&#9670;&#160;</a></span>octree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename IndexType , typename DerivedCH , typename DerivedCN , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::octree </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCH &gt; &amp;&#160;</td>
          <td class="paramname"><em>CH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of 3D points P, generate data structures for a pointerless octree. </p>
<p>Each cell stores its points, children, center location and width. Our octree is not dense. We use the following rule: if the current cell has any number of points, it will have all 8 children. A leaf cell will have -1's as its list of child indices.</p>
<p>We use a binary numbering of children. Treating the parent cell's center as the origin, we number the octants in the following manner: The first bit is 1 iff the octant's x coordinate is positive The second bit is 1 iff the octant's y coordinate is positive The third bit is 1 iff the octant's z coordinate is positive</p>
<p>For example, the octant with negative x, positive y, positive z is: 110 binary = 6 decimal</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of point locations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_indices</td><td>a vector of vectors, where the ith entry is a vector of the indices into P that are the ith octree cell's points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CH</td><td>#OctreeCells by 8, where the ith row is the indices of the ith octree cell's children </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CN</td><td>#OctreeCells by 3, where the ith row is a 3d row vector representing the position of the ith cell's center </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#OctreeCells, a vector where the ith entry is the width of the ith octree cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afff5efd1454c4544da0680e4c410b7cf" name="afff5efd1454c4544da0680e4c410b7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff5efd1454c4544da0680e4c410b7cf">&#9670;&#160;</a></span>offset_surface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename isolevelType , typename DerivedSV , typename DerivedSF , typename DerivedGV , typename Derivedside , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::offset_surface </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const isolevelType&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Derivedside::Scalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a> &amp;&#160;</td>
          <td class="paramname"><em>signed_distance_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedside &gt; &amp;&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a triangulated offset surface using matching cubes on a grid of signed distance values from the input triangle mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isolevel</td><td>iso level to extract (signed distance: negative inside) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>number of grid cells along longest side (controls resolution) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">signed_distance_type</td><td>type of signing to use (see ../signed_distance.h) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SV</td><td>#SV by 3 list of output surface mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SF</td><td>#SF by 3 list of output mesh triangle indices into SV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GV</td><td>#GV=side(0)*side(1)*side(2) by 3 list of grid cell centers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">side</td><td>list of number of grid cells in x, y, and z directions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#GV by 3 list of signed distance values <em>near</em> <code>isolevel</code> ("far" from <code>isolevel</code> these values are incorrect) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f19762456ef8396dfc4096f34c841e6" name="a9f19762456ef8396dfc4096f34c841e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f19762456ef8396dfc4096f34c841e6">&#9670;&#160;</a></span>on_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::on_boundary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; IntegerT &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine boundary facets of mesh elements stored in T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegerT</td><td>integer-value: i.e. int </td></tr>
    <tr><td class="paramname">IntegerF</td><td>integer-value: i.e. int </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>triangle|tetrahedron index list, m by 3|4, where m is the number of elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>m long list of bools whether tet is on boundary </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>m by 3|4 list of bools whether opposite facet is on boundary </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc0e9a973c6c86bc98645ef61f4d4b43" name="acc0e9a973c6c86bc98645ef61f4d4b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0e9a973c6c86bc98645ef61f4d4b43">&#9670;&#160;</a></span>on_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::on_boundary </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae76f879f4715d4a8596d28f12bc7161d" name="ae76f879f4715d4a8596d28f12bc7161d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76f879f4715d4a8596d28f12bc7161d">&#9670;&#160;</a></span>orient_halfedges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DerivedOE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::orient_halfedges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orients halfedges for a triangle mesh, assigning them to a unique edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 input mesh connectivity </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oE</td><td>#E by 3 the orientation (e.g., -1 or 1) of each halfedge compared to the orientation of the actual edge. Every edge appears positively oriented exactly once.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a23358af3f14021f32e9d30758f80a9a7" title="Find combinatorially unique simplices in F.">unique_simplices</a> </dd></dl>

</div>
</div>
<a id="a13811b519cd4b97b94f6ef8f3fe90f30" name="a13811b519cd4b97b94f6ef8f3fe90f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13811b519cd4b97b94f6ef8f3fe90f30">&#9670;&#160;</a></span>orient_outward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC , typename DerivedFF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::orient_outward </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient each component (identified by C) of a mesh (V,F) so the normals on average point away from the patch's centroid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#F list of components (output of orientable_patches) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#F by 3 list of new triangle indices such that FF(~I,:) = F(~I,:) and FF(I,:) = fliplr(F(I,:)) (OK if &amp;FF = &amp;F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>max(C)+1 list of whether face has been flipped</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#aa7ea97ba9a25206eb1ba9d7469b371d1" title="Compute connected components of facets connected by manifold edges.">orientable_patches</a>, reorient_facets_raycast </dd></dl>

</div>
</div>
<a id="aa7ea97ba9a25206eb1ba9d7469b371d1" name="aa7ea97ba9a25206eb1ba9d7469b371d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ea97ba9a25206eb1ba9d7469b371d1">&#9670;&#160;</a></span>orientable_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedC , typename AScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::orientable_patches </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; AScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connected components of facets connected by manifold edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of facets </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F list of component ids </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#F by #F adjacency matrix</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5c31bf9a8576f1775affb93a5722e85" name="ad5c31bf9a8576f1775affb93a5722e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c31bf9a8576f1775affb93a5722e85">&#9670;&#160;</a></span>orientable_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::orientable_patches </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3f9293ec84689fd8949325ccb22d55fb" name="a3f9293ec84689fd8949325ccb22d55fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9293ec84689fd8949325ccb22d55fb">&#9670;&#160;</a></span>oriented_facets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::oriented_facets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines all "directed
[facets](https://en.wikipedia.org/wiki/Simplex#Elements)" of a given set of simplicial elements. </p>
<p>For a manifold triangle mesh, this computes all half-edges. For a manifold tetrahedral mesh, this computes all half-faces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of simplices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by simplex_size-1 list of facets, such that E.row(f+#F*c) is the facet opposite F(f,c)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is not the same as <a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee" title="Constructs a list of unique edges represented in a given mesh (V,F)">igl::edges</a> because this includes every directed edge including repeats (meaning interior edges on a surface will show up once for each direction and non-manifold edges may appear more than once for each direction). </dd></dl>

</div>
</div>
<a id="a8010396f68fc2ad676aa1a713b6a7bc4" name="a8010396f68fc2ad676aa1a713b6a7bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8010396f68fc2ad676aa1a713b6a7bc4">&#9670;&#160;</a></span>orth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::orth </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthogonalization of a matrix. </p>
<p>ORTH(A,Q) produces Q as an orthonormal basis for the range of A. That is, Q'*Q = I, the columns of Q span the same space as the columns of A, and the number of columns of Q is the rank of A.</p>
<p>The algorithm uses singular value decomposition, SVD, instead of orthogonal factorization, QR. This doubles the computation time, but provides more reliable and consistent rank determination. Closely follows MATLAB implementation in orth.m</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>m by n matrix with orthonormal columns spanning same column space as A</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Implementation listed as "Broken" </dd></dl>

</div>
</div>
<a id="a4aa53ae1b1d678353d4056c724b7df7c" name="a4aa53ae1b1d678353d4056c724b7df7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa53ae1b1d678353d4056c724b7df7c">&#9670;&#160;</a></span>ortho()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ortho </td>
          <td>(</td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>nearVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>farVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of the deprecated glOrtho function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left</td><td>coordinate of left vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right</td><td>coordinate of right vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bottom</td><td>coordinate of bottom vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top</td><td>coordinate of top vertical clipping plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nearVal</td><td>distance to near plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">farVal</td><td>distance to far plane </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>4x4 perspective matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf646b1d4c8ad6dd0d2660d0a5cae584" name="abf646b1d4c8ad6dd0d2660d0a5cae584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf646b1d4c8ad6dd0d2660d0a5cae584">&#9670;&#160;</a></span>outer_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::outer_vertex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>v_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a vertex that is reachable from infinite without crossing any faces. </p>
<p>Such vertex is called "outer vertex."</p>
<p>Precondition: The input mesh must have all self-intersection resolved and no duplicated vertices. See cgal::remesh_self_intersections.h for how to obtain such input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of facets to consider </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v_index</td><td>index of outer vertex </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#A list of facets incident to the outer vertex</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="outer__element_8h.html">include/igl/outer_element.h</a> <br  />
 </p>

</div>
</div>
<a id="a8a1dbaf3fab3346a4956ef93313e488b" name="a8a1dbaf3fab3346a4956ef93313e488b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1dbaf3fab3346a4956ef93313e488b">&#9670;&#160;</a></span>outer_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::outer_edge </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an edge that is reachable from infinity without crossing any faces. </p>
<p>Such edge is called "outer edge."</p>
<p>Precondition: The input mesh must have all self-intersection resolved and no duplicated vertices. The correctness of the output depends on the fact that there is no edge overlap. See cgal::remesh_self_intersections.h for how to obtain such input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of facets to consider </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>index of the first end point of outer edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>index of the second end point of outer edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#A list of facets incident to the outer edge</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="outer__element_8h.html">include/igl/outer_element.h</a> <br  />
 </p>

</div>
</div>
<a id="ab8ea262d61548f3946263a5c00ed0192" name="ab8ea262d61548f3946263a5c00ed0192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ea262d61548f3946263a5c00ed0192">&#9670;&#160;</a></span>outer_facet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::outer_facet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>flipped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a facet that is reachable from infinity without crossing any faces. </p>
<p>Such facet is called "outer facet."</p>
<p>Precondition: The input mesh must have all self-intersection resolved. I.e there is no duplicated vertices, no overlapping edge and no intersecting faces (the only exception is there could be topologically duplicated faces). See cgal::remesh_self_intersections.h for how to obtain such input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#N by 3 list of face normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of facets to consider </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Index of the outer facet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flipped</td><td>true iff the normal of f points inwards.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="outer__element_8h.html">include/igl/outer_element.h</a> </p>

</div>
</div>
<a id="a48ba3dac8f2da11935cd7e566f27e69d" name="a48ba3dac8f2da11935cd7e566f27e69d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ba3dac8f2da11935cd7e566f27e69d">&#9670;&#160;</a></span>parallel_for() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename FunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>loop_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>min_parallel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functional implementation of a basic, open-mp style, parallel for loop. </p>
<p>If the inner block of a for-loop can be rewritten/encapsulated in a single (anonymous/lambda) function call <code>func</code> so that the serial code looks like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;loop_size;i++)</div>
<div class="line">{</div>
<div class="line">  func(i);</div>
<div class="line">}</div>
</div><!-- fragment --><p>then <code>parallel_for(loop_size,func,min_parallel)</code> will use as many threads as available on the current hardware to parallelize this for loop so long as loop_size&lt;min_parallel, otherwise it will just use a serial for loop.</p>
<p>Often if your code looks like:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;loop_size;i++)</div>
<div class="line">{</div>
<div class="line">  …</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then you can make a minimal two-line change to parallelize it:</p>
<div class="fragment"><div class="line"><span class="comment">//for(int i = 0;i&lt;loop_size;i++)</span></div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a48ba3dac8f2da11935cd7e566f27e69d">parallel_for</a>(loop_size,[&amp;](<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">  …</div>
<div class="line">}</div>
<div class="line">,1000);</div>
<div class="ttc" id="anamespaceigl_html_a48ba3dac8f2da11935cd7e566f27e69d"><div class="ttname"><a href="namespaceigl.html#a48ba3dac8f2da11935cd7e566f27e69d">igl::parallel_for</a></div><div class="ttdeci">bool parallel_for(const Index loop_size, const FunctionType &amp;func, const size_t min_parallel=0)</div><div class="ttdoc">Functional implementation of a basic, open-mp style, parallel for loop.</div><div class="ttdef"><b>Definition</b> parallel_for.h:123</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loop_size</td><td>number of iterations. I.e. for(int i = 0;i&lt;loop_size;i++) ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function handle taking iteration index as only argument to compute inner block of for loop I.e. for(int i ...){ func(i); } </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_parallel</td><td>min size of loop_size such that parallel (non-serial) thread pooling should be attempted {0} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff thread pool was invoked </dd></dl>

</div>
</div>
<a id="a8e1804e24a4fefa3bbe3e6241bd00f75" name="a8e1804e24a4fefa3bbe3e6241bd00f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1804e24a4fefa3bbe3e6241bd00f75">&#9670;&#160;</a></span>parallel_for() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename PrepFunctionType , typename FunctionType , typename AccumFunctionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::parallel_for </td>
          <td>(</td>
          <td class="paramtype">const Index&#160;</td>
          <td class="paramname"><em>loop_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PrepFunctionType &amp;&#160;</td>
          <td class="paramname"><em>prep_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AccumFunctionType &amp;&#160;</td>
          <td class="paramname"><em>accum_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>min_parallel</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functional implementation of an open-mp style, parallel for loop with accumulation. </p>
<p>For example, serial code separated into n chunks (each to be parallelized with a thread) might look like:</p>
<div class="fragment"><div class="line">Eigen::VectorXd S;</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; prep_func = [&amp;S](<span class="keywordtype">int</span> n){ S = Eigen:VectorXd::Zero(n); };</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; func = [&amp;X,&amp;S](<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> t){ S(t) += X(i); };</div>
<div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp; accum_func = [&amp;S,&amp;<a class="code hl_function" href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734">sum</a>](<span class="keywordtype">int</span> t){ <a class="code hl_function" href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734">sum</a> += S(t); };</div>
<div class="line">prep_func(n);</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;loop_size;i++)</div>
<div class="line">{</div>
<div class="line">  func(i,i%n);</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">double</span> <a class="code hl_function" href="namespaceigl.html#adf21bb95cf3e8474259c54e4a55ed734">sum</a> = 0;</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> t = 0;t&lt;n;t++)</div>
<div class="line">{</div>
<div class="line">  accum_func(t);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">loop_size</td><td>number of iterations. I.e. for(int i = 0;i&lt;loop_size;i++) ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prep_func</td><td>function handle taking n &gt;= number of threads as only argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function handle taking iteration index i and thread id t as only arguments to compute inner block of for loop I.e. for(int i ...){ func(i,t); } </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accum_func</td><td>function handle taking thread index as only argument, to be called after all calls of func, e.g., for serial accumulation across all n (potential) threads, see n in description of prep_func. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_parallel</td><td>min size of loop_size such that parallel (non-serial) thread pooling should be attempted {0} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff thread pool was invoked </dd></dl>

</div>
</div>
<a id="a842fd7e11ac0c43a81d15fa137337adb" name="a842fd7e11ac0c43a81d15fa137337adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842fd7e11ac0c43a81d15fa137337adb">&#9670;&#160;</a></span>parallel_transport_angles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedK &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::parallel_transport_angles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E2F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedK &gt; &amp;&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the per-face local bases computed via <a class="el" href="namespaceigl.html#a108a662cae580e5c3459d81435f32e24" title="Compute a local orthogonal reference system for each triangle in the given mesh.">igl::local_basis</a>, this function computes the angle between the two reference frames across each edge. </p>
<p>Any two vectors across the edge whose 2D representation only differs by this angle are considered to be parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3 list of face normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E2F</td><td>#E by 2 list of the edge-to-face relation (e.g. computed via <a class="el" href="namespaceigl.html#a182268447e88dbae647fd2971598226a" title="Initialize Edges and their topological relations (assumes an edge-manifold mesh).">igl::edge_topology</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F2E</td><td>#F by 3 list of the face-to-edge relation (e.g. computed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>#E by 1 list of the parallel transport angles (zero for all boundary edges) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af85fb6c92debf67385c27c8a06c2a1f9" name="af85fb6c92debf67385c27c8a06c2a1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85fb6c92debf67385c27c8a06c2a1f9">&#9670;&#160;</a></span>partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::partition </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition vertices into groups based on each vertex's vector: vertices with similar coordinates (close in space) will be put in the same group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#W by dim coordinate matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>desired number of groups default is dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#W list of group indices (1 to k) for each vertex, such that vertex i is assigned to group G(i) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>k list of seed vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#W list of squared distances for each vertex to it's corresponding closest seed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9dfa8a07d0d391278ff5023da5ba1bf" name="aa9dfa8a07d0d391278ff5023da5ba1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dfa8a07d0d391278ff5023da5ba1bf">&#9670;&#160;</a></span>parula() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::parula </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rgb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parula colormap like MATLAB's parula. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>factor determining color value as if 0 was min and 1 was max </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rgb</td><td>resulting rgb color<ul>
<li>r red value</li>
<li>g green value</li>
<li>b blue value </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a5375852c84e549987ad3aedd7e80e" name="a79a5375852c84e549987ad3aedd7e80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a5375852c84e549987ad3aedd7e80e">&#9670;&#160;</a></span>parula() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::parula </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a36caf45296cda61ad8a61ee3772378e7" name="a36caf45296cda61ad8a61ee3772378e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36caf45296cda61ad8a61ee3772378e7">&#9670;&#160;</a></span>parula() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedZ , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::parula </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>normalize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>#Z list of factors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>whether to normalize Z to be tightly between [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C by 3 list of rgb colors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70ff59da460d9fa5095c2cd9447fe9a4" name="a70ff59da460d9fa5095c2cd9447fe9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ff59da460d9fa5095c2cd9447fe9a4">&#9670;&#160;</a></span>parula() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedZ , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::parula </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_z</td><td>value at blue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_z</td><td>value at red </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9dedb9d3d8f684abb92cef75cacdb69" name="ad9dedb9d3d8f684abb92cef75cacdb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9dedb9d3d8f684abb92cef75cacdb69">&#9670;&#160;</a></span>path_to_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedI , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::path_to_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_loop</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a path as an ordered list of N&gt;=2 vertex indices I[0], I[1], ..., I[N-1] construct a list of edges [[I[0],I[1]], [I[1],I[2]], ..., [I[N-2], I[N-1]]] connecting each sequential pair of vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of vertex indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">make_loop</td><td>bool If true, include an edge connecting I[N-1] to I[0] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#I-1 by 2 list of edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc2ac47ac2adbe917283d5dd317dab36" name="abc2ac47ac2adbe917283d5dd317dab36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2ac47ac2adbe917283d5dd317dab36">&#9670;&#160;</a></span>path_to_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::path_to_edges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_loop</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a35cb149bbe78233befd8a3fcbf0bf0f9" name="a35cb149bbe78233befd8a3fcbf0bf0f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35cb149bbe78233befd8a3fcbf0bf0f9">&#9670;&#160;</a></span>path_to_executable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string igl::path_to_executable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Path to current executable. </p>
<dl class="section return"><dt>Returns</dt><dd>path as string </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Tested for Mac OS X </dd></dl>

</div>
</div>
<a id="a541dccb34e02684e3d43966fca86bdaf" name="a541dccb34e02684e3d43966fca86bdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541dccb34e02684e3d43966fca86bdaf">&#9670;&#160;</a></span>pathinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::pathinfo </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dirname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>basename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function like PHP's pathinfo to return information about path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>string containing input path </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dirname</td><td>string containing dirname (see <a class="el" href="dirname_8h.html">dirname.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">basename</td><td>string containing basename (see <a class="el" href="basename_8h.html">basename.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">extension</td><td>string containing extension (characters after last '.') </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">filename</td><td>string containing filename (characters of basename before last '.')</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md18"></a>
Examples</h4>
<pre class="fragment"> input                     | dirname        basename       ext    filename
 "/"                       | "/"            ""             ""     ""
 "//"                      | "/"            ""             ""     ""
 "/foo"                    | "/"            "foo"          ""     "foo"
 "/foo/"                   | "/"            "foo"          ""     "foo"
 "/foo//"                  | "/"            "foo"          ""     "foo"
 "/foo/./"                 | "/foo"         "."            ""     ""
 "/foo/bar"                | "/foo"         "bar"          ""     "bar"
 "/foo/bar."               | "/foo"         "bar."         ""     "bar"
 "/foo/bar.txt"            | "/foo"         "bar.txt"      "txt"  "bar"
 "/foo/bar.txt.zip"        | "/foo"         "bar.txt.zip"  "zip"  "bar.txt"
 "/foo/bar.dir/"           | "/foo"         "bar.dir"      "dir"  "bar"
 "/foo/bar.dir/file"       | "/foo/bar.dir" "file"         ""     "file"
 "/foo/bar.dir/file.txt"   | "/foo/bar.dir" "file.txt"     "txt"  "file"
</pre> <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#aa32f08d2b80c8d69515001b7d6347e82" title="Extract basename of file path (like PHP&#39;s basename).">basename</a>, <a class="el" href="namespaceigl.html#aef1ff1d390be65861384b6ff764ebe09" title="Function like PHP&#39;s dirname: /etc/passwd --&gt; /etc,.">dirname</a> </dd></dl>

</div>
</div>
<a id="a3a09c2edf78994c6f25f23a9212a3666" name="a3a09c2edf78994c6f25f23a9212a3666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a09c2edf78994c6f25f23a9212a3666">&#9670;&#160;</a></span>per_corner_normals() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedCN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_corner_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>corner_threshold_degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute per corner normals for a triangle mesh by computing the area-weighted average of normals at incident faces whose normals deviate less than the provided threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner_threshold_degrees</td><td>threshold in degrees on sharp angles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CN</td><td>#F*3 by 3 list of mesh vertex 3D normals, where the normal for corner F(i,j) is at CN.row(i*3+j) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1038de65b964583d4ea533a631e6c1b8" name="a1038de65b964583d4ea533a631e6c1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1038de65b964583d4ea533a631e6c1b8">&#9670;&#160;</a></span>per_corner_normals() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVF , typename DerivedNI , typename DerivedCN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_corner_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>corner_threshold_degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVF &gt; &amp;&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedNI &gt; &amp;&#160;</td>
          <td class="paramname"><em>NI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VF</td><td>3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NI</td><td>#V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. "How many faces" have been seen before visiting this vertex and its incident faces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acabdf409439e0498066a620d30db6899" title="vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F)">vertex_triangle_adjacency</a> </dd></dl>

</div>
</div>
<a id="a01b4e893d7a38a99124fb826f0f337c1" name="a01b4e893d7a38a99124fb826f0f337c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b4e893d7a38a99124fb826f0f337c1">&#9670;&#160;</a></span>per_corner_normals() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedCI , typename DerivedCC , typename DerivedCN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_corner_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCI &gt; &amp;&#160;</td>
          <td class="paramname"><em>CI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCC &gt; &amp;&#160;</td>
          <td class="paramname"><em>CC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">CI</td><td>#CI list of face neighbors as indices into rows of F </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CC</td><td>3*#F+1 list of cumulative sizes so that CC(i*3+j+1) - CC(i*3+j) is the number of faces considered smoothly incident on corner at F(i,j)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#aef5e220e449787733ece4abbc94f419a" title="Determine the corner-to-face adjacency relationship that can be used for computing crease-aware per-c...">smooth_corner_adjacency</a> </dd></dl>

</div>
</div>
<a id="aac0d1344faa3702f4c79dcdf54888c68" name="aac0d1344faa3702f4c79dcdf54888c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0d1344faa3702f4c79dcdf54888c68">&#9670;&#160;</a></span>per_corner_normals() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedNV , typename DerivedNF , typename DerivedCN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_corner_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedNV &gt; &amp;&#160;</td>
          <td class="paramname"><em>NV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given indexed normals (e.g., read from a .obj file), explode into per-corner normals (e.g., as expected by <a class="el" href="classigl_1_1opengl_1_1ViewerData.html" title="Object being drawn (i.e., mesh and its accessories) by the ViewerCore.">igl::opengl::ViewerData</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">NV</td><td>#NV by 3 list of index normal vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">NF</td><td>#F by nc list of indices into rows of NV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CN</td><td>#F*nc by 3 list of per-corner normals so that CN.row(i*nc+c) = NV.row(NF(i,c)) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4353bfd8d4ca70d1ea3bdf98dbfb50f4" name="a4353bfd8d4ca70d1ea3bdf98dbfb50f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4353bfd8d4ca70d1ea3bdf98dbfb50f4">&#9670;&#160;</a></span>per_corner_normals() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename DerivedVV , typename DerivedFF , typename DerivedJ , typename DerivedNN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_corner_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>corner_threshold_degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNN &gt; &amp;&#160;</td>
          <td class="paramname"><em>NN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Per-corner normals for a polygon mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner_threshold</td><td>threshold in degrees on sharp angles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>#I by 3 list of per corner normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VV</td><td>#I+#polygons by 3 list of auxiliary triangle mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#I by 3 list of triangle indices into rows of VV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#I list of indices into original polygons </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NN</td><td>#FF by 3 list of normals for each auxiliary triangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0359520eb722b81b3460a2dc23178e2" name="ae0359520eb722b81b3460a2dc23178e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0359520eb722b81b3460a2dc23178e2">&#9670;&#160;</a></span>per_edge_normals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedN , typename DerivedE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_edge_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">PerEdgeNormalsWeightingType</a>&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face normals via vertex position list, face list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>weighting type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3 matrix of 3D face normals per face </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>#2 by 3 matrix of mesh edge 3D normals per row </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#E by 2 matrix of edge indices per row </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#E by 1 matrix of indices from all edges to E </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accd393d9be7212b4986f0e14328e4acc" name="accd393d9be7212b4986f0e14328e4acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd393d9be7212b4986f0e14328e4acc">&#9670;&#160;</a></span>per_edge_normals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_edge_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a347183daf701cad3537c990f8ce0cf55">PerEdgeNormalsWeightingType</a>&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abe5c6976aa15d2689a00df1cbb695776" name="abe5c6976aa15d2689a00df1cbb695776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5c6976aa15d2689a00df1cbb695776">&#9670;&#160;</a></span>per_edge_normals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_edge_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3d793baadcefcf122deae556812b2406" name="a3d793baadcefcf122deae556812b2406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d793baadcefcf122deae556812b2406">&#9670;&#160;</a></span>per_face_normals() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedZ , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_face_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute face normals via vertex position list, face list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Z</td><td>3 vector normal given to faces with degenerate normal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>#F by 3 eigen Matrix of mesh face (triangle) 3D normals</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md19"></a>
Example</h4>
<p>// Give degenerate faces (1/3,1/3,1/3)^0.5 per_face_normals(V,F,Vector3d(1,1,1).normalized(),N); </p>

</div>
</div>
<a id="aa5e240d2506aa22bb2a07edd7636d6cb" name="aa5e240d2506aa22bb2a07edd7636d6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e240d2506aa22bb2a07edd7636d6cb">&#9670;&#160;</a></span>per_face_normals() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_face_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper with Z = (0,0,0). Note that this means that row norms will be zero (i.e. not 1) for degenerate normals. </p>

</div>
</div>
<a id="a49d8e3459f18186d9cbfd36ba4c053bc" name="a49d8e3459f18186d9cbfd36ba4c053bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d8e3459f18186d9cbfd36ba4c053bc">&#9670;&#160;</a></span>per_face_normals_stable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_face_normals_stable </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Special version where order of face indices is guaranteed not to effect output. </p>

</div>
</div>
<a id="a95670a831d56f91f1afdd042cc8ae97b" name="a95670a831d56f91f1afdd042cc8ae97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95670a831d56f91f1afdd042cc8ae97b">&#9670;&#160;</a></span>per_face_normals() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedI , typename DerivedC , typename DerivedN , typename DerivedVV , typename DerivedFF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_face_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Per face normals for a general polygon mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner_threshold</td><td>threshold in degrees on sharp angles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>#polygons by 3 list of per face normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VV</td><td>#I+#polygons by 3 list of auxiliary triangle mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#I by 3 list of triangle indices into rows of VV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#I list of indices into original polygons </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55694e78e07c4a2640cbfa122fa3deed" name="a55694e78e07c4a2640cbfa122fa3deed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55694e78e07c4a2640cbfa122fa3deed">&#9670;&#160;</a></span>per_vertex_attribute_smoothing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_vertex_attribute_smoothing </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Aout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth vertex attributes using uniform Laplacian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ain</td><td>#V by #A eigen Matrix of mesh vertex attributes (each vertex has #A attributes) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigne Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Aout</td><td>#V by #A eigen Matrix of mesh vertex attributes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d913043c5590b413bc2ea64adae0c17" name="a7d913043c5590b413bc2ea64adae0c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d913043c5590b413bc2ea64adae0c17">&#9670;&#160;</a></span>per_vertex_normals() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_vertex_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">igl::PerVertexNormalsWeightingType</a>&#160;</td>
          <td class="paramname"><em>weighting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute vertex normals via vertex position list, face list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 eigen Matrix of face (triangle) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weighting</td><td>Weighting type </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>#V by 3 eigen Matrix of mesh vertex 3D normals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0ea8f0fee8d96f0acbda506d40fe2d" name="a3b0ea8f0fee8d96f0acbda506d40fe2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0ea8f0fee8d96f0acbda506d40fe2d">&#9670;&#160;</a></span>per_vertex_normals() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_vertex_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa29a9edc300d4684a03a6d656d2d715c" name="aa29a9edc300d4684a03a6d656d2d715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29a9edc300d4684a03a6d656d2d715c">&#9670;&#160;</a></span>per_vertex_normals() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_vertex_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a9bd1d9465ddaaed7691194b99b3b9f94">PerVertexNormalsWeightingType</a>&#160;</td>
          <td class="paramname"><em>weighting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3 matrix of face (triangle) normals </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addca97c5fd3aeb0c2ed9fb260b020092" name="addca97c5fd3aeb0c2ed9fb260b020092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addca97c5fd3aeb0c2ed9fb260b020092">&#9670;&#160;</a></span>per_vertex_normals() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_vertex_normals </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3ac6a5f35466ea9216e1de32fecaf032" name="a3ac6a5f35466ea9216e1de32fecaf032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac6a5f35466ea9216e1de32fecaf032">&#9670;&#160;</a></span>per_vertex_point_to_plane_quadrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::per_vertex_point_to_plane_quadrics </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute quadrics per vertex of a "closed" triangle mesh (V,F). </p>
<p>Rather than follow the qslim paper, this implements the lesser-known <em>follow up</em> "Simplifying Surfaces with Color and Texture using Quadric Error Metrics". This allows V to be n-dimensional (where the extra coordiantes store texture UVs, color RGBs, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by n list of vertex positions. Assumes that vertices with infinite coordinates are "points at infinity" being used to close up boundary edges with faces. This allows special subspace quadrice for boundary edges: There should never be more than one "point at
    infinity" in a single triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quadrics</td><td>#V list of quadrics, where a quadric is a tuple {A,b,c} such that the quadratic energy of moving this vertex to position x is given by x'Ax - 2b + c </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9edfc37639a2817ac5ffde534ec7391a" name="a9edfc37639a2817ac5ffde534ec7391a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edfc37639a2817ac5ffde534ec7391a">&#9670;&#160;</a></span>piecewise_constant_winding_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DeriveduE , typename DeriveduEC , typename DeriveduEE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::piecewise_constant_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. </p>
<p><b>Assumes</b> that <code>(V,F)</code> contains no self-intersections (including degeneracies and co-incidences). If there are co-planar and co-incident vertex placements, a mesh could <em>fail</em> this combinatorial test but still induce a piecewise-constant winding number <em>geometrically</em>. For example, consider a hemisphere with boundary and then pinch the boundary "shut" along a line segment. The **_bullet-proof_** check is to first resolve all self-intersections in <code>(V,F) -&gt; (SV,SF)</code> (i.e. what the <code><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a55276c7ddaadbfad9b0ddf0beeb756fe" title="Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input...">igl::copyleft::cgal::piecewise_constant_winding_number</a></code> overload does).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into some (abstract) list of vertices V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of unique edges indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumsums of directed edges sharing each unique edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#E list of indices into E (see <code><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">igl::unique_edge_map</a></code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mesh <em>combinatorially</em> induces a piecewise constant winding number field. </dd></dl>

</div>
</div>
<a id="a4321fc08252fa849e3fa6f47f3047fd9" name="a4321fc08252fa849e3fa6f47f3047fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4321fc08252fa849e3fa6f47f3047fd9">&#9670;&#160;</a></span>piecewise_constant_winding_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::piecewise_constant_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad226f56507bf0f6f88843734531e04cb" name="ad226f56507bf0f6f88843734531e04cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad226f56507bf0f6f88843734531e04cb">&#9670;&#160;</a></span>pinv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::pinv </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedA::Scalar&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Moore-Penrose pseudoinverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance (if negative then default is used) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>n by m matrix so that A*X*A = A and X*A*X = X and A*X = (A*X)' and (X*A) = (X*A)'</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11e789f2ff1ea85406f3c41468c7f1b5" name="a11e789f2ff1ea85406f3c41468c7f1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e789f2ff1ea85406f3c41468c7f1b5">&#9670;&#160;</a></span>pinv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::pinv </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4a6123b286eebf1eb6e5ca4957ae2b89" name="a4a6123b286eebf1eb6e5ca4957ae2b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6123b286eebf1eb6e5ca4957ae2b89">&#9670;&#160;</a></span>planarize_quad_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::planarize_quad_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Planarizes a given quad mesh using the algorithm described in the paper "Shape-Up: Shaping Discrete Geometry with Projections" by S. </p>
<p>Bouaziz, M. Deuss, Y. Schwartzburg, T. Weise, M. Pauly, Computer Graphics Forum, Volume 31, Issue 5, August 2012, p. 1657-1667 (<a href="http://dl.acm.org/citation.cfm?id=2346802">http://dl.acm.org/citation.cfm?id=2346802</a>). The algorithm iterates between projecting each quad to its closest planar counterpart and stitching those quads together via a least squares optimization. It stops whenever all quads' non-planarity is less than a given threshold (suggested value: 0.01), or a maximum number of iterations is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vin</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 4 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxIter</td><td>maximum numbers of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>minimum allowed threshold for non-planarity </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vout</td><td>#V by 3 eigen Matrix of planar mesh vertex 3D positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dad55e28df3f93b606cddb108b85e9d" name="a0dad55e28df3f93b606cddb108b85e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dad55e28df3f93b606cddb108b85e9d">&#9670;&#160;</a></span>point_in_circle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::point_in_circle </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>qx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>qy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if 2d point is in a circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">qx</td><td>x-coordinate of query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">qy</td><td>y-coordinate of query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cx</td><td>x-coordinate of circle center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cy</td><td>y-coordinate of circle center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>radius of circle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if query point is in circle, false otherwise </dd></dl>

</div>
</div>
<a id="ae9616bb9fd33e6c00dcb4e8f91952091" name="ae9616bb9fd33e6c00dcb4e8f91952091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9616bb9fd33e6c00dcb4e8f91952091">&#9670;&#160;</a></span>point_mesh_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedV , typename DerivedEle , typename DerivedsqrD , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::point_mesh_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute distances from a set of points P to a triangle mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ele</td><td>#Ele by (3|2|1) list of (triangle|edge|point) indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrD</td><td>#P list of smallest squared distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#P list of primitive indices corresponding to smallest distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#P by 3 list of closest points</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="autotoc_md20"></a> </p><h5>Example:</h5>
<div class="fragment"><div class="line">Eigen::MatrixXd V;</div>
<div class="line">Eigen::MatrixXi F;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a6bd18b073b51beb1500c10c4f2825aba">igl::read_triangle_mesh</a>(<span class="stringliteral">&quot;bunny.obj&quot;</span>,V,F);</div>
<div class="line"><span class="comment">// 100 points in [-1,1]³ cube</span></div>
<div class="line">Eigen::MatrixXd P = Eigen::MatrixXd::Random(100,3);</div>
<div class="line">Eigen::VectorXd sqrD;</div>
<div class="line">Eigen::VectorXi I;</div>
<div class="line">Eigen::MatrixXd C;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#ae9616bb9fd33e6c00dcb4e8f91952091">igl::point_mesh_squared_distance</a>(P,V,F,sqrD,I,C);</div>
<div class="line"><span class="comment">// Now sqrD(i) = squared distance from P.row(i) to mesh</span></div>
<div class="line"><span class="comment">// I(i) = closest primitive index</span></div>
<div class="line"><span class="comment">// C.row(i) = closest point on mesh to P.row(i)</span></div>
<div class="ttc" id="anamespaceigl_html_a6bd18b073b51beb1500c10c4f2825aba"><div class="ttname"><a href="namespaceigl.html#a6bd18b073b51beb1500c10c4f2825aba">igl::read_triangle_mesh</a></div><div class="ttdeci">bool read_triangle_mesh(const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</div><div class="ttdoc">Read mesh from an ascii file with automatic detection of file format among: mesh, msh obj,...</div></div>
<div class="ttc" id="anamespaceigl_html_ae9616bb9fd33e6c00dcb4e8f91952091"><div class="ttname"><a href="namespaceigl.html#ae9616bb9fd33e6c00dcb4e8f91952091">igl::point_mesh_squared_distance</a></div><div class="ttdeci">void point_mesh_squared_distance(const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;Ele, Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;sqrD, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</div><div class="ttdoc">Compute distances from a set of points P to a triangle mesh (V,F)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8c64da392edc068d98cf9c78ec8a6ee3" name="a8c64da392edc068d98cf9c78ec8a6ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c64da392edc068d98cf9c78ec8a6ee3">&#9670;&#160;</a></span>point_simplex_squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, typename Derivedp , typename DerivedV , typename DerivedEle , typename Derivedsqr_d , typename Derivedc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::point_simplex_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedp &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedEle::Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Derivedsqr_d &amp;&#160;</td>
          <td class="paramname"><em>sqr_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine squared distance from a point to linear simplex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>d-long query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by d list of vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ele</td><td>#Ele by ss&lt;=d+1 list of simplex indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index into Ele of simplex </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqr_d</td><td>squared distance of Ele(i) to p </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>closest point on Ele(i) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a937e7f60501c5fa10d8ddf3aba6e3d2e" name="a937e7f60501c5fa10d8ddf3aba6e3d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937e7f60501c5fa10d8ddf3aba6e3d2e">&#9670;&#160;</a></span>point_simplex_squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int DIM, typename Derivedp , typename DerivedV , typename DerivedEle , typename Derivedsqr_d , typename Derivedc , typename Derivedb &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::point_simplex_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedp &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEle &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedEle::Index&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Derivedsqr_d &amp;&#160;</td>
          <td class="paramname"><em>sqr_d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedb &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine squared distance from a point to linear simplex. </p>
<p>Also return barycentric coordinate of closest point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>d-long query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by d list of vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ele</td><td>#Ele by ss&lt;=d+1 list of simplex indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index into Ele of simplex </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqr_d</td><td>squared distance of Ele(i) to p </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>closest point on Ele(i) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>barycentric coordinates of closest point on Ele(i) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adef4fd6ebad61768a405ac601011aa83" name="adef4fd6ebad61768a405ac601011aa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef4fd6ebad61768a405ac601011aa83">&#9670;&#160;</a></span>polar_dec() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_dec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the polar decomposition (R,T) of a matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>3 by 3 matrix to be decomposed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeReflections</td><td>Whether to force R to be a rotation, or allow it to be a reflection </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>3 by 3 orthonormal matrix part of decomposition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>3 by 3 stretch matrix part of decomposition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>3 by 3 left-singular vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>3 by 1 singular values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>3 by 3 right-singular vectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4542a1ce3e5fc92a58929332bf0d5afe" name="a4542a1ce3e5fc92a58929332bf0d5afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4542a1ce3e5fc92a58929332bf0d5afe">&#9670;&#160;</a></span>polar_dec() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_dec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af5cc516e97872405063d0bcf3005f99e" name="af5cc516e97872405063d0bcf3005f99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5cc516e97872405063d0bcf3005f99e">&#9670;&#160;</a></span>polar_dec() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_dec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>For backward compatibility, these set includeReflections = false. </p>

</div>
</div>
<a id="a32e10aea297c30b7daf1616d1eba2a4f" name="a32e10aea297c30b7daf1616d1eba2a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e10aea297c30b7daf1616d1eba2a4f">&#9670;&#160;</a></span>polar_dec() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_dec </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aaa0b3fd9e1e8dbf5c6ddb9750f575b77" name="aaa0b3fd9e1e8dbf5c6ddb9750f575b77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0b3fd9e1e8dbf5c6ddb9750f575b77">&#9670;&#160;</a></span>polar_svd() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_svd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the polar decomposition (R,T) of a matrix A using SVD singular value decomposition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>3 by 3 matrix to be decomposed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeReflections</td><td>Whether to force R to be a rotation, or allow it to be a reflection </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>3 by 3 rotation matrix part of decomposition (<b>always rotataion</b>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>3 by 3 stretch matrix part of decomposition </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>3 by 3 left-singular vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>3 by 1 singular values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>3 by 3 right-singular vectors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9357cd43402973e99dcba962cdc1c8f9" name="a9357cd43402973e99dcba962cdc1c8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9357cd43402973e99dcba962cdc1c8f9">&#9670;&#160;</a></span>polar_svd() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_svd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5bf5509fee9fb84f1bce5173d27cb3e4" name="a5bf5509fee9fb84f1bce5173d27cb3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf5509fee9fb84f1bce5173d27cb3e4">&#9670;&#160;</a></span>polar_svd() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT , typename DerivedU , typename DerivedS , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_svd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>For backward compatibility, these set includeReflections = false. </p>

</div>
</div>
<a id="a299b725f8b4d5586c64c2c5e22a242db" name="a299b725f8b4d5586c64c2c5e22a242db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299b725f8b4d5586c64c2c5e22a242db">&#9670;&#160;</a></span>polar_svd() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_svd </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a78fc94343abfa102d5a9b95e8faca581" name="a78fc94343abfa102d5a9b95e8faca581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fc94343abfa102d5a9b95e8faca581">&#9670;&#160;</a></span>polar_svd3x3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polar_svd3x3 </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the closest rotation to input matrix A using specialized 3x3 SVD singular value decomposition (WunderSVD3x3) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>3 by 3 matrix to be decomposed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>3 by 3 closest element in SO(3) (closeness in terms of Frobenius metric)</td></tr>
  </table>
  </dd>
</dl>
<p>This means that det(R) = 1. Technically it's not polar decomposition which guarantees positive semidefinite stretch factor (at the cost of having det(R) = -1). "• The orthogonal factors U and V will be true
rotation matrices..." [McAdams, Selle, Tamstorf, Teran, Sefakis 2011] </p>

</div>
</div>
<a id="ae45e0eb6f9263af4777dc45bc136e1fd" name="ae45e0eb6f9263af4777dc45bc136e1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45e0eb6f9263af4777dc45bc136e1fd">&#9670;&#160;</a></span>polygon_corners() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PType , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polygon_corners </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; PType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list-of-lists polygon mesh faces representation to list of polygon corners and sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P list of lists of vertex indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#P+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5393c55c226b5d9d116837047c016f14" name="a5393c55c226b5d9d116837047c016f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5393c55c226b5d9d116837047c016f14">&#9670;&#160;</a></span>polygon_corners() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedQ , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polygon_corners </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Convert a pure k-gon list of polygon mesh indices to list of polygon corners and sizes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by k list of polygon indices (ith row is a k-gon, unless Q(i,j) = -1 then it's a j-gon) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c951f3fc9bfbbd0c78c007fd43c8337" name="a5c951f3fc9bfbbd0c78c007fd43c8337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c951f3fc9bfbbd0c78c007fd43c8337">&#9670;&#160;</a></span>polygons_to_triangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedI , typename DerivedC , typename DerivedF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::polygons_to_triangles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a polygon mesh, trivially triangulate each polygon with a fan. </p>
<p>This purely combinatorial triangulation will work well for convex/flat polygons and degrade otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#polygons+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F list of indices into 0:#P-1 of corresponding polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a381027e74d14b6e7adb31c0565a26027" name="a381027e74d14b6e7adb31c0565a26027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381027e74d14b6e7adb31c0565a26027">&#9670;&#160;</a></span>principal_curvature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedPD1 , typename DerivedPD2 , typename DerivedPV1 , typename DerivedPV2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::principal_curvature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPD1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPD2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPV1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPV2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PV2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radius</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useKring</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the principal curvature directions and magnitude of the given triangle mesh DerivedV derived from vertex positions matrix type: i.e. </p>
<p>MatrixXd DerivedF derived from face indices matrix type: i.e. MatrixXi </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>eigen matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD1</td><td>#V by 3 maximal curvature direction for each vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PD2</td><td>#V by 3 minimal curvature direction for each vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PV1</td><td>#V by 1 maximal curvature value for each vertex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">PV2</td><td>#V by 1 minimal curvature value for each vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>controls the size of the neighbourhood used, 1 = average edge length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">useKring</td><td>use Kring neighbourhood instead of ball neighbourhood </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of indices of bad vertices if any.</dd></dl>
<p>This function has been developed by: Nikolas De Giorgis, Luigi Rocca and Enrico Puppo. The algorithm is based on: Efficient Multi-scale Curvature and Crease Estimation Daniele Panozzo, Enrico Puppo, Luigi Rocca GraVisMa, 2010</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ac457ea2c4e31fec1d7a3855fefb0260d" title="Move a scalar field defined on vertices to faces by averaging.">average_onto_faces</a>, <a class="el" href="namespaceigl.html#ac14f50dc6ec911af71c62d6c187fe3c2" title="Move a scalar field defined on faces to vertices by averaging.">average_onto_vertices</a> </dd></dl>

</div>
</div>
<a id="a1521eb853db32a29fdb6eacbf3ad9fc2" name="a1521eb853db32a29fdb6eacbf3ad9fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1521eb853db32a29fdb6eacbf3ad9fc2">&#9670;&#160;</a></span>principal_curvature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedPD1 , typename DerivedPD2 , typename DerivedPV1 , typename DerivedPV2 , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::principal_curvature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPD1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPD2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PD2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPV1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PV1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedPV2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>PV2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Index &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>radius</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useKring</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">bad_vertices</td><td>vector of indices of bad vertices if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f935d00d75dd71d9b65d2f6a7fe4a19" name="a0f935d00d75dd71d9b65d2f6a7fe4a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f935d00d75dd71d9b65d2f6a7fe4a19">&#9670;&#160;</a></span>print_ijv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::print_ijv </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a 3 column matrix representing [I,J,V] = find(X). </p>
<p>That is, each row is the row index, column index and value for each non zero entry. Each row is printed on a new line</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix whose entries are to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>optional offset for I and J indices {0}</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a64d87355c9c3b734e7658eed10bdd764" title="This is a routine to print a matrix using format suitable for pasting into the matlab IDE.">matlab_format</a> </dd></dl>

</div>
</div>
<a id="a5d05e9d7e5d74e1a763370ff141d3628" name="a5d05e9d7e5d74e1a763370ff141d3628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d05e9d7e5d74e1a763370ff141d3628">&#9670;&#160;</a></span>print_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::print_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59761c584c133e800d3e0f34dfa717cc" name="a59761c584c133e800d3e0f34dfa717cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59761c584c133e800d3e0f34dfa717cc">&#9670;&#160;</a></span>print_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::print_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f43ea8a5c6f5622b8340b9d9d5d3936" name="a6f43ea8a5c6f5622b8340b9d9d5d3936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f43ea8a5c6f5622b8340b9d9d5d3936">&#9670;&#160;</a></span>procrustes() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename Scalar , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::procrustes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve Procrustes problem in d dimensions. </p>
<p>Given two point sets X,Y in R^d find best scale s, orthogonal R and translation t s.t. |s*X*R + t - Y|^2 is minimized.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>point type </td></tr>
    <tr><td class="paramname">Scalar</td><td>scalar type </td></tr>
    <tr><td class="paramname">DerivedR</td><td>type of R </td></tr>
    <tr><td class="paramname">DerivedT</td><td>type of t </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>#V by DIM first list of points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>#V by DIM second list of points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeScaling</td><td>if scaling should be allowed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">includeReflections</td><td>if R is allowed to be a reflection </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scale</td><td>scaling </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>orthogonal matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>translation</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md21"></a>
Example</h4>
<div class="fragment"><div class="line">MatrixXd X, Y; (containing 3d points as rows)</div>
<div class="line"><span class="keywordtype">double</span> scale;</div>
<div class="line">MatrixXd R;</div>
<div class="line">VectorXd t;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a6f43ea8a5c6f5622b8340b9d9d5d3936">igl::procrustes</a>(X,Y,<span class="keyword">true</span>,<span class="keyword">false</span>,scale,R,t);</div>
<div class="line">R *= scale;</div>
<div class="line">MatrixXd Xprime = (X * R).rowwise() + t.transpose();</div>
<div class="ttc" id="anamespaceigl_html_a6f43ea8a5c6f5622b8340b9d9d5d3936"><div class="ttname"><a href="namespaceigl.html#a6f43ea8a5c6f5622b8340b9d9d5d3936">igl::procrustes</a></div><div class="ttdeci">void procrustes(const Eigen::MatrixBase&lt; DerivedX &gt; &amp;X, const Eigen::MatrixBase&lt; DerivedY &gt; &amp;Y, const bool includeScaling, const bool includeReflections, Scalar &amp;scale, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;t)</div><div class="ttdoc">Solve Procrustes problem in d dimensions.</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a71995610b0f5d6e170ea2748950c0138" name="a71995610b0f5d6e170ea2748950c0138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71995610b0f5d6e170ea2748950c0138">&#9670;&#160;</a></span>procrustes() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename Scalar , int DIM, int TType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::procrustes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Transform&lt; Scalar, DIM, TType &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Same as above but returns Eigen transformation object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>transformation that minimizes error <br  />
</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md22"></a>
Example</h4>
<div class="fragment"><div class="line">MatrixXd X, Y; (containing 3d points as rows)</div>
<div class="line">AffineCompact3d T;</div>
<div class="line"><a class="code hl_function" href="namespaceigl.html#a6f43ea8a5c6f5622b8340b9d9d5d3936">igl::procrustes</a>(X,Y,<span class="keyword">true</span>,<span class="keyword">false</span>,T);</div>
<div class="line">MatrixXd Xprime = (X * T.linear()).rowwise() + T.translation().transpose();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2f02fa686c9416188ccb0b47bbb41985" name="a2f02fa686c9416188ccb0b47bbb41985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f02fa686c9416188ccb0b47bbb41985">&#9670;&#160;</a></span>procrustes() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::procrustes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeScaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>includeReflections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>S=scale*R, instead of scale and R separately </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5807bccc7e6795e024af55047f473e6" name="aa5807bccc7e6795e024af55047f473e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5807bccc7e6795e024af55047f473e6">&#9670;&#160;</a></span>procrustes() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::procrustes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Convenient wrapper for rigid case (no scaling, no reflections) </p>

</div>
</div>
<a id="ab2b1805a74d6529030a2eb932a6f2fa0" name="ab2b1805a74d6529030a2eb932a6f2fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b1805a74d6529030a2eb932a6f2fa0">&#9670;&#160;</a></span>procrustes() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename Scalar , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::procrustes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Rotation2D&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Convenient wrapper for 2D case. </p>

</div>
</div>
<a id="aea21608bab1115f54a773ade037824bd" name="aea21608bab1115f54a773ade037824bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea21608bab1115f54a773ade037824bd">&#9670;&#160;</a></span>project() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, 3, 1 &gt; igl::project </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen reimplementation of gluProject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj*</td><td>3D objects' x, y, and z coordinates respectively </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>model matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>viewport vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>screen space x, y, and z coordinates respectively </dd></dl>

</div>
</div>
<a id="af7eb3109db11f7024416cd77670e4bb6" name="af7eb3109db11f7024416cd77670e4bb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7eb3109db11f7024416cd77670e4bb6">&#9670;&#160;</a></span>project() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::project </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of object points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>model matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>viewport vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#V by 3 list of screen space points</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md23"></a>
Example:</h4>
<div class="fragment"><div class="line"><a class="code hl_class" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html">igl::opengl::glfw::Viewer</a> vr;</div>
<div class="line">...</div>
<div class="line">igl::project(V,vr.<a class="code hl_function" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">core</a>().<a class="code hl_variable" href="classigl_1_1opengl_1_1ViewerCore.html#a8ce15c9d27268543847a0d83c2010cb6">view</a>,vr.<a class="code hl_function" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">core</a>().<a class="code hl_variable" href="classigl_1_1opengl_1_1ViewerCore.html#a50af5081883025581f00b0918b3d9d30">proj</a>,vr.<a class="code hl_function" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">core</a>().<a class="code hl_variable" href="classigl_1_1opengl_1_1ViewerCore.html#ac5a0f15fc245747e1d83b8e718f2e74f">viewport</a>,P);</div>
<div class="ttc" id="aclassigl_1_1opengl_1_1ViewerCore_html_a50af5081883025581f00b0918b3d9d30"><div class="ttname"><a href="classigl_1_1opengl_1_1ViewerCore.html#a50af5081883025581f00b0918b3d9d30">igl::opengl::ViewerCore::proj</a></div><div class="ttdeci">Eigen::Matrix4f proj</div><div class="ttdoc">OpenGL proj transformation matrix on last render pass.</div><div class="ttdef"><b>Definition</b> ViewerCore.h:226</div></div>
<div class="ttc" id="aclassigl_1_1opengl_1_1ViewerCore_html_a8ce15c9d27268543847a0d83c2010cb6"><div class="ttname"><a href="classigl_1_1opengl_1_1ViewerCore.html#a8ce15c9d27268543847a0d83c2010cb6">igl::opengl::ViewerCore::view</a></div><div class="ttdeci">Eigen::Matrix4f view</div><div class="ttdoc">OpenGL view transformation matrix on last render pass.</div><div class="ttdef"><b>Definition</b> ViewerCore.h:224</div></div>
<div class="ttc" id="aclassigl_1_1opengl_1_1ViewerCore_html_ac5a0f15fc245747e1d83b8e718f2e74f"><div class="ttname"><a href="classigl_1_1opengl_1_1ViewerCore.html#ac5a0f15fc245747e1d83b8e718f2e74f">igl::opengl::ViewerCore::viewport</a></div><div class="ttdeci">Eigen::Vector4f viewport</div><div class="ttdoc">Viewport size.</div><div class="ttdef"><b>Definition</b> ViewerCore.h:221</div></div>
<div class="ttc" id="aclassigl_1_1opengl_1_1glfw_1_1Viewer_html"><div class="ttname"><a href="classigl_1_1opengl_1_1glfw_1_1Viewer.html">igl::opengl::glfw::Viewer</a></div><div class="ttdef"><b>Definition</b> Viewer.h:43</div></div>
<div class="ttc" id="aclassigl_1_1opengl_1_1glfw_1_1Viewer_html_a4fc39cbf6a2d68d0eaf63bef3fd49464"><div class="ttname"><a href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">igl::opengl::glfw::Viewer::core</a></div><div class="ttdeci">ViewerCore &amp; core(unsigned core_id=0)</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a33f14c3d07d3f875efa80645432c32b8" name="a33f14c3d07d3f875efa80645432c32b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f14c3d07d3f875efa80645432c32b8">&#9670;&#160;</a></span>project_isometrically_to_plane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedU , typename DerivedUF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::project_isometrically_to_plane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUF &gt; &amp;&#160;</td>
          <td class="paramname"><em>UF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project each triangle to the plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#F*3 by 2 list of triangle positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UF</td><td>#F by 3 list of mesh indices into U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#V by #F*3 such that I(i,j) = 1 implies U(j,:) corresponds to V(i,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a1c901184c35afeb294420a2cfe4f5" name="a51a1c901184c35afeb294420a2cfe4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a1c901184c35afeb294420a2cfe4f5">&#9670;&#160;</a></span>project_to_line() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::project_to_line </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project points onto vectors, that is find the parameter t for a point p such that proj_p = (y-x). </p>
<p>*t, additionally compute the squared distance from p to the line of the vector, such that |p - proj_p|² = sqr_d</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by dim list of points to be projected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>size dim start position of line vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>size dim destination position of line vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#P by 1 list of parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrD</td><td>#P by 1 list of squared distances </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6f357976c09a2f618f23fa9710bbf5c" name="aa6f357976c09a2f618f23fa9710bbf5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f357976c09a2f618f23fa9710bbf5c">&#9670;&#160;</a></span>project_to_line() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::project_to_line </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>py</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>projpx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>projpy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>projpz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>sqrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Same as above but for a single query point </p>

</div>
</div>
<a id="a3608b109e5112e5f70ff99cbdd56af0a" name="a3608b109e5112e5f70ff99cbdd56af0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3608b109e5112e5f70ff99cbdd56af0a">&#9670;&#160;</a></span>project_to_line() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::project_to_line </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>py</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>sqrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1dc57864ef37d9b1d37f52bb65fccc07" name="a1dc57864ef37d9b1d37f52bb65fccc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc57864ef37d9b1d37f52bb65fccc07">&#9670;&#160;</a></span>project_to_line_segment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedS , typename DerivedD , typename Derivedt , typename DerivedsqrD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::project_to_line_segment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project points onto vectors, that is find the parameter t for a point p such that proj_p = (y-x). </p>
<p>*t, additionally compute the squared distance from p to the line of the vector, such that |p - proj_p|² = sqr_d</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by dim list of points to be projected </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>size dim start position of line vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>size dim destination position of line vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#P by 1 list of parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrD</td><td>#P by 1 list of squared distances </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cc2bb56a9aea43d8fc3108544294915" name="a6cc2bb56a9aea43d8fc3108544294915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2bb56a9aea43d8fc3108544294915">&#9670;&#160;</a></span>projection_constraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename DerivedA , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::projection_constraint </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct two constraint equations for projecting a point to the screen. </p>
<p>Of the form: </p><pre class="fragment">A z = B
</pre><p> with A 2x3 and B 2x1, where z is the 3d position of point in the scene, given the current projection matrix (e.g. gl_proj * gl_modelview), viewport (corner u/v and width/height) and screen space point x,y. Satisfying this equation means that z projects to screen space point (x,y).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UV</td><td>2-long uv-coordinates of screen space point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>4 by 4 projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VP</td><td>4-long viewport: (corner_u, corner_v, width, height) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>2 by 3 system matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>2 by 1 right-hand side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55630c2a7977e397d8b8fbc562a05bc5" name="a55630c2a7977e397d8b8fbc562a05bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55630c2a7977e397d8b8fbc562a05bc5">&#9670;&#160;</a></span>pseudonormal_test() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::pseudonormal_test </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;&#160;</td>
          <td class="paramname"><em>VN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;&#160;</td>
          <td class="paramname"><em>EN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh (V,F), a query point q, and a point on (V,F) c, determine whether q is inside (V,F) --&gt; s=-1 or outside (V,F) s=1, based on the sign of the dot product between (q-c) and n, where n is the normal <em>at c</em>, carefully chosen according to [Bærentzen &amp; Aanæs 2005]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3 list of triangle normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VN</td><td>#V by 3 list of vertex normals (ANGLE WEIGHTING) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EN</td><td>#E by 3 list of edge normals (UNIFORM WEIGHTING) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 mapping edges in F to E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Query point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>index into F to face to which c belongs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>Point on (V,F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>sign </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>normal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56d059b63286144db10a9dc08d5083d2" name="a56d059b63286144db10a9dc08d5083d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d059b63286144db10a9dc08d5083d2">&#9670;&#160;</a></span>pseudonormal_test() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedEN , typename DerivedVN , typename Derivedq , typename Derivedc , typename Scalar , typename Derivedn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::pseudonormal_test </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;&#160;</td>
          <td class="paramname"><em>EN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;&#160;</td>
          <td class="paramname"><em>VN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>2D version. </p>

</div>
</div>
<a id="a011d3a109b2f48a5285cb49b1cf1f288" name="a011d3a109b2f48a5285cb49b1cf1f288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011d3a109b2f48a5285cb49b1cf1f288">&#9670;&#160;</a></span>pso() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar igl::pso </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Scalar(DerivedX &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>population</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivedX &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global optimization with the particle swarm algorithm. </p>
<p>Solve the problem:</p>
<p>minimize f(x) subject to lb ≤ x ≤ ub</p>
<p>by particle swarm optimization (PSO).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function that evaluates the objective for a given "particle" location </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LB</td><td>#X vector of lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>#X vector of upper bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_iters</td><td>maximum number of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">population</td><td>number of particles in swarm </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>best particle seen so far </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>objective corresponding to best particle seen so far </dd></dl>

</div>
</div>
<a id="a1b1cad08724f66e0be85d15317bb5f11" name="a1b1cad08724f66e0be85d15317bb5f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1cad08724f66e0be85d15317bb5f11">&#9670;&#160;</a></span>pso() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar igl::pso </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Scalar(DerivedX &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>population</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivedX &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>whether each DOF is periodic</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5a2ee54dd545ede9b79ee62905dfc4d" name="ad5a2ee54dd545ede9b79ee62905dfc4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a2ee54dd545ede9b79ee62905dfc4d">&#9670;&#160;</a></span>qslim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::qslim </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decimate (simplify) a triangle mesh in nD according to the paper "Simplifying Surfaces with Color and Texture using Quadric Error Metrics" by [Garland and Heckbert, 1987] (technically a followup to qslim). </p>
<p>The mesh can have open boundaries but should be edge-manifold.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions. Assumes that vertices with infinite coordinates are "points at infinity" being used to close up boundary edges with faces. This allows special subspace quadrice for boundary edges: There should never be more than one "point at
    infinity" in a single triangle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_m</td><td>desired number of output faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#U by dim list of output vertex posistions (can be same ref as V) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of output face indices into U (can be same ref as F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G list of indices into F of birth face </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#U list of indices into V of birth vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb165fc9bf550b7a4248ef3e4750c7b5" name="acb165fc9bf550b7a4248ef3e4750c7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb165fc9bf550b7a4248ef3e4750c7b5">&#9670;&#160;</a></span>quad_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedQ , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quad_grid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa374c6a411a695fa5fec90e301b42daf" name="aa374c6a411a695fa5fec90e301b42daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa374c6a411a695fa5fec90e301b42daf">&#9670;&#160;</a></span>quad_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedQ , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quad_grid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="addf84125e942c49f765c4d652f607cd2" name="addf84125e942c49f765c4d652f607cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf84125e942c49f765c4d652f607cd2">&#9670;&#160;</a></span>quad_planarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quad_planarity </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute planarity of the faces of a quad mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of mesh vertex 3D positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 4 eigen Matrix of face (quad) indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#F by 1 eigen Matrix of mesh face (quad) planarities </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af95394212815de2e493636449c262bfc" name="af95394212815de2e493636449c262bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95394212815de2e493636449c262bfc">&#9670;&#160;</a></span>quadprog() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int n, int ni&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, n, 1 &gt; igl::quadprog </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, ni, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>Ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, ni, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lbi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, ni, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ubi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a convex quadratic program. </p>
<p>Optimized for small dense problems. Still works for Eigen::Dynamic (and then everything needs to be Dynamic). </p><pre class="fragment">min_x ½ xᵀ H x + xᵀf
subject to:
  lbi ≤ Ai x ≤ ubi
  lb ≤ x ≤ u
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>(e.g., double) </td></tr>
    <tr><td class="paramname">n</td><td>#H or Eigen::Dynamic if not known at compile time </td></tr>
    <tr><td class="paramname">ni</td><td>#Ai or Eigen::Dynamic if not known at compile time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>#H by #H quadratic coefficients (only lower triangle used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>#H linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ai</td><td>#Ai by #H list of linear equality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lbi</td><td>#Ai list of linear equality lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ubi</td><td>#Ai list of linear equality upper bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lb</td><td>#H list of lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ub</td><td>#H list of lower bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#H-long solution x </dd></dl>

</div>
</div>
<a id="a552c079165c8e8dac0d633ddc36ad8f7" name="a552c079165c8e8dac0d633ddc36ad8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552c079165c8e8dac0d633ddc36ad8f7">&#9670;&#160;</a></span>quadprog() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int n, int m&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, n, 1 &gt; igl::quadprog </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, m, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, m, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a convex quadratic program. </p>
<p>Optimized for small dense problems. All inequalities must be simple bounds. </p><pre class="fragment"> min_x ½ xᵀ H x + xᵀf
 subject to:
   A x = b
   lb ≤ x ≤ u
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>(e.g., double) </td></tr>
    <tr><td class="paramname">n</td><td>#H or Eigen::Dynamic if not known at compile time </td></tr>
    <tr><td class="paramname">m</td><td>#A or Eigen::Dynamic if not known at compile time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>#H by #H quadratic coefficients (only lower triangle used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>#H linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A by #H list of linear equality constraint coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#A list of linear equality lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lb</td><td>#H list of lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ub</td><td>#H list of lower bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#H-long solution x </dd></dl>

</div>
</div>
<a id="a4086d9d0f9c0d8f922776a698cbe2055" name="a4086d9d0f9c0d8f922776a698cbe2055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4086d9d0f9c0d8f922776a698cbe2055">&#9670;&#160;</a></span>quadprog() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, n, 1 &gt; igl::quadprog </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, n &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, n, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a convex quadratic program. </p>
<p>Optimized for small dense problems. All constraints must be simple bounds. </p><pre class="fragment"> min_x ½ xᵀ H x + xᵀf
 subject to:
   lb ≤ x ≤ u
</pre> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>(e.g., double) </td></tr>
    <tr><td class="paramname">n</td><td>#H or Eigen::Dynamic if not known at compile time </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>#H by #H quadratic coefficients (only lower triangle used) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>#H linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lb</td><td>#H list of lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ub</td><td>#H list of lower bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#H-long solution x </dd></dl>

</div>
</div>
<a id="a0c609e4b0050f7ab7371dcde020c5566" name="a0c609e4b0050f7ab7371dcde020c5566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c609e4b0050f7ab7371dcde020c5566">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; igl::operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::tuple&lt; Eigen::MatrixXd, Eigen::RowVectorXd, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A binary addition operator for Quadric tuples compatible with qslim, computing c = a+b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>QSlim quadric </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>QSlim quadric </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>QSlim quadric</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="quadric__binary__plus__operator_8h.html">include/igl/quadric_binary_plus_operator.h</a> </p>

</div>
</div>
<a id="ada511054bec3939ade8f2a9494ada31b" name="ada511054bec3939ade8f2a9494ada31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada511054bec3939ade8f2a9494ada31b">&#9670;&#160;</a></span>quat_conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quat_conjugate </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute conjugate of given quaternion <a href="http://en.wikipedia.org/wiki/Quaternion#Conjugation.2C_the_norm.2C_and_reciprocal">http://en.wikipedia.org/wiki/Quaternion#Conjugation.2C_the_norm.2C_and_reciprocal</a> A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q1</td><td>input quaternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result of conjugation, allowed to be same as input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac19bfa1b6952d8ab0687e3b33f445444" name="ac19bfa1b6952d8ab0687e3b33f445444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19bfa1b6952d8ab0687e3b33f445444">&#9670;&#160;</a></span>quat_mult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quat_mult </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes out = q1 * q2 with quaternion multiplication A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q1</td><td>left quaternion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q2</td><td>right quaternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result of multiplication </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0300d689abe2fb73dcf6b2c51821dada" name="a0300d689abe2fb73dcf6b2c51821dada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0300d689abe2fb73dcf6b2c51821dada">&#9670;&#160;</a></span>quat_to_axis_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quat_to_axis_angle </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert quat representation of a rotation to axis angle A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>quaternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">axis</td><td>3d vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">angle</td><td>scalar in radians </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a279531123a14c37bbfeddb71253c50d9" name="a279531123a14c37bbfeddb71253c50d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279531123a14c37bbfeddb71253c50d9">&#9670;&#160;</a></span>quat_to_axis_angle_deg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quat_to_axis_angle_deg </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type &amp;&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="quat__to__axis__angle_8h.html">include/igl/quat_to_axis_angle.h</a>. </p>

</div>
</div>
<a id="aeb3f708cef51eb10e942ea1274a4fdc1" name="aeb3f708cef51eb10e942ea1274a4fdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3f708cef51eb10e942ea1274a4fdc1">&#9670;&#160;</a></span>quat_to_mat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::quat_to_mat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a quaternion to a 4x4 matrix A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">quat</td><td>pointer to four elements of quaternion (x,y,z,w) <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mat</td><td>pointer to 16 elements of matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1bd78c3679effe1e85e5049ddeba5f4" name="af1bd78c3679effe1e85e5049ddeba5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bd78c3679effe1e85e5049ddeba5f4">&#9670;&#160;</a></span>quats_to_column() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::quats_to_column </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt;&#160;</td>
          <td class="paramname"><em>vQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Columnize" a list of quaternions (q1x,q1y,q1z,q1w,q2x,q2y,q2z,q2w,...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vQ</td><td>n-long list of quaternions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>n*4-long list of coefficients </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586f0e07552e1ed4293b6e627b2d21a9" name="a586f0e07552e1ed4293b6e627b2d21a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586f0e07552e1ed4293b6e627b2d21a9">&#9670;&#160;</a></span>quats_to_column() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd igl::quats_to_column </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Quaterniond, Eigen::aligned_allocator&lt; Eigen::Quaterniond &gt; &gt;&#160;</td>
          <td class="paramname"><em>vQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0fe9e431751b9d9370672f22da915cea" name="a0fe9e431751b9d9370672f22da915cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe9e431751b9d9370672f22da915cea">&#9670;&#160;</a></span>ramer_douglas_peucker() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedS , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ramer_douglas_peucker </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ramer-Douglas-Peucker piecewise-linear curve simplification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by dim ordered list of vertices along the curve </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>tolerance (maximal euclidean distance allowed between the new line and a vertex) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#S by dim ordered list of points along the curve </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#S list of indices into P so that S = P(J,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef4dc2b120bfd3e28f7e1731a3afe7d1" name="aef4dc2b120bfd3e28f7e1731a3afe7d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4dc2b120bfd3e28f7e1731a3afe7d1">&#9670;&#160;</a></span>ramer_douglas_peucker() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedS , typename DerivedJ , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::ramer_douglas_peucker </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedP::Scalar&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Run Ramer-Douglas-Peucker curve simplification but keep track of where every point on the original curve maps to on the simplified curve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>#P by dim list of points mapping along simplified curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0064a7187fded546bbaf927301a9c7c" name="ae0064a7187fded546bbaf927301a9c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0064a7187fded546bbaf927301a9c7c">&#9670;&#160;</a></span>random_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector3d igl::random_dir </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a uniformly random unit direction in 3D, return as vector. </p>
<dl class="section return"><dt>Returns</dt><dd>random direction </dd></dl>

</div>
</div>
<a id="a4782a4291e5724eb403de4686b8c786d" name="a4782a4291e5724eb403de4686b8c786d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4782a4291e5724eb403de4686b8c786d">&#9670;&#160;</a></span>random_dir_stratified()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd igl::random_dir_stratified </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate n stratified uniformly random unit directions in 3d, return as rows of an n by 3 matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of directions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n by 3 matrix of random directions </dd></dl>

</div>
</div>
<a id="a1fc88d96c492e3bf962501af8bea413e" name="a1fc88d96c492e3bf962501af8bea413e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc88d96c492e3bf962501af8bea413e">&#9670;&#160;</a></span>random_points_on_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedB , typename DerivedFI , typename DerivedX , typename URBG  = DEFAULT_URBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::random_points_on_mesh </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;&#160;</td>
          <td class="paramname"><em>FI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>urbg</em> = <code><a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly sample a mesh (V,F) n times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">urbg</td><td>An instance of UnformRandomBitGenerator (e.g., <code>std::minstd_rand(0)</code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FI</td><td>n list of indices into F </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">urbg</td><td>An instance of UnformRandomBitGenerator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>n by dim list of sample positions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17abb32491125229903977390f4149b6" name="a17abb32491125229903977390f4149b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17abb32491125229903977390f4149b6">&#9670;&#160;</a></span>random_points_on_mesh_intrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeriveddblA , typename DerivedB , typename DerivedFI , typename URBG  = DEFAULT_URBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::random_points_on_mesh_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveddblA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dblA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;&#160;</td>
          <td class="paramname"><em>FI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>urbg</em> = <code><a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly sample a mesh (V,F) n times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dblA</td><td>#F list of double areas of triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>n by 3 list of barycentric coordinates, ith row are coordinates of ith sampled point in face FI(i) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FI</td><td>n list of indices into F </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">urbg</td><td>An instance of UnformRandomBitGenerator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96aa82c3339685c664b22f768a8a6e0e" name="a96aa82c3339685c664b22f768a8a6e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aa82c3339685c664b22f768a8a6e0e">&#9670;&#160;</a></span>random_points_on_mesh_intrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DeriveddblA , typename DerivedF , typename ScalarB , typename DerivedFI , typename URBG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::random_points_on_mesh_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveddblA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dblA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFI &gt; &amp;&#160;</td>
          <td class="paramname"><em>FI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>urbg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_vertices</td><td>number of vertices in mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>n by num_vertices sparse matrix so that B*V produces a list of sample points if dbl = doublearea(V,F) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afce1200f20db3dc284cca380285517cf" name="afce1200f20db3dc284cca380285517cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce1200f20db3dc284cca380285517cf">&#9670;&#160;</a></span>random_quaternion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Quaternion&lt; Scalar &gt; igl::random_quaternion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a random quaternion via uniform sampling of the 4-sphere. </p>
<dl class="section return"><dt>Returns</dt><dd>a random quaternion <br  />
 </dd></dl>

</div>
</div>
<a id="ad39042be3d7a469bc3519bc2a6ce7932" name="ad39042be3d7a469bc3519bc2a6ce7932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39042be3d7a469bc3519bc2a6ce7932">&#9670;&#160;</a></span>random_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename DerivedX , typename DerivedLB , typename DerivedUB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar igl::random_search </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; Scalar(DerivedX &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedLB &gt; &amp;&#160;</td>
          <td class="paramname"><em>LB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUB &gt; &amp;&#160;</td>
          <td class="paramname"><em>UB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DerivedX &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Global optimization via random search. </p>
<p>Solve the problem:</p>
<p>minimize f(x) subject to lb ≤ x ≤ ub</p>
<p>by uniform random search.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function to minimize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LB</td><td>#X vector of finite lower bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UB</td><td>#X vector of finite upper bounds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iters</td><td>number of iterations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>#X optimal parameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(X) </dd></dl>

</div>
</div>
<a id="a7279a059983ae9a728c94ccc1983343d" name="a7279a059983ae9a728c94ccc1983343d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7279a059983ae9a728c94ccc1983343d">&#9670;&#160;</a></span>randperm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedI , typename URBG  = DEFAULT_URBG&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::randperm </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">URBG &amp;&amp;&#160;</td>
          <td class="paramname"><em>urbg</em> = <code><a class="el" href="namespaceigl.html#a23d8ca74669cc6ed33b89020ee4f9b2e">igl::generate_default_urbg</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like matlab's randperm(n) but minus 1. </p>
<p>When urbg is not specified, randperm will use default random bit generator std::minstd_rand initialized with random seed generated by std::rand()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>n list of rand permutation of 0:n-1 </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">urbg</td><td>An instance of UnformRandomBitGenerator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af41f8552f81764bc8793cb5f76a87553" name="af41f8552f81764bc8793cb5f76a87553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41f8552f81764bc8793cb5f76a87553">&#9670;&#160;</a></span>ray_box_intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedsource , typename Deriveddir , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::ray_box_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>tmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>tmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether a ray origin+t*dir and box intersect within the ray's parameterized range (t0,t1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>3-vector origin of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>3-vector direction of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>axis aligned box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t0</td><td>hit only if hit.t less than t0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t1</td><td>hit only if hit.t greater than t1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tmin</td><td>minimum of interval of overlap within [t0,t1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tmax</td><td>maximum of interval of overlap within [t0,t1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if hit </dd></dl>

</div>
</div>
<a id="a18af1e6cc596af264e3a02e02b823a01" name="a18af1e6cc596af264e3a02e02b823a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18af1e6cc596af264e3a02e02b823a01">&#9670;&#160;</a></span>ray_box_intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedsource , typename Deriveddir , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::ray_box_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_dir_pad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>tmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>tmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>same with direction inverse precomputed </p>

</div>
</div>
<a id="adcb07bb96941cdba2a28b4239f88a246" name="adcb07bb96941cdba2a28b4239f88a246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb07bb96941cdba2a28b4239f88a246">&#9670;&#160;</a></span>ray_mesh_intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::ray_mesh_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shoot a ray against a mesh (V,F) and collect all hits. </p>
<p>If you have many rays, consider using <a class="el" href="AABB_8h.html">AABB.h</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source</td><td>3-vector origin of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>3-vector direction of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hits</td><td><b>sorted</b> list of hits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there were any hits (hits.size() &gt; 0)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> </dd></dl>

</div>
</div>
<a id="a6a827e72cc935817ec986e83ce56cc73" name="a6a827e72cc935817ec986e83ce56cc73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a827e72cc935817ec986e83ce56cc73">&#9670;&#160;</a></span>ray_mesh_intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::ray_mesh_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">hit</td><td>first hit, set only if it exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afab2426f066fcd19c79646bcca3501b8" name="afab2426f066fcd19c79646bcca3501b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab2426f066fcd19c79646bcca3501b8">&#9670;&#160;</a></span>ray_triangle_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedsource , typename Deriveddir , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::ray_triangle_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedsource &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &amp;&#160;</td>
          <td class="paramname"><em>hit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11b3c855b74e0beac5385f073686761e" name="a11b3c855b74e0beac5385f073686761e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b3c855b74e0beac5385f073686761e">&#9670;&#160;</a></span>ray_sphere_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedo , typename Derivedd , typename Derivedc , typename r_type , typename t_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::ray_sphere_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedo &gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedd &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">r_type&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_type &amp;&#160;</td>
          <td class="paramname"><em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t_type &amp;&#160;</td>
          <td class="paramname"><em>t1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the intersection between a ray from O in direction D and a sphere centered at C with radius r. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">o</td><td>origin of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>direction of ray </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>center of sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>radius of sphere </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t0</td><td>parameterization of first hit (set only if exists) so that hit position = o + t0*d </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t1</td><td>parameterization of second hit (set only if exists) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of hits </dd></dl>

</div>
</div>
<a id="a28bb8198773c2124500fd5bc9a5f810b" name="a28bb8198773c2124500fd5bc9a5f810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bb8198773c2124500fd5bc9a5f810b">&#9670;&#160;</a></span>read_file_binary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::read_file_binary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>fileBufferBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read contents of file into a buffer of uint8_t bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fp</td><td>pointer to open File </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fileBufferBytes</td><td>contents of file as vector of bytes</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md24"></a>
Side effects:</h4>
<p>closes fp </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">runtime_error</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bd18b073b51beb1500c10c4f2825aba" name="a6bd18b073b51beb1500c10c4f2825aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd18b073b51beb1500c10c4f2825aba">&#9670;&#160;</a></span>read_triangle_mesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::read_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read mesh from an ascii file with automatic detection of file format among: mesh, msh obj, off, ply, stl, wrl. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>eigen double matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>eigen int matrix #F by 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff success </dd></dl>

</div>
</div>
<a id="ad787fca3bc0010177aa587a1ad0d8bc8" name="ad787fca3bc0010177aa587a1ad0d8bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad787fca3bc0010177aa587a1ad0d8bc8">&#9670;&#160;</a></span>read_triangle_mesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::read_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>outputs to vectors, only .off and .obj supported. </p>

</div>
</div>
<a id="ae6cf40d2ba95e3819ecc7d733a73d321" name="ae6cf40d2ba95e3819ecc7d733a73d321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cf40d2ba95e3819ecc7d733a73d321">&#9670;&#160;</a></span>read_triangle_mesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::read_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>directory path (see <a class="el" href="pathinfo_8h.html">pathinfo.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">base</td><td>base name (see <a class="el" href="pathinfo_8h.html">pathinfo.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ext</td><td>extension (see <a class="el" href="pathinfo_8h.html">pathinfo.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>filename (see <a class="el" href="pathinfo_8h.html">pathinfo.h</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8cfd07940eb9445554a8f64c84ea385c" name="a8cfd07940eb9445554a8f64c84ea385c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfd07940eb9445554a8f64c84ea385c">&#9670;&#160;</a></span>read_triangle_mesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::read_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ext</td><td>file extension </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fp</td><td>pointer to already opened .ext file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4efbc110f683b253ef703142d1406f28" name="a4efbc110f683b253ef703142d1406f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4efbc110f683b253ef703142d1406f28">&#9670;&#160;</a></span>readBF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedWI , typename DerivedP , typename DerivedO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readBF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWI &gt; &amp;&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>O</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a bones forest from a file, returns a list of bone roots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>path to .bf bones tree file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td>#B list of unique weight indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#B list of parent indices into B, -1 for roots </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">O</td><td>#B by 3 list of tip offset vectors from parent (or position for roots) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="a0ad78f74b0306e9a2775575579314170" name="a0ad78f74b0306e9a2775575579314170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad78f74b0306e9a2775575579314170">&#9670;&#160;</a></span>readBF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedWI , typename DerivedbfP , typename DerivedO , typename DerivedC , typename DerivedBE , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readBF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWI &gt; &amp;&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedbfP &gt; &amp;&#160;</td>
          <td class="paramname"><em>bfP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedBE &gt; &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read bone forest into pure bone-skeleton format, expects only bones (no point handles), and that a root in the .bf &lt;&mdash;&gt; no weight attachment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>path to .bf bones tree file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WI</td><td>#B list of unique weight indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#B list of parent indices into B, -1 for roots </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">O</td><td>#B by 3 list of tip offset vectors from parent (or position for roots) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C by 3 list of absolute joint locations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BE</td><td>#BE by 3 list of bone indices into C, in order of weight index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>#BE list of parent bone indices into BE, -1 means root bone </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a0e2ff313a45b1882bc42711ef59518ea" title="Read a graph from a .tgf file.">readTGF</a>, <a class="el" href="namespaceigl.html#af9bff7fe392542fa173e6665ddaf7a21" title="Recover &quot;parent&quot; bones from directed graph representation.">bone_parents</a>, <a class="el" href="namespaceigl.html#a583ee685a22b43577be16d088b6d3f29" title="Given a skeleton and a set of relative bone rotations compute absolute rigid transformations for each...">forward_kinematics</a> </dd></dl>

</div>
</div>
<a id="a5b133398a6e09068c97655f27de173a0" name="a5b133398a6e09068c97655f27de173a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b133398a6e09068c97655f27de173a0">&#9670;&#160;</a></span>readCSV()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readCSV </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a matrix from a csv file into a Eigen matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to .csv file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>eigen matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a44a50547ab59bcb0705475875bb39a7d" name="a44a50547ab59bcb0705475875bb39a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a50547ab59bcb0705475875bb39a7d">&#9670;&#160;</a></span>readDMAT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readDMAT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix from an .dmat file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>path to .dmat file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>eigen matrix containing read-in coefficients </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error </dd></dl>

</div>
</div>
<a id="a866564d1ac5b6f69fcee878f2ac2429d" name="a866564d1ac5b6f69fcee878f2ac2429d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866564d1ac5b6f69fcee878f2ac2429d">&#9670;&#160;</a></span>readDMAT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readDMAT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa40ef4e0517c71c597272824497377b2" name="aa40ef4e0517c71c597272824497377b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40ef4e0517c71c597272824497377b2">&#9670;&#160;</a></span>readMESH() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMESH </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>mesh_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a tetrahedral volume mesh from a .mesh file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_file_name</td><td>path of .mesh file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#T list of tet indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F list of face indices into vertex positions</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a078957e6e3c6a1f4cff7de4d0a28956d" name="a078957e6e3c6a1f4cff7de4d0a28956d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078957e6e3c6a1f4cff7de4d0a28956d">&#9670;&#160;</a></span>readMESH() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMESH </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>mesh_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1471e99a81d4975918c69176594f4621" name="a1471e99a81d4975918c69176594f4621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1471e99a81d4975918c69176594f4621">&#9670;&#160;</a></span>readMESH() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMESH </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pointer</td><td>to already opened .mesh file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bcad51e218e111ff185566bea366cb3" name="a2bcad51e218e111ff185566bea366cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bcad51e218e111ff185566bea366cb3">&#9670;&#160;</a></span>readMESH() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMESH </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9364f18a5e9db3da7b923ab9ee054481" name="a9364f18a5e9db3da7b923ab9ee054481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9364f18a5e9db3da7b923ab9ee054481">&#9670;&#160;</a></span>readMSH() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int EigenMatrixOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMSH </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>TriTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>TetTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>XFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>XF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>EFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TriF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TetF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read triangle surface mesh and tetrahedral volume mesh from .msh file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenMatrixOptions</td><td>matrix options of output matrices (e.g., Eigen::ColMajor, Eigen::RowMajor) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msh</td><td>- file name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>eigen double matrix of vertex positions #X by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Tri</td><td>#Tri eigen integer matrix of triangular faces indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Tet</td><td>#Tet eigen integer matrix of tetrahedral indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TriTag</td><td>#Tri eigen integer vector of tags associated with surface faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TetTag</td><td>#Tet eigen integer vector of tags associated with volume elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">XFields</td><td>#XFields list of strings with field names associated with nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">XF</td><td>#XFields list of eigen double matrices, fields associated with nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EFields</td><td>#EFields list of strings with field names associated with elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TriF</td><td>#EFields list of eigen double matrices, fields associated with surface elements </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TetF</td><td>#EFields list of eigen double matrices, fields associated with volume elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="aadcaf1cbdf935ab8ae06264bc17a80b1" name="aadcaf1cbdf935ab8ae06264bc17a80b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcaf1cbdf935ab8ae06264bc17a80b1">&#9670;&#160;</a></span>readMSH() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int EigenMatrixOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMSH </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>TriTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>TetTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad3928fbb4033580f092da0afb953cc7c" name="ad3928fbb4033580f092da0afb953cc7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3928fbb4033580f092da0afb953cc7c">&#9670;&#160;</a></span>readMSH() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int EigenMatrixOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMSH </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>TriTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af2a21df0040f4d7799d33535261164ac" name="af2a21df0040f4d7799d33535261164ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a21df0040f4d7799d33535261164ac">&#9670;&#160;</a></span>readMSH() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int EigenMatrixOptions&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readMSH </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, Eigen::Dynamic, Eigen::Dynamic, EigenMatrixOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>Tri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0a5218e3a581f3ae7d3937db7cb6bafe" name="a0a5218e3a581f3ae7d3937db7cb6bafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5218e3a581f3ae7d3937db7cb6bafe">&#9670;&#160;</a></span>readNODE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readNODE </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>node_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>load a list of points from a .node file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node_file_name</td><td>path of .node file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by dim </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>list of indices (first tells whether 0 or 1 indexed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9897d432300521fe95987a223d3c834c" name="a9897d432300521fe95987a223d3c834c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9897d432300521fe95987a223d3c834c">&#9670;&#160;</a></span>readNODE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readNODE </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>node_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad3d68499324615abfb462bf80130431b" name="ad3d68499324615abfb462bf80130431b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d68499324615abfb462bf80130431b">&#9670;&#160;</a></span>readOBJ() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>obj_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, Index, Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates. </p>
<p>Mesh may have faces of any number of degree</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to .obj file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TC</td><td>double matrix of texture coordinats #TC by 2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>double matrix of corner normals #N by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F list of face indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FTC</td><td>#F list of face indices into vertex texture coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FN</td><td>#F list of face indices into vertex normals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8" name="aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3e2d2ac8f8dd1a2a8d5cdf8a6a80b8">&#9670;&#160;</a></span>readOBJ() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>obj_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a86d39ea33fc7a17fb16a3e02a5065757" name="a86d39ea33fc7a17fb16a3e02a5065757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d39ea33fc7a17fb16a3e02a5065757">&#9670;&#160;</a></span>readOBJ() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>obj_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; std::string, Index, Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>FM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">obj_file</td><td>pointer to already opened .obj file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6485914541d342f476f70e9ba97a00ff" name="a6485914541d342f476f70e9ba97a00ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6485914541d342f476f70e9ba97a00ff">&#9670;&#160;</a></span>readOBJ() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>obj_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2d8c28b2557217c00bb8e146d828cd35" name="a2d8c28b2557217c00bb8e146d828cd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8c28b2557217c00bb8e146d828cd35">&#9670;&#160;</a></span>readOBJ() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedTC , typename DerivedCN , typename DerivedF , typename DerivedFTC , typename DerivedFN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTC &gt; &amp;&#160;</td>
          <td class="paramname"><em>TC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFTC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Eigen Wrappers. These will return true only if the data is perfectly "rectangular": All faces are the same degree, all have the same number of textures/normals etc. </p>

</div>
</div>
<a id="a3034889b938bdf0fa96f79ad62f47641" name="a3034889b938bdf0fa96f79ad62f47641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3034889b938bdf0fa96f79ad62f47641">&#9670;&#160;</a></span>readOBJ() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4c4849d6cdcfeffd1ed7b48c15d493ad" name="a4c4849d6cdcfeffd1ed7b48c15d493ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4849d6cdcfeffd1ed7b48c15d493ad">&#9670;&#160;</a></span>readOBJ() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Polygon mesh version. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#I vectorized list of polygon corner indices into rows of some matrix V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#P+1 list of cumulative polygon sizes so that C(i+1)-C(i) = size of the ith polygon, and so I(C(i)) through I(C(i+1)-1) are the indices of the ith polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0b3fbb305991ff009d5ef2bf7c2bb99" name="ae0b3fbb305991ff009d5ef2bf7c2bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b3fbb305991ff009d5ef2bf7c2bb99">&#9670;&#160;</a></span>readOFF() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOFF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>off_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a mesh from an ascii OFF file, filling in vertex positions, normals and texture coordinates. </p>
<p>Mesh may have faces of any number of degree</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to .obj file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F list of face indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>list of vertex normals #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>list of rgb color values per vertex #V by 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="a80e987bbb9c21c44facf425147ce0c0e" name="a80e987bbb9c21c44facf425147ce0c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e987bbb9c21c44facf425147ce0c0e">&#9670;&#160;</a></span>readOFF() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOFF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a53bb9e4bd7e6acfc8838f372351d7fd5" name="a53bb9e4bd7e6acfc8838f372351d7fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53bb9e4bd7e6acfc8838f372351d7fd5">&#9670;&#160;</a></span>readOFF() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOFF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a805a632075fa2b99892f172b2063e8de" name="a805a632075fa2b99892f172b2063e8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a632075fa2b99892f172b2063e8de">&#9670;&#160;</a></span>readOFF() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readOFF </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>off_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">off_file</td><td>pointer to already open .off file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19dbe47791345f0dff905ae3515ffd21" name="a19dbe47791345f0dff905ae3515ffd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19dbe47791345f0dff905ae3515ffd21">&#9670;&#160;</a></span>readPLY() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>ply_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFD &gt; &amp;&#160;</td>
          <td class="paramname"><em>FD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Fheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedED &gt; &amp;&#160;</td>
          <td class="paramname"><em>ED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Eheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read triangular mesh from ply file, filling in vertex positions, normals and texture coordinates, if available also read additional properties associated with vertex,faces and edges and file comments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived*</td><td>from Eigen matrix parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ply_stream</td><td>ply file input stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>(#V,3) matrix of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>(#F,3) list of face indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>(#E,2) list of edge indices into vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>(#V,3) list of normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UV</td><td>(#V,2) list of texture coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VD</td><td>(#V,*) additional vertex data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Vheader</td><td>(#V) list of vertex data headers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FD</td><td>(#F,*) additional face data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Fheader</td><td>(#F) list of face data headers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ED</td><td>(#E,*) additional edge data </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Eheader</td><td>(#E) list of edge data headers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">comments</td><td>(*) file comments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unlike previous versions, all matrices are left untouched if they are not read from the file. <br  />
 </dd></dl>

</div>
</div>
<a id="a2d9d95305b4c4ad23b0ae936bf8ebe28" name="a2d9d95305b4c4ad23b0ae936bf8ebe28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9d95305b4c4ad23b0ae936bf8ebe28">&#9670;&#160;</a></span>readPLY() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ply_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>VDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFD &gt; &amp;&#160;</td>
          <td class="paramname"><em>FD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>FDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedED &gt; &amp;&#160;</td>
          <td class="paramname"><em>ED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>EDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ply_file</td><td>ply file name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa82ecbf00ab1917446d26d4aaed0c79f" name="aa82ecbf00ab1917446d26d4aaed0c79f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82ecbf00ab1917446d26d4aaed0c79f">&#9670;&#160;</a></span>readPLY() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedUV , typename DerivedVD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vheader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a500ef30b39ed4e46a12342238fddd1ea" name="a500ef30b39ed4e46a12342238fddd1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500ef30b39ed4e46a12342238fddd1ea">&#9670;&#160;</a></span>readPLY() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aab45ac576aa1e4ed7721b0a00e5d12c1" name="aab45ac576aa1e4ed7721b0a00e5d12c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab45ac576aa1e4ed7721b0a00e5d12c1">&#9670;&#160;</a></span>readPLY() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a18adc6f5870ec2806992a65719834abd" name="a18adc6f5870ec2806992a65719834abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18adc6f5870ec2806992a65719834abd">&#9670;&#160;</a></span>readPLY() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0c0ed58390b96d5981b908b62103c250" name="a0c0ed58390b96d5981b908b62103c250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0ed58390b96d5981b908b62103c250">&#9670;&#160;</a></span>readPLY() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readPLY </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fp</td><td>pointer to ply file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1e874916eb50201727b290cc48fbaac" name="aa1e874916eb50201727b290cc48fbaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e874916eb50201727b290cc48fbaac">&#9670;&#160;</a></span>readSTL() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readSTL </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a mesh from an ascii/binary stl file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>path to .stl file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>double matrix of vertex positions #V*3 by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>index matrix of triangle indices #F by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>double matrix of surface normals #F by 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors</dd></dl>
<h4><a class="anchor" id="autotoc_md30"></a>
Example</h4>
<pre class="fragment">bool success = readSTL(filename,temp_V,F,N);
remove_duplicate_vertices(temp_V,0,V,SVI,SVJ);
for_each(F.data(),F.data()+F.size(),[&amp;SVJ](int &amp; f){f=SVJ(f);});
writeOBJ("Downloads/cat.obj",V,F); 
</pre> 
</div>
</div>
<a id="a1b3c654bf8fde8ab6f7b55c515b11bea" name="a1b3c654bf8fde8ab6f7b55c515b11bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3c654bf8fde8ab6f7b55c515b11bea">&#9670;&#160;</a></span>readSTL() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeV , typename TypeF , typename TypeN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readSTL </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; TypeV, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; TypeF, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::array&lt; TypeN, 3 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa7d360f2f2694afebd1e62cee1551de4" name="aa7d360f2f2694afebd1e62cee1551de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d360f2f2694afebd1e62cee1551de4">&#9670;&#160;</a></span>readSTL() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readSTL </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fp</td><td>pointer to ply file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e2ff313a45b1882bc42711ef59518ea" name="a0e2ff313a45b1882bc42711ef59518ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e2ff313a45b1882bc42711ef59518ea">&#9670;&#160;</a></span>readTGF() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readTGF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tgf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>CE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>PE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a graph from a .tgf file. </p>
<p>Input: filename .tgf file name Output: V # vertices by 3 list of vertex positions E # edges by 2 list of edge indices P # point-handles list of point handle indices BE # bone-edges by 2 list of bone-edge indices CE # cage-edges by 2 list of cage-edge indices PE # pseudo-edges by 2 list of pseudo-edge indices</p>
<p>Assumes that graph vertices are 3 dimensional </p>

</div>
</div>
<a id="a86a753ab8f368313c20aa9d6aa98841c" name="a86a753ab8f368313c20aa9d6aa98841c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a753ab8f368313c20aa9d6aa98841c">&#9670;&#160;</a></span>readTGF() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readTGF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tgf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>CE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>PE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2cfc64e83ab4d2cd4fb8a6e31d4403d6" name="a2cfc64e83ab4d2cd4fb8a6e31d4403d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfc64e83ab4d2cd4fb8a6e31d4403d6">&#9670;&#160;</a></span>readTGF() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readTGF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tgf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a480b2999b4d8ec50dcfa86d790f7b9d0" name="a480b2999b4d8ec50dcfa86d790f7b9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480b2999b4d8ec50dcfa86d790f7b9d0">&#9670;&#160;</a></span>readWRL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readWRL </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>wrl_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a mesh from an ascii wrl file, filling in vertex positions and face indices of the first model. </p>
<p>Mesh may have faces of any number of degree</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to .wrl file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F list of face indices into vertex positions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="a90ea20362e20a0f75e389904a2957ed2" name="a90ea20362e20a0f75e389904a2957ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ea20362e20a0f75e389904a2957ed2">&#9670;&#160;</a></span>readWRL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::readWRL </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>wrl_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wrl_file</td><td>pointer to already opened .wrl file (will be closed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af757c8be2caaeaf804de6240cc6ffa7f" name="af757c8be2caaeaf804de6240cc6ffa7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af757c8be2caaeaf804de6240cc6ffa7f">&#9670;&#160;</a></span>redux()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename Func , typename DerivedB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void igl::redux </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform reductions on the rows or columns of a SparseMatrix. </p>
<p>This is <em>similar</em> to DenseBase::redux, but different in two important ways:</p><ol type="1">
<li>(unstored) Zeros are <b>not</b> "visited", however if the first element in the column/row does not appear in the first row/column then the reduction is assumed to start with zero. In this way, "any", "all", "count"(non-zeros) work as expected. This means it is <b>not</b> possible to use this to count (implicit) zeros.</li>
<li>This redux is more powerful in the sense that A and B may have different types. This makes it possible to count the number of non-zeros in a SparseMatrix&lt;bool&gt; A into a VectorXi B.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to sum (1 or 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function handle with the prototype <code>X(Y a, I i, J j, Z b)</code> where a is the running value, b is A(i,j) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>n-long sparse vector (if dim == 1) or m-long sparse vector (if dim == 2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a09311547ed4f12bee75c2631d2d19bfd" title="FOR_EACH Call a given function for each non-zero (i.e., explicit value might actually be ==0) in a Sp...">for_each</a> </dd></dl>

</div>
</div>
<a id="a492e4e2a6bc227fe67a79b0110d4c8de" name="a492e4e2a6bc227fe67a79b0110d4c8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492e4e2a6bc227fe67a79b0110d4c8de">&#9670;&#160;</a></span>remesh_along_isoline() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedU , typename DerivedG , typename DerivedJ , typename BCtype , typename DerivedSU , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remesh_along_isoline </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSU &gt; &amp;&#160;</td>
          <td class="paramname"><em>SU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; BCtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>BC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a triangle mesh and a scalar field, remesh so that a given isovalue of the scalar field follows (new) edges of the output mesh. </p>
<p>Effectively running "marching triangles" on mesh, but not in any coherent order. The output mesh should be as manifold as the input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#V by 1 list of scalar field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value of S to remesh along </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#U by dim list of mesh vertex positions #U&gt;=#V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of mesh triangle indices into U, #G&gt;=#F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SU</td><td>#U list of scalar field values over new mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G list of indices into F revealing birth triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BC</td><td>#U by #V sparse matrix of barycentric coordinates so that U = BC*V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#G list of bools whether scalar field in triangle below or above val </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7057971dd3f4cb240c6598b5ee52eaff" name="a7057971dd3f4cb240c6598b5ee52eaff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7057971dd3f4cb240c6598b5ee52eaff">&#9670;&#160;</a></span>remesh_along_isoline() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedS , typename DerivedG , typename DerivedJ , typename BCtype , typename DerivedSU , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remesh_along_isoline </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedS::Scalar&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSU &gt; &amp;&#160;</td>
          <td class="paramname"><em>SU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; BCtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>BC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of vertices (#V) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4684c8d485a5cd367751c6bb92e8b415" name="a4684c8d485a5cd367751c6bb92e8b415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4684c8d485a5cd367751c6bb92e8b415">&#9670;&#160;</a></span>remove_duplicate_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedSV , typename DerivedSVI , typename DerivedSVJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remove_duplicate_vertices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>SVI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSVJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>SVJ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicate vertices upto a uniqueness tolerance (epsilon) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>uniqueness tolerance used coordinate-wise: 1e0 --&gt; integer match, 1e-1 --&gt; match up to first decimal, ... , 0 --&gt; exact match. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SV</td><td>#SV by dim new list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SVI</td><td>#SV by 1 list of indices so SV = V(SVI,:) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SVJ</td><td>#V by 1 list of indices so V = SV(SVJ,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2865c2682b8f7cda67db377ca026619" name="ae2865c2682b8f7cda67db377ca026619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2865c2682b8f7cda67db377ca026619">&#9670;&#160;</a></span>remove_duplicate_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedSV , typename DerivedSVI , typename DerivedSVJ , typename DerivedSF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remove_duplicate_vertices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>SVI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSVJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>SVJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper that also remaps given faces (F) --&gt; (SF) so that SF index SV </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">SF</td><td>#F by dim list of face indices into SV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d51bedab2b1bb46c40334e6d59035bc" name="a8d51bedab2b1bb46c40334e6d59035bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d51bedab2b1bb46c40334e6d59035bc">&#9670;&#160;</a></span>remove_unreferenced() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF , typename DerivedI , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remove_unreferenced </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;&#160;</td>
          <td class="paramname"><em>NV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove unreferenced vertices from V, updating F accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by ss list of simplices (Values of -1 are quitely skipped) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NV</td><td>#NV by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NF</td><td>#NF by ss list of simplices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#V by 1 list of indices such that: NF = IM(F) and NT = IM(T) and V(find(IM&lt;=size(NV,1)),:) = NV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#NV by 1 list, such that NV = V(J,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84fd84522be8f2e70fa6ef154849f3c1" name="a84fd84522be8f2e70fa6ef154849f3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84fd84522be8f2e70fa6ef154849f3c1">&#9670;&#160;</a></span>remove_unreferenced() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remove_unreferenced </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;&#160;</td>
          <td class="paramname"><em>NV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6afd2f60ecc2994c7f37deecac94dc80" name="a6afd2f60ecc2994c7f37deecac94dc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6afd2f60ecc2994c7f37deecac94dc80">&#9670;&#160;</a></span>remove_unreferenced() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedI , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::remove_unreferenced </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of vertices (possibly greater than F.maxCoeff()+1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad35357b4f4e8dbf29c3fad77850fb957" name="ad35357b4f4e8dbf29c3fad77850fb957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad35357b4f4e8dbf29c3fad77850fb957">&#9670;&#160;</a></span>repdiag() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::repdiag </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat a matrix along the diagonal a certain number of times, so that if A is a m by n matrix and we want to repeat along the diagonal d times, we get a m*d by n*d matrix B such that: B( (k*m+1):(k*m+1+m-1), (k*n+1):(k*n+1+n-1)) = A for k from 0 to d-1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix we are repeating along the diagonal. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>number of times to repeat A along the diagonal </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>m*d by n*d matrix with A repeated d times along the diagonal, will be dense or sparse to match A </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4425112c9b09eccba5935d7390228b8f" name="a4425112c9b09eccba5935d7390228b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4425112c9b09eccba5935d7390228b8f">&#9670;&#160;</a></span>repdiag() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::repdiag </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8da20ed25cb6630b40cb666c4f0153fb" name="a8da20ed25cb6630b40cb666c4f0153fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da20ed25cb6630b40cb666c4f0153fb">&#9670;&#160;</a></span>repdiag() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat igl::repdiag </td>
          <td>(</td>
          <td class="paramtype">const Mat &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af22441a0a5c291b8fd51ee68e5817c38" name="af22441a0a5c291b8fd51ee68e5817c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22441a0a5c291b8fd51ee68e5817c38">&#9670;&#160;</a></span>repmat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::repmat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replicate and tile a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>number of row-direction copies </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>number of col-direction copies </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>r*m by c*n output matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>At least for Dense matrices this is replaced by <code>replicate</code> e.g., dst = src.replicate(n,m); <a href="http://forum.kde.org/viewtopic.php?f=74&t=90876#p173517">http://forum.kde.org/viewtopic.php?f=74&amp;t=90876#p173517</a> </dd></dl>

</div>
</div>
<a id="ab60f3cce9962403250a40b72d322e7c3" name="ab60f3cce9962403250a40b72d322e7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60f3cce9962403250a40b72d322e7c3">&#9670;&#160;</a></span>repmat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int majorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::repmat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T, majorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T, majorType &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aaadc5b485c5ab4b8719143b79e9458b2" name="aaadc5b485c5ab4b8719143b79e9458b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaadc5b485c5ab4b8719143b79e9458b2">&#9670;&#160;</a></span>resolve_duplicated_faces()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF1 , typename DerivedF2 , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::resolve_duplicated_faces </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolve duplicated faces according to the following rules per unique face: </p>
<ol type="1">
<li>If the number of positively oriented faces equals the number of negatively oriented faces, remove all duplicated faces at this triangle.</li>
<li>If the number of positively oriented faces equals the number of negatively oriented faces plus 1, keeps one of the positively oriented face.</li>
<li>If the number of positively oriented faces equals the number of negatively oriented faces minus 1, keeps one of the negatively oriented face.</li>
<li>If the number of postively oriented faces differ with the number of negativley oriented faces by more than 1, the mesh is not orientable. An exception will be thrown.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F1</td><td>#F1 by 3 array of input faces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F2</td><td>#F2 by 3 array of output faces without duplicated faces. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F2 list of indices into F1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c02b0853de3739e4fcfe1a39591826" name="ad9c02b0853de3739e4fcfe1a39591826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c02b0853de3739e4fcfe1a39591826">&#9670;&#160;</a></span>rgb_to_hsv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename H &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::rgb_to_hsv </td>
          <td>(</td>
          <td class="paramtype">const R *&#160;</td>
          <td class="paramname"><em>rgb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">H *&#160;</td>
          <td class="paramname"><em>hsv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert RGB to HSV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rgb</td><td>rgb triplet in (0,1)³ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hsv</td><td>hsv triplet in (0,360),(0,1),(0,1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ffa1e3139c0b53002dfc44fa70bb3de" name="a2ffa1e3139c0b53002dfc44fa70bb3de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffa1e3139c0b53002dfc44fa70bb3de">&#9670;&#160;</a></span>rgb_to_hsv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedR , typename DerivedH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::rgb_to_hsv </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedH &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>#R by 3 list of rgb triplets in (0,1)ⁿˣ³ </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">H</td><td>#R by 3 list of hsv triplets in [(0,360),(0,1),(0,1)]ⁿ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9b76e4f79b4040f8b327696d8120ac6" name="ad9b76e4f79b4040f8b327696d8120ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b76e4f79b4040f8b327696d8120ac6">&#9670;&#160;</a></span>rigid_alignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedP , typename DerivedN , typename DerivedR , typename Derivedt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::rigid_alignment </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedt &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the rigid transformation that best aligns the 3D points X to their corresponding points P with associated normals N. </p>
<pre class="fragment"> min       ‖(X*R+t-P)'N‖²
 R∈SO(3)
 t∈R³
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>#X by 3 list of query points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#X by 3 list of corresponding (e.g., closest) points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#X by 3 list of unit normals for each row in P </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>3 by 3 rotation matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>1 by 3 translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>icp </dd></dl>

</div>
</div>
<a id="ad3a4c70fcd75b8cb889db416e1412838" name="ad3a4c70fcd75b8cb889db416e1412838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a4c70fcd75b8cb889db416e1412838">&#9670;&#160;</a></span>rotate_by_quat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::rotate_by_quat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute rotation of a given vector/point by a quaternion A Quaternion, q, is defined here as an arrays of four scalars (x,y,z,w), such that q = x*i + y*j + z*k + w. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>input 3d point/vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>input quaternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out</td><td>result of rotation, allowed to be same as v </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6346e87eb125dbf3922a86b2430cd66" name="ac6346e87eb125dbf3922a86b2430cd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6346e87eb125dbf3922a86b2430cd66">&#9670;&#160;</a></span>rotate_vectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd igl::rotate_vectors </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>B2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate the vectors V by A radians on the tangent plane spanned by B1 and B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 eigen Matrix of vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#V eigen vector of rotation angles or a single angle to be applied to all vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B1</td><td>#V by 3 eigen Matrix of base vector 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B2</td><td>#V by 3 eigen Matrix of base vector 2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated vectors </dd></dl>

</div>
</div>
<a id="a9d8d4e651144f2c59335a8050526d3a2" name="a9d8d4e651144f2c59335a8050526d3a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8d4e651144f2c59335a8050526d3a2">&#9670;&#160;</a></span>rotation_matrix_from_directions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, 3, 3 &gt; igl::rotation_matrix_from_directions </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt;&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given 2 vectors centered on origin calculate the rotation matrix from first to the second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v0</td><td>3D column vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>3D column vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">3</td><td>by 3 rotation matrix that takes v0 to v1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae02094b6dc03417864b855a494010674" name="ae02094b6dc03417864b855a494010674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02094b6dc03417864b855a494010674">&#9670;&#160;</a></span>round() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedX igl::round </td>
          <td>(</td>
          <td class="paramtype">const DerivedX&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round a scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x rounded to integer </dd></dl>

</div>
</div>
<a id="a97b570d716cfd4d32ff22a5ec6b1d14b" name="a97b570d716cfd4d32ff22a5ec6b1d14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b570d716cfd4d32ff22a5ec6b1d14b">&#9670;&#160;</a></span>round() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::round </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round a given matrix to nearest integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix of scalars </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n matrix of rounded integers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fa793427dc212ca586bf37babf9459e" name="a7fa793427dc212ca586bf37babf9459e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa793427dc212ca586bf37babf9459e">&#9670;&#160;</a></span>rows_to_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Row , class Mat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::rows_to_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Row &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list (std::vector) of row vectors of the same length to a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Row</td><td>row vector type, must implement: .size() </td></tr>
    <tr><td class="paramname">Mat</td><td>Matrix type, must implement: .resize(m,n) .row(i) = Row </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>a m-long list of vectors of size n </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>an m by n matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="a32d8c4634efb1346c13c78dc765a3550" name="a32d8c4634efb1346c13c78dc765a3550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d8c4634efb1346c13c78dc765a3550">&#9670;&#160;</a></span>sample_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::sample_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute k extra points along each edge in E defined over vertices of V. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>vertices over which edges are defined, # vertices by dim </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>edge list, # edges by 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of extra samples to be computed along edge not including start and end points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>sampled vertices, size less than # edges * (2+k) by dim always begins with V so that E is also defined over S </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037463f70cf735b53d1205d9f24f8bd3" name="a037463f70cf735b53d1205d9f24f8bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037463f70cf735b53d1205d9f24f8bd3">&#9670;&#160;</a></span>scalar_to_cr_vector_gradient() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::scalar_to_cr_vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the gradient matrix with hat functions on the right, and vector CR functions on the left. </p>
<p>See Oded Stein, Max Wardetzky, Alec Jacobson, Eitan Grinspun, 2020. "A Simple Discretization of the Vector Dirichlet
Energy"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/4 list of triangle/tetrahedron indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>2*|HE| by #V gradient matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb08e6f491b4715eb69439e76a9d6829" name="adb08e6f491b4715eb69439e76a9d6829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb08e6f491b4715eb69439e76a9d6829">&#9670;&#160;</a></span>scalar_to_cr_vector_gradient() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::scalar_to_cr_vector_gradient </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#F by 3 a mapping from each halfedge to each edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">oE</td><td>#F by 3 the orientation (e.g., -1 or 1) of each halfedge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27653ad9aae1bdd251eeb2b990cb69be" name="a27653ad9aae1bdd251eeb2b990cb69be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27653ad9aae1bdd251eeb2b990cb69be">&#9670;&#160;</a></span>scalar_to_cr_vector_gradient_intrinsic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DeriveddA , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::scalar_to_cr_vector_gradient_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveddA &gt; &amp;&#160;</td>
          <td class="paramname"><em>dA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>intrinsic version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">l_sq</td><td>#F by 3 list of squared edge lengths of each halfedge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dA</td><td>#F list of double areas</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="scalar__to__cr__vector__gradient_8h.html">include/igl/scalar_to_cr_vector_gradient.h</a> </p>

</div>
</div>
<a id="a9e243eeab5d04120f9aa5670610e5961" name="a9e243eeab5d04120f9aa5670610e5961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e243eeab5d04120f9aa5670610e5961">&#9670;&#160;</a></span>scalar_to_cr_vector_gradient_intrinsic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedL_sq , typename DerivedE , typename DerivedOE , typename ScalarG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::scalar_to_cr_vector_gradient_intrinsic </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL_sq &gt; &amp;&#160;</td>
          <td class="paramname"><em>l_sq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedOE &gt; &amp;&#160;</td>
          <td class="paramname"><em>oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; ScalarG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <a class="el" href="scalar__to__cr__vector__gradient_8h.html">include/igl/scalar_to_cr_vector_gradient.h</a>. </p>

</div>
</div>
<a id="a0aea89901f87476263f8973c9ea065e4" name="a0aea89901f87476263f8973c9ea065e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aea89901f87476263f8973c9ea065e4">&#9670;&#160;</a></span>screen_space_selection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW , typename Deriveda &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::screen_space_selection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Matrix&lt; Ltype, 1, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Deriveda &gt; &amp;&#160;</td>
          <td class="paramname"><em>and_visible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh, a camera determine which points are inside of a given 2D screen space polygon <b>culling points based on self-occlusion. </b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>precomputed bounding volume heirarchy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>4 by 4 camera model-view matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>4 by 4 camera projection matrix (perspective or orthoraphic) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>4-vector containing camera viewport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#L by 2 list of 2D polygon vertices (in order) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by 1 list of winding numbers (|W|&gt;0.5 indicates inside) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">and_visible</td><td>#V by 1 list of visibility values (only correct for vertices with |W|&gt;0.5) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa76ba56f1ce1b064b681b9c9d1a258bf" name="aa76ba56f1ce1b064b681b9c9d1a258bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76ba56f1ce1b064b681b9c9d1a258bf">&#9670;&#160;</a></span>screen_space_selection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename Ltype , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::screen_space_selection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::Matrix&lt; Ltype, 1, 2 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh, a camera determine which points are inside of a given 2D screen space polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>4 by 4 camera model-view matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>4 by 4 camera projection matrix (perspective or orthoraphic) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>4-vector containing camera viewport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#L by 2 list of 2D polygon vertices (in order) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by 1 list of winding numbers (|W|&gt;0.5 indicates inside) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad310e7bb193a3ef3e6b0de1b5598799b" name="ad310e7bb193a3ef3e6b0de1b5598799b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad310e7bb193a3ef3e6b0de1b5598799b">&#9670;&#160;</a></span>screen_space_selection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedM , typename DerivedN , typename DerivedO , typename DerivedP , typename DerivedE , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::screen_space_selection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh, a camera determine which points are inside of a given 2D screen space polygon. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>4 by 4 camera model-view matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>4 by 4 camera projection matrix (perspective or orthoraphic) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>4-vector containing camera viewport </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 2 list of screen space polygon vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of screen space edges as indices into rows of P </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by 1 list of winding numbers (|W|&gt;0.5 indicates inside) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac159f8e26c3ca48a403dd1f27d3fd645" name="ac159f8e26c3ca48a403dd1f27d3fd645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac159f8e26c3ca48a403dd1f27d3fd645">&#9670;&#160;</a></span>seam_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedTC , typename DerivedF , typename DerivedFTC , typename Derivedseams , typename Derivedboundaries , typename Derivedfoldovers &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::seam_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedTC &gt; &amp;&#160;</td>
          <td class="paramname"><em>TC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFTC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FTC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedseams &gt; &amp;&#160;</td>
          <td class="paramname"><em>seams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedboundaries &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedfoldovers &gt; &amp;&#160;</td>
          <td class="paramname"><em>foldovers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all UV-space boundaries of a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of positions of the input mesh. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TC</td><td>#TC by 2 list of 2D texture coordinates of the input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triange indices into V representing a manifold-with-boundary triangle mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FTC</td><td>#F by 3 list of indices into TC for each corner </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">seams</td><td>Edges where the forwards and backwards directions have different texture coordinates, as a #seams-by-4 matrix of indices. Each row is organized as [ forward_face_index, forward_face_vertex_index, backwards_face_index, backwards_face_vertex_index ] such that one side of the seam is the edge: F[ seams( i, 0 ), seams( i, 1 ) ], F[ seams( i, 0 ), (seams( i, 1 ) + 1) % 3 ] and the other side is the edge: F[ seams( i, 2 ), seams( i, 3 ) ], F[ seams( i, 2 ), (seams( i, 3 ) + 1) % 3 ] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundaries</td><td>Edges with only one incident triangle, as a #boundaries-by-2 matrix of indices. Each row is organized as [ face_index, face_vertex_index ] such that the edge is: F[ boundaries( i, 0 ), boundaries( i, 1 ) ], F[ boundaries( i, 0 ), (boundaries( i, 1 ) + 1) % 3 ] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">foldovers</td><td>Edges where the two incident triangles fold over each other in UV-space, as a #foldovers-by-4 matrix of indices. Each row is organized as [ forward_face_index, forward_face_vertex_index, backwards_face_index, backwards_face_vertex_index ] such that one side of the foldover is the edge: F[ foldovers( i, 0 ), foldovers( i, 1 ) ], F[ foldovers( i, 0 ), (foldovers( i, 1 ) + 1) % 3 ] and the other side is the edge: F[ foldovers( i, 2 ), foldovers( i, 3 ) ], F[ foldovers( i, 2 ), (foldovers( i, 3 ) + 1) % 3 ] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4c9b0f32a7605d9de8575ba478e0817" name="ab4c9b0f32a7605d9de8575ba478e0817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c9b0f32a7605d9de8575ba478e0817">&#9670;&#160;</a></span>segment_segment_intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedSource , typename DerivedDir &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::segment_segment_intersect </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedSource &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDir &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedSource &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedDir &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether two line segments A,B intersect. </p>
<p>A: p + t*r : t \in [0,1] B: q + u*s : u \in [0,1]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>3-vector origin of segment A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>3-vector direction of segment A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>3-vector origin of segment B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>3-vector direction of segment B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>scalar point of intersection along segment A, t \in [0,1] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>scalar point of intersection along segment B, u \in [0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>precision </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if intersection </dd></dl>

</div>
</div>
<a id="a212b29890b63152674a53444a2003677" name="a212b29890b63152674a53444a2003677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212b29890b63152674a53444a2003677">&#9670;&#160;</a></span>serialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::serialize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2bd82ed66c652d0930f6b460886010b" name="ab2bd82ed66c652d0930f6b460886010b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bd82ed66c652d0930f6b460886010b">&#9670;&#160;</a></span>serialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::serialize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af1e1aa7b19e544f9f8d0e5d2872c1b21" name="af1e1aa7b19e544f9f8d0e5d2872c1b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e1aa7b19e544f9f8d0e5d2872c1b21">&#9670;&#160;</a></span>serialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::serialize </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61617b81f6b89d6692a31f8d34c6d294" name="a61617b81f6b89d6692a31f8d34c6d294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61617b81f6b89d6692a31f8d34c6d294">&#9670;&#160;</a></span>deserialize() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::deserialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8dfda78a1c420b40f80b07d1c3f8b2e" name="aa8dfda78a1c420b40f80b07d1c3f8b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dfda78a1c420b40f80b07d1c3f8b2e">&#9670;&#160;</a></span>deserialize() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::deserialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dd8043bf43851bafaa6e264162eefce" name="a5dd8043bf43851bafaa6e264162eefce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd8043bf43851bafaa6e264162eefce">&#9670;&#160;</a></span>deserialize() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::deserialize </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b7a7a566f0d4a5553987d4d25aedec" name="ad1b7a7a566f0d4a5553987d4d25aedec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b7a7a566f0d4a5553987d4d25aedec">&#9670;&#160;</a></span>serializer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::serializer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dba28198b48a2a0432d5c4e640484e4" name="a8dba28198b48a2a0432d5c4e640484e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dba28198b48a2a0432d5c4e640484e4">&#9670;&#160;</a></span>serializer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::serializer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af28b32c6f34213f61257beff8a2927ca" name="af28b32c6f34213f61257beff8a2927ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28b32c6f34213f61257beff8a2927ca">&#9670;&#160;</a></span>serializer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::serializer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>serialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>objectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9fa51487804e5c3f67e72d4ff8fceb1" name="ad9fa51487804e5c3f67e72d4ff8fceb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fa51487804e5c3f67e72d4ff8fceb1">&#9670;&#160;</a></span>setdiff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedIA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::setdiff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set difference of elements of matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m-long vector of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>n-long vector of indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>(k&lt;=m)-long vector of unique elements appearing in A but not in B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>(k&lt;=m)-long list of indices into A so that C = A(IA) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a925a8ea3a2337a70f7cadc603e7e741e" name="a925a8ea3a2337a70f7cadc603e7e741e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925a8ea3a2337a70f7cadc603e7e741e">&#9670;&#160;</a></span>setunion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedIA , typename DerivedIB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::setunion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIB &gt; &amp;&#160;</td>
          <td class="paramname"><em>IB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of elements of matrices (like matlab's <code>union</code>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m-long vector of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>n-long vector of indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>(k&gt;=m)-long vector of unique elements appearing in A and/or B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>(&lt;k&gt;=m)-long list of indices into A so that C = sort([A(IA);B(IB)]) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IB</td><td>(&lt;k&gt;=m)-long list of indices into B so that C = sort([A(IA);B(IB)]) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bbf23ea4d8a5f3ef6ce4117496fb037" name="a9bbf23ea4d8a5f3ef6ce4117496fb037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbf23ea4d8a5f3ef6ce4117496fb037">&#9670;&#160;</a></span>setxor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedIA , typename DerivedIB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::setxor </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIB &gt; &amp;&#160;</td>
          <td class="paramname"><em>IB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set xor of elements of matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m-long vector of indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>n-long vector of indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>(k&lt;=m)-long vector of unique elements appearing in A but not in B or B but not in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>(&lt;k&lt;=m)-long list of indices into A so that C = sort([A(IA);B(IB)]) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IB</td><td>(&lt;k&lt;=m)-long list of indices into B so that C = sort([A(IA);B(IB)]) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3df5a621d40fe169f2138e39b8b81fec" name="a3df5a621d40fe169f2138e39b8b81fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df5a621d40fe169f2138e39b8b81fec">&#9670;&#160;</a></span>shape_diameter_function() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::shape_diameter_function </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; double(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>shoot_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute shape diamater function per given point. </p>
<p>In the parlence of the paper "Consistent Mesh Partitioning and Skeletonisation using the Shape
Diameter Function" [Shapiro et al. 2008], this implementation uses a 180° cone and a <em>uniform</em> average (<em>not</em> a average weighted by inverse angles).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shoot_ray</td><td>function handle that outputs hits of a given ray against a mesh (embedded in function handles as captured variable/data) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of origin normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of shape diamater function values between bounding box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diagonal</td><td>(perfect sphere) and 0 (perfect needle hook) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a982784dfbf6aae442c5e9b0bc3fdcb53" name="a982784dfbf6aae442c5e9b0bc3fdcb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982784dfbf6aae442c5e9b0bc3fdcb53">&#9670;&#160;</a></span>shape_diameter_function() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , int DIM, typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::shape_diameter_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">igl::AABB</a>&lt; DerivedV, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>aabb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a></td><td>axis-aligned bounding box hierarchy around (V,F) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh face indices into V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46e0193f9523e75a450e14e3cf8179fd" name="a46e0193f9523e75a450e14e3cf8179fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e0193f9523e75a450e14e3cf8179fd">&#9670;&#160;</a></span>shape_diameter_function() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::shape_diameter_function </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a725c756cdeba9b4dbc64ab4a50c50cfa" name="a725c756cdeba9b4dbc64ab4a50c50cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725c756cdeba9b4dbc64ab4a50c50cfa">&#9670;&#160;</a></span>shape_diameter_function() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::shape_diameter_function </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>per_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">per_face</td><td>whether to compute per face (S is #F by 1) or per vertex (S is #V by 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5df9db393a5b6b3865e7a10d9d02a31b" name="a5df9db393a5b6b3865e7a10d9d02a31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df9db393a5b6b3865e7a10d9d02a31b">&#9670;&#160;</a></span>shapeup_identity_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::shapeup_identity_projection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>SC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>projP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This projection does nothing but render points into projP. </p>
<p>Mostly used for "echoing" the global step</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 set of points, either the initial solution, or from previous iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SC</td><td>#Set by 1 cardinalities of sets in S </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#Sets by max(SC) independent sets where the local projection applies. Values beyond column SC(i)-1 in row S(i,:) are "don't care" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projP</td><td>#S by 3*max(SC) in format xyzxyzxyz, where the projected points correspond to each set in S in the same order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value appears to be ignored</dd></dl>
<p><a class="el" href="shapeup_8h.html">include/igl/shapeup.h</a> </p>

</div>
</div>
<a id="aaced06a2a1f184dc5bfe8ff1b87d6d0d" name="aaced06a2a1f184dc5bfe8ff1b87d6d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaced06a2a1f184dc5bfe8ff1b87d6d0d">&#9670;&#160;</a></span>shapeup_regular_face_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::shapeup_regular_face_projection </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>SC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>projP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the projection assumes that the sets are vertices of polygons in cyclic order </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 set of points, either the initial solution, or from previous iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SC</td><td>#Set by 1 cardinalities of sets in S </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#Sets by max(SC) independent sets where the local projection applies. Values beyond column SC(i)-1 in row S(i,:) are "don't care" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">projP</td><td>#S by 3*max(SC) in format xyzxyzxyz, where the projected points correspond to each set in S in the same order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return value appears to be ignored</dd></dl>
<p><a class="el" href="shapeup_8h.html">include/igl/shapeup.h</a> </p>

</div>
</div>
<a id="ad94a2c7d2cbbaf046ff244daa6620895" name="ad94a2c7d2cbbaf046ff244daa6620895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94a2c7d2cbbaf046ff244daa6620895">&#9670;&#160;</a></span>shapeup_precomputation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedSC , typename DerivedS , typename Derivedw &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::shapeup_precomputation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedSC &gt; &amp;&#160;</td>
          <td class="paramname"><em>SC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedSC &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedw &gt; &amp;&#160;</td>
          <td class="paramname"><em>wShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; Derivedw &gt; &amp;&#160;</td>
          <td class="paramname"><em>wSmooth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1ShapeupData.html">ShapeupData</a> &amp;&#160;</td>
          <td class="paramname"><em>sudata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function precomputation the necessary matrices for the ShapeUp process, and prefactorizes them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SC</td><td>#Set by 1 cardinalities of sets in S </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#Sets by max(SC) independent sets where the local projection applies. Values beyond column SC(i)-1 in row S(i,:) are "don't care" </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 the "edges" of the set P; used for the smoothness energy. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>#b by 1 boundary (fixed) vertices from P. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wShape</td><td>#Set by 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wSmooth</td><td>#b by 1 weights for constraints from S and positional constraints (used in the global step) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sudata</td><td>struct <a class="el" href="structigl_1_1ShapeupData.html" title="Parameters and precomputed data for ShapeUp.">ShapeupData</a> the data necessary to solve the system in shapeup_solve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if precomputation was successful, false otherwise</dd></dl>
<p><a class="el" href="shapeup_8h.html">include/igl/shapeup.h</a> </p>

</div>
</div>
<a id="a9b6baf02654fad9293e1560d71475185" name="a9b6baf02654fad9293e1560d71475185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6baf02654fad9293e1560d71475185">&#9670;&#160;</a></span>shapeup_solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedSC , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::shapeup_solve </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;, const Eigen::PlainObjectBase&lt; DerivedSC &gt; &amp;, const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;, Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>local_projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1ShapeupData.html">ShapeupData</a> &amp;&#160;</td>
          <td class="paramname"><em>sudata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>quietIterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function solve the shapeup project optimization. </p>
<p>shapeup_precompute must be called before with the same sudata, or results are unpredictable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by 3 fixed point values corresonding to "b" in sudata </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_projection</td><td>function pointer taking (P,SC,S,projP), where the first three parameters are as defined, and "projP" is the output, as a #S by 3*max(SC) function in format xyzxyzxyz, and where it returns the projected points corresponding to each set in S in the same order. NOTE: the input values in P0 don't need to correspond to prescribed values in bc; the iterations will project them automatically (by design). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P0</td><td>#P by 3 initial solution (point positions) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sudata</td><td>the ShapeUpData structure computed in <a class="el" href="namespaceigl.html#ad94a2c7d2cbbaf046ff244daa6620895" title="This function precomputation the necessary matrices for the ShapeUp process, and prefactorizes them.">shapeup_precomputation()</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quietIterations</td><td>flagging if to output iteration information. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>the solution to the problem, indices corresponding to P0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the solver converged, false otherwise.</dd></dl>
<p><a class="el" href="shapeup_8h.html">include/igl/shapeup.h</a> </p>

</div>
</div>
<a id="a0b1cfc3d745b201faa8129b75d5a3b79" name="a0b1cfc3d745b201faa8129b75d5a3b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1cfc3d745b201faa8129b75d5a3b79">&#9670;&#160;</a></span>sharp_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedSE , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2Etype , typename sharptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sharp_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSE &gt; &amp;&#160;</td>
          <td class="paramname"><em>SE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2Etype &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; sharptype &gt; &amp;&#160;</td>
          <td class="paramname"><em>sharp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mesh, compute sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle mesh indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle</td><td>dihedral angle considered to sharp (e.g., <a class="el" href="namespaceigl.html#af3c65fcb2a063b19e572a9d982b5dcdc" title="π">igl::PI</a> * 0.11) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SE</td><td>#SE by 2 list of edge indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE</td><td>#uE by 2 list of unique undirected edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+#F*c)) is the unique edge corresponding to E.row(f+#F*c) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges, so that E.row(uE2E[i][j]) corresponds to uE.row(i) for all j in 0..uE2E[i].size()-1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sharp</td><td>#SE list of indices into uE revealing sharp undirected edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7002429ac13c0e1d678e1e9d9aea99d8" name="a7002429ac13c0e1d678e1e9d9aea99d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7002429ac13c0e1d678e1e9d9aea99d8">&#9670;&#160;</a></span>sharp_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedSE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sharp_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSE &gt; &amp;&#160;</td>
          <td class="paramname"><em>SE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a571aed34e627db21360984824ccc7838" name="a571aed34e627db21360984824ccc7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571aed34e627db21360984824ccc7838">&#9670;&#160;</a></span>shortest_edge_and_midpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::shortest_edge_and_midpoint </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cost and placement function compatible with <a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>. </p>
<p>The cost of collapsing an edge is its length (prefer to collapse short edges) and the placement strategy for the new vertex is the midpoint of the collapsed edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index into E of edge to be considered for collapse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of faces (ignored) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of edge indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of half-edges indices into E (ignored) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge-face flaps into F (ignored) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge-face opposite corners (ignored) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost</td><td>set to edge length </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>placed point set to edge midpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78da3ad1832aa83542b3dc3a28e1a8e1" name="a78da3ad1832aa83542b3dc3a28e1a8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78da3ad1832aa83542b3dc3a28e1a8e1">&#9670;&#160;</a></span>signed_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedA::Scalar igl::signed_angle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed angle subtended by the oriented 3d triangle (A,B,C) at some point P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>2D position of corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>2D position of corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>2D position of query point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signed angle </dd></dl>

</div>
</div>
<a id="a094f93a7b569504f70587f81f75fd879" name="a094f93a7b569504f70587f81f75fd879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a094f93a7b569504f70587f81f75fd879">&#9670;&#160;</a></span>signed_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a>&#160;</td>
          <td class="paramname"><em>sign_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes signed distance to a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by (2|3) list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by (2|3) list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by ss list of triangle indices, ss should be 3 unless sign_type == SIGNED_DISTANCE_TYPE_UNSIGNED | SIGNED_DISTANCE_TYPE_WINDING_NUMBER </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign_type</td><td>method for computing distance <em>sign</em> S </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_bound</td><td>lower bound of distances needed {std::numeric_limits::min} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upper_bound</td><td>lower bound of distances needed {std::numeric_limits::max} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of smallest signed distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#P list of facet indices corresponding to smallest distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#P by (2|3) list of closest points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>#P by (2|3) list of closest normals (only set if sign_type=SIGNED_DISTANCE_TYPE_PSEUDONORMAL)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9379f935afc42d6fbad6340c07639c54" name="a9379f935afc42d6fbad6340c07639c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9379f935afc42d6fbad6340c07639c54">&#9670;&#160;</a></span>signed_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a>&#160;</td>
          <td class="paramname"><em>sign_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a102279423d1d1b649cdf6a74558883dc" name="a102279423d1d1b649cdf6a74558883dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a102279423d1d1b649cdf6a74558883dc">&#9670;&#160;</a></span>signed_distance_pseudonormal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename Derivedq &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedV::Scalar igl::signed_distance_pseudonormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;&#160;</td>
          <td class="paramname"><em>VN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;&#160;</td>
          <td class="paramname"><em>EN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes signed distance to mesh using pseudonormal with precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree and edge/vertice normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> acceleration tree (see <a class="el" href="AABB_8h.html">AABB.h</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3 list of triangle normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VN</td><td>#V by 3 list of vertex normals (ANGLE WEIGHTING) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EN</td><td>#E by 3 list of edge normals (UNIFORM WEIGHTING) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 mapping edges in F to E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Query point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signed distance to mesh</dd></dl>
<p><a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a> </p>

</div>
</div>
<a id="aead78bb0215bc26bdb1dafabc8366acd" name="aead78bb0215bc26bdb1dafabc8366acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead78bb0215bc26bdb1dafabc8366acd">&#9670;&#160;</a></span>signed_distance_pseudonormal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename DerivedS , typename DerivedI , typename DerivedC , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance_pseudonormal </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;&#160;</td>
          <td class="paramname"><em>VN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;&#160;</td>
          <td class="paramname"><em>EN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a>. </p>

</div>
</div>
<a id="a391b1e9f4f4bc678fac2b8c522ce4331" name="a391b1e9f4f4bc678fac2b8c522ce4331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391b1e9f4f4bc678fac2b8c522ce4331">&#9670;&#160;</a></span>signed_distance_pseudonormal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFN , typename DerivedVN , typename DerivedEN , typename DerivedEMAP , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance_pseudonormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;&#160;</td>
          <td class="paramname"><em>VN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;&#160;</td>
          <td class="paramname"><em>EN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>sqrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>sign </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrd</td><td>squared distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">i</td><td>closest primitive </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>closest point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n</td><td>normal</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a> </p>

</div>
</div>
<a id="a5011d0263ec9b3347530d3d807596671" name="a5011d0263ec9b3347530d3d807596671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5011d0263ec9b3347530d3d807596671">&#9670;&#160;</a></span>signed_distance_pseudonormal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedE , typename DerivedEN , typename DerivedVN , typename Derivedq , typename Scalar , typename Derivedc , typename Derivedn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance_pseudonormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEN &gt; &amp;&#160;</td>
          <td class="paramname"><em>EN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVN &gt; &amp;&#160;</td>
          <td class="paramname"><em>VN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>sqrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedn &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a75576a9807c547b55f797639412650d6" name="a75576a9807c547b55f797639412650d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75576a9807c547b55f797639412650d6">&#9670;&#160;</a></span>signed_distance_winding_number() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedq &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedV::Scalar igl::signed_distance_winding_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1WindingNumberAABB.html">igl::WindingNumberAABB</a>&lt; Derivedq, DerivedV, DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>hier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes signed distance to mesh using winding number with precomputed <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> acceleration tree (see <a class="el" href="copyleft_2cgal_2point__mesh__squared__distance_8h.html">cgal/point_mesh_squared_distance.h</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hier</td><td>Winding number evaluation hierarchy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>Query point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signed distance to mesh</dd></dl>
<p><a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a> </p>

</div>
</div>
<a id="ad184a41c6d66cebef9a4714a2d59326f" name="ad184a41c6d66cebef9a4714a2d59326f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad184a41c6d66cebef9a4714a2d59326f">&#9670;&#160;</a></span>signed_distance_winding_number() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance_winding_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1WindingNumberAABB.html">igl::WindingNumberAABB</a>&lt; Derivedq, DerivedV, DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>hier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>sqrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>sign </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrd</td><td>squared distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>closest point and primitve <a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af25f0719d3f6108b4917e1511a4941f5" name="af25f0719d3f6108b4917e1511a4941f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25f0719d3f6108b4917e1511a4941f5">&#9670;&#160;</a></span>signed_distance_winding_number() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedq , typename Scalar , typename Derivedc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance_winding_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>sqrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedc &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a88918723d512e80456d10a043fa25177" name="a88918723d512e80456d10a043fa25177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88918723d512e80456d10a043fa25177">&#9670;&#160;</a></span>signed_distance_fast_winding_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::signed_distance_fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const igl::FastWindingNumberBVH &amp;&#160;</td>
          <td class="paramname"><em>fwn_bvh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates signed distance at query points P, using fast winding number for sign. </p>
<h4><a class="anchor" id="autotoc_md34"></a>
Usage:</h4>
<p>VectorXd S; <br  />
 VectorXd V, P; //where V is mesh vertices, P are query points VectorXi F; <br  />
 igl::FastWindingNumberBVH fwn_bvh; <a class="el" href="namespaceigl.html#af9a50987fefc0df065fb3e2cde90c92e" title="Generate the precomputation for the fast winding number for point data [Barill et.">igl::fast_winding_number</a>(V.cast&lt;float&gt;(), F, 2, fwn_bvh); igl::signed_distance_fast_winding_number(P,V,F,tree,fwn_bvh,S);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> acceleration tree (see <a class="el" href="AABB_8h.html">AABB.h</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bvh</td><td>fast winding precomputation (see Fast_Winding_Number.h) <br  />
 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of signed distances of each point in P</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a> </p>

</div>
</div>
<a id="a0dabf308e8466b0ec192b798fc538eb4" name="a0dabf308e8466b0ec192b798fc538eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dabf308e8466b0ec192b798fc538eb4">&#9670;&#160;</a></span>signed_distance_fast_winding_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedq , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedV::Scalar igl::signed_distance_fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1AABB.html">AABB</a>&lt; DerivedV, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const igl::FastWindingNumberBVH &amp;&#160;</td>
          <td class="paramname"><em>fwn_bvh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates signed distance at query point q, using fast winding number for sign. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> acceleration tree (see <a class="el" href="AABB_8h.html">AABB.h</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bvh</td><td>fast winding precomputation (see Fast_Winding_Number.h) <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>1 by 3 list of query point positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of signed distances of each point in P</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="signed__distance_8h.html">include/igl/signed_distance.h</a> </p>

</div>
</div>
<a id="a4d3b37a4f86172d30f35d330aed1e7fe" name="a4d3b37a4f86172d30f35d330aed1e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3b37a4f86172d30f35d330aed1e7fe">&#9670;&#160;</a></span>simplify_polyhedron()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::simplify_polyhedron </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>OV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>OF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify a polyhedron represented as a triangle mesh (OV,OF) by collapsing any edge that doesn't contribute to defining surface's pointset. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This <em>would</em> also make sense for open and non-manifold meshes, but the current implementation only works with closed manifold surfaces with well defined triangle normals.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">OV</td><td>#OV by 3 list of input mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">OF</td><td>#OF by 3 list of input mesh triangle indices into OV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of output mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of input mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F list of indices into OF of birth parents </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a547a8704200d3af48fe92105c15a32ad" name="a547a8704200d3af48fe92105c15a32ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547a8704200d3af48fe92105c15a32ad">&#9670;&#160;</a></span>slice() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TX , typename TY , typename DerivedR , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; TX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; TY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negative integer indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>list of row indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>list of column indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>#R by #C matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#acb30d6061d773254628256682b88b427" title="Act like the matlab X(row_mask,col_mask) operator, where row_mask, col_mask are non-negative integer ...">slice_mask</a>, <a class="el" href="namespaceigl.html#ab893d0a94d4eb6a1c5422e7cfe368daf" title="Act like the matlab Y(row_indices,col_indices) = X.">slice_into</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>See also Eigen's unaryExpr <a href="https://stackoverflow.com/a/49411587/148668">https://stackoverflow.com/a/49411587/148668</a> </dd></dl>

</div>
</div>
<a id="ae747d042c40e074264e161b49906216d" name="ae747d042c40e074264e161b49906216d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae747d042c40e074264e161b49906216d">&#9670;&#160;</a></span>slice() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatX , typename DerivedR , typename MatY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice </td>
          <td>(</td>
          <td class="paramtype">const MatX &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatY &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper to only slice in one direction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension to slice in 1 or 2, dim=1 --&gt; X(R,:), dim=2 --&gt; X(:,R)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For now this is just a cheap wrapper. </dd></dl>

</div>
</div>
<a id="aa05264f934b9cecbac042ef69735b74b" name="aa05264f934b9cecbac042ef69735b74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05264f934b9cecbac042ef69735b74b">&#9670;&#160;</a></span>slice() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aae8c4cf15b6f5f8cc16da9405b96be59" name="aae8c4cf15b6f5f8cc16da9405b96be59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8c4cf15b6f5f8cc16da9405b96be59">&#9670;&#160;</a></span>slice() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Vector version  </p>

</div>
</div>
<a id="a90268d9fb8c64692427036793191a8b7" name="a90268d9fb8c64692427036793191a8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90268d9fb8c64692427036793191a8b7">&#9670;&#160;</a></span>slice() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedR , typename DerivedC , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>See <a class="el" href="slice_8h.html">slice.h</a> for more details </p>

</div>
</div>
<a id="a86abeffa3ef136e9e35057e526618dc8" name="a86abeffa3ef136e9e35057e526618dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86abeffa3ef136e9e35057e526618dc8">&#9670;&#160;</a></span>slice() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedX igl::slice </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>VectorXi Y = slice(X,R); This templating is bad because the return type might not have the same size as <code>DerivedX</code>. This will probably only work if DerivedX has Dynamic as it's non-trivial sizes or if the number of rows in R happens to equal the number of rows in <code>DerivedX</code>. </p>

</div>
</div>
<a id="aa5271870d0385781c2236145ee9c3897" name="aa5271870d0385781c2236145ee9c3897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5271870d0385781c2236145ee9c3897">&#9670;&#160;</a></span>slice() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedX igl::slice </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a473da3d5636834fa6b0510d7a2f97628" name="a473da3d5636834fa6b0510d7a2f97628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473da3d5636834fa6b0510d7a2f97628">&#9670;&#160;</a></span>slice_cached_precompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TX , typename TY , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_cached_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; TX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; int, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; TY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negative integer indices. </p>
<p>This is a fast version of <a class="el" href="namespaceigl.html#a547a8704200d3af48fe92105c15a32ad" title="Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negat...">igl::slice</a> that can analyze and store the sparsity structure. It is slower at the irst evaluation (slice_cached_precompute), but faster on the subsequent ones.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>list of row indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>list of column indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>Temporary data used by slice_cached to repeat this operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>#R by #C matrix</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md35"></a>
Example</h4>
<pre class="fragment">// Construct and slice up Laplacian
SparseMatrix&lt;double&gt; L,L_sliced;
igl::cotmatrix(V,F,L);
// Normal igl::slice call
igl::slice(L,in,in,L_in_in);
…
// Fast version
static VectorXi data; // static or saved in a global state
if (data.size() == 0)
  igl::slice_cached_precompute(L,in,in,data,L_sliced);
else
  igl::slice_cached(L,data,L_sliced);
</pre><p> <a class="el" href="slice__cached_8h.html">include/igl/slice_cached.h</a> </p>

</div>
</div>
<a id="a192c36479a5f74cfc02aaddd3afa4fea" name="a192c36479a5f74cfc02aaddd3afa4fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192c36479a5f74cfc02aaddd3afa4fea">&#9670;&#160;</a></span>slice_cached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TX , typename TY , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_cached </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; TX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; TY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slice X by cached C,R indices into Y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Temporary data used by slice_cached to repeat this operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>#R by #C matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab893d0a94d4eb6a1c5422e7cfe368daf" name="ab893d0a94d4eb6a1c5422e7cfe368daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab893d0a94d4eb6a1c5422e7cfe368daf">&#9670;&#160;</a></span>slice_into() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DerivedR , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_into </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like the matlab Y(row_indices,col_indices) = X. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>xm by xn rhs matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>list of row indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>list of column indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Y</td><td>ym by yn lhs matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>ym by yn lhs matrix, same as input but Y(R,C) = X</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a547a8704200d3af48fe92105c15a32ad" title="Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negat...">slice</a> </dd></dl>

</div>
</div>
<a id="a185ee703c7cf8760af368bcb0861d37f" name="a185ee703c7cf8760af368bcb0861d37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185ee703c7cf8760af368bcb0861d37f">&#9670;&#160;</a></span>slice_into() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatX , typename MatY , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_into </td>
          <td>(</td>
          <td class="paramtype">const MatX &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatY &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper to only slice in one direction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[int]</td><td>dim dimension to slice in 1 or 2, dim=1 --&gt; X(R,:), dim=2 --&gt; X(:,R)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For now this is just a cheap wrapper. </dd></dl>

</div>
</div>
<a id="afce428bb768059c8d6f9563873f8e730" name="afce428bb768059c8d6f9563873f8e730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce428bb768059c8d6f9563873f8e730">&#9670;&#160;</a></span>slice_into() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedR , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_into </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>See <a class="el" href="slice_8h.html">slice.h</a> for more details </p>

</div>
</div>
<a id="aa29b762b3094e33fd5167ca196de49ce" name="aa29b762b3094e33fd5167ca196de49ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29b762b3094e33fd5167ca196de49ce">&#9670;&#160;</a></span>slice_into() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedR , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_into </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Vector version </p>

</div>
</div>
<a id="acb30d6061d773254628256682b88b427" name="acb30d6061d773254628256682b88b427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb30d6061d773254628256682b88b427">&#9670;&#160;</a></span>slice_mask() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename YType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_mask </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; XType &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; YType &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like the matlab X(row_mask,col_mask) operator, where row_mask, col_mask are non-negative integer indices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>m list of row bools </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>n list of column bools </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>#trues-in-R by #trues-in-C matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a547a8704200d3af48fe92105c15a32ad" title="Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negat...">slice</a> </dd></dl>

</div>
</div>
<a id="a6770877236349590d6b4bbc2a6f616ad" name="a6770877236349590d6b4bbc2a6f616ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6770877236349590d6b4bbc2a6f616ad">&#9670;&#160;</a></span>slice_mask() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename YType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_mask </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; XType &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; YType &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper to only slice in one direction</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[int]</td><td>dim dimension to slice in 1 or 2, dim=1 --&gt; X(R,:), dim=2 --&gt; X(:,R) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef569f1ee0e9cd71c2cfabd1e27e2f40" name="aef569f1ee0e9cd71c2cfabd1e27e2f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef569f1ee0e9cd71c2cfabd1e27e2f40">&#9670;&#160;</a></span>slice_mask() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_mask </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>See <a class="el" href="slice_8h.html">slice.h</a> for more details </p>

</div>
</div>
<a id="ab448e84d310f37a2cffd09d50faad326" name="ab448e84d310f37a2cffd09d50faad326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab448e84d310f37a2cffd09d50faad326">&#9670;&#160;</a></span>slice_mask() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_mask </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe884ab3e3a80bcea135959a5b9aa831" name="afe884ab3e3a80bcea135959a5b9aa831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe884ab3e3a80bcea135959a5b9aa831">&#9670;&#160;</a></span>slice_mask() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedX igl::slice_mask </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This templating is bad because the return type might not have the same size as <code>DerivedX</code>. This will probably only work if DerivedX has Dynamic as it's non-trivial sizes or if the number of rows in R happens to equal the number of rows in <code>DerivedX</code>. </dd></dl>

</div>
</div>
<a id="ae4dd189219e52c3496a80f36b82cbbce" name="ae4dd189219e52c3496a80f36b82cbbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4dd189219e52c3496a80f36b82cbbce">&#9670;&#160;</a></span>slice_mask() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedX igl::slice_mask </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Array&lt; bool, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af8a1c0b05598d819b78e57f2525f5497" name="af8a1c0b05598d819b78e57f2525f5497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a1c0b05598d819b78e57f2525f5497">&#9670;&#160;</a></span>slice_sorted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TX , typename TY , typename DerivedR , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::slice_sorted </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; TX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; TY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negative integer indices. </p>
<p>This version is about 2x faster than <a class="el" href="namespaceigl.html#a547a8704200d3af48fe92105c15a32ad" title="Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negat...">igl::slice</a>, but it assumes that the indices to slice with are already sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>list of row indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>list of column indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>#R by #C matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a547a8704200d3af48fe92105c15a32ad" title="Act like the matlab X(row_indices,col_indices) operator, where row_indices, col_indices are non-negat...">slice</a> </dd></dl>

</div>
</div>
<a id="a4b29382a965c510055a154aac6ecde4e" name="a4b29382a965c510055a154aac6ecde4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b29382a965c510055a154aac6ecde4e">&#9670;&#160;</a></span>slim_precompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::slim_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structigl_1_1SLIMData.html">SLIMData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">MappingEnergyType</a>&#160;</td>
          <td class="paramname"><em>slim_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>soft_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute necessary information to start using SLIM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3/3 list of mesh faces (triangles/tets) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_init</td><td>#V by 3 list of initial mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Precomputation data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slim_energy</td><td>Energy to minimize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>list of boundary indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bc</td><td>#b by dim list of boundary conditions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">soft_p</td><td>Soft penalty factor (can be zero)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="slim_8h.html">include/igl/slim.h</a> </p>

</div>
</div>
<a id="a5651f5d9a88f7dc131b6dd3b99f31fdf" name="a5651f5d9a88f7dc131b6dd3b99f31fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5651f5d9a88f7dc131b6dd3b99f31fdf">&#9670;&#160;</a></span>slim_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd igl::slim_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structigl_1_1SLIMData.html">SLIMData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iter_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run iter_num iterations of SLIM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">data</td><td>Precomputation data structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_num</td><td>Number of iterations to run </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#V by dim list of mesh vertex positions</dd></dl>
<p><a class="el" href="slim_8h.html">include/igl/slim.h</a> </p>

</div>
</div>
<a id="a02c86d444aaf4ab498a1466a59775059" name="a02c86d444aaf4ab498a1466a59775059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c86d444aaf4ab498a1466a59775059">&#9670;&#160;</a></span>slim_update_weights_and_closest_rotations_with_jacobians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::slim_update_weights_and_closest_rotations_with_jacobians </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Ji</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a79904ddf7fe8d79169b339cf43f9e739">igl::MappingEnergyType</a>&#160;</td>
          <td class="paramname"><em>slim_energy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exp_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Ri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal Routine. </p>
<p>Exposed for Integration with SCAF</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Ji</td><td>?? by ?? list of Jacobians?? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slim_energy</td><td>Energy to minimize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exp_factor</td><td>??? used for exponential energies, ignored otherwise </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>?? by ?? list of weights?? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ri</td><td>?? by ?? list of rotations??</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="slim_8h.html">include/igl/slim.h</a> </p>

</div>
</div>
<a id="ac1a2368c134ab7daeb5cfb40b5a0e639" name="ac1a2368c134ab7daeb5cfb40b5a0e639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a2368c134ab7daeb5cfb40b5a0e639">&#9670;&#160;</a></span>slim_buildA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::slim_buildA </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>Dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Triplet&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>IJV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Undocumented function related to SLIM optimization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Dx</td><td>?? by ?? matrix to compute of x derivatives? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dy</td><td>?? by ?? matrix to compute of y derivatives? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Dz</td><td>?? bz ?? matrix to compute of z derivatives? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>?? by ?? list of weights?? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IJV</td><td>?? by ?? list of triplets to some A matrix?? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef5e220e449787733ece4abbc94f419a" name="aef5e220e449787733ece4abbc94f419a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5e220e449787733ece4abbc94f419a">&#9670;&#160;</a></span>smooth_corner_adjacency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::smooth_corner_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>corner_threshold_radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>CI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the corner-to-face adjacency relationship that can be used for computing crease-aware per-corner normals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle mesh indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">corner_threshold_radians</td><td>dihedral angle considered non-smooth (in radians) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CI</td><td>#CI list of face neighbors as indices into rows of F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CC</td><td>3*#F+1 list of cumulative sizes so that CC(i*3+j+1) - CC(i*3+j) is the number of faces considered smoothly incident on corner at F(i,j) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eedd51ba703a9667e0bc21d6de863d8" name="a6eedd51ba703a9667e0bc21d6de863d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eedd51ba703a9667e0bc21d6de863d8">&#9670;&#160;</a></span>smooth_corner_adjacency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::smooth_corner_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>FV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>CI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>CC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the effective corner-to-face adjacency relationship implied by a set of indexed vertex positions (FV) and normals (FV) (e.g., those read in from a .obj file). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FV</td><td>#F by 3 list of triangle mesh indices into rows of some V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3 list of triangle mesh indices into rows of some N </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CI</td><td>#CI list of face neighbors as indices into rows of F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CC</td><td>3*#F+1 list of cumulative sizes so that CC(i*3+j+1) - CC(i*3+j) is the number of faces considered smoothly incident on corner at F(i,j) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c65a87d0656aad1a67568ce7fe62505" name="a3c65a87d0656aad1a67568ce7fe62505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c65a87d0656aad1a67568ce7fe62505">&#9670;&#160;</a></span>snap_points() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD , typename DerivedVI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::snap_points </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedminD &gt; &amp;&#160;</td>
          <td class="paramname"><em>minD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>VI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snap list of points C to closest of another list of points V. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C by dim list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of data point positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#C list of indices into V of closest points to C </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minD</td><td>#C list of squared (^p) distances to closest points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VI</td><td>#C by dim list of new point positions, VI = V(I,:) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0456e1ef831df9943ee2f062e8119655" name="a0456e1ef831df9943ee2f062e8119655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0456e1ef831df9943ee2f062e8119655">&#9670;&#160;</a></span>snap_points() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC , typename DerivedV , typename DerivedI , typename DerivedminD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::snap_points </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedminD &gt; &amp;&#160;</td>
          <td class="paramname"><em>minD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa76c38e927f8da17319f7809593f78b0" name="aa76c38e927f8da17319f7809593f78b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76c38e927f8da17319f7809593f78b0">&#9670;&#160;</a></span>snap_points() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC , typename DerivedV , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::snap_points </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a2773ac49873440379d546be16bf756e8" name="a2773ac49873440379d546be16bf756e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2773ac49873440379d546be16bf756e8">&#9670;&#160;</a></span>snap_to_canonical_view_quat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalarq , typename Scalars &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::snap_to_canonical_view_quat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalarq &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Quaternion&lt; Scalars &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snap the quaternion q to the nearest canonical view quaternion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>quaternion to be snapped (also see Outputs) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>(optional) threshold: 1.0 --&gt; snap any input 0.5 --&gt; snap inputs somewhat close to canonical views 0.0 --&gt; snap no input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>quaternion possibly set to nearest canonical view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only if q was snapped to the nearest canonical view </dd></dl>

</div>
</div>
<a id="a972274b2ed4c85251899428421619ad5" name="a972274b2ed4c85251899428421619ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a972274b2ed4c85251899428421619ad5">&#9670;&#160;</a></span>snap_to_canonical_view_quat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::snap_to_canonical_view_quat </td>
          <td>(</td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af6de4ebdb7f531d96fb57a566e0d121c" name="af6de4ebdb7f531d96fb57a566e0d121c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6de4ebdb7f531d96fb57a566e0d121c">&#9670;&#160;</a></span>snap_to_fixed_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Qtype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::snap_to_fixed_up </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Quaternion&lt; Qtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Quaternion&lt; Qtype &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snap an arbitrary rotation to a rotation resulting from a rotation about the y-axis then the x-axis (maintaining fixed up like two_axis_valuator_fixed_up.) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>General rotation as quaternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>the resulting rotation (as quaternion)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#aaef42c6f3251414c7485b4d1433a54e4" title="Applies a two-axis valuator drag rotation (as seen in Maya/Studio max) to a given rotation.">two_axis_valuator_fixed_up</a> </dd></dl>

</div>
</div>
<a id="ac42833fb0899d755feb35dbf0db24410" name="ac42833fb0899d755feb35dbf0db24410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42833fb0899d755feb35dbf0db24410">&#9670;&#160;</a></span>solid_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedA::Scalar igl::solid_angle </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed solid angle subtended by the oriented 3d triangle (A,B,C) at some point P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>3D position of corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>3D position of corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>3D position of corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>3D position of query point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>signed solid angle </dd></dl>

</div>
</div>
<a id="aea54a5804527aa194785e403870ba7db" name="aea54a5804527aa194785e403870ba7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea54a5804527aa194785e403870ba7db">&#9670;&#160;</a></span>sort() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;&#160;</td>
          <td class="paramname"><em>IX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the elements of a matrix X along a given dimension like matlabs sort function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedX</td><td>derived scalar type, e.g. MatrixXi or MatrixXd </td></tr>
    <tr><td class="paramname">DerivedIX</td><td>derived integer type, e.g. MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix whose entries are to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimensional along which to sort: 1 sort each column (matlab default) 2 sort each row </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascending</td><td>sort ascending (true, matlab default) or descending (false) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n matrix whose entries are sorted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IX</td><td>m by n matrix of indices so that if dim = 1, then in matlab notation for j = 1:n, Y(:,j) = X(I(:,j),j); end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8c55dff1cae23221b5570ad7f9c194" name="a1b8c55dff1cae23221b5570ad7f9c194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8c55dff1cae23221b5570ad7f9c194">&#9670;&#160;</a></span>sort() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4dd6daca2b874edaf27301a111ed2401" name="a4dd6daca2b874edaf27301a111ed2401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd6daca2b874edaf27301a111ed2401">&#9670;&#160;</a></span>sort_new()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_new </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;&#160;</td>
          <td class="paramname"><em>IX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="section note"><dt>Note</dt><dd>This should be renamed to something like sort_small because it is only faster if size(X,dim) is small. </dd></dl>

</div>
</div>
<a id="a61ad3bd047a94be9c5ad7bf8890dd798" name="a61ad3bd047a94be9c5ad7bf8890dd798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ad3bd047a94be9c5ad7bf8890dd798">&#9670;&#160;</a></span>sort2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort2 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;&#160;</td>
          <td class="paramname"><em>IX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Special case if size(X,dim) == 2 </p>

</div>
</div>
<a id="a6bfeee50844cf4deac8ad3b473407428" name="a6bfeee50844cf4deac8ad3b473407428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfeee50844cf4deac8ad3b473407428">&#9670;&#160;</a></span>sort3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIX &gt; &amp;&#160;</td>
          <td class="paramname"><em>IX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Special case if size(X,dim) == 3 </p>

</div>
</div>
<a id="a5ee021e4c406d792e624a3ddbdc5145d" name="a5ee021e4c406d792e624a3ddbdc5145d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee021e4c406d792e624a3ddbdc5145d">&#9670;&#160;</a></span>sort() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like matlab's [Y,I] = SORT(X) for std library vectors. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a class that implements the '&lt;' comparator operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unsorted</td><td>unsorted vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascending</td><td>sort ascending (true, matlab default) or descending (false) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sorted</td><td>sorted vector, allowed to be same as unsorted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index_map</td><td>an index map such that sorted[i] = unsorted[index_map[i]] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af203a35e46d72618e788c9c02e5f2e0c" name="af203a35e46d72618e788c9c02e5f2e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af203a35e46d72618e788c9c02e5f2e0c">&#9670;&#160;</a></span>sort_angles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedM , typename DerivedR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_angles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort angles in ascending order in a numerically robust way. </p>
<p>Instead of computing angles using atan2(y, x), sort directly on (y, x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>m by n matrix of scalars. (n &gt;= 2). Assuming the first column of M contains values for y, and the second column is x. Using the rest of the columns as tie-breaker. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">R</td><td>an array of m indices. M.row(R[i]) contains the i-th smallest angle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c0a98c41282a4c612da5ad971a4a676" name="a1c0a98c41282a4c612da5ad971a4a676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0a98c41282a4c612da5ad971a4a676">&#9670;&#160;</a></span>sort_triangles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedMV , typename DerivedP , typename DerivedFF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_triangles </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedMV &gt; &amp;&#160;</td>
          <td class="paramname"><em>MV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort triangles by depth (from back to front) using a painter's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by <b>4</b> list of homogeneous vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MV</td><td>4 by 4 model view matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>4 by 4 projection matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#F by 3 list of sorted triangles indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#F list of sorted indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d31a3df6fc3ab3d769b240cc8ca2f5" name="ab6d31a3df6fc3ab3d769b240cc8ca2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d31a3df6fc3ab3d769b240cc8ca2f5">&#9670;&#160;</a></span>sort_vectors_ccw() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_vectors_ccw </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a set of N coplanar vectors in a ccw order, and returns their order. </p>
<p>Optionally it also returns a copy of the ordered vector set, or the indices, in the original unordered set, of the vectors in the ordered set (called here the "inverse" set of indices).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>1 by 3N row vector of the vectors to be sorted, stacked horizontally </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#1 by 3 normal of the plane where the vectors lie </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">order</td><td>N by 1 order of the vectors (indices of the unordered vectors into the ordered vector set) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sorted</td><td>1 by 3N row vector of the ordered vectors, stacked horizontally </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inv_order</td><td>N by 1 "inverse" order of the vectors (the indices of the ordered vectors into the unordered vector set) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad12fb37ec629691009ae42d926adcb02" name="ad12fb37ec629691009ae42d926adcb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12fb37ec629691009ae42d926adcb02">&#9670;&#160;</a></span>sort_vectors_ccw() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_vectors_ccw </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9b4fdcbef0f11737a037711a7ebf833c" name="a9b4fdcbef0f11737a037711a7ebf833c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4fdcbef0f11737a037711a7ebf833c">&#9670;&#160;</a></span>sort_vectors_ccw() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_vectors_ccw </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a08c139732fd7bcd7379c91befbb35775" name="a08c139732fd7bcd7379c91befbb35775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c139732fd7bcd7379c91befbb35775">&#9670;&#160;</a></span>sort_vectors_ccw() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sort_vectors_ccw </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af8ac99e9c2a051fdbc1b1c132e8102f8" name="af8ac99e9c2a051fdbc1b1c132e8102f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ac99e9c2a051fdbc1b1c132e8102f8">&#9670;&#160;</a></span>sortrows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sortrows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like matlab's [Y,I] = sortrows(X) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedX</td><td>derived scalar type, e.g. MatrixXi or MatrixXd </td></tr>
    <tr><td class="paramname">DerivedI</td><td>derived integer type, e.g. MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n matrix whose entries are to be sorted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascending</td><td>sort ascending (true, matlab default) or descending (false) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>m by n matrix whose entries are sorted (<b>should not</b> be same reference as X) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>m list of indices so that Y = X(I,:); </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f276cc65a7f7d0a0929e983028a3169" name="a4f276cc65a7f7d0a0929e983028a3169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f276cc65a7f7d0a0929e983028a3169">&#9670;&#160;</a></span>sortrows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sortrows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedY &gt; &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aa0031015feb34d6398264ceac841bc0c" name="aa0031015feb34d6398264ceac841bc0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0031015feb34d6398264ceac841bc0c">&#9670;&#160;</a></span>sparse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexVectorI , class IndexVectorJ , class ValueVector , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse </td>
          <td>(</td>
          <td class="paramtype">const IndexVectorI &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexVectorJ &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueVector &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a sparse matrix from list of indices and values (I,J,V), functions like the sparse function in matlab. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexVector</td><td>list of indices, value should be non-negative and should expect to be cast to an index. Must implement operator(i) to retrieve ith element </td></tr>
    <tr><td class="paramname">ValueVector</td><td>list of values, value should be expect to be cast to type T. Must implement operator(i) to retrieve ith element </td></tr>
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>nnz vector of row indices of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>nnz vector of column indices of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>nnz vector of non-zeros entries in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of cols </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>m by n matrix of type T whose entries are to be found</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55e6cc04971d8a30de15d18272221aa9" name="a55e6cc04971d8a30de15d18272221aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e6cc04971d8a30de15d18272221aa9">&#9670;&#160;</a></span>sparse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexVector , class ValueVector , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse </td>
          <td>(</td>
          <td class="paramtype">const IndexVector &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexVector &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueVector &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1af79e7e819b442592de8d5db2e5829c" name="a1af79e7e819b442592de8d5db2e5829c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af79e7e819b442592de8d5db2e5829c">&#9670;&#160;</a></span>sparse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedD , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a full, dense matrix to a sparse one. </p>
<dl class="section note"><dt>Note</dt><dd>Just use .sparseView()</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>m by n full, dense matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>m by n sparse matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee96f9beefd8dd12066e82a32b314855" name="aee96f9beefd8dd12066e82a32b314855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee96f9beefd8dd12066e82a32b314855">&#9670;&#160;</a></span>sparse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::SparseMatrix&lt; typename DerivedD::Scalar &gt; igl::sparse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac623ce43ac510a2b3374c791984d819c" name="ac623ce43ac510a2b3374c791984d819c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac623ce43ac510a2b3374c791984d819c">&#9670;&#160;</a></span>sparse_cached_precompute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedI , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse_cached_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a sparse matrix from list of indices and values (I,J,V), similarly to the sparse function in matlab. </p>
<p>Divides the construction in two phases, one for fixing the sparsity pattern, and one to populate it with values. Compared to <a class="el" href="namespaceigl.html#aa0031015feb34d6398264ceac841bc0c" title="Build a sparse matrix from list of indices and values (I,J,V), functions like the sparse function in ...">igl::sparse</a>, this version is slower for the first time (since it requires a precomputation), but faster to the subsequent evaluations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>nnz vector of row indices of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>nnz vector of column indices of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>?? vector of ?? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">X</td><td>m by n matrix of type T whose entries are to be found</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md36"></a>
Example:</h4>
<pre class="fragment">  Eigen::SparseMatrix&lt;double&gt; A;
  std::vector&lt;Eigen::Triplet&lt;double&gt; &gt; IJV;
  slim_buildA(IJV);
  if (A.rows() == 0)
  {
    A = Eigen::SparseMatrix&lt;double&gt;(rows,cols);
    igl::sparse_cached_precompute(IJV,A_data,A);
  }
  else
    igl::sparse_cached(IJV,A_data,A);
</pre> 
</div>
</div>
<a id="a652603bae4d621913f8679441ac6d771" name="a652603bae4d621913f8679441ac6d771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652603bae4d621913f8679441ac6d771">&#9670;&#160;</a></span>sparse_cached_precompute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse_cached_precompute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triplets</td><td>nnz vector of triplets of non zeros entries in X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abff00fedf6ea99985f251a964eb2fe21" name="abff00fedf6ea99985f251a964eb2fe21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff00fedf6ea99985f251a964eb2fe21">&#9670;&#160;</a></span>sparse_cached() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse_cached </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::Triplet&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>triplets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a sparse matrix from cached list of data and values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triplets</td><td>nnz vector of triplets of non zeros entries in X </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>?? vector of ?? </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">X</td><td>m by n matrix of type T whose entries are to be found <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb2f3d6b20dcda22b4415935b0b4a250" name="adb2f3d6b20dcda22b4415935b0b4a250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2f3d6b20dcda22b4415935b0b4a250">&#9670;&#160;</a></span>sparse_cached() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse_cached </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V list of values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4c369ebc42c4e76553730c636d7967d" name="ae4c369ebc42c4e76553730c636d7967d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c369ebc42c4e76553730c636d7967d">&#9670;&#160;</a></span>sparse_voxel_grid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP0 , typename Func , typename DerivedS , typename DerivedV , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sparse_voxel_grid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Func &amp;&#160;</td>
          <td class="paramname"><em>scalarFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>expected_number_of_cubes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>CS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>CV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>CI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point, p0, on an isosurface, construct a shell of epsilon sized cubes surrounding the surface. </p>
<p>These cubes can be used as the input to marching cubes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p0</td><td>A 3D point on the isosurface surface defined by scalarFunc(x) = 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scalarFunc</td><td>A scalar function from R^3 to R &ndash; points which map to 0 lie on the surface, points which are negative lie inside the surface, and points which are positive lie outside the surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>The edge length of the cubes surrounding the surface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expected_number_of_cubes</td><td>This pre-allocates internal data structures to speed things up </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CS</td><td>#CV by 1 list of scalar values at the cube vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CV</td><td>#CV by 3 list of cube vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">CI</td><td>#CI by 8 list of cube indices into rows of CS and CV. Each row represents 8 corners of cube in y-x-z binary counting order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7bca403061433327f7ae13005e190a6" name="ab7bca403061433327f7ae13005e190a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7bca403061433327f7ae13005e190a6">&#9670;&#160;</a></span>speye() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::speye </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an m by n sparse identity matrix like matlab's speye function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>number of rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of cols </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>m by n sparse matrix with 1's on the main diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99a506e0e604f1618c56560c1c3238a7" name="a99a506e0e604f1618c56560c1c3238a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a506e0e604f1618c56560c1c3238a7">&#9670;&#160;</a></span>speye() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::speye </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>m = n </p>

</div>
</div>
<a id="ad087e73516c7afa1370f7b24c1132a36" name="ad087e73516c7afa1370f7b24c1132a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad087e73516c7afa1370f7b24c1132a36">&#9670;&#160;</a></span>split_nonmanifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedSF , typename DerivedSVI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::split_nonmanifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>SVI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a non-manifold (or non-orientable) mesh into a orientable manifold mesh possibly with more connected components and geometrically duplicate vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into rows of some V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SF</td><td>#F by 3 list of mesh triangle indices into rows of a new vertex list SV = V(SVI,:) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SVI</td><td>#SV list of indices into V identifying vertex positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6330810b20e78a8af65cb151d537d6d" name="af6330810b20e78a8af65cb151d537d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6330810b20e78a8af65cb151d537d6d">&#9670;&#160;</a></span>split_nonmanifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedSV , typename DerivedSF , typename DerivedSVI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::split_nonmanifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSV &gt; &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSF &gt; &amp;&#160;</td>
          <td class="paramname"><em>SF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedSVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>SVI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim explicit list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SV</td><td>#SV by dim explicit list of vertex positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45669ed07ec4ce3c9d9af3c976246bda" name="a45669ed07ec4ce3c9d9af3c976246bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45669ed07ec4ce3c9d9af3c976246bda">&#9670;&#160;</a></span>squared_edge_lengths()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::squared_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a list of squared lengths of edges opposite each index in a face (triangle/tet) list. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived from vertex positions matrix type: i.e. MatrixXd </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived from face indices matrix type: i.e. MatrixXi </td></tr>
    <tr><td class="paramname">DerivedL</td><td>derived from edge lengths matrix type: i.e. MatrixXd </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>eigen matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by (2|3|4) list of mesh edges, triangles or tets </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>#F by {1|3|6} list of edge lengths squared for edges, column of lengths for triangles, columns correspond to edges [1,2],[2,0],[0,1] for tets, columns correspond to edges [3 0],[3 1],[3 2],[1 2],[2 0],[0 1] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f4750b8f143bb05a426374c4c65b92a" name="a8f4750b8f143bb05a426374c4c65b92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4750b8f143bb05a426374c4c65b92a">&#9670;&#160;</a></span>stdin_to_temp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::stdin_to_temp </td>
          <td>(</td>
          <td class="paramtype">FILE **&#160;</td>
          <td class="paramname"><em>temp_file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write stdin/piped input to a temporary file which can than be preprocessed as it is (a normal file). </p>
<p>This is often useful if you want to process stdin/piped with library functions that expect to be able to fseek(), rewind() etc..</p>
<p>If your application is not using fseek(), rewind(), etc. but just reading from stdin then this will likely cause a bottle neck as it defeats the whole purpose of piping.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">temp_file</td><td>pointer to temp file pointer, rewound to beginning of file so its ready to be read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only if no errors were found</dd></dl>
<dl class="section note"><dt>Note</dt><dd>caller is responsible for closing the file (tmpfile() automatically unlinks the file so there is no need to remove/delete/unlink the file) </dd></dl>

</div>
</div>
<a id="a43464482f2fd9b2c4b7e2beac12fc522" name="a43464482f2fd9b2c4b7e2beac12fc522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43464482f2fd9b2c4b7e2beac12fc522">&#9670;&#160;</a></span>straighten_seams()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVT , typename DerivedFT , typename Scalar , typename DerivedUE , typename DerivedUT , typename DerivedOT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::straighten_seams </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVT &gt; &amp;&#160;</td>
          <td class="paramname"><em>VT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFT &gt; &amp;&#160;</td>
          <td class="paramname"><em>FT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUE &gt; &amp;&#160;</td>
          <td class="paramname"><em>UE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedUT &gt; &amp;&#160;</td>
          <td class="paramname"><em>UT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedOT &gt; &amp;&#160;</td>
          <td class="paramname"><em>OT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a obj-style mesh with (V,F) defining the geometric surface of the mesh and (VT,FT) defining the parameterization/texture-mapping of the mesh in the uv-domain, find all seams and boundaries in the texture-mapping and "straighten" them, remapping vertices along the boundary and in the interior. </p>
<p>This will be careful to consistently straighten multiple seams in the texture-mesh corresponding to the same edge chains in the surface-mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VT</td><td>#VT by 2 list of texture coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FT</td><td>#F by 3 list of triangle texture coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>followed by Ramer-Douglas-Peucker tolerance as a fraction of the curves bounding box diagonal (see dpsimplify) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UE</td><td>#UE by 2 list of indices into VT of coarse output polygon edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UT</td><td>#VT by 3 list of new texture coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OT</td><td>#OT by 2 list of indices into VT of boundary edges</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a0fe9e431751b9d9370672f22da915cea" title="Ramer-Douglas-Peucker piecewise-linear curve simplification.">ramer_douglas_peucker</a> </dd></dl>

</div>
</div>
<a id="ac4a359f88733a83493b68b6f605a5161" name="ac4a359f88733a83493b68b6f605a5161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a359f88733a83493b68b6f605a5161">&#9670;&#160;</a></span>starts_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string starts with a given prefix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefix</td><td>prefix to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if str starts with prefix, false otherwise</dd></dl>
<p><a class="el" href="string__utils_8h.html">include/igl/string_utils.h</a> </p>

</div>
</div>
<a id="ad5e02163e30570e181965fba3609c8b4" name="ad5e02163e30570e181965fba3609c8b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e02163e30570e181965fba3609c8b4">&#9670;&#160;</a></span>starts_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="string__utils_8h.html">include/igl/string_utils.h</a>. </p>

</div>
</div>
<a id="adf21bb95cf3e8474259c54e4a55ed734" name="adf21bb95cf3e8474259c54e4a55ed734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf21bb95cf3e8474259c54e4a55ed734">&#9670;&#160;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseVector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sum the columns or rows of a sparse matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">should</td><td>be a eigen sparse matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>m by n sparse matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension along which to sum (1 or 2) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>n-long sparse vector (if dim == 1) or m-long sparse vector (if dim == 2)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If your looking for dense matrix matlab like sum for eigen matrics just use: <pre class="fragment"> M.colwise().sum() or M.rowwise().sum()
</pre> </dd></dl>

</div>
</div>
<a id="a5bcbac428755ce31717db4079956840b" name="a5bcbac428755ce31717db4079956840b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bcbac428755ce31717db4079956840b">&#9670;&#160;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AType , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseMatrix&lt; AType &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Sum is "conducted" in the type of DerivedB::Scalar </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AType</td><td>should be a eigen sparse matrix primitive type like int or double </td></tr>
    <tr><td class="paramname">DerivedB</td><td>should be a eigen dense matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b7376c37ca3ec7bb7dc4cf7fdecfe36" name="a3b7376c37ca3ec7bb7dc4cf7fdecfe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b7376c37ca3ec7bb7dc4cf7fdecfe36">&#9670;&#160;</a></span>svd3x3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::svd3x3 </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Super fast 3x3 SVD according to <a href="http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html">http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html</a> The resulting decomposition is A = U * diag(S[0], S[1], S[2]) * V'. </p>
<dl class="section note"><dt>Note</dt><dd>this SVD algorithm guarantees that det(U) = det(V) = 1, but this comes at the cost that 'sigma3' can be negative for computing polar decomposition it's great because all we need to do is U*V' and the result will automatically have positive determinant</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>3x3 matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>3x3 left singular vectors </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>3x1 singular values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>3x3 right singular vectors</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4153817f124410a202847cbf878d271b" name="a4153817f124410a202847cbf878d271b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4153817f124410a202847cbf878d271b">&#9670;&#160;</a></span>svd3x3_avx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::svd3x3_avx </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3 *8, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3 *8, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3 *8, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3 *8, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Super fast 3x3 SVD according to <a href="http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html">http://pages.cs.wisc.edu/~sifakis/project_pages/svd.html</a> This is AVX version of svd3x3 (see <a class="el" href="svd3x3_8h.html">svd3x3.h</a>) which works on 8 matrices at a time These eight matrices are simply stacked in columns, the rest is the same as for svd3x3. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>12 by 3 stack of 3x3 matrices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>12x3 left singular vectors stacked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>12x1 singular values stacked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>12x3 right singular vectors stacked</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae67ee73993135205bd97cfc9c8453d68" name="ae67ee73993135205bd97cfc9c8453d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67ee73993135205bd97cfc9c8453d68">&#9670;&#160;</a></span>svd3x3_sse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::svd3x3_sse </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, 3 *4, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3 *4, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3 *4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, 3 *4, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>12 by 3 stack of 3x3 matrices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>12x3 left singular vectors stacked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>12x1 singular values stacked </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>12x3 right singular vectors stacked</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a525f425d4315f9547a6e82782d7d672b" name="a525f425d4315f9547a6e82782d7d672b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525f425d4315f9547a6e82782d7d672b">&#9670;&#160;</a></span>swept_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::swept_volume </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Affine3d(const double t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>grid_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>SV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>SF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the surface of the swept volume of a solid object with surface (V,F) mesh under going rigid motion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh positions in reference pose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>function handle so that transform(t) returns the rigid transformation at time t∈[0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>number of time steps: steps=3 --&gt; t∈{0,0.5,1} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">grid_res</td><td>number of grid cells on the longest side containing the motion (isolevel+1 cells will also be added on each side as padding) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isolevel</td><td>distance level to be contoured as swept volume </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SV</td><td>#SV by 3 list of mesh positions of the swept surface </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">SF</td><td>#SF by 3 list of mesh faces into SV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0739e2c6e91f7aa950aca9580a90e612" name="a0739e2c6e91f7aa950aca9580a90e612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0739e2c6e91f7aa950aca9580a90e612">&#9670;&#160;</a></span>swept_volume_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::swept_volume_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::RowVector3d(const size_t vi, const double t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::AlignedBox3d &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an axis-aligned bounding box containing a shape undergoing a motion sampled at <code>steps</code> discrete momements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>function handle so that V(i,t) returns the 3d position of vertex i at time t, for t∈[0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>number of time steps: steps=3 --&gt; t∈{0,0.5,1} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">box</td><td>box containing mesh under motion </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2df37d639d7915a6623d3dd0deecaf8a" name="a2df37d639d7915a6623d3dd0deecaf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df37d639d7915a6623d3dd0deecaf8a">&#9670;&#160;</a></span>swept_volume_signed_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::swept_volume_signed_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Affine3d(const double t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVector3i &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>S0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed distance to a sweep surface of a mesh under-going an arbitrary motion V(t) discretely sampled at <code>steps</code>-many moments in time at a grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh positions in reference pose </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices [0,n) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>function handle so that transform(t) returns the rigid transformation at time t∈[0,1] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>number of time steps: steps=3 --&gt; t∈{0,0.5,1} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">GV</td><td>#GV by 3 list of evaluation point grid positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">res</td><td>3-long resolution of GV grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>edge-length of grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isolevel</td><td>isolevel to "focus" on; grid positions far enough away from isolevel (based on h) will get approximate values). Set isolevel=infinity to get good values everywhere (slow and unnecessary if just trying to extract isolevel-level set). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S0</td><td>#GV initial values (will take minimum with these), can be same as S) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#GV list of signed distances </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a030deb66b915a2f498701588640ee3a4" name="a030deb66b915a2f498701588640ee3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030deb66b915a2f498701588640ee3a4">&#9670;&#160;</a></span>swept_volume_signed_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::swept_volume_signed_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Eigen::Affine3d(const double t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVector3i &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>isolevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aca626f9c0a1f205b884fc1c6787c6a59" name="aca626f9c0a1f205b884fc1c6787c6a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca626f9c0a1f205b884fc1c6787c6a59">&#9670;&#160;</a></span>tan_half_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar igl::tan_half_angle </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the tangent of half of the angle opposite the side with length a, in a triangle with side lengths (a,b,c). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>scalar edge length of first side of triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>scalar edge length of second side of triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>scalar edge length of third side of triangle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tangent of half of the angle opposite side with length a</dd>
<dd>
is_intrinsic_delaunay </dd></dl>

</div>
</div>
<a id="ab9fcd72a6173a2c6d4e4651a706b2911" name="ab9fcd72a6173a2c6d4e4651a706b2911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fcd72a6173a2c6d4e4651a706b2911">&#9670;&#160;</a></span>tet_tet_adjacency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename DerivedTT , typename DerivedTTi &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::tet_tet_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTTi &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the tet_tet adjacency matrix for a given tet mesh with tets T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T by 4 list of tets </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TT</td><td>#T by #4 adjacency matrix, the element i,j is the id of the tet adjacent to the j face of tet i </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TTi</td><td>#T by #4 adjacency matrix, the element i,j is the id of face of the tet TT(i,j) that is adjacent to tet i</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the first face of a tet is [0,1,2], the second [0,1,3], the third [1,2,3], and the fourth [2,0,3]. </dd></dl>

</div>
</div>
<a id="ada72de8eeac466f8cb2a52016a1bd1cf" name="ada72de8eeac466f8cb2a52016a1bd1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada72de8eeac466f8cb2a52016a1bd1cf">&#9670;&#160;</a></span>tet_tet_adjacency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedT , typename DerivedTT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::tet_tet_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a09d82782b314ba8729b05712387f7ec4" name="a09d82782b314ba8729b05712387f7ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d82782b314ba8729b05712387f7ec4">&#9670;&#160;</a></span>tetrahedralized_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedGV , typename DerivedGT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::tetrahedralized_grid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">TetrahedralizedGripType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGT &gt; &amp;&#160;</td>
          <td class="paramname"><em>GT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct vertices of a regular grid, suitable for input to <code><a class="el" href="namespaceigl.html#a5512306a29939c7ac8d4ebcef2cd032a" title="Performs the marching tetrahedra algorithm on a tet mesh defined by TV and TT with scalar values defi...">igl::marching_tets</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>number of grid vertices in x direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>number of grid vertices in y direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nz</td><td>number of grid vertices in z direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of tetrahedralization of cube to use </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GV</td><td>nx*ny*nz by 3 list of grid vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GT</td><td>(nx-1)*(ny-1)*(nz-1)*k by 4 list of tetrahedron indices into rows of V, where k is the number of tets per cube (dependent on type)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a3be3b842294c1e29d654ace1e4f735ca" title="Create a regular grid of elements (only 2D supported, currently) Vertex position order is compatible ...">triangulated_grid</a>, <a class="el" href="namespaceigl.html#acb165fc9bf550b7a4248ef3e4750c7b5">quad_grid</a> </dd></dl>

</div>
</div>
<a id="ae86a7e69f97c1ca839467731e3944441" name="ae86a7e69f97c1ca839467731e3944441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86a7e69f97c1ca839467731e3944441">&#9670;&#160;</a></span>tetrahedralized_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedside , typename DerivedGT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::tetrahedralized_grid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedside &gt; &amp;&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#ac3bae8c76c2714f3cce8b651ae93fae2">TetrahedralizedGripType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGT &gt; &amp;&#160;</td>
          <td class="paramname"><em>GT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">side</td><td>3-long list {nx,ny,nz} see above </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f1fa0516e3b6395846621d6a79507e8" name="a6f1fa0516e3b6395846621d6a79507e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1fa0516e3b6395846621d6a79507e8">&#9670;&#160;</a></span>topological_hole_fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename VectorIndex , typename DerivedF_filled &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::topological_hole_fill </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; VectorIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>holes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF_filled &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_filled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Topological fill hole on a mesh, with one additional vertex each hole Index of new abstract vertices will be F.maxCoeff() + (index of hole) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of element indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">holes</td><td>vector of hole loops to fill </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F_filled</td><td>input F stacked with filled triangles.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c72a7f89ae16b8e5196c4cd37fb2689" name="a4c72a7f89ae16b8e5196c4cd37fb2689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c72a7f89ae16b8e5196c4cd37fb2689">&#9670;&#160;</a></span>trackball() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::trackball </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type&#160;</td>
          <td class="paramname"><em>speed_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>down_mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>down_mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a trackball drag to identity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>width of the trackball context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>height of the trackball context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed_factor</td><td>controls how fast the trackball feels, 1 is normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_mouse_x</td><td>x position of mouse down </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_mouse_y</td><td>y position of mouse down </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mouse_x</td><td>current x position of mouse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mouse_y</td><td>current y position of mouse </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quat</td><td>the resulting rotation (as quaternion) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c31d9f94cfdba0d5da1b69f4f4d968" name="a46c31d9f94cfdba0d5da1b69f4f4d968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c31d9f94cfdba0d5da1b69f4f4d968">&#9670;&#160;</a></span>trackball() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Q_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::trackball </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type&#160;</td>
          <td class="paramname"><em>speed_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Q_type *&#160;</td>
          <td class="paramname"><em>down_quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>down_mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>down_mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Q_type *&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a trackball drag to a given rotation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>width of the trackball context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>height of the trackball context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed_factor</td><td>controls how fast the trackball feels, 1 is normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_quat</td><td>rotation at mouse down, i.e. the rotation we're applying the trackball motion to (as quaternion) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_mouse_x</td><td>x position of mouse down </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_mouse_y</td><td>y position of mouse down </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mouse_x</td><td>current x position of mouse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mouse_y</td><td>current y position of mouse </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quat</td><td>the resulting rotation (as quaternion) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf9d8f7f6bbca5f24365f3ce5f401f9a" name="aaf9d8f7f6bbca5f24365f3ce5f401f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9d8f7f6bbca5f24365f3ce5f401f9a">&#9670;&#160;</a></span>trackball() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalardown_quat , typename Scalarquat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::trackball </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>speed_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalardown_quat &gt; &amp;&#160;</td>
          <td class="paramname"><em>down_quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>down_mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>down_mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Quaternion&lt; Scalarquat &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5fa327db1af41a1e29e474981b963409" name="a5fa327db1af41a1e29e474981b963409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa327db1af41a1e29e474981b963409">&#9670;&#160;</a></span>transpose_blocks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::transpose_blocks </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transpose blocks of a matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>should be a eigen matrix primitive type like int or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m*k by n (dim: 1) or m by n*k (dim: 2) eigen Matrix of type T values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of blocks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>dimension in which to transpose </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>n*k by m (dim: 1) or n by m*k (dim: 2) eigen Matrix of type T values, NOT allowed to be the same as A</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md37"></a>
Example:</h4>
<p>A = [ 1 2 3 4 5 6 7 8 101 102 103 104 105 106 107 108 201 202 203 204 205 206 207 208]; transpose_blocks(A,1,3,B); B -&gt; [ 1 5 2 6 3 7 4 8 101 105 102 106 103 107 104 108 201 205 202 206 203 207 204 208]; </p>

</div>
</div>
<a id="a62161fdfef57c22542b38d735550b635" name="a62161fdfef57c22542b38d735550b635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62161fdfef57c22542b38d735550b635">&#9670;&#160;</a></span>tri_tri_overlap_test_3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP1 , typename DerivedQ1 , typename DerivedR1 , typename DerivedP2 , typename DerivedQ2 , typename DerivedR2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::tri_tri_overlap_test_3d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a56ff893a73c2642eeec2692d37aad4d0" name="a56ff893a73c2642eeec2692d37aad4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ff893a73c2642eeec2692d37aad4d0">&#9670;&#160;</a></span>tri_tri_intersection_test_3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP1 , typename DerivedQ1 , typename DerivedR1 , typename DerivedP2 , typename DerivedQ2 , typename DerivedR2 , typename DerivedS , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::tri_tri_intersection_test_3d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>coplanar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4e80369c0a74cc009ec973dd70fd752" name="ac4e80369c0a74cc009ec973dd70fd752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e80369c0a74cc009ec973dd70fd752">&#9670;&#160;</a></span>tri_tri_overlap_test_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP1 , typename DerivedQ1 , typename DerivedR1 , typename DerivedP2 , typename DerivedQ2 , typename DerivedR2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::tri_tri_overlap_test_2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedR2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ce1a2b984f20466ffc7732ab29501ba" name="a9ce1a2b984f20466ffc7732ab29501ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce1a2b984f20466ffc7732ab29501ba">&#9670;&#160;</a></span>triangle_fan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedE , typename Derivedcap &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_fan </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedcap &gt; &amp;&#160;</td>
          <td class="paramname"><em>cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of faces tessellate all of the "exterior" edges forming another list of. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by simplex_size-1 list of exterior edges (see <a class="el" href="exterior__edges_8h.html">exterior_edges.h</a>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cap</td><td>#cap by simplex_size list of "faces" tessellating the boundary edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b17a92c69587c651fe1b4d549235a9d" name="a6b17a92c69587c651fe1b4d549235a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b17a92c69587c651fe1b4d549235a9d">&#9670;&#160;</a></span>triangle_fan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXi igl::triangle_fan </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae07b1e4d35569138ffa0d8a874f0e24f" name="ae07b1e4d35569138ffa0d8a874f0e24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07b1e4d35569138ffa0d8a874f0e24f">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedTT , typename DerivedTTi &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTTi &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the triangle-triangle adjacency matrix for a given mesh (V,F). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TT</td><td>#F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TTi</td><td>#F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the first edge of a triangle is [0,1] the second [1,2] and the third [2,3]. This convention is DIFFERENT from <a class="el" href="cotmatrix__entries_8h.html">cotmatrix_entries.h</a>/edge_lengths.h/etc. To fix this you could use:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Fix mis-match convention</span></div>
<div class="line">{</div>
<div class="line">  Eigen::PermutationMatrix&lt;3,3&gt; perm(3);</div>
<div class="line">  perm.indices() = Eigen::Vector3i(1,2,0);</div>
<div class="line">  TT = (TT*perm).eval();</div>
<div class="line">  TTi = (TTi*perm).eval();</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0;i&lt;TTi.rows();i++)</div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;TTi.cols();j++)</div>
<div class="line">      TTi(i,j)=TTi(i,j)==-1?-1:(TTi(i,j)+3-1)%3;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7210f2492117b1c482907e6a47dbed75" name="a7210f2492117b1c482907e6a47dbed75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7210f2492117b1c482907e6a47dbed75">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedTT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="add74393b2dabd37b8efd0a7c2145372a" name="add74393b2dabd37b8efd0a7c2145372a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add74393b2dabd37b8efd0a7c2145372a">&#9670;&#160;</a></span>triangle_triangle_adjacency_preprocess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename TTT_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency_preprocess </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; TTT_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preprocessing for triangle_triangle_adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TT</td><td>#F by #3 adjacent matrix, the element i,j is the id of the triangle adjacent to the j edge of triangle i</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="triangle__triangle__adjacency_8h.html">include/igl/triangle_triangle_adjacency.h</a> </p>

</div>
</div>
<a id="a45cd01351200f4312c4fa5abef9c63a1" name="a45cd01351200f4312c4fa5abef9c63a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cd01351200f4312c4fa5abef9c63a1">&#9670;&#160;</a></span>triangle_triangle_adjacency_extractTT()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename TTT_type , typename DerivedTT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency_extractTT </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; TTT_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTT &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the face adjacencies for triangle_triangle_adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TTT</td><td>#F list of lists adjacent triangles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TT</td><td>#F by #3 adjacentmatrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="triangle__triangle__adjacency_8h.html">include/igl/triangle_triangle_adjacency.h</a> </p>

</div>
</div>
<a id="a81887c23c0079fb92f46a517cd42f752" name="a81887c23c0079fb92f46a517cd42f752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81887c23c0079fb92f46a517cd42f752">&#9670;&#160;</a></span>triangle_triangle_adjacency_extractTTi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename TTT_type , typename DerivedTTi &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency_extractTTi </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; TTT_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedTTi &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the face adjacencies indices for triangle_triangle_adjacency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex_size list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TTT</td><td>#F list of lists adjacent triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TTi</td><td>#F by #3 adjacent matrix, the element i,j is the id of edge of the triangle TT(i,j) that is adjacent with triangle i</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="triangle__triangle__adjacency_8h.html">include/igl/triangle_triangle_adjacency.h</a> </p>

</div>
</div>
<a id="a99e6fd086c1507cb6b02df0b458566cd" name="a99e6fd086c1507cb6b02df0b458566cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e6fd086c1507cb6b02df0b458566cd">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename TTIndex , typename TTiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjacency list version, which works with non-manifold meshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TT</td><td>#F by 3 list of lists so that TT[i][c] --&gt; {j,k,...} means that faces j and k etc. are edge-neighbors of face i on face i's edge opposite corner c </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">TTj</td><td>#F list of lists so that TTj[i][c] --&gt; {j,k,...} means that face TT[i][c][0] is an edge-neighbor of face i incident on the edge of face TT[i][c][0] opposite corner j, and TT[i][c][1] " corner k, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ea1a1ba3c8bee980c00db518fb9f443" name="a5ea1a1ba3c8bee980c00db518fb9f443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea1a1ba3c8bee980c00db518fb9f443">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename TTIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad091a40b270aa5030a3dd0909e6402e6" name="ad091a40b270aa5030a3dd0909e6402e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad091a40b270aa5030a3dd0909e6402e6">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename TTIndex , typename TTiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>construct_TTi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab979438c0daba73490363a56fc67f54a" name="ab979438c0daba73490363a56fc67f54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab979438c0daba73490363a56fc67f54a">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedE , typename DerivedEMAP , typename uE2EType , typename TTIndex , typename TTiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>construct_TTi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#F*3 by 2 list of all of directed edges in order (see <code>oriented_facets</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique undirected edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">construct_TTi</td><td>whether to compute TTi</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">unique_edge_map</a>, <a class="el" href="namespaceigl.html#a3f9293ec84689fd8949325ccb22d55fb" title="Determines all &quot;directed [facets](https://en.wikipedia.org/wiki/Simplex#Elements)&quot; of a given set of ...">oriented_facets</a> </dd></dl>

</div>
</div>
<a id="afc80c379b811624a97c1ed29ba4df0fb" name="afc80c379b811624a97c1ed29ba4df0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc80c379b811624a97c1ed29ba4df0fb">&#9670;&#160;</a></span>triangle_triangle_adjacency() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename TTIndex , typename TTiIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangle_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>construct_TTi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::vector&lt; TTiIndex &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TTi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumulative counts of directed edges sharing each unique edge so the uEC(i+1)-uEC(i) is the number of directed edges sharing the ith unique edge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#E list of indices into E, so that the consecutive segment of indices uEE.segment(uEC(i),uEC(i+1)-uEC(i)) lists all directed edges sharing the ith unique edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae67465786e131443ebdb6bdae0aa701f" name="ae67465786e131443ebdb6bdae0aa701f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67465786e131443ebdb6bdae0aa701f">&#9670;&#160;</a></span>triangles_from_strip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedS , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangles_from_strip </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a list of triangles from a stream of indices along a strip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>#S list of indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#S-2 by 3 list of triangle indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be3b842294c1e29d654ace1e4f735ca" name="a3be3b842294c1e29d654ace1e4f735ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be3b842294c1e29d654ace1e4f735ca">&#9670;&#160;</a></span>triangulated_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename YType , typename DerivedGV , typename DerivedGF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangulated_grid </td>
          <td>(</td>
          <td class="paramtype">const XType &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const YType &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGF &gt; &amp;&#160;</td>
          <td class="paramname"><em>GF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a regular grid of elements (only 2D supported, currently) Vertex position order is compatible with <code><a class="el" href="namespaceigl.html#adfb4bab2b437369dce2059e85836bd9a" title="Construct vertices of a regular grid, suitable for input to igl::marching_cubes">igl::grid</a></code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nx</td><td>number of vertices in the x direction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ny</td><td>number of vertices in the y direction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GV</td><td>nx*ny by 2 list of mesh vertex positions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GF</td><td>2*(nx-1)*(ny-1) by 3 list of triangle indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#adfb4bab2b437369dce2059e85836bd9a" title="Construct vertices of a regular grid, suitable for input to igl::marching_cubes">grid</a>, <a class="el" href="namespaceigl.html#acb165fc9bf550b7a4248ef3e4750c7b5">quad_grid</a> </dd></dl>

</div>
</div>
<a id="a82c16be739961936bc5159688a4c7683" name="a82c16be739961936bc5159688a4c7683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82c16be739961936bc5159688a4c7683">&#9670;&#160;</a></span>triangulated_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename XType , typename YType , typename DerivedGF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::triangulated_grid </td>
          <td>(</td>
          <td class="paramtype">const XType &amp;&#160;</td>
          <td class="paramname"><em>nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const YType &amp;&#160;</td>
          <td class="paramname"><em>ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGF &gt; &amp;&#160;</td>
          <td class="paramname"><em>GF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a38fd083e49162fe9dfe2e1de54948c89" name="a38fd083e49162fe9dfe2e1de54948c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fd083e49162fe9dfe2e1de54948c89">&#9670;&#160;</a></span>turning_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedV::Scalar igl::turning_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the turning number of a closed curve in the plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tn turning number </dd></dl>

</div>
</div>
<a id="aaef42c6f3251414c7485b4d1433a54e4" name="aaef42c6f3251414c7485b4d1433a54e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef42c6f3251414c7485b4d1433a54e4">&#9670;&#160;</a></span>two_axis_valuator_fixed_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalardown_quat , typename Scalarquat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::two_axis_valuator_fixed_up </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>speed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Quaternion&lt; Scalardown_quat &gt; &amp;&#160;</td>
          <td class="paramname"><em>down_quat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>down_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>down_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mouse_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>mouse_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Quaternion&lt; Scalarquat &gt; &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a two-axis valuator drag rotation (as seen in Maya/Studio max) to a given rotation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>width of the trackball context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>height of the trackball context </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">speed</td><td>controls how fast the trackball feels, 1 is normal </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_quat</td><td>rotation at mouse down, i.e. the rotation we're applying the trackball motion to (as quaternion). <b>Note:</b> Up-vector that is fixed is with respect to this rotation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_x</td><td>position of mouse down </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">down_y</td><td>position of mouse down </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mouse_x</td><td>current x position of mouse </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mouse_y</td><td>current y position of mouse </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">quat</td><td>the resulting rotation (as quaternion)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#af6de4ebdb7f531d96fb57a566e0d121c" title="Snap an arbitrary rotation to a rotation resulting from a rotation about the y-axis then the x-axis (...">snap_to_fixed_up</a> </dd></dl>

</div>
</div>
<a id="a653da1c359295934ee69235ad8d43db4" name="a653da1c359295934ee69235ad8d43db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653da1c359295934ee69235ad8d43db4">&#9670;&#160;</a></span>uniformly_sample_two_manifold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::uniformly_sample_two_manifold </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>push</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>WS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to sample a mesh uniformly with k-points by furthest point relaxation as described in "Fast Automatic Skinning Transformations" [Jacobson et al. </p>
<p>12] Section 3.3. The input is not expected to be a typical 3D triangle mesh (e.g., [V,F]), instead each vertex is embedded in a high dimensional unit-hypercude ("weight space") defined by W, with triangles given by F. This algorithm will first conduct furthest point sampling from the set of vertices and then attempt to relax the sampled points along the surface of the high-dimensional triangle mesh (i.e., the output points may be in the middle of triangles, not just at vertices). An additional "push" factor will repel samples away from the corners of the hypercube.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>#W by dim positions of mesh in weight space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 indices of triangles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>number of samples </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">push</td><td>factor by which corners should be pushed away </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WS</td><td>k by dim locations in weight space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a1fc88d96c492e3bf962501af8bea413e" title="Randomly sample a mesh (V,F) n times.">random_points_on_mesh</a> </dd></dl>

</div>
</div>
<a id="ad17a2faf487e7a4ee375842967d6b285" name="ad17a2faf487e7a4ee375842967d6b285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17a2faf487e7a4ee375842967d6b285">&#9670;&#160;</a></span>uniformly_sample_two_manifold_at_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::uniformly_sample_two_manifold_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>push</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.<a class="el" href="uniformly__sample__two__manifold_8h.html">include/igl/uniformly_sample_two_manifold.h</a>. </p>

</div>
</div>
<a id="a45aa8c440aeb5e9aab5fb79156197153" name="a45aa8c440aeb5e9aab5fb79156197153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45aa8c440aeb5e9aab5fb79156197153">&#9670;&#160;</a></span>unique() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>IC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like matlab's [C,IA,IC] = unique(X) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>comparable type T </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A vector of type T </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C vector of unique entries in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>#C index vector so that C = A(IA); </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IC</td><td>#A index vector so that A = C(IC); </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae97cc0b7a30e7285c6375d63fca2946c" name="ae97cc0b7a30e7285c6375d63fca2946c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae97cc0b7a30e7285c6375d63fca2946c">&#9670;&#160;</a></span>unique() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a715dcc29e1a1beb8b358ebd275765fbb" name="a715dcc29e1a1beb8b358ebd275765fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715dcc29e1a1beb8b358ebd275765fbb">&#9670;&#160;</a></span>unique() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedC , typename DerivedIA , typename DerivedIC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;&#160;</td>
          <td class="paramname"><em>IC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a03a554daf5ff87c8e4661b250e0078ce" name="a03a554daf5ff87c8e4661b250e0078ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a554daf5ff87c8e4661b250e0078ce">&#9670;&#160;</a></span>unique() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5ec9f63d03451613c1a56df8308fe4b2" name="a5ec9f63d03451613c1a56df8308fe4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec9f63d03451613c1a56df8308fe4b2">&#9670;&#160;</a></span>unique_edge_map() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename uE2EType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique_edge_map </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct relationships between facet "half"-(or rather "viewed")-edges E to unique edges of the mesh seen as a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of simplices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>#F*3 by 2 list of all directed edges, such that E.row(f+#F*c) is the edge opposite F(f,c) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE</td><td>#uE by 2 list of unique undirected edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE, mapping each directed edge to unique undirected edge so that uE(EMAP(f+#F*c)) is the unique edge corresponding to E.row(f+#F*c) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE2E</td><td>#uE list of lists of indices into E of coexisting edges, so that E.row(uE2E[i][j]) corresponds to uE.row(i) for all j in 0..uE2E[i].size()-1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a386a94bc8aaf45b2eb84b355d2bff311" name="a386a94bc8aaf45b2eb84b355d2bff311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386a94bc8aaf45b2eb84b355d2bff311">&#9670;&#160;</a></span>unique_edge_map() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique_edge_map </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a50a5bc29088ffa37e630cf9fd0d92c66" name="a50a5bc29088ffa37e630cf9fd0d92c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a5bc29088ffa37e630cf9fd0d92c66">&#9670;&#160;</a></span>unique_edge_map() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedE , typename DeriveduE , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique_edge_map </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>It is usual much faster if your algorithm can be written in terms of (uEC,uEE) rather than (uE2E).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">uEC</td><td>#uE+1 list of cumulative counts of directed edges sharing each unique edge so the uEC(i+1)-uEC(i) is the number of directed edges sharing the ith unique edge. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uEE</td><td>#E list of indices into E, so that the consecutive segment of indices uEE.segment(uEC(i),uEC(i+1)-uEC(i)) lists all directed edges sharing the ith unique edge.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md38"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="comment">// Using uE2E</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> u = 0;u&lt;uE2E.size();u++)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;uE2E[u].size();i++)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// eth directed-edge is ith edge equivalent to uth undirected edge</span></div>
<div class="line">    e = uE2E[u][i]; </div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// Using uEC,uEE</span></div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> u = 0;u&lt;uE.size();u++)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = uEC(u);j&lt;uEC(u+1);j++)</div>
<div class="line">  {</div>
<div class="line">    e = uEE(j); <span class="comment">// i = j-uEC(u);</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="adc1388186f7f12be43df64d7ad45a136" name="adc1388186f7f12be43df64d7ad45a136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1388186f7f12be43df64d7ad45a136">&#9670;&#160;</a></span>unique_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedC , typename DerivedIA , typename DerivedIC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique_rows </td>
          <td>(</td>
          <td class="paramtype">const Eigen::DenseBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;&#160;</td>
          <td class="paramname"><em>IC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Act like matlab's [C,IA,IC] = unique(X,'rows') </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedA</td><td>derived scalar type, e.g. MatrixXi or MatrixXd </td></tr>
    <tr><td class="paramname">DerivedIA</td><td>derived integer type, e.g. MatrixXi </td></tr>
    <tr><td class="paramname">DerivedIC</td><td>derived integer type, e.g. MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>m by n matrix whose entries are to unique'd according to rows </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C vector of unique rows in A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>#C index vector so that C = A(IA,:); </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IC</td><td>#A index vector so that A = C(IC,:); </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23358af3f14021f32e9d30758f80a9a7" name="a23358af3f14021f32e9d30758f80a9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23358af3f14021f32e9d30758f80a9a7">&#9670;&#160;</a></span>unique_simplices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedFF , typename DerivedIA , typename DerivedIC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique_simplices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIA &gt; &amp;&#160;</td>
          <td class="paramname"><em>IA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIC &gt; &amp;&#160;</td>
          <td class="paramname"><em>IC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find <em>combinatorially</em> unique simplices in F. </p>
<p><b>Order independent</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by simplex-size list of simplices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#FF by simplex-size list of unique simplices in F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IA</td><td>#FF index vector so that FF == sort(F(IA,:),2); </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IC</td><td>#F index vector so that sort(F,2) == FF(IC,:); </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20ecb806162f1bbe1260c630e8bb941d" name="a20ecb806162f1bbe1260c630e8bb941d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ecb806162f1bbe1260c630e8bb941d">&#9670;&#160;</a></span>unique_simplices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unique_simplices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a04b29a2138c5fa4268400e42b8df04a9" name="a04b29a2138c5fa4268400e42b8df04a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b29a2138c5fa4268400e42b8df04a9">&#9670;&#160;</a></span>unproject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedwin , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Derivedscene &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unproject </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedwin &gt; &amp;&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedmodel &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedproj &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedviewport &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedscene &gt; &amp;&#160;</td>
          <td class="paramname"><em>scene</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eigen reimplementation of gluUnproject. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">win</td><td>#P by 3 or 3-vector (#P=1) of screen space x, y, and z coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>4x4 model-view matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>4x4 projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>4-long viewport vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">scene</td><td>#P by 3 or 3-vector (#P=1) the unprojected x, y, and z coordinates</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac545f7c2b0b725169a3785ba8e5bdbc2" name="ac545f7c2b0b725169a3785ba8e5bdbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac545f7c2b0b725169a3785ba8e5bdbc2">&#9670;&#160;</a></span>unproject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; Scalar, 3, 1 &gt; igl::unproject </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 3, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, 4, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="adec5b69e885a84437436bde2e86bb09a" name="adec5b69e885a84437436bde2e86bb09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec5b69e885a84437436bde2e86bb09a">&#9670;&#160;</a></span>unproject_in_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedobj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::unproject_in_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position <em>inside</em> a given mesh. </p>
<p>If the ray through the given screen location (x,y) <em>hits</em> the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>screen space coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>model matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>vieweport vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>3d unprojected mouse point in mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hits</td><td>vector of hits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of hits </dd></dl>

</div>
</div>
<a id="a25fc2d8b2c9e58a5006fe7f8ea6308ec" name="a25fc2d8b2c9e58a5006fe7f8ea6308ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fc2d8b2c9e58a5006fe7f8ea6308ec">&#9670;&#160;</a></span>unproject_in_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedobj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::unproject_in_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a86f5bf3b46d4f04f8189b0a5b489e4bb" name="a86f5bf3b46d4f04f8189b0a5b489e4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f5bf3b46d4f04f8189b0a5b489e4bb">&#9670;&#160;</a></span>unproject_in_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedobj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::unproject_in_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;, std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>shoot_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shoot_ray</td><td>function handle that outputs first hit of a given ray against a mesh (embedded in function handles as captured variable/data) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d4df676266aad88e2fad4b43a0777c" name="a28d4df676266aad88e2fad4b43a0777c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d4df676266aad88e2fad4b43a0777c">&#9670;&#160;</a></span>unproject_on_line() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename Derivedorigin , typename Deriveddir &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unproject_on_line </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedorigin &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename DerivedUV::Scalar &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a screen space point (u,v) and the current projection matrix (e.g. </p>
<p>gl_proj * gl_modelview) and viewport, <em>unproject</em> the point into the scene so that it lies on given line (origin and dir) and projects as closely as possible to the given screen space point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UV</td><td>2-long uv-coordinates of screen space point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>4 by 4 projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VP</td><td>4-long viewport: (corner_u, corner_v, width, height) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>point on line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dir</td><td>vector parallel to line </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">t</td><td>line parameter so that closest poin on line to viewer ray through UV lies at origin+t*dir </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addb8ea814628c47819f95f70ed6ff5d8" name="addb8ea814628c47819f95f70ed6ff5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb8ea814628c47819f95f70ed6ff5d8">&#9670;&#160;</a></span>unproject_on_line() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename Derivedorigin , typename Deriveddir , typename DerivedZ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unproject_on_line </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedorigin &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>3d position of closest point on line to viewing ray through UV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cf2e9896877756fbe8f09c0b051e76d" name="a0cf2e9896877756fbe8f09c0b051e76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf2e9896877756fbe8f09c0b051e76d">&#9670;&#160;</a></span>unproject_on_plane()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedUV , typename DerivedM , typename DerivedVP , typename DerivedP , typename DerivedZ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unproject_on_plane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedM &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVP &gt; &amp;&#160;</td>
          <td class="paramname"><em>VP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedZ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a screen space point (u,v) and the current projection matrix (e.g. </p>
<p>gl_proj * gl_modelview) and viewport, <em>unproject</em> the point into the scene so that it lies on given plane.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">UV</td><td>2-long uv-coordinates of screen space point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>4 by 4 projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VP</td><td>4-long viewport: (corner_u, corner_v, width, height) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>4-long plane equation coefficients: P*(X 1) = 0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Z</td><td>3-long world coordinate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbefb4e32e184a299b36f663b23b7b9c" name="abbefb4e32e184a299b36f663b23b7b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbefb4e32e184a299b36f663b23b7b9c">&#9670;&#160;</a></span>unproject_onto_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedbc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::unproject_onto_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position <em>onto</em> a given mesh, if the ray through the given screen location (x,y) <em>hits</em> the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>screen space coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>model matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>vieweport vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fid</td><td>id of the first face hit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bc</td><td>barycentric coordinates of hit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there's a hit</dd></dl>
<h4><a class="anchor" id="autotoc_md39"></a>
Example:</h4>
<div class="fragment"><div class="line"><a class="code hl_class" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html">igl::opengl::glfw::Viewer</a> vr;</div>
<div class="line">...</div>
<div class="line">igl::unproject_onto_mesh(</div>
<div class="line">  pos,vr.<a class="code hl_function" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">core</a>().<a class="code hl_variable" href="classigl_1_1opengl_1_1ViewerCore.html#a8ce15c9d27268543847a0d83c2010cb6">view</a>,vr.<a class="code hl_function" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">core</a>().<a class="code hl_variable" href="classigl_1_1opengl_1_1ViewerCore.html#a50af5081883025581f00b0918b3d9d30">proj</a>,vr.<a class="code hl_function" href="classigl_1_1opengl_1_1glfw_1_1Viewer.html#a4fc39cbf6a2d68d0eaf63bef3fd49464">core</a>().<a class="code hl_variable" href="classigl_1_1opengl_1_1ViewerCore.html#ac5a0f15fc245747e1d83b8e718f2e74f">viewport</a>,V,F,fid,bc);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af4d029fbc6f770b7dec469f743858d8f" name="af4d029fbc6f770b7dec469f743858d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d029fbc6f770b7dec469f743858d8f">&#9670;&#160;</a></span>unproject_onto_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedbc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::unproject_onto_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const Eigen::Vector3f &amp;, const Eigen::Vector3f &amp;, <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &amp;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>shoot_ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedbc &gt; &amp;&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shoot_ray</td><td>function handle that outputs hits of a given ray against a mesh (embedded in function handles as captured variable/data) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a171d8ab81ed0ba003408f162c80a5505" name="a171d8ab81ed0ba003408f162c80a5505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171d8ab81ed0ba003408f162c80a5505">&#9670;&#160;</a></span>unproject_ray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedpos , typename Derivedmodel , typename Derivedproj , typename Derivedviewport , typename Deriveds , typename Deriveddir &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unproject_ray </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedpos &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedmodel &gt; &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedproj &gt; &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedviewport &gt; &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Deriveds &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Deriveddir &gt; &amp;&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a ray (source point + direction vector) given a screen space positions (e.g. </p>
<p>mouse) and a model-view projection constellation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>2d screen-space position (x,y) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>4x4 model-view matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>4x4 projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>4-long viewport vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>source of ray (pos unprojected with z=0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dir</td><td>direction of ray (d - s) where d is pos unprojected with z=1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a681d80aaa80e594a1983b10aaf6006fd" name="a681d80aaa80e594a1983b10aaf6006fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681d80aaa80e594a1983b10aaf6006fd">&#9670;&#160;</a></span>unzip_corners()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedU , typename DerivedG , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::unzip_corners </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::reference_wrapper&lt; DerivedA &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedU &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a triangle mesh where corners of each triangle index different matrices of attributes (e.g. </p>
<p>read from an OBJ file), unzip the corners into unique efficiently: attributes become properly vertex valued (usually creating greater than #V but less than #F*3 vertices).</p>
<p>To pass a list of attributes this function takes an std::vector of std::reference_wrapper of an Eigen::... type. This allows you to use list initializers <b>without</b> incurring a copy, but means you'll need to provide the derived type of A as an explicit template parameter: </p><pre class="fragment"> unzip_corners&lt;Eigen::MatrixXi&gt;({F,FTC,FN},U,G,J);
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#A list of #F by 3 attribute indices, typically {F,FTC,FN} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#U by #A list of indices into each attribute for each unique mesh vertex: U(v,a) is the attribute index of vertex v in attribute a. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#F by 3 list of triangle indices into U </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F*3 by 1 list of indices so that A[](i,j) = U.row(i+j*#F)</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md40"></a>
Matlibberish Example</h4>
<p>[V,F,TC,FTC] = readOBJ('~/Downloads/kiwis/kiwi.obj'); [U,G] = unzip_corners(cat(3,F,FTC)); % display mesh tsurf(G,V(U(:,1),:)); % display texture coordinates tsurf(G,TC(U(:,2),:)); </p>

</div>
</div>
<a id="a7897e133babd19415648e5aaef9cc63a" name="a7897e133babd19415648e5aaef9cc63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7897e133babd19415648e5aaef9cc63a">&#9670;&#160;</a></span>upsample() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename SType , typename DerivedNF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::upsample </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n_verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; SType &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide without moving vertices: Given the triangle mesh [V, F], where n_verts = V.rows(), computes newV and a sparse matrix S s.t. </p>
<p>[newV, newF] is the subdivided mesh where newV = S*V.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_verts</td><td>an integer (number of mesh vertices) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>an m by 3 matrix of integers of triangle faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>a sparse matrix (will become the subdivision matrix) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newF</td><td>a matrix containing the new faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22564028c3ea860f1dcfb72d48872602" name="a22564028c3ea860f1dcfb72d48872602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22564028c3ea860f1dcfb72d48872602">&#9670;&#160;</a></span>upsample() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedNV , typename DerivedNF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::upsample </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNV &gt; &amp;&#160;</td>
          <td class="paramname"><em>NV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNF &gt; &amp;&#160;</td>
          <td class="paramname"><em>NF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>number_of_subdivs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide a mesh without moving vertices: loop subdivision but odd vertices stay put and even vertices are just edge midpoints. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatV</td><td>matrix for vertex positions, e.g. MatrixXd </td></tr>
    <tr><td class="paramname">MatF</td><td>matrix for vertex positions, e.g. MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 mesh triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NV</td><td>new vertex positions, V is guaranteed to be at top </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NF</td><td>new list of face indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>V should not be the same as NV, </dd>
<dd>
F should not be the same as NF, use other proto</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>assumes (V,F) is edge-manifold. </dd></dl>

</div>
</div>
<a id="a9347f30f3803c2aa656a3b73ed9c02f5" name="a9347f30f3803c2aa656a3b73ed9c02f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9347f30f3803c2aa656a3b73ed9c02f5">&#9670;&#160;</a></span>upsample() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatV , typename MatF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::upsample </td>
          <td>(</td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatF &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>number_of_subdivs</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a3e7408bbfe1e7f478d79af1ab05dc0" name="a4a3e7408bbfe1e7f478d79af1ab05dc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3e7408bbfe1e7f478d79af1ab05dc0">&#9670;&#160;</a></span>vector_area_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vector_area_matrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::SparseMatrix&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs the symmetric area matrix A, s.t. </p>
<p>[V.col(0)' V.col(1)'] * A * [V.col(0); V.col(1)] is the <b>vector area</b> of the mesh (V,F).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>derived type of eigen matrix for V (e.g. derived from MatrixXd) </td></tr>
    <tr><td class="paramname">DerivedF</td><td>derived type of eigen matrix for F (e.g. derived from MatrixXi) </td></tr>
    <tr><td class="paramname">Scalar</td><td>scalar type for eigen sparse matrix (e.g. double) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#Vx2 by #Vx2 area matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1052b6f357eb1bcc4258d45490d866ad" name="a1052b6f357eb1bcc4258d45490d866ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1052b6f357eb1bcc4258d45490d866ad">&#9670;&#160;</a></span>verbose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int igl::verbose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a wrapper for printf, called verbose that functions exactly like printf if VERBOSE is defined and does exactly nothing if VERBOSE is undefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>printf style format string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>printf style arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters printed </dd></dl>

</div>
</div>
<a id="ab8159118b103ccc116d788259917acdb" name="ab8159118b103ccc116d788259917acdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8159118b103ccc116d788259917acdb">&#9670;&#160;</a></span>vertex_components() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedC , typename Derivedcounts &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vertex_components </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedcounts &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute connected components of a graph represented by an adjacency matrix. </p>
<p>Outputs a component ID per vertex of the graph where connectivity is established by edges.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>n by n adjacency matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>n list of component ids (starting with 0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>#components list of counts for each component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a669ae9814690f3c0f466cfae73890263" name="a669ae9814690f3c0f466cfae73890263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669ae9814690f3c0f466cfae73890263">&#9670;&#160;</a></span>vertex_components() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vertex_components </td>
          <td>(</td>
          <td class="paramtype">const Eigen::SparseCompressedBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1cfebfe524e61fecdadf7d789ddb9ec9" name="a1cfebfe524e61fecdadf7d789ddb9ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfebfe524e61fecdadf7d789ddb9ec9">&#9670;&#160;</a></span>vertex_components() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vertex_components </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the connected components for a mesh given its faces. </p>
<p>Returns a component ID per vertex of the mesh where connectivity is established by edges.</p>
<p>For computing connected components per face see <a class="el" href="namespaceigl.html#a7823f08d518cb237ee3cb47bb03cdb6d" title="Compute connected components of facets based on edge-edge adjacency.">igl::facet_components</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>n by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>max(F) list of component ids </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acabdf409439e0498066a620d30db6899" name="acabdf409439e0498066a620d30db6899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdf409439e0498066a620d30db6899">&#9670;&#160;</a></span>vertex_triangle_adjacency() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename VFType , typename VFiType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vertex_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const typename DerivedF::Scalar&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VFType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; VFiType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VFi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vertex_face_adjacency constructs the vertex-face topology of a given mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of vertices #V (e.g. <code>F.maxCoeff()+1</code> or <code>V.rows()</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh faces (must be triangles) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VF</td><td>#V list of lists of incident faces (adjacency list) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VI</td><td>#V list of lists of index of incidence within incident faces listed in VF</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a0efd6c6b371a55178d53cf0afacf34ee" title="Constructs a list of unique edges represented in a given mesh (V,F)">edges</a>, <a class="el" href="namespaceigl.html#acbfe6ae19ab6f94e36b3d92be1159fe9" title="Constructs the cotangent stiffness matrix (discrete laplacian) for a given mesh (V,...">cotmatrix</a>, diag, vv</dd></dl>

</div>
</div>
<a id="a44c886a9ced7765ce3e2f03332bbcf91" name="a44c886a9ced7765ce3e2f03332bbcf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c886a9ced7765ce3e2f03332bbcf91">&#9670;&#160;</a></span>vertex_triangle_adjacency() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vertex_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; IndexType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VFi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6e4082714e403404167543bddf89ba53" name="a6e4082714e403404167543bddf89ba53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4082714e403404167543bddf89ba53">&#9670;&#160;</a></span>vertex_triangle_adjacency() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedF , typename DerivedVF , typename DerivedNI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::vertex_triangle_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVF &gt; &amp;&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedNI &gt; &amp;&#160;</td>
          <td class="paramname"><em>NI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into some vertex list V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of vertices, #V (e.g., F.maxCoeff()+1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VF</td><td>3*#F list List of faces indice on each vertex, so that VF(NI(i)+j) = f, means that face f is the jth face (in no particular order) incident on vertex i. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">NI</td><td>#V+1 list cumulative sum of vertex-triangle degrees with a preceeding zero. "How many faces" have been seen before visiting this vertex and its incident faces. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a289cc75429d0c045af9eca70642b8f8a" name="a289cc75429d0c045af9eca70642b8f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289cc75429d0c045af9eca70642b8f8a">&#9670;&#160;</a></span>volume() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename Derivedvol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::volume </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedvol &gt; &amp;&#160;</td>
          <td class="paramname"><em>vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute volume for all tets of a given tet mesh (V,T) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T by 4 list of tet indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vol</td><td>#T list of tetrahedron volumes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab25567c5af213643fd332e32003e63b4" name="ab25567c5af213643fd332e32003e63b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25567c5af213643fd332e32003e63b4">&#9670;&#160;</a></span>volume() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedA , typename DerivedB , typename DerivedC , typename DerivedD , typename Derivedvol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::volume </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedvol &gt; &amp;&#160;</td>
          <td class="paramname"><em>vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>#V by dim list of first corner position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>#V by dim list of second corner position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#V by dim list of third corner position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>#V by dim list of fourth corner position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89ebffa70b6797c8fd0404da673aaf3c" name="a89ebffa70b6797c8fd0404da673aaf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ebffa70b6797c8fd0404da673aaf3c">&#9670;&#160;</a></span>volume_single()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VecA , typename VecB , typename VecC , typename VecD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VecA::Scalar igl::volume_single </td>
          <td>(</td>
          <td class="paramtype">const VecA &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecC &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecD &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Single tet </p>

</div>
</div>
<a id="a0da5bd53ebc802822b96aebabbfddfa1" name="a0da5bd53ebc802822b96aebabbfddfa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da5bd53ebc802822b96aebabbfddfa1">&#9670;&#160;</a></span>volume() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedL , typename Derivedvol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::volume </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedvol &gt; &amp;&#160;</td>
          <td class="paramname"><em>vol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Intrinsic version:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>#V by 6 list of edge lengths (see edge_lengths) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbd087fd838f29b3d9e50ef45403f2ce" name="adbd087fd838f29b3d9e50ef45403f2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd087fd838f29b3d9e50ef45403f2ce">&#9670;&#160;</a></span>voxel_grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename DerivedGV , typename Derivedside &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::voxel_grid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::AlignedBox&lt; Scalar, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pad_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedside &gt; &amp;&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the cell center positions of a regular voxel grid (lattice) made of perfectly square voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>bounding box to enclose by grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>number of cell centers on largest side (including 2*pad_count) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pad_count</td><td>number of cells beyond box </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">GV</td><td>side(0)*side(1)*side(2) by 3 list of cell center positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">side</td><td>1 by 3 list of dimension of voxel grid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a467c3ec21d8d152e2e6aaf04ef8ab1da" name="a467c3ec21d8d152e2e6aaf04ef8ab1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467c3ec21d8d152e2e6aaf04ef8ab1da">&#9670;&#160;</a></span>voxel_grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedGV , typename Derivedside &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::voxel_grid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Scalar&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>pad_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedGV &gt; &amp;&#160;</td>
          <td class="paramname"><em>GV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedside &gt; &amp;&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>offset to add to each cell center </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a468f01ca961ac9ea78d02b3ecac25bee" name="a468f01ca961ac9ea78d02b3ecac25bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468f01ca961ac9ea78d02b3ecac25bee">&#9670;&#160;</a></span>winding_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedO , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>O</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the generalized winding number at each dim-dimensional query point in O with respect to the oriented one-codimensional mesh (V,F). </p>
<p>This is equivalent to summing the subtended signed angles/solid angles of each element in (V,F). See, "Robust
Inside-Outside Segmentation using Generalized Winding Numbers" [Jacobson et al. 2013].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of mesh facets as indices into rows of V. If dim==2, then (V,F) describes a set of edges in the plane. If dim==3, then (V,F) describes a triangle mesh/soup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">O</td><td>#O by dim list of query points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#O by 1 list of winding numbers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#af9a50987fefc0df065fb3e2cde90c92e" title="Generate the precomputation for the fast winding number for point data [Barill et.">fast_winding_number</a> </dd></dl>

</div>
</div>
<a id="a6aab3f308b50dd0cafa361fed13ee213" name="a6aab3f308b50dd0cafa361fed13ee213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aab3f308b50dd0cafa361fed13ee213">&#9670;&#160;</a></span>winding_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DerivedV::Scalar igl::winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedp &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute winding number of a single point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>n by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by dim list of triangle indices, minimum index is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>single origin position </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>winding number of this point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10e48891b5b843708fd73f095a5f96c" name="aa10e48891b5b843708fd73f095a5f96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10e48891b5b843708fd73f095a5f96c">&#9670;&#160;</a></span>write_triangle_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::write_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em> = <code><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">FileEncoding::Ascii</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write mesh to a file with automatic detection of file format. </p>
<p>supported: obj, off, stl, wrl, ply, mesh).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>eigen double matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>eigen int matrix #F by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoding</td><td>set file encoding (ascii or binary) when both are available </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff success </dd></dl>

</div>
</div>
<a id="a95b5e18062898bc13278debb80127424" name="a95b5e18062898bc13278debb80127424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b5e18062898bc13278debb80127424">&#9670;&#160;</a></span>writeBF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedWI , typename DerivedP , typename DerivedO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeBF </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedWI &gt; &amp;&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedO &gt; &amp;&#160;</td>
          <td class="paramname"><em>O</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a bones forest to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>path to .bf bones tree file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WI</td><td>#B list of unique weight indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#B list of parent indices into B, -1 for roots </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">O</td><td>#B list of tip offsets </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a4efbc110f683b253ef703142d1406f28" title="Read a bones forest from a file, returns a list of bone roots.">readBF</a> </dd></dl>

</div>
</div>
<a id="a8159d2953cb18953457a90976885ff57" name="a8159d2953cb18953457a90976885ff57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8159d2953cb18953457a90976885ff57">&#9670;&#160;</a></span>writeDMAT() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeDMAT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascii</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a matrix using ascii dmat file type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat</td><td>matrix type that supports .rows(), .cols(), operator(i,j) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_name</td><td>path to .dmat file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">W</td><td>eigen matrix containing to-be-written coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ascii</td><td>write ascii file {true} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a44a50547ab59bcb0705475875bb39a7d" title="Read a matrix from an .dmat file.">readDMAT</a> </dd></dl>

</div>
</div>
<a id="a24f57ac9b3108c7e4e62890786a69337" name="a24f57ac9b3108c7e4e62890786a69337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f57ac9b3108c7e4e62890786a69337">&#9670;&#160;</a></span>writeDMAT() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeDMAT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascii</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ace5cabc9f902b654e3a9169855250e7c" name="ace5cabc9f902b654e3a9169855250e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5cabc9f902b654e3a9169855250e7c">&#9670;&#160;</a></span>writeDMAT() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeDMAT </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>ascii</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6a6b14a1061d9ce7d0ef20880e604186" name="a6a6b14a1061d9ce7d0ef20880e604186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a6b14a1061d9ce7d0ef20880e604186">&#9670;&#160;</a></span>writeMESH() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeMESH </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>mesh_file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save a tetrahedral volume mesh to a .mesh file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be cast as double) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be cast to int) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_file_name</td><td>path of .mesh file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>double matrix of vertex positions #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#T list of tet indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F list of face indices into vertex positions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors</dd></dl>

</div>
</div>
<a id="ac173c671f0c9f633abe3daa005455507" name="ac173c671f0c9f633abe3daa005455507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac173c671f0c9f633abe3daa005455507">&#9670;&#160;</a></span>writeMESH() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedT , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeMESH </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>save a tetrahedral volume mesh to a .mesh file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedV</td><td>real-value: i.e. from MatrixXd </td></tr>
    <tr><td class="paramname">DerivedT</td><td>integer-value: i.e. from MatrixXi </td></tr>
    <tr><td class="paramname">DerivedF</td><td>integer-value: i.e. from MatrixXi </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_file_name</td><td>path of .mesh file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>eigen double matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>eigen int matrix #T by 4 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>eigen int matrix #F by 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="a2df694c52f937d065a10d20c184ddfc4" name="a2df694c52f937d065a10d20c184ddfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df694c52f937d065a10d20c184ddfc4">&#9670;&#160;</a></span>writeMSH()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeMSH </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>Tri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>Tet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>TriTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>TetTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>XFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>XF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>EFields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>TriF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>TetF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write triangle surface mesh and tetrahedral volume mesh to .msh file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msh</td><td>- file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>eigen double matrix of vertex positions #X by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tri</td><td>#Tri eigen integer matrix of triangular faces indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tet</td><td>#Tet eigen integer matrix of tetrahedral indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TriTag</td><td>#Tri eigen integer vector of tags associated with surface faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TetTag</td><td>#Tet eigen integer vector of tags associated with volume elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XFields</td><td>#XFields list of strings with field names associated with nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XF</td><td>#XFields list of eigen double matrices, fields associated with nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EFields</td><td>#EFields list of strings with field names associated with elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TriF</td><td>#EFields list of eigen double matrices, fields associated with surface elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TetF</td><td>#EFields list of eigen double matrices, fields associated with volume elements</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a1761a85ec5cdef44ce8104d0ccdc3f" name="a1a1761a85ec5cdef44ce8104d0ccdc3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1761a85ec5cdef44ce8104d0ccdc3f">&#9670;&#160;</a></span>writeOBJ() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedCN , typename DerivedFN , typename DerivedTC , typename DerivedFTC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedCN &gt; &amp;&#160;</td>
          <td class="paramname"><em>CN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFN &gt; &amp;&#160;</td>
          <td class="paramname"><em>FN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedTC &gt; &amp;&#160;</td>
          <td class="paramname"><em>TC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFTC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FTC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a mesh in an ascii obj file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to outputfile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3|4 mesh indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CN</td><td>#CN by 3 normal vectors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FN</td><td>#F by 3|4 corner normal indices into CN </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TC</td><td>#TC by 2|3 texture coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FTC</td><td>#F by 3|4 corner texture coord indices into TC </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#ad3d68499324615abfb462bf80130431b" title="Read a mesh from an ascii obj file, filling in vertex positions, normals and texture coordinates.">readOBJ</a> </dd></dl>

</div>
</div>
<a id="ad361555ef88be9751c1940298028a4a3" name="ad361555ef88be9751c1940298028a4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad361555ef88be9751c1940298028a4a3">&#9670;&#160;</a></span>writeOBJ() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5acdf796fe0c739fd37989deb859f564" name="a5acdf796fe0c739fd37989deb859f564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acdf796fe0c739fd37989deb859f564">&#9670;&#160;</a></span>writeOBJ() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeOBJ </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a mesh of mixed tris and quads to an ascii obj file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to outputfile </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F std::vector of std::vector&lt;Index&gt; of size 3 or 4 mesh indices into V </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on error </dd></dl>

</div>
</div>
<a id="a3c26424f96cf3b86305b18dd91dd0c83" name="a3c26424f96cf3b86305b18dd91dd0c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c26424f96cf3b86305b18dd91dd0c83">&#9670;&#160;</a></span>writeOFF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeOFF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Export geometry and colors-by-vertex to an ascii OFF file. </p>
<p>Only triangle meshes are supported</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
    <tr><td class="paramname">Index</td><td>type for indices (will be read as int and cast to Index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to .off output file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 mesh indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>double matrix of rgb values per vertex #V by 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="ab9d5937707edc99d534ccab39d14429c" name="ab9d5937707edc99d534ccab39d14429c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d5937707edc99d534ccab39d14429c">&#9670;&#160;</a></span>writeOFF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeOFF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ad75b8abd010b0cc4ce47469b3f855e42" name="ad75b8abd010b0cc4ce47469b3f855e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad75b8abd010b0cc4ce47469b3f855e42">&#9670;&#160;</a></span>writePLY() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ply_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>VDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFD &gt; &amp;&#160;</td>
          <td class="paramname"><em>FD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>FDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedED &gt; &amp;&#160;</td>
          <td class="paramname"><em>ED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>EDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write triangular mesh to ply file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Derived</td><td>from Eigen matrix parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ply_stream</td><td>ply file output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>(#V,3) matrix of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>(#F,3) list of face indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>(#E,2) list of edge indices into vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>(#V,3) list of normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UV</td><td>(#V,2) list of texture coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VD</td><td>(#V,*) additional vertex data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Vheader</td><td>(#V) list of vertex data headers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FD</td><td>(#F,*) additional face data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Fheader</td><td>(#F) list of face data headers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ED</td><td>(#E,*) additional edge data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Eheader</td><td>(#E) list of edge data headers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comments</td><td>(*) file comments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoding</td><td>- enum, to set binary or ascii file format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="ab97df6737c8ab9d4d1c9093491d41c2a" name="ab97df6737c8ab9d4d1c9093491d41c2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97df6737c8ab9d4d1c9093491d41c2a">&#9670;&#160;</a></span>writePLY() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD , typename DerivedFD , typename DerivedED &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>VDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFD &gt; &amp;&#160;</td>
          <td class="paramname"><em>FD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>FDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedED &gt; &amp;&#160;</td>
          <td class="paramname"><em>ED</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>EDheader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>path to .ply file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a089a8c3e1a12d0ad0be24eb7b9b35f47" name="a089a8c3e1a12d0ad0be24eb7b9b35f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089a8c3e1a12d0ad0be24eb7b9b35f47">&#9670;&#160;</a></span>writePLY() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0f47de9a532d3a6d2ccc94267d3806f2" name="a0f47de9a532d3a6d2ccc94267d3806f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f47de9a532d3a6d2ccc94267d3806f2">&#9670;&#160;</a></span>writePLY() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a21c501124b7b44b6adf81a2a11a1fea2" name="a21c501124b7b44b6adf81a2a11a1fea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c501124b7b44b6adf81a2a11a1fea2">&#9670;&#160;</a></span>writePLY() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedUV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a263e6503e126ed829c6a3e3e9c188110" name="a263e6503e126ed829c6a3e3e9c188110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263e6503e126ed829c6a3e3e9c188110">&#9670;&#160;</a></span>writePLY() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abe192d7895221e908003d65ab544d24f" name="abe192d7895221e908003d65ab544d24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe192d7895221e908003d65ab544d24f">&#9670;&#160;</a></span>writePLY() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a689ca1568cfbecb2d29a1c37d6f38e7b" name="a689ca1568cfbecb2d29a1c37d6f38e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689ca1568cfbecb2d29a1c37d6f38e7b">&#9670;&#160;</a></span>writePLY() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0c7f6c3884f0355670c8fcdb36923671" name="a0c7f6c3884f0355670c8fcdb36923671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7f6c3884f0355670c8fcdb36923671">&#9670;&#160;</a></span>writePLY() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedUV , typename DerivedVD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em> = <code>Eigen::MatrixXd(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>VDheader</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comments</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aedef9e44fe11f235719d619185e404b7" name="aedef9e44fe11f235719d619185e404b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedef9e44fe11f235719d619185e404b7">&#9670;&#160;</a></span>writePLY() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedE , typename DerivedN , typename DerivedUV , typename DerivedVD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writePLY </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedUV &gt; &amp;&#160;</td>
          <td class="paramname"><em>UV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVD &gt; &amp;&#160;</td>
          <td class="paramname"><em>VD</em> = <code>Eigen::MatrixXd(0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>VDheader</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>comments</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a07adddd7239a8b049f1383c09d78d245" name="a07adddd7239a8b049f1383c09d78d245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07adddd7239a8b049f1383c09d78d245">&#9670;&#160;</a></span>writeSTL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeSTL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em> = <code><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">FileEncoding::Ascii</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a mesh to an stl file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>type for positions and vectors (will be read as double and cast to Scalar) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>path to .obj file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>double matrix of vertex positions #F*3 by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>index matrix of triangle indices #F by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>double matrix of vertex positions #F by 3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">encoding</td><td>enum to set file encoding (ascii by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on errors </dd></dl>

</div>
</div>
<a id="a13c6477f242f1c28b713fc41205f21db" name="a13c6477f242f1c28b713fc41205f21db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c6477f242f1c28b713fc41205f21db">&#9670;&#160;</a></span>writeSTL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeSTL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbf">FileEncoding</a>&#160;</td>
          <td class="paramname"><em>encoding</em> = <code><a class="el" href="namespaceigl.html#a85ec0330094fed10f10bb12010bbcdbfa76b8d0dcd02ccaf203c167ced6d7ef31">FileEncoding::Ascii</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae98f5c58b4e2db831a37794d14e68190" name="ae98f5c58b4e2db831a37794d14e68190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98f5c58b4e2db831a37794d14e68190">&#9670;&#160;</a></span>writeTGF() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeTGF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tgf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a graph to a .tgf file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>.tgf file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td># vertices by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td># edges by 2 list of edge indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes that graph vertices are 3 dimensional</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a0e2ff313a45b1882bc42711ef59518ea" title="Read a graph from a .tgf file.">readTGF</a> </dd></dl>

</div>
</div>
<a id="a217cf16c6a0be84701d89c49b3337ff4" name="a217cf16c6a0be84701d89c49b3337ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217cf16c6a0be84701d89c49b3337ff4">&#9670;&#160;</a></span>writeTGF() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeTGF </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>tgf_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0cfecc2999b584fe90aa57e9e6538ddd" name="a0cfecc2999b584fe90aa57e9e6538ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfecc2999b584fe90aa57e9e6538ddd">&#9670;&#160;</a></span>writeWRL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeWRL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write mesh to a .wrl file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to .wrl file </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff succes </dd></dl>

</div>
</div>
<a id="a315f62cc42f483bf2651f05eb1fd6d71" name="a315f62cc42f483bf2651f05eb1fd6d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315f62cc42f483bf2651f05eb1fd6d71">&#9670;&#160;</a></span>writeWRL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::writeWRL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>double matrix of rgb values per vertex #V by 3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4132693fc82720d3e947c09aad236d96" name="a4132693fc82720d3e947c09aad236d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4132693fc82720d3e947c09aad236d96">&#9670;&#160;</a></span>IDENTITY_QUAT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::IDENTITY_QUAT_F[4] = {0,0,0,1}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc1c639c804d4e91dc1ffb424c5caf37" name="afc1c639c804d4e91dc1ffb424c5caf37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1c639c804d4e91dc1ffb424c5caf37">&#9670;&#160;</a></span>XY_PLANE_QUAT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::XY_PLANE_QUAT_F[4] = {0,0,0,1}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf4ae9044c47ccad908df3775523d731" name="adf4ae9044c47ccad908df3775523d731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4ae9044c47ccad908df3775523d731">&#9670;&#160;</a></span>XZ_PLANE_QUAT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::XZ_PLANE_QUAT_F[4] = {-<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>,0,0,<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd154ccb32e580426fe71c29fccf45e8" name="abd154ccb32e580426fe71c29fccf45e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd154ccb32e580426fe71c29fccf45e8">&#9670;&#160;</a></span>YZ_PLANE_QUAT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::YZ_PLANE_QUAT_F[4] = {-0.5,-0.5,-0.5,0.5}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab16914177d382aa61d647d2bdac2f61a" name="ab16914177d382aa61d647d2bdac2f61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16914177d382aa61d647d2bdac2f61a">&#9670;&#160;</a></span>CANONICAL_VIEW_QUAT_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::CANONICAL_VIEW_QUAT_F[][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d25a0a671a74bdb8bea35d6dc482d66" name="a4d25a0a671a74bdb8bea35d6dc482d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d25a0a671a74bdb8bea35d6dc482d66">&#9670;&#160;</a></span>IDENTITY_QUAT_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::IDENTITY_QUAT_D[4] = {0,0,0,1}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e0bd2386fb8512b5fccf9abaab47952" name="a1e0bd2386fb8512b5fccf9abaab47952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0bd2386fb8512b5fccf9abaab47952">&#9670;&#160;</a></span>XY_PLANE_QUAT_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::XY_PLANE_QUAT_D[4] = {0,0,0,1}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83519a14c0cfc4eb50105894232e10a4" name="a83519a14c0cfc4eb50105894232e10a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83519a14c0cfc4eb50105894232e10a4">&#9670;&#160;</a></span>XZ_PLANE_QUAT_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::XZ_PLANE_QUAT_D[4] = {-<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>,0,0,<a class="el" href="canonical__quaternions_8h.html#aeffaebb2528081eee665b34e5654a535">SQRT_2_OVER_2</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec963f40812a8ab05b4b6b370fce4cfd" name="aec963f40812a8ab05b4b6b370fce4cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec963f40812a8ab05b4b6b370fce4cfd">&#9670;&#160;</a></span>YZ_PLANE_QUAT_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::YZ_PLANE_QUAT_D[4] = {-0.5,-0.5,-0.5,0.5}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbe2a3410b25f28096dcde690d7df743" name="abbe2a3410b25f28096dcde690d7df743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe2a3410b25f28096dcde690d7df743">&#9670;&#160;</a></span>CANONICAL_VIEW_QUAT_D</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::CANONICAL_VIEW_QUAT_D[][4]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a959bd85cf0ed1b59e3a9ad857c953604" name="a959bd85cf0ed1b59e3a9ad857c953604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a959bd85cf0ed1b59e3a9ad857c953604">&#9670;&#160;</a></span>DOUBLE_EPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::DOUBLE_EPS = 1.0e-14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard value for double epsilon. </p>

</div>
</div>
<a id="ab4c4eb25dcc0beddf9732c13704a07b7" name="ab4c4eb25dcc0beddf9732c13704a07b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c4eb25dcc0beddf9732c13704a07b7">&#9670;&#160;</a></span>DOUBLE_EPS_SQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::DOUBLE_EPS_SQ = 1.0e-28</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard value for double epsilon² </p>

</div>
</div>
<a id="a7184cb6e2f319e3c31a0e1f5bc90354d" name="a7184cb6e2f319e3c31a0e1f5bc90354d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7184cb6e2f319e3c31a0e1f5bc90354d">&#9670;&#160;</a></span>FLOAT_EPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FLOAT_EPS = 1.0e-7f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard value for single epsilon. </p>

</div>
</div>
<a id="a529be4dc6f96c94adc21d8480d9d9bbf" name="a529be4dc6f96c94adc21d8480d9d9bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529be4dc6f96c94adc21d8480d9d9bbf">&#9670;&#160;</a></span>FLOAT_EPS_SQ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FLOAT_EPS_SQ = 1.0e-14f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard value for single epsilon² </p>

</div>
</div>
<a id="a2719a5fd20a68136038b7132136e74bf" name="a2719a5fd20a68136038b7132136e74bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2719a5fd20a68136038b7132136e74bf">&#9670;&#160;</a></span>GOLD_AMBIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::GOLD_AMBIENT[4] = { 51.0/255.0, 43.0/255.0,33.3/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8589d6f0c07c7387258e004cfade2567" name="a8589d6f0c07c7387258e004cfade2567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8589d6f0c07c7387258e004cfade2567">&#9670;&#160;</a></span>GOLD_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::GOLD_DIFFUSE[4] = { 255.0/255.0,228.0/255.0,58.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63110eff6fbd6ded60fc3c4a004c1ac3" name="a63110eff6fbd6ded60fc3c4a004c1ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63110eff6fbd6ded60fc3c4a004c1ac3">&#9670;&#160;</a></span>GOLD_SPECULAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::GOLD_SPECULAR[4] = { 255.0/255.0,235.0/255.0,80.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cea9492c40178a4255d810a81b27abb" name="a2cea9492c40178a4255d810a81b27abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cea9492c40178a4255d810a81b27abb">&#9670;&#160;</a></span>SILVER_AMBIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::SILVER_AMBIENT[4] = { 0.2f, 0.2f, 0.2f, 1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a285eccdcab39b99b34da071d0e811328" name="a285eccdcab39b99b34da071d0e811328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285eccdcab39b99b34da071d0e811328">&#9670;&#160;</a></span>SILVER_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::SILVER_DIFFUSE[4] = { 1.0f, 1.0f, 1.0f, 1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adde55f12f19663cc168932e3cbaa1033" name="adde55f12f19663cc168932e3cbaa1033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde55f12f19663cc168932e3cbaa1033">&#9670;&#160;</a></span>SILVER_SPECULAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::SILVER_SPECULAR[4] = { 1.0f, 1.0f, 1.0f, 1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41f327ea1271a24126e5b54b58137207" name="a41f327ea1271a24126e5b54b58137207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f327ea1271a24126e5b54b58137207">&#9670;&#160;</a></span>CYAN_AMBIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::CYAN_AMBIENT[4] = { 59.0/255.0, 68.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa91b40d8001ba8a6732b57ea544e3cff" name="aa91b40d8001ba8a6732b57ea544e3cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91b40d8001ba8a6732b57ea544e3cff">&#9670;&#160;</a></span>CYAN_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::CYAN_DIFFUSE[4] = { 94.0/255.0,185.0/255.0,238.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2aa44781d95faf982b844c0aa39b3138" name="a2aa44781d95faf982b844c0aa39b3138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa44781d95faf982b844c0aa39b3138">&#9670;&#160;</a></span>CYAN_SPECULAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::CYAN_SPECULAR[4] = { 163.0/255.0,221.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35121926b4786e30ae17f9f96c2657c6" name="a35121926b4786e30ae17f9f96c2657c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35121926b4786e30ae17f9f96c2657c6">&#9670;&#160;</a></span>DENIS_PURPLE_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::DENIS_PURPLE_DIFFUSE[4] = { 80.0/255.0,64.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31d9148951bd2c269433253e37bdb5fa" name="a31d9148951bd2c269433253e37bdb5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d9148951bd2c269433253e37bdb5fa">&#9670;&#160;</a></span>LADISLAV_ORANGE_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::LADISLAV_ORANGE_DIFFUSE[4] = {1.0f, 125.0f / 255.0f, 19.0f / 255.0f, 0.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ef7cc70cc21ec016debd929ca40cb25" name="a3ef7cc70cc21ec016debd929ca40cb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef7cc70cc21ec016debd929ca40cb25">&#9670;&#160;</a></span>FAST_GREEN_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FAST_GREEN_DIFFUSE[4] = { 113.0f/255.0f, 239.0f/255.0f, 46.0f/255.0f, 1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6d07e97190e3d6eb57c438d929fd9f7" name="af6d07e97190e3d6eb57c438d929fd9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d07e97190e3d6eb57c438d929fd9f7">&#9670;&#160;</a></span>FAST_RED_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FAST_RED_DIFFUSE[4] = { 255.0f/255.0f, 65.0f/255.0f, 46.0f/255.0f, 1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81c3adfdf58bb4b9041258ed528419d8" name="a81c3adfdf58bb4b9041258ed528419d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c3adfdf58bb4b9041258ed528419d8">&#9670;&#160;</a></span>FAST_BLUE_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FAST_BLUE_DIFFUSE[4] = { 106.0f/255.0f, 106.0f/255.0f, 255.0f/255.0f, 1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a8c0ec0db4f21074319658ec9cda122" name="a1a8c0ec0db4f21074319658ec9cda122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a8c0ec0db4f21074319658ec9cda122">&#9670;&#160;</a></span>FAST_GRAY_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FAST_GRAY_DIFFUSE[4] = { 150.0f/255.0f, 150.0f/255.0f, 150.0f/255.0f, 1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42bdfa6acbe2c64f29cbd31426c86bfb" name="a42bdfa6acbe2c64f29cbd31426c86bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bdfa6acbe2c64f29cbd31426c86bfb">&#9670;&#160;</a></span>WHITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::WHITE[4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba9827caee2da38a16d2578ad87c18b8" name="aba9827caee2da38a16d2578ad87c18b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9827caee2da38a16d2578ad87c18b8">&#9670;&#160;</a></span>BLACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::BLACK[4] = { 0.0/255.0,0.0/255.0,0.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ace1077f98e7c25d1b590afc21001d4" name="a4ace1077f98e7c25d1b590afc21001d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ace1077f98e7c25d1b590afc21001d4">&#9670;&#160;</a></span>WHITE_AMBIENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::WHITE_AMBIENT[4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af258223de150eac4510266bce6c15adc" name="af258223de150eac4510266bce6c15adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af258223de150eac4510266bce6c15adc">&#9670;&#160;</a></span>WHITE_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::WHITE_DIFFUSE[4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa83f669c0c7352ed86d6991e28616eed" name="aa83f669c0c7352ed86d6991e28616eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83f669c0c7352ed86d6991e28616eed">&#9670;&#160;</a></span>WHITE_SPECULAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::WHITE_SPECULAR[4] = { 255.0/255.0,255.0/255.0,255.0/255.0,1.0f }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d653f310491c5eeea8199df41a8506b" name="a8d653f310491c5eeea8199df41a8506b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d653f310491c5eeea8199df41a8506b">&#9670;&#160;</a></span>BBW_POINT_COLOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::BBW_POINT_COLOR[4] = {239./255.,213./255.,46./255.,255.0/255.0}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a441cf01da7bb4f7455fa87831cc862" name="a2a441cf01da7bb4f7455fa87831cc862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a441cf01da7bb4f7455fa87831cc862">&#9670;&#160;</a></span>BBW_LINE_COLOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::BBW_LINE_COLOR[4] = {106./255.,106./255.,255./255.,255./255.}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3443568d1ef02dea80982a3df4bbfec1" name="a3443568d1ef02dea80982a3df4bbfec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3443568d1ef02dea80982a3df4bbfec1">&#9670;&#160;</a></span>MIDNIGHT_BLUE_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::MIDNIGHT_BLUE_DIFFUSE[4] = { 21.0f/255.0f, 27.0f/255.0f, 84.0f/255.0f, 1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9c277b6c43132159685619ae7e56d38" name="aa9c277b6c43132159685619ae7e56d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c277b6c43132159685619ae7e56d38">&#9670;&#160;</a></span>EASTER_RED_DIFFUSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::EASTER_RED_DIFFUSE[4] = {0.603922,0.494118f,0.603922f,1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af16c584a27f3dcfaa597e5864861931f" name="af16c584a27f3dcfaa597e5864861931f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af16c584a27f3dcfaa597e5864861931f">&#9670;&#160;</a></span>WN_OPEN_BOUNDARY_COLOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::WN_OPEN_BOUNDARY_COLOR[4] = {154./255.,0./255.,0./255.,1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a147760067e19822d9de2d3386c607b6e" name="a147760067e19822d9de2d3386c607b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147760067e19822d9de2d3386c607b6e">&#9670;&#160;</a></span>WN_NON_MANIFOLD_EDGE_COLOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::WN_NON_MANIFOLD_EDGE_COLOR[4] = {201./255., 51./255.,255./255.,1.0f}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a417e9fcd5135f9dfc60524331328b9d8" name="a417e9fcd5135f9dfc60524331328b9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417e9fcd5135f9dfc60524331328b9d8">&#9670;&#160;</a></span>CHAR_ONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char igl::CHAR_ONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Often one needs a reference to a dummy variable containing one as its value, for example when using AntTweakBar's TwSetParam( "3D View", "opened", TW_PARAM_INT32, 1, &amp;INT_ONE);. </p>

</div>
</div>
<a id="a13bf1ec6ed30256c1043772e67394b33" name="a13bf1ec6ed30256c1043772e67394b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bf1ec6ed30256c1043772e67394b33">&#9670;&#160;</a></span>INT_ONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int igl::INT_ONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57884543ce9ab8f3b3b1f9ffbef9a977" name="a57884543ce9ab8f3b3b1f9ffbef9a977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57884543ce9ab8f3b3b1f9ffbef9a977">&#9670;&#160;</a></span>UNSIGNED_INT_ONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int igl::UNSIGNED_INT_ONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad63b4ffb0ea045dc3cd8a516ba072090" name="ad63b4ffb0ea045dc3cd8a516ba072090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63b4ffb0ea045dc3cd8a516ba072090">&#9670;&#160;</a></span>DOUBLE_ONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::DOUBLE_ONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7ed44be1be4ade1ba7a4e7b382085db" name="af7ed44be1be4ade1ba7a4e7b382085db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ed44be1be4ade1ba7a4e7b382085db">&#9670;&#160;</a></span>FLOAT_ONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FLOAT_ONE = 1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3c65fcb2a063b19e572a9d982b5dcdc" name="af3c65fcb2a063b19e572a9d982b5dcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c65fcb2a063b19e572a9d982b5dcdc">&#9670;&#160;</a></span>PI</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double igl::PI = 3.1415926535897932384626433832795</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>π </p>

</div>
</div>
<a id="a89d712ab3a824b8712b6f228dc8242cf" name="a89d712ab3a824b8712b6f228dc8242cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d712ab3a824b8712b6f228dc8242cf">&#9670;&#160;</a></span>CHAR_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char igl::CHAR_ZERO = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad26002c6ec8c14b1b4a7acc5db59b1e4" name="ad26002c6ec8c14b1b4a7acc5db59b1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26002c6ec8c14b1b4a7acc5db59b1e4">&#9670;&#160;</a></span>INT_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int igl::INT_ZERO = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d956292d4f64a8ce6b1e1d92a9f9d24" name="a3d956292d4f64a8ce6b1e1d92a9f9d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d956292d4f64a8ce6b1e1d92a9f9d24">&#9670;&#160;</a></span>UNSIGNED_INT_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int igl::UNSIGNED_INT_ZERO = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1cef568dc365b5b596341a5b7f06867" name="af1cef568dc365b5b596341a5b7f06867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cef568dc365b5b596341a5b7f06867">&#9670;&#160;</a></span>DOUBLE_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double igl::DOUBLE_ZERO = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec3a0ea947dabbe9fc09e7e8da909613" name="aec3a0ea947dabbe9fc09e7e8da909613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3a0ea947dabbe9fc09e7e8da909613">&#9670;&#160;</a></span>FLOAT_ZERO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float igl::FLOAT_ZERO = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceigl.html">igl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
