<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libigl: igl::copyleft::cgal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libigl<span id="projectnumber">&#160;v2.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceigl_1_1copyleft_1_1cgal.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">igl::copyleft::cgal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary winding number operations.  <a href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__INTERSECT_01_4.html">BinaryWindingNumberOperations&lt; MESH_BOOLEAN_TYPE_INTERSECT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ∩ B ∩ ... ∩ Z.  <a href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__INTERSECT_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__MINUS_01_4.html">BinaryWindingNumberOperations&lt; MESH_BOOLEAN_TYPE_MINUS &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A \ B \ ... \ Z = A \ (B ∪ ... ∪ Z)  <a href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__MINUS_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__RESOLVE_01_4.html">BinaryWindingNumberOperations&lt; MESH_BOOLEAN_TYPE_RESOLVE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve all intersections without removing non-coplanar faces.  <a href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__RESOLVE_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__UNION_01_4.html">BinaryWindingNumberOperations&lt; MESH_BOOLEAN_TYPE_UNION &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ∪ B ∪ ... ∪ Z.  <a href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__UNION_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__XOR_01_4.html">BinaryWindingNumberOperations&lt; MESH_BOOLEAN_TYPE_XOR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ∆ B ∆ ... ∆ Z (equivalent to set inside odd number of objects)  <a href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations_3_01MESH__BOOLEAN__TYPE__XOR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1CSGTree.html">CSGTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for defining and computing a constructive solid geometry result out of a tree of boolean operations on "solid" triangle meshes.  <a href="classigl_1_1copyleft_1_1cgal_1_1CSGTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh.html" title="Class for computing the self-intersections of a mesh.">SelfIntersectMesh</a>, remesh_self_intersections and remesh_intersections, and intersect_other.  <a href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh.html">SelfIntersectMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing the self-intersections of a mesh.  <a href="classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter.html">WindingNumberFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter winding numbers according to keep policy.  <a href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter_3_01KEEP__ALL_01_4.html">WindingNumberFilter&lt; KEEP_ALL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep all policy.  <a href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter_3_01KEEP__ALL_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter_3_01KEEP__INSIDE_01_4.html">WindingNumberFilter&lt; KEEP_INSIDE &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep inside policy.  <a href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter_3_01KEEP__INSIDE_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a41dc481531d9dd2585c545308a2937d7" id="r_a41dc481531d9dd2585c545308a2937d7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt; <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056">MESH_BOOLEAN_TYPE_UNION</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a41dc481531d9dd2585c545308a2937d7">BinaryUnion</a></td></tr>
<tr class="separator:a41dc481531d9dd2585c545308a2937d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cad0d59d1e687e9faa8c93e15957b95" id="r_a3cad0d59d1e687e9faa8c93e15957b95"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt; <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34">MESH_BOOLEAN_TYPE_INTERSECT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3cad0d59d1e687e9faa8c93e15957b95">BinaryIntersect</a></td></tr>
<tr class="separator:a3cad0d59d1e687e9faa8c93e15957b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0880ae718ceaa681706d8b827d54fe" id="r_adb0880ae718ceaa681706d8b827d54fe"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt; <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80">MESH_BOOLEAN_TYPE_MINUS</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#adb0880ae718ceaa681706d8b827d54fe">BinaryMinus</a></td></tr>
<tr class="separator:adb0880ae718ceaa681706d8b827d54fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda076539de2c25a135eda9462171d87" id="r_acda076539de2c25a135eda9462171d87"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt; <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b">MESH_BOOLEAN_TYPE_XOR</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#acda076539de2c25a135eda9462171d87">BinaryXor</a></td></tr>
<tr class="separator:acda076539de2c25a135eda9462171d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac06a2805099d616ad29e497091315ac0" id="r_ac06a2805099d616ad29e497091315ac0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt; <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708">MESH_BOOLEAN_TYPE_RESOLVE</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac06a2805099d616ad29e497091315ac0">BinaryResolve</a></td></tr>
<tr class="separator:ac06a2805099d616ad29e497091315ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca810a2d57eab3749b7a4f9379a9f008" id="r_aca810a2d57eab3749b7a4f9379a9f008"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aca810a2d57eab3749b7a4f9379a9f008">KeepInside</a> = <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter.html">WindingNumberFilter</a>&lt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce">KEEP_INSIDE</a> &gt;</td></tr>
<tr class="separator:aca810a2d57eab3749b7a4f9379a9f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab770fd7d59c9d5b18d15351d8c13d1" id="r_aaab770fd7d59c9d5b18d15351d8c13d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aaab770fd7d59c9d5b18d15351d8c13d1">KeepAll</a> = <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter.html">WindingNumberFilter</a>&lt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844">KEEP_ALL</a> &gt;</td></tr>
<tr class="separator:aaab770fd7d59c9d5b18d15351d8c13d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a652b3870ca0cbdd378a3b383ba9bd5f2" id="r_a652b3870ca0cbdd378a3b383ba9bd5f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2">KeeperType</a> { <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce">KEEP_INSIDE</a>
, <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844">KEEP_ALL</a>
 }</td></tr>
<tr class="memdesc:a652b3870ca0cbdd378a3b383ba9bd5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Keep policies.  <a href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2">More...</a><br /></td></tr>
<tr class="separator:a652b3870ca0cbdd378a3b383ba9bd5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed8d1b22fc3cb87822647766b3dc863" id="r_a2ed8d1b22fc3cb87822647766b3dc863"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863">TrimWithSolidMethod</a> { <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863af6beb371c912a1daa28342fb54aa5644">CHECK_EACH_FACE</a> = 1
, <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863a2fa5c48d2f98ca34cd4cc7a247120d35">CHECK_EACH_PATCH</a> = 2
, <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863a1c69a30202b872a482875c36d59d9252">RESOLVE_BOTH_AND_RESTORE_THEN_CHECK_EACH_PATCH</a> = 3
 }</td></tr>
<tr class="separator:a2ed8d1b22fc3cb87822647766b3dc863"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a12c0c03c36999f6c7b35421c59ac9ca4" id="r_a12c0c03c36999f6c7b35421c59ac9ca4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC , typename DerivedD &gt; </td></tr>
<tr class="memitem:a12c0c03c36999f6c7b35421c59ac9ca4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a12c0c03c36999f6c7b35421c59ac9ca4">assign</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, const bool slow_and_more_precise, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:a12c0c03c36999f6c7b35421c59ac9ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector version of assign_scalar.  <br /></td></tr>
<tr class="separator:a12c0c03c36999f6c7b35421c59ac9ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ac4bd4ebabba6c96eb47d91a52bf2b" id="r_a76ac4bd4ebabba6c96eb47d91a52bf2b"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC , typename DerivedD &gt; </td></tr>
<tr class="memitem:a76ac4bd4ebabba6c96eb47d91a52bf2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a76ac4bd4ebabba6c96eb47d91a52bf2b">assign</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:a76ac4bd4ebabba6c96eb47d91a52bf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a76ac4bd4ebabba6c96eb47d91a52bf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab463bca3955e73d59383a31bdff724db" id="r_ab463bca3955e73d59383a31bdff724db"><td class="memTemplParams" colspan="2">template&lt;typename ReturnScalar , typename DerivedC &gt; </td></tr>
<tr class="memitem:ab463bca3955e73d59383a31bdff724db"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; ReturnScalar, DerivedC::RowsAtCompileTime, DerivedC::ColsAtCompileTime, 1, DerivedC::MaxRowsAtCompileTime, DerivedC::MaxColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ab463bca3955e73d59383a31bdff724db">assign</a> (const Eigen::MatrixBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:ab463bca3955e73d59383a31bdff724db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab463bca3955e73d59383a31bdff724db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed0cef244df8ed5e76d2d55af9d57a8" id="r_a5ed0cef244df8ed5e76d2d55af9d57a8"><td class="memTemplParams" colspan="2">template&lt;typename RHS , typename LHS &gt; </td></tr>
<tr class="memitem:a5ed0cef244df8ed5e76d2d55af9d57a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a5ed0cef244df8ed5e76d2d55af9d57a8">assign_scalar</a> (const RHS &amp;rhs, const bool &amp;slow_and_more_precise, LHS &amp;lhs)</td></tr>
<tr class="memdesc:a5ed0cef244df8ed5e76d2d55af9d57a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct the casting copy: lhs = rhs using <code>slow_and_more_precise</code> rounding if more desired.  <br /></td></tr>
<tr class="separator:a5ed0cef244df8ed5e76d2d55af9d57a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be1cc14112217171bd19402c493b3f6" id="r_a9be1cc14112217171bd19402c493b3f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a9be1cc14112217171bd19402c493b3f6">assign_scalar</a> (const CGAL::Epeck::FT &amp;cgal, CGAL::Epeck::FT &amp;d)</td></tr>
<tr class="memdesc:a9be1cc14112217171bd19402c493b3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a9be1cc14112217171bd19402c493b3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4577690cb751eced5a7579f08f0573" id="r_abd4577690cb751eced5a7579f08f0573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#abd4577690cb751eced5a7579f08f0573">assign_scalar</a> (const CGAL::Epeck::FT &amp;cgal, double &amp;d)</td></tr>
<tr class="memdesc:abd4577690cb751eced5a7579f08f0573"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abd4577690cb751eced5a7579f08f0573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335662495e808c70886c2e4d908c3e4f" id="r_a335662495e808c70886c2e4d908c3e4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a335662495e808c70886c2e4d908c3e4f">assign_scalar</a> (const CGAL::Epeck::FT &amp;cgal, float &amp;d)</td></tr>
<tr class="memdesc:a335662495e808c70886c2e4d908c3e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a335662495e808c70886c2e4d908c3e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9ac29ce05a74a311e52206293f83f7" id="r_a6f9ac29ce05a74a311e52206293f83f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a6f9ac29ce05a74a311e52206293f83f7">assign_scalar</a> (const double &amp;c, double &amp;d)</td></tr>
<tr class="separator:a6f9ac29ce05a74a311e52206293f83f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeb4c3f3e9b2e4b546bad7d1864f9ad" id="r_a7eeb4c3f3e9b2e4b546bad7d1864f9ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7eeb4c3f3e9b2e4b546bad7d1864f9ad">assign_scalar</a> (const float &amp;c, float &amp;d)</td></tr>
<tr class="memdesc:a7eeb4c3f3e9b2e4b546bad7d1864f9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7eeb4c3f3e9b2e4b546bad7d1864f9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2e0dfa178eeb9a6fb563eda548073" id="r_a3ec2e0dfa178eeb9a6fb563eda548073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3ec2e0dfa178eeb9a6fb563eda548073">assign_scalar</a> (const float &amp;c, double &amp;d)</td></tr>
<tr class="memdesc:a3ec2e0dfa178eeb9a6fb563eda548073"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3ec2e0dfa178eeb9a6fb563eda548073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c75726a89edabf3602ab1bdc4b1a6f8" id="r_a0c75726a89edabf3602ab1bdc4b1a6f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a0c75726a89edabf3602ab1bdc4b1a6f8">assign_scalar</a> (const CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;cgal, CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;d)</td></tr>
<tr class="memdesc:a0c75726a89edabf3602ab1bdc4b1a6f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0c75726a89edabf3602ab1bdc4b1a6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0a277a5e9ae4b929373f8a4b812caa" id="r_a7a0a277a5e9ae4b929373f8a4b812caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7a0a277a5e9ae4b929373f8a4b812caa">assign_scalar</a> (const CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;cgal, double &amp;d)</td></tr>
<tr class="memdesc:a7a0a277a5e9ae4b929373f8a4b812caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7a0a277a5e9ae4b929373f8a4b812caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b2bca21db0d19d293a93ff87246d3a" id="r_a76b2bca21db0d19d293a93ff87246d3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a76b2bca21db0d19d293a93ff87246d3a">assign_scalar</a> (const CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;cgal, float &amp;d)</td></tr>
<tr class="memdesc:a76b2bca21db0d19d293a93ff87246d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a76b2bca21db0d19d293a93ff87246d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1927287ea1fac749a475615e452d8b3" id="r_ab1927287ea1fac749a475615e452d8b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ab1927287ea1fac749a475615e452d8b3">assign_scalar</a> (const CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;cgal, CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;d)</td></tr>
<tr class="memdesc:ab1927287ea1fac749a475615e452d8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ab1927287ea1fac749a475615e452d8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268e7b784c30482867d062cdf2bd4235" id="r_a268e7b784c30482867d062cdf2bd4235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a268e7b784c30482867d062cdf2bd4235">assign_scalar</a> (const CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;cgal, double &amp;d)</td></tr>
<tr class="memdesc:a268e7b784c30482867d062cdf2bd4235"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a268e7b784c30482867d062cdf2bd4235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376e3a13203eae4eb9d3749dfb98e8f7" id="r_a376e3a13203eae4eb9d3749dfb98e8f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a376e3a13203eae4eb9d3749dfb98e8f7">assign_scalar</a> (const CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;cgal, float &amp;d)</td></tr>
<tr class="memdesc:a376e3a13203eae4eb9d3749dfb98e8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a376e3a13203eae4eb9d3749dfb98e8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f57dae2a4485cc2651abfb51f55cf0e" id="r_a5f57dae2a4485cc2651abfb51f55cf0e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedC &gt; </td></tr>
<tr class="memitem:a5f57dae2a4485cc2651abfb51f55cf0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a5f57dae2a4485cc2651abfb51f55cf0e">cell_adjacency</a> (const Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;per_patch_cells, const size_t num_cells, std::vector&lt; std::set&lt; std::tuple&lt; typename DerivedC::Scalar, bool, size_t &gt; &gt; &gt; &amp;<a class="el" href="namespaceigl.html#a4c905c0e9124bb38a79769497fa9b48b">adjacency_list</a>)</td></tr>
<tr class="memdesc:a5f57dae2a4485cc2651abfb51f55cf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine adjacency of cells.  <br /></td></tr>
<tr class="separator:a5f57dae2a4485cc2651abfb51f55cf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288a0d884f994aadcf7d8058b35113d8" id="r_a288a0d884f994aadcf7d8058b35113d8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename Kernel , typename DerivedR , typename DerivedS &gt; </td></tr>
<tr class="memitem:a288a0d884f994aadcf7d8058b35113d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a288a0d884f994aadcf7d8058b35113d8">closest_facet</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE, const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;VF, const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;VFi, const CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; typename Kernel::Triangle_3 &gt;::iterator &gt; &gt; &gt; &amp;tree, const std::vector&lt; typename Kernel::Triangle_3 &gt; &amp;triangles, const std::vector&lt; bool &gt; &amp;in_I, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a288a0d884f994aadcf7d8058b35113d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the closest facet for each of the input points.  <br /></td></tr>
<tr class="separator:a288a0d884f994aadcf7d8058b35113d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac948de3c14554d16b33cc16d7131a5f2" id="r_ac948de3c14554d16b33cc16d7131a5f2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedR , typename DerivedS &gt; </td></tr>
<tr class="memitem:ac948de3c14554d16b33cc16d7131a5f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac948de3c14554d16b33cc16d7131a5f2">closest_facet</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:ac948de3c14554d16b33cc16d7131a5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac948de3c14554d16b33cc16d7131a5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97e3b6b93bfa938e1f0a7bc2308ca40" id="r_af97e3b6b93bfa938e1f0a7bc2308ca40"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedR , typename DerivedS &gt; </td></tr>
<tr class="memitem:af97e3b6b93bfa938e1f0a7bc2308ca40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#af97e3b6b93bfa938e1f0a7bc2308ca40">closest_facet</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE, Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;R, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:af97e3b6b93bfa938e1f0a7bc2308ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af97e3b6b93bfa938e1f0a7bc2308ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccff123c73356ecd24f15f90143a4b7" id="r_a1ccff123c73356ecd24f15f90143a4b7"><td class="memTemplParams" colspan="2">template&lt;typename Tr , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a1ccff123c73356ecd24f15f90143a4b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1ccff123c73356ecd24f15f90143a4b7">complex_to_mesh</a> (const CGAL::Complex_2_in_triangulation_3&lt; Tr &gt; &amp;c2t3, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a1ccff123c73356ecd24f15f90143a4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a CGAL::Complex_2_in_triangulation_3 to a mesh (V,F)  <br /></td></tr>
<tr class="separator:a1ccff123c73356ecd24f15f90143a4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9135f1c36fb37be3a3dc9a924ef40fe6" id="r_a9135f1c36fb37be3a3dc9a924ef40fe6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a9135f1c36fb37be3a3dc9a924ef40fe6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a9135f1c36fb37be3a3dc9a924ef40fe6">component_inside_component</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V1, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F1, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I1, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V2, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F2, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I2)</td></tr>
<tr class="memdesc:a9135f1c36fb37be3a3dc9a924ef40fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if connected facet component (V1, F1, I1) is inside of connected facet component (V2, F2, I2).  <br /></td></tr>
<tr class="separator:a9135f1c36fb37be3a3dc9a924ef40fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01406d0fbbda3a765535e66ed8ee95a" id="r_ac01406d0fbbda3a765535e66ed8ee95a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ac01406d0fbbda3a765535e66ed8ee95a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac01406d0fbbda3a765535e66ed8ee95a">component_inside_component</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V1, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F1, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V2, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F2)</td></tr>
<tr class="memdesc:ac01406d0fbbda3a765535e66ed8ee95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac01406d0fbbda3a765535e66ed8ee95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28edab222791aa6fba773fb1216f592" id="r_ae28edab222791aa6fba773fb1216f592"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedW , typename DerivedG &gt; </td></tr>
<tr class="memitem:ae28edab222791aa6fba773fb1216f592"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ae28edab222791aa6fba773fb1216f592">convex_hull</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G)</td></tr>
<tr class="memdesc:ae28edab222791aa6fba773fb1216f592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points (V), compute the convex hull as a triangle mesh (W,G)  <br /></td></tr>
<tr class="separator:ae28edab222791aa6fba773fb1216f592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d6357a7a4ea861133f2983359ec4ef" id="r_ac3d6357a7a4ea861133f2983359ec4ef"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ac3d6357a7a4ea861133f2983359ec4ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac3d6357a7a4ea861133f2983359ec4ef">convex_hull</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ac3d6357a7a4ea861133f2983359ec4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac3d6357a7a4ea861133f2983359ec4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac00710a1dcb3c5d4a26e102f0f422" id="r_a84ac00710a1dcb3c5d4a26e102f0f422"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV &gt; </td></tr>
<tr class="memitem:a84ac00710a1dcb3c5d4a26e102f0f422"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a84ac00710a1dcb3c5d4a26e102f0f422">coplanar</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V)</td></tr>
<tr class="memdesc:a84ac00710a1dcb3c5d4a26e102f0f422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether all points are on same plane.  <br /></td></tr>
<tr class="separator:a84ac00710a1dcb3c5d4a26e102f0f422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a07bdc787f5318cc08c6496b4d72fa7" id="r_a7a07bdc787f5318cc08c6496b4d72fa7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a7a07bdc787f5318cc08c6496b4d72fa7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7a07bdc787f5318cc08c6496b4d72fa7">delaunay_triangulation</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a7a07bdc787f5318cc08c6496b4d72fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in 2D, return a Delaunay triangulation of these points.  <br /></td></tr>
<tr class="separator:a7a07bdc787f5318cc08c6496b4d72fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5b45863dd50fb45ac3cdd481623afe" id="r_a1f5b45863dd50fb45ac3cdd481623afe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DeriveduE , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedC &gt; </td></tr>
<tr class="memitem:a1f5b45863dd50fb45ac3cdd481623afe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1f5b45863dd50fb45ac3cdd481623afe">extract_cells</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;EMAP, const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;cells)</td></tr>
<tr class="memdesc:a1f5b45863dd50fb45ac3cdd481623afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract connected 3D space partitioned by mesh (V, F).  <br /></td></tr>
<tr class="separator:a1f5b45863dd50fb45ac3cdd481623afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7332bc7dbe6723fc063783c66439b1" id="r_aca7332bc7dbe6723fc063783c66439b1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </td></tr>
<tr class="memitem:aca7332bc7dbe6723fc063783c66439b1"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aca7332bc7dbe6723fc063783c66439b1">extract_cells</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;cells)</td></tr>
<tr class="memdesc:aca7332bc7dbe6723fc063783c66439b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aca7332bc7dbe6723fc063783c66439b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fad6c44f9853281fe023252bf967fa" id="r_a57fad6c44f9853281fe023252bf967fa"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DeriveduE , typename DeriveduEC , typename DeriveduEE , typename DerivedC &gt; </td></tr>
<tr class="memitem:a57fad6c44f9853281fe023252bf967fa"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a57fad6c44f9853281fe023252bf967fa">extract_cells_single_component</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;cells)</td></tr>
<tr class="memdesc:a57fad6c44f9853281fe023252bf967fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract connected 3D space partitioned by mesh (V,F) composed of <b>possibly multiple components</b> (the name of this function is dubious).  <br /></td></tr>
<tr class="separator:a57fad6c44f9853281fe023252bf967fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db9c1082a8f9b57e7b7344a328badd7" id="r_a2db9c1082a8f9b57e7b7344a328badd7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedfeature_edges &gt; </td></tr>
<tr class="memitem:a2db9c1082a8f9b57e7b7344a328badd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2db9c1082a8f9b57e7b7344a328badd7">extract_feature</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const double tol, Eigen::PlainObjectBase&lt; Derivedfeature_edges &gt; &amp;feature_edges)</td></tr>
<tr class="memdesc:a2db9c1082a8f9b57e7b7344a328badd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract feature edges based on dihedral angle.  <br /></td></tr>
<tr class="separator:a2db9c1082a8f9b57e7b7344a328badd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6453a79d93b320a4360444550d13b0ac" id="r_a6453a79d93b320a4360444550d13b0ac"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DeriveduE , typename Derivedfeature_edges &gt; </td></tr>
<tr class="memitem:a6453a79d93b320a4360444550d13b0ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a6453a79d93b320a4360444550d13b0ac">extract_feature</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const double tol, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const std::vector&lt; std::vector&lt; typename DeriveduE::Scalar &gt; &gt; &amp;uE2E, Eigen::PlainObjectBase&lt; Derivedfeature_edges &gt; &amp;feature_edges)</td></tr>
<tr class="separator:a6453a79d93b320a4360444550d13b0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9825eec87220923c563797c7119485e" id="r_aa9825eec87220923c563797c7119485e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedN , typename DerivedQ , typename BetaType , typename DerivedWN &gt; </td></tr>
<tr class="memitem:aa9825eec87220923c563797c7119485e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aa9825eec87220923c563797c7119485e">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, const int expansion_order, const BetaType beta, Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;WN)</td></tr>
<tr class="memdesc:aa9825eec87220923c563797c7119485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the fast winding number for point data, without known areas.  <br /></td></tr>
<tr class="separator:aa9825eec87220923c563797c7119485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed4986e59db067d2f048150af7ca39f" id="r_abed4986e59db067d2f048150af7ca39f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedN , typename DerivedQ , typename DerivedWN &gt; </td></tr>
<tr class="memitem:abed4986e59db067d2f048150af7ca39f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#abed4986e59db067d2f048150af7ca39f">fast_winding_number</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;Q, Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;WN)</td></tr>
<tr class="memdesc:abed4986e59db067d2f048150af7ca39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:abed4986e59db067d2f048150af7ca39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9139148a9ac6f9b4b152790a827c0427" id="r_a9139148a9ac6f9b4b152790a827c0427"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV &gt; </td></tr>
<tr class="memitem:a9139148a9ac6f9b4b152790a827c0427"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a9139148a9ac6f9b4b152790a827c0427">half_space_box</a> (const CGAL::Plane_3&lt; CGAL::Epeck &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::Matrix&lt; CGAL::Epeck::FT, 8, 3 &gt; &amp;BV, Eigen::Matrix&lt; int, 12, 3 &gt; &amp;BF)</td></tr>
<tr class="memdesc:a9139148a9ac6f9b4b152790a827c0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a mesh of box (BV,BF) so that it contains the intersection of the half-space under the plane (P) and the bounding box of V, and does not contain any of the half-space above (P).  <br /></td></tr>
<tr class="separator:a9139148a9ac6f9b4b152790a827c0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7726e6100f1c5c7645949fa2156cf2a" id="r_aa7726e6100f1c5c7645949fa2156cf2a"><td class="memTemplParams" colspan="2">template&lt;typename Derivedp , typename Derivedn , typename DerivedV &gt; </td></tr>
<tr class="memitem:aa7726e6100f1c5c7645949fa2156cf2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aa7726e6100f1c5c7645949fa2156cf2a">half_space_box</a> (const Eigen::MatrixBase&lt; Derivedp &gt; &amp;p, const Eigen::MatrixBase&lt; Derivedn &gt; &amp;n, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::Matrix&lt; CGAL::Epeck::FT, 8, 3 &gt; &amp;BV, Eigen::Matrix&lt; int, 12, 3 &gt; &amp;BF)</td></tr>
<tr class="memdesc:aa7726e6100f1c5c7645949fa2156cf2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa7726e6100f1c5c7645949fa2156cf2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92813e51e83af95eb0961bf8756b557" id="r_ad92813e51e83af95eb0961bf8756b557"><td class="memTemplParams" colspan="2">template&lt;typename Derivedequ , typename DerivedV &gt; </td></tr>
<tr class="memitem:ad92813e51e83af95eb0961bf8756b557"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ad92813e51e83af95eb0961bf8756b557">half_space_box</a> (const Eigen::MatrixBase&lt; Derivedequ &gt; &amp;equ, const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, Eigen::Matrix&lt; CGAL::Epeck::FT, 8, 3 &gt; &amp;BV, Eigen::Matrix&lt; int, 12, 3 &gt; &amp;BF)</td></tr>
<tr class="memdesc:ad92813e51e83af95eb0961bf8756b557"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ad92813e51e83af95eb0961bf8756b557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac0ac630b70601fd761c3f55877c178" id="r_a3ac0ac630b70601fd761c3f55877c178"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename Kernel , typename Scalar &gt; </td></tr>
<tr class="memitem:a3ac0ac630b70601fd761c3f55877c178"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3ac0ac630b70601fd761c3f55877c178">hausdorff</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt;::iterator &gt; &gt; &gt; &amp;treeB, const std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;TB, Scalar &amp;l, Scalar &amp;u)</td></tr>
<tr class="memdesc:a3ac0ac630b70601fd761c3f55877c178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.g., mesh, triangle soup) given by a distance function handle (dist_to_B).  <br /></td></tr>
<tr class="separator:a3ac0ac630b70601fd761c3f55877c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbee8698ddf7b0868d3b433b6d5bd77" id="r_a3cbee8698ddf7b0868d3b433b6d5bd77"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a3cbee8698ddf7b0868d3b433b6d5bd77"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3cbee8698ddf7b0868d3b433b6d5bd77">incircle</a> (const Scalar *pa, const Scalar *pb, const Scalar *pc, const Scalar *pd)</td></tr>
<tr class="memdesc:a3cbee8698ddf7b0868d3b433b6d5bd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether point is in a given circle.  <br /></td></tr>
<tr class="separator:a3cbee8698ddf7b0868d3b433b6d5bd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1796699e0d1f0830cc933d704cc918" id="r_ada1796699e0d1f0830cc933d704cc918"><td class="memTemplParams" colspan="2">template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:ada1796699e0d1f0830cc933d704cc918"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ada1796699e0d1f0830cc933d704cc918">insert_into_cdt</a> (const CGAL::Object &amp;obj, const CGAL::Plane_3&lt; Kernel &gt; &amp;P, CGAL::Constrained_triangulation_plus_2&lt; CGAL::Constrained_Delaunay_triangulation_2&lt; Kernel, CGAL::Triangulation_data_structure_2&lt; CGAL::Triangulation_vertex_base_2&lt; Kernel &gt;, CGAL::Constrained_triangulation_face_base_2&lt; Kernel &gt; &gt;, CGAL::Exact_intersections_tag &gt; &gt; &amp;cdt)</td></tr>
<tr class="memdesc:ada1796699e0d1f0830cc933d704cc918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a current 2D constrained Delaunay triangulation (cdt), insert a 3D "object" (e.g., resulting from intersecting two triangles) into the cdt, by projecting it via the given plane (P) and adding appropriate constraints.  <br /></td></tr>
<tr class="separator:ada1796699e0d1f0830cc933d704cc918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296c297c8c29baf446426fb8e72e4974" id="r_a296c297c8c29baf446426fb8e72e4974"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a296c297c8c29baf446426fb8e72e4974"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a296c297c8c29baf446426fb8e72e4974">insphere</a> (const Scalar pa[3], const Scalar pb[3], const Scalar pc[3], const Scalar pd[3], const Scalar pe[3])</td></tr>
<tr class="memdesc:a296c297c8c29baf446426fb8e72e4974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether point is in a given sphere.  <br /></td></tr>
<tr class="separator:a296c297c8c29baf446426fb8e72e4974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0ee9bfc55573ac2ac722c5d6e6d8bc" id="r_aad0ee9bfc55573ac2ac722c5d6e6d8bc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedIF , typename DerivedVVAB , typename DerivedFFAB , typename DerivedJAB , typename DerivedIMAB &gt; </td></tr>
<tr class="memitem:aad0ee9bfc55573ac2ac722c5d6e6d8bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aad0ee9bfc55573ac2ac722c5d6e6d8bc">intersect_other</a> (const Eigen::PlainObjectBase&lt; DerivedVA &gt; &amp;VA, const Eigen::PlainObjectBase&lt; DerivedFA &gt; &amp;FA, const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;VB, const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;FB, const <a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a> &amp;params, Eigen::PlainObjectBase&lt; DerivedIF &gt; &amp;IF, Eigen::PlainObjectBase&lt; DerivedVVAB &gt; &amp;VVAB, Eigen::PlainObjectBase&lt; DerivedFFAB &gt; &amp;FFAB, Eigen::PlainObjectBase&lt; DerivedJAB &gt; &amp;JAB, Eigen::PlainObjectBase&lt; DerivedIMAB &gt; &amp;IMAB)</td></tr>
<tr class="memdesc:aad0ee9bfc55573ac2ac722c5d6e6d8bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces.  <br /></td></tr>
<tr class="separator:aad0ee9bfc55573ac2ac722c5d6e6d8bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d884b824ed6773fde6de21ce4178b1a" id="r_a0d884b824ed6773fde6de21ce4178b1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a0d884b824ed6773fde6de21ce4178b1a">intersect_other</a> (const Eigen::MatrixXd &amp;VA, const Eigen::MatrixXi &amp;FA, const Eigen::MatrixXd &amp;VB, const Eigen::MatrixXi &amp;FB, const bool first_only, Eigen::MatrixXi &amp;IF)</td></tr>
<tr class="memdesc:a0d884b824ed6773fde6de21ce4178b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a0d884b824ed6773fde6de21ce4178b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf85761952ab999a6d3a69e91017ee1" id="r_acbf85761952ab999a6d3a69e91017ee1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedp , typename Derivedn , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:acbf85761952ab999a6d3a69e91017ee1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#acbf85761952ab999a6d3a69e91017ee1">intersect_with_half_space</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedp &gt; &amp;p, const Eigen::MatrixBase&lt; Derivedn &gt; &amp;n, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:acbf85761952ab999a6d3a69e91017ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersect a PWN mesh with a half-space.  <br /></td></tr>
<tr class="separator:acbf85761952ab999a6d3a69e91017ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6b67a7451e027f0c39d1ae171fd1dc" id="r_afc6b67a7451e027f0c39d1ae171fd1dc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Derivedequ , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:afc6b67a7451e027f0c39d1ae171fd1dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#afc6b67a7451e027f0c39d1ae171fd1dc">intersect_with_half_space</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; Derivedequ &gt; &amp;equ, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:afc6b67a7451e027f0c39d1ae171fd1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:afc6b67a7451e027f0c39d1ae171fd1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d4989493710230161702638797c2af" id="r_a28d4989493710230161702638797c2af"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a28d4989493710230161702638797c2af"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a28d4989493710230161702638797c2af">intersect_with_half_space</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const CGAL::Plane_3&lt; CGAL::Epeck &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a28d4989493710230161702638797c2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a28d4989493710230161702638797c2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d7510126e3d13d597b9c2dbe0bac28" id="r_a15d7510126e3d13d597b9c2dbe0bac28"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedF &gt; </td></tr>
<tr class="memitem:a15d7510126e3d13d597b9c2dbe0bac28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a15d7510126e3d13d597b9c2dbe0bac28">lexicographic_triangulation</a> (const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a15d7510126e3d13d597b9c2dbe0bac28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points in 2D, return a lexicographic triangulation of these points.  <br /></td></tr>
<tr class="separator:a15d7510126e3d13d597b9c2dbe0bac28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c593a5aedf52ccb8234edccc484607" id="r_a06c593a5aedf52ccb8234edccc484607"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a06c593a5aedf52ccb8234edccc484607"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a06c593a5aedf52ccb8234edccc484607">mesh_boolean</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;VB, const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;FB, const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;type, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a06c593a5aedf52ccb8234edccc484607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Boolean csg operations on "solid", consistently oriented meshes.  <br /></td></tr>
<tr class="separator:a06c593a5aedf52ccb8234edccc484607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8cdea765193ffb966531a02372dfd6" id="r_ada8cdea765193ffb966531a02372dfd6"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:ada8cdea765193ffb966531a02372dfd6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ada8cdea765193ffb966531a02372dfd6">mesh_boolean</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;VB, const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;FB, const std::string &amp;type_str, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:ada8cdea765193ffb966531a02372dfd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ada8cdea765193ffb966531a02372dfd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80e3892da699c718eebaec432e26db5" id="r_af80e3892da699c718eebaec432e26db5"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:af80e3892da699c718eebaec432e26db5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#af80e3892da699c718eebaec432e26db5">mesh_boolean</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;VB, const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;FB, const std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;wind_num_op, const std::function&lt; int(const int, const int)&gt; &amp;keep, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:af80e3892da699c718eebaec432e26db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:af80e3892da699c718eebaec432e26db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbd1329be2838714aeed904875b7a39" id="r_a2cbd1329be2838714aeed904875b7a39"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a2cbd1329be2838714aeed904875b7a39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2cbd1329be2838714aeed904875b7a39">mesh_boolean</a> (const std::vector&lt; DerivedV &gt; &amp;Vlist, const std::vector&lt; DerivedF &gt; &amp;Flist, const std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;wind_num_op, const std::function&lt; int(const int, const int)&gt; &amp;keep, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a2cbd1329be2838714aeed904875b7a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variadic mesh Boolean operations.  <br /></td></tr>
<tr class="separator:a2cbd1329be2838714aeed904875b7a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2365a0f9b66688565308b8c431321390" id="r_a2365a0f9b66688565308b8c431321390"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a2365a0f9b66688565308b8c431321390"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2365a0f9b66688565308b8c431321390">mesh_boolean</a> (const std::vector&lt; DerivedV &gt; &amp;Vlist, const std::vector&lt; DerivedF &gt; &amp;Flist, const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;type, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a2365a0f9b66688565308b8c431321390"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a2365a0f9b66688565308b8c431321390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ca56172ae354965d5ec22690a6f488" id="r_ae3ca56172ae354965d5ec22690a6f488"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVV , typename DerivedFF , typename Derivedsizes , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </td></tr>
<tr class="memitem:ae3ca56172ae354965d5ec22690a6f488"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ae3ca56172ae354965d5ec22690a6f488">mesh_boolean</a> (const Eigen::MatrixBase&lt; DerivedVV &gt; &amp;VV, const Eigen::MatrixBase&lt; DerivedFF &gt; &amp;FF, const Eigen::MatrixBase&lt; Derivedsizes &gt; &amp;sizes, const std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;wind_num_op, const std::function&lt; int(const int, const int)&gt; &amp;keep, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:ae3ca56172ae354965d5ec22690a6f488"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ae3ca56172ae354965d5ec22690a6f488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f53bb9649aefd700d76e8fbbc628c" id="r_aa93f53bb9649aefd700d76e8fbbc628c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC &gt; </td></tr>
<tr class="memitem:aa93f53bb9649aefd700d76e8fbbc628c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aa93f53bb9649aefd700d76e8fbbc628c">mesh_boolean</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;VB, const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;FB, const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;type, Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;VC, Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;FC)</td></tr>
<tr class="memdesc:aa93f53bb9649aefd700d76e8fbbc628c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa93f53bb9649aefd700d76e8fbbc628c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a5d1111aea73ba095a0af9bf39153" id="r_a4a7a5d1111aea73ba095a0af9bf39153"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a4a7a5d1111aea73ba095a0af9bf39153">mesh_boolean_type_to_funcs</a> (const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;type, std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;wind_num_op, std::function&lt; int(const int, const int)&gt; &amp;keep)</td></tr>
<tr class="memdesc:a4a7a5d1111aea73ba095a0af9bf39153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a MeshBooleanType enum to a pair of winding number conversion function and "keep" function used by mesh_boolean.  <br /></td></tr>
<tr class="separator:a4a7a5d1111aea73ba095a0af9bf39153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d72d2b7b5a3aa61b67b44df084c7db" id="r_ac9d72d2b7b5a3aa61b67b44df084c7db"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Kernel &gt; </td></tr>
<tr class="memitem:ac9d72d2b7b5a3aa61b67b44df084c7db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac9d72d2b7b5a3aa61b67b44df084c7db">mesh_to_cgal_triangle_list</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;T)</td></tr>
<tr class="memdesc:ac9d72d2b7b5a3aa61b67b44df084c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a mesh (V,F) to a list of CGAL triangles.  <br /></td></tr>
<tr class="separator:ac9d72d2b7b5a3aa61b67b44df084c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02acbbee9fc0e71fecf7e1f3ee5a58a8" id="r_a02acbbee9fc0e71fecf7e1f3ee5a58a8"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Polyhedron &gt; </td></tr>
<tr class="memitem:a02acbbee9fc0e71fecf7e1f3ee5a58a8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a02acbbee9fc0e71fecf7e1f3ee5a58a8">mesh_to_polyhedron</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, Polyhedron &amp;poly)</td></tr>
<tr class="memdesc:a02acbbee9fc0e71fecf7e1f3ee5a58a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a mesh (V,F) to a CGAL Polyhedron.  <br /></td></tr>
<tr class="separator:a02acbbee9fc0e71fecf7e1f3ee5a58a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae36641a8877fe6384673c10bef5d05c" id="r_aae36641a8877fe6384673c10bef5d05c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedW , typename DerivedG , typename DerivedJ &gt; </td></tr>
<tr class="memitem:aae36641a8877fe6384673c10bef5d05c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aae36641a8877fe6384673c10bef5d05c">minkowski_sum</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;VB, const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;FB, const bool resolve_overlaps, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:aae36641a8877fe6384673c10bef5d05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Minkowski sum of a closed triangle mesh (V,F) and a set of simplices in 3D.  <br /></td></tr>
<tr class="separator:aae36641a8877fe6384673c10bef5d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24439be4f8127484eeecd0dbf9f0ded" id="r_ac24439be4f8127484eeecd0dbf9f0ded"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename sType , int sCols, int sOptions, typename dType , int dCols, int dOptions, typename DerivedW , typename DerivedG , typename DerivedJ &gt; </td></tr>
<tr class="memitem:ac24439be4f8127484eeecd0dbf9f0ded"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac24439be4f8127484eeecd0dbf9f0ded">minkowski_sum</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::Matrix&lt; sType, 1, sCols, sOptions &gt; &amp;s, const Eigen::Matrix&lt; dType, 1, dCols, dOptions &gt; &amp;d, const bool resolve_overlaps, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:ac24439be4f8127484eeecd0dbf9f0ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac24439be4f8127484eeecd0dbf9f0ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a270ca1724856eb95f5d2a31056f99" id="r_aa7a270ca1724856eb95f5d2a31056f99"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename sType , int sCols, int sOptions, typename dType , int dCols, int dOptions, typename DerivedW , typename DerivedG , typename DerivedJ &gt; </td></tr>
<tr class="memitem:aa7a270ca1724856eb95f5d2a31056f99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aa7a270ca1724856eb95f5d2a31056f99">minkowski_sum</a> (const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;VA, const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;FA, const Eigen::Matrix&lt; sType, 1, sCols, sOptions &gt; &amp;s, const Eigen::Matrix&lt; dType, 1, dCols, dOptions &gt; &amp;d, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:aa7a270ca1724856eb95f5d2a31056f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa7a270ca1724856eb95f5d2a31056f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8689344acbbb3e7bec33eb425d59cdde" id="r_a8689344acbbb3e7bec33eb425d59cdde"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a8689344acbbb3e7bec33eb425d59cdde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a8689344acbbb3e7bec33eb425d59cdde">order_facets_around_edge</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, size_t s, size_t d, const std::vector&lt; int &gt; &amp;adj_faces, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;order, bool debug=false)</td></tr>
<tr class="memdesc:a8689344acbbb3e7bec33eb425d59cdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a directed edge, sort its adjacent faces.  <br /></td></tr>
<tr class="separator:a8689344acbbb3e7bec33eb425d59cdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24fb4d258316354531a7d02652cf1f3" id="r_aa24fb4d258316354531a7d02652cf1f3"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </td></tr>
<tr class="memitem:aa24fb4d258316354531a7d02652cf1f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aa24fb4d258316354531a7d02652cf1f3">order_facets_around_edge</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, size_t s, size_t d, const std::vector&lt; int &gt; &amp;adj_faces, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;pivot_point, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;order)</td></tr>
<tr class="memdesc:aa24fb4d258316354531a7d02652cf1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa24fb4d258316354531a7d02652cf1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6ed199484566caed79fdc9ca79d92a" id="r_afc6ed199484566caed79fdc9ca79d92a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename uE2EType , typename uE2oEType , typename uE2CType &gt; </td></tr>
<tr class="memitem:afc6ed199484566caed79fdc9ca79d92a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; typenameDerivedV::Scalar, typenameCGAL::Exact_predicates_exact_constructions_kernel::FT &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#afc6ed199484566caed79fdc9ca79d92a">order_facets_around_edges</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, std::vector&lt; std::vector&lt; uE2oEType &gt; &gt; &amp;uE2oE, std::vector&lt; std::vector&lt; uE2CType &gt; &gt; &amp;uE2C)</td></tr>
<tr class="memdesc:afc6ed199484566caed79fdc9ca79d92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each undirected edge, sort its adjacent faces.  <br /></td></tr>
<tr class="separator:afc6ed199484566caed79fdc9ca79d92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77808bfdbb9a20091bf1403f0df54225" id="r_a77808bfdbb9a20091bf1403f0df54225"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename uE2EType , typename uE2oEType , typename uE2CType &gt; </td></tr>
<tr class="memitem:a77808bfdbb9a20091bf1403f0df54225"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typenameDerivedV::Scalar, typenameCGAL::Exact_predicates_exact_constructions_kernel::FT &gt;::value, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a77808bfdbb9a20091bf1403f0df54225">order_facets_around_edges</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, std::vector&lt; std::vector&lt; uE2oEType &gt; &gt; &amp;uE2oE, std::vector&lt; std::vector&lt; uE2CType &gt; &gt; &amp;uE2C)</td></tr>
<tr class="memdesc:a77808bfdbb9a20091bf1403f0df54225"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a77808bfdbb9a20091bf1403f0df54225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d848d80df05abbc188abf9410eff26" id="r_ac9d848d80df05abbc188abf9410eff26"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DeriveduE , typename uE2EType , typename uE2oEType , typename uE2CType &gt; </td></tr>
<tr class="memitem:ac9d848d80df05abbc188abf9410eff26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac9d848d80df05abbc188abf9410eff26">order_facets_around_edges</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;uE2E, std::vector&lt; std::vector&lt; uE2oEType &gt; &gt; &amp;uE2oE, std::vector&lt; std::vector&lt; uE2CType &gt; &gt; &amp;uE2C)</td></tr>
<tr class="memdesc:ac9d848d80df05abbc188abf9410eff26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ac9d848d80df05abbc188abf9410eff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc46637c226f5ef8f24214ecf37fa2dc" id="r_afc46637c226f5ef8f24214ecf37fa2dc"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:afc46637c226f5ef8f24214ecf37fa2dc"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#afc46637c226f5ef8f24214ecf37fa2dc">orient2D</a> (const Scalar *pa, const Scalar *pb, const Scalar *pc)</td></tr>
<tr class="memdesc:afc46637c226f5ef8f24214ecf37fa2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a point is above, on, or below a line.  <br /></td></tr>
<tr class="separator:afc46637c226f5ef8f24214ecf37fa2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b50178318855b0ef08301aabb646e1" id="r_ad5b50178318855b0ef08301aabb646e1"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ad5b50178318855b0ef08301aabb646e1"><td class="memTemplItemLeft" align="right" valign="top">short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ad5b50178318855b0ef08301aabb646e1">orient3D</a> (const Scalar pa[3], const Scalar pb[3], const Scalar pc[3], const Scalar pd[3])</td></tr>
<tr class="memdesc:ad5b50178318855b0ef08301aabb646e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a point is above, on, or below a plane.  <br /></td></tr>
<tr class="separator:ad5b50178318855b0ef08301aabb646e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8612a06da5a83f2d0eb5234eb996a099" id="r_a8612a06da5a83f2d0eb5234eb996a099"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </td></tr>
<tr class="memitem:a8612a06da5a83f2d0eb5234eb996a099"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a8612a06da5a83f2d0eb5234eb996a099">outer_edge</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, IndexType &amp;v1, IndexType &amp;v2, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a8612a06da5a83f2d0eb5234eb996a099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an edge that is reachable from infinity without crossing any faces.  <br /></td></tr>
<tr class="separator:a8612a06da5a83f2d0eb5234eb996a099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d429e270d88b1c279c860631ad5a7" id="r_af01d429e270d88b1c279c860631ad5a7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename IndexType &gt; </td></tr>
<tr class="memitem:af01d429e270d88b1c279c860631ad5a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#af01d429e270d88b1c279c860631ad5a7">outer_facet</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, IndexType &amp;f, bool &amp;flipped)</td></tr>
<tr class="memdesc:af01d429e270d88b1c279c860631ad5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a facet that is reachable from infinity without crossing any faces.  <br /></td></tr>
<tr class="separator:af01d429e270d88b1c279c860631ad5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075bcb6ea0a7e4bd56f56d57255422f7" id="r_a075bcb6ea0a7e4bd56f56d57255422f7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType &gt; </td></tr>
<tr class="memitem:a075bcb6ea0a7e4bd56f56d57255422f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a075bcb6ea0a7e4bd56f56d57255422f7">outer_facet</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, IndexType &amp;f, bool &amp;flipped)</td></tr>
<tr class="memdesc:a075bcb6ea0a7e4bd56f56d57255422f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a075bcb6ea0a7e4bd56f56d57255422f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86c29b557c7341d5d6a2ae734273d4" id="r_abf86c29b557c7341d5d6a2ae734273d4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedHV , typename DerivedHF , typename DerivedJ , typename Derivedflip &gt; </td></tr>
<tr class="memitem:abf86c29b557c7341d5d6a2ae734273d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#abf86c29b557c7341d5d6a2ae734273d4">outer_hull</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedHV &gt; &amp;HV, Eigen::PlainObjectBase&lt; DerivedHF &gt; &amp;HF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; Derivedflip &gt; &amp;flip)</td></tr>
<tr class="memdesc:abf86c29b557c7341d5d6a2ae734273d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the "outer hull" of a piecewise constant winding number induce triangle mesh (V,F).  <br /></td></tr>
<tr class="separator:abf86c29b557c7341d5d6a2ae734273d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a69c0cfdf86cb14a3a1af742b322257" id="r_a0a69c0cfdf86cb14a3a1af742b322257"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedG , typename DerivedJ , typename Derivedflip &gt; </td></tr>
<tr class="memitem:a0a69c0cfdf86cb14a3a1af742b322257"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a0a69c0cfdf86cb14a3a1af742b322257">outer_hull_legacy</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;G, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; Derivedflip &gt; &amp;flip)</td></tr>
<tr class="memdesc:a0a69c0cfdf86cb14a3a1af742b322257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the "outer hull" of a potentially non-manifold mesh (V,F) whose intersections have been "resolved" (e.g.  <br /></td></tr>
<tr class="separator:a0a69c0cfdf86cb14a3a1af742b322257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978bd4e32580644accd9602fafec9c3d" id="r_a978bd4e32580644accd9602fafec9c3d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </td></tr>
<tr class="memitem:a978bd4e32580644accd9602fafec9c3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a978bd4e32580644accd9602fafec9c3d">outer_vertex</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, IndexType &amp;v_index, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a978bd4e32580644accd9602fafec9c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a vertex that is reachable from infinite without crossing any faces.  <br /></td></tr>
<tr class="separator:a978bd4e32580644accd9602fafec9c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3a5e1ab834f987bb22bceea2d29f36" id="r_a1a3a5e1ab834f987bb22bceea2d29f36"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename Derivedflip &gt; </td></tr>
<tr class="memitem:a1a3a5e1ab834f987bb22bceea2d29f36"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1a3a5e1ab834f987bb22bceea2d29f36">peel_outer_hull_layers</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; Derivedflip &gt; &amp;flip)</td></tr>
<tr class="memdesc:a1a3a5e1ab834f987bb22bceea2d29f36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes necessary generic information for boolean operations by successively "peeling" off the "outer hull" of a mesh (V,F) resulting from "resolving" all (self-)intersections.  <br /></td></tr>
<tr class="separator:a1a3a5e1ab834f987bb22bceea2d29f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f61d0bdf6d687737bc08b5fa72111a" id="r_ac1f61d0bdf6d687737bc08b5fa72111a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedW &gt; </td></tr>
<tr class="memitem:ac1f61d0bdf6d687737bc08b5fa72111a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac1f61d0bdf6d687737bc08b5fa72111a">peel_winding_number_layers</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:ac1f61d0bdf6d687737bc08b5fa72111a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel Winding number layers from a mesh.  <br /></td></tr>
<tr class="separator:ac1f61d0bdf6d687737bc08b5fa72111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55276c7ddaadbfad9b0ddf0beeb756fe" id="r_a55276c7ddaadbfad9b0ddf0beeb756fe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a55276c7ddaadbfad9b0ddf0beeb756fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a55276c7ddaadbfad9b0ddf0beeb756fe">piecewise_constant_winding_number</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a55276c7ddaadbfad9b0ddf0beeb756fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations.  <br /></td></tr>
<tr class="separator:a55276c7ddaadbfad9b0ddf0beeb756fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1240cef3d039ac518baca44025fe1adc" id="r_a1240cef3d039ac518baca44025fe1adc"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA , typename DerivedT &gt; </td></tr>
<tr class="memitem:a1240cef3d039ac518baca44025fe1adc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1240cef3d039ac518baca44025fe1adc">point_areas</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A, Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;T)</td></tr>
<tr class="memdesc:a1240cef3d039ac518baca44025fe1adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 3D set of points P, each with a list of k-nearest-neighbours, estimate the geodesic voronoi area associated with each point.  <br /></td></tr>
<tr class="separator:a1240cef3d039ac518baca44025fe1adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9e1a72f57d4b751d6ad9a482a00e36" id="r_a3b9e1a72f57d4b751d6ad9a482a00e36"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA &gt; </td></tr>
<tr class="memitem:a3b9e1a72f57d4b751d6ad9a482a00e36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3b9e1a72f57d4b751d6ad9a482a00e36">point_areas</a> (const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedI &gt; &amp;I, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;A)</td></tr>
<tr class="memdesc:a3b9e1a72f57d4b751d6ad9a482a00e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a3b9e1a72f57d4b751d6ad9a482a00e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538a22d0da720af8d4bc8943eeb78ccd" id="r_a538a22d0da720af8d4bc8943eeb78ccd"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedsqrD , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:a538a22d0da720af8d4bc8943eeb78ccd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a538a22d0da720af8d4bc8943eeb78ccd">point_mesh_squared_distance</a> (const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;sqrD, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a538a22d0da720af8d4bc8943eeb78ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distances from a set of points P to a triangle mesh (V,F)  <br /></td></tr>
<tr class="separator:a538a22d0da720af8d4bc8943eeb78ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7079694987005d32d246369f638930a2" id="r_a7079694987005d32d246369f638930a2"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a7079694987005d32d246369f638930a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7079694987005d32d246369f638930a2">point_mesh_squared_distance_precompute</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt;::iterator &gt; &gt; &gt; &amp;tree, std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;T)</td></tr>
<tr class="memdesc:a7079694987005d32d246369f638930a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">precomputation for point_mesh_squared_distance  <br /></td></tr>
<tr class="separator:a7079694987005d32d246369f638930a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b06702d1399da65b7d57a7883a903cd" id="r_a4b06702d1399da65b7d57a7883a903cd"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename DerivedP , typename DerivedsqrD , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:a4b06702d1399da65b7d57a7883a903cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a4b06702d1399da65b7d57a7883a903cd">point_mesh_squared_distance</a> (const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt;::iterator &gt; &gt; &gt; &amp;tree, const std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;T, Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;sqrD, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a4b06702d1399da65b7d57a7883a903cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute distances from a set of points P to a triangle mesh (V,F) using precomputed trees.  <br /></td></tr>
<tr class="separator:a4b06702d1399da65b7d57a7883a903cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0f63485251c67fe5632d5177cf3cf8" id="r_aeb0f63485251c67fe5632d5177cf3cf8"><td class="memTemplParams" colspan="2">template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:aeb0f63485251c67fe5632d5177cf3cf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aeb0f63485251c67fe5632d5177cf3cf8">point_segment_squared_distance</a> (const CGAL::Point_3&lt; Kernel &gt; &amp;P1, const CGAL::Segment_3&lt; Kernel &gt; &amp;S2, CGAL::Point_3&lt; Kernel &gt; &amp;P2, typename Kernel::FT &amp;d)</td></tr>
<tr class="memdesc:aeb0f63485251c67fe5632d5177cf3cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point P1 and segment S2 find the points on each of closest approach and the squared distance thereof.  <br /></td></tr>
<tr class="separator:aeb0f63485251c67fe5632d5177cf3cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6c0e12a671c3facc2b5129904c738e" id="r_aba6c0e12a671c3facc2b5129904c738e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedQ , typename DerivedVB , typename DerivedFB , typename DerivedD &gt; </td></tr>
<tr class="memitem:aba6c0e12a671c3facc2b5129904c738e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aba6c0e12a671c3facc2b5129904c738e">point_solid_signed_squared_distance</a> (const Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;Q, const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;VB, const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;FB, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D)</td></tr>
<tr class="memdesc:aba6c0e12a671c3facc2b5129904c738e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of points (Q) and the boundary mesh (VB,FB) of a solid (as defined in [Zhou et al.  <br /></td></tr>
<tr class="separator:aba6c0e12a671c3facc2b5129904c738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27577e36f63f566d05abe10135706585" id="r_a27577e36f63f566d05abe10135706585"><td class="memTemplParams" colspan="2">template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a27577e36f63f566d05abe10135706585"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a27577e36f63f566d05abe10135706585">point_triangle_squared_distance</a> (const CGAL::Point_3&lt; Kernel &gt; &amp;P1, const CGAL::Triangle_3&lt; Kernel &gt; &amp;T2, CGAL::Point_3&lt; Kernel &gt; &amp;P2, typename Kernel::FT &amp;d)</td></tr>
<tr class="memdesc:a27577e36f63f566d05abe10135706585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a point P1 and triangle T2 find the points on each of closest approach and the squared distance thereof.  <br /></td></tr>
<tr class="separator:a27577e36f63f566d05abe10135706585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41473b3f595af6326c481f3be623b95d" id="r_a41473b3f595af6326c481f3be623b95d"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedB &gt; </td></tr>
<tr class="memitem:a41473b3f595af6326c481f3be623b95d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a41473b3f595af6326c481f3be623b95d">points_inside_component</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;inside)</td></tr>
<tr class="memdesc:a41473b3f595af6326c481f3be623b95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if queries points P are inside of connected facet component (V, F, I), where I indicates a subset of facets that forms the component.  <br /></td></tr>
<tr class="separator:a41473b3f595af6326c481f3be623b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa361bd05fcdd8ce7cc09059a90a71397" id="r_aa361bd05fcdd8ce7cc09059a90a71397"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedB &gt; </td></tr>
<tr class="memitem:aa361bd05fcdd8ce7cc09059a90a71397"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aa361bd05fcdd8ce7cc09059a90a71397">points_inside_component</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;inside)</td></tr>
<tr class="memdesc:aa361bd05fcdd8ce7cc09059a90a71397"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:aa361bd05fcdd8ce7cc09059a90a71397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9163b384abc034cb8ef2c61e545c1da0" id="r_a9163b384abc034cb8ef2c61e545c1da0"><td class="memTemplParams" colspan="2">template&lt;typename Polyhedron , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a9163b384abc034cb8ef2c61e545c1da0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a9163b384abc034cb8ef2c61e545c1da0">polyhedron_to_mesh</a> (const Polyhedron &amp;poly, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a9163b384abc034cb8ef2c61e545c1da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a CGAL Polyhedron to a mesh (V,F)  <br /></td></tr>
<tr class="separator:a9163b384abc034cb8ef2c61e545c1da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b773fa54359274318604d433dd2e9a" id="r_ad6b773fa54359274318604d433dd2e9a"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename Index &gt; </td></tr>
<tr class="memitem:ad6b773fa54359274318604d433dd2e9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ad6b773fa54359274318604d433dd2e9a">projected_cdt</a> (const std::vector&lt; CGAL::Object &gt; &amp;objects, const CGAL::Plane_3&lt; Kernel &gt; &amp;P, std::vector&lt; CGAL::Point_3&lt; Kernel &gt; &gt; &amp;vertices, std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;faces)</td></tr>
<tr class="memdesc:ad6b773fa54359274318604d433dd2e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of objects (e.g., resulting from intersecting a triangle with many other triangles), construct a constrained Delaunay triangulation on a given plane (P), by inersting constraints for each object projected onto that plane.  <br /></td></tr>
<tr class="separator:ad6b773fa54359274318604d433dd2e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45607f6c08fba2fc4a797244d7c75b81" id="r_a45607f6c08fba2fc4a797244d7c75b81"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:a45607f6c08fba2fc4a797244d7c75b81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a45607f6c08fba2fc4a797244d7c75b81">projected_cdt</a> (const std::vector&lt; CGAL::Object &gt; &amp;objects, const CGAL::Plane_3&lt; Kernel &gt; &amp;P, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:a45607f6c08fba2fc4a797244d7c75b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a45607f6c08fba2fc4a797244d7c75b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a62d282e26f8a1b91722dd9da3b5bd2" id="r_a7a62d282e26f8a1b91722dd9da3b5bd2"><td class="memTemplParams" colspan="2">template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a7a62d282e26f8a1b91722dd9da3b5bd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7a62d282e26f8a1b91722dd9da3b5bd2">projected_delaunay</a> (const CGAL::Triangle_3&lt; Kernel &gt; &amp;A, const std::vector&lt; CGAL::Object &gt; &amp;A_objects_3, CGAL::Constrained_triangulation_plus_2&lt; CGAL::Constrained_Delaunay_triangulation_2&lt; Kernel, CGAL::Triangulation_data_structure_2&lt; CGAL::Triangulation_vertex_base_2&lt; Kernel &gt;, CGAL::Constrained_triangulation_face_base_2&lt; Kernel &gt; &gt;, CGAL::Exact_intersections_tag &gt; &gt; &amp;cdt)</td></tr>
<tr class="memdesc:a7a62d282e26f8a1b91722dd9da3b5bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute 2D delaunay triangulation of a given 3d triangle and a list of intersection objects (points,segments,triangles).  <br /></td></tr>
<tr class="separator:a7a62d282e26f8a1b91722dd9da3b5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29a1ce9ef6539d66c1400a27db655d0" id="r_ab29a1ce9ef6539d66c1400a27db655d0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedL , typename DerivedW &gt; </td></tr>
<tr class="memitem:ab29a1ce9ef6539d66c1400a27db655d0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ab29a1ce9ef6539d66c1400a27db655d0">propagate_winding_numbers</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;labels, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:ab29a1ce9ef6539d66c1400a27db655d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute winding number on each side of the face.  <br /></td></tr>
<tr class="separator:ab29a1ce9ef6539d66c1400a27db655d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a2fbf8152086bfb9f61740ebdec358" id="r_a55a2fbf8152086bfb9f61740ebdec358"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DeriveduE , typename DeriveduEC , typename DeriveduEE , typename DerivedP , typename DerivedC , typename DerivedL , typename DerivedW &gt; </td></tr>
<tr class="memitem:a55a2fbf8152086bfb9f61740ebdec358"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a55a2fbf8152086bfb9f61740ebdec358">propagate_winding_numbers</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;uE, const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;uEC, const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;uEE, const size_t num_patches, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const size_t num_cells, const Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, const Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;labels, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="separator:a55a2fbf8152086bfb9f61740ebdec358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8359e73ff0ee8149c314d3816b5958f" id="r_ae8359e73ff0ee8149c314d3816b5958f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF &gt; </td></tr>
<tr class="memitem:ae8359e73ff0ee8149c314d3816b5958f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ae8359e73ff0ee8149c314d3816b5958f">read_triangle_mesh</a> (const std::string str, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F)</td></tr>
<tr class="memdesc:ae8359e73ff0ee8149c314d3816b5958f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper, reads floating point precision but assigns to DerivedV::Scalar which may be a CGAL type.  <br /></td></tr>
<tr class="separator:ae8359e73ff0ee8149c314d3816b5958f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3dc739f900eb1f9479e974de035d2c" id="r_a3d3dc739f900eb1f9479e974de035d2c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedC , typename FT , typename DerivedW &gt; </td></tr>
<tr class="memitem:a3d3dc739f900eb1f9479e974de035d2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3d3dc739f900eb1f9479e974de035d2c">relabel_small_immersed_cells</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const size_t num_patches, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const size_t num_cells, const Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C, const FT vol_threashold, Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;W)</td></tr>
<tr class="memdesc:a3d3dc739f900eb1f9479e974de035d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relabel winding numbers of small immersed cells.  <br /></td></tr>
<tr class="separator:a3d3dc739f900eb1f9479e974de035d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d687331f910fef280e3a0e5f5370c7" id="r_a99d687331f910fef280e3a0e5f5370c7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename Kernel , typename DerivedVV , typename DerivedFF , typename DerivedJ , typename DerivedIM &gt; </td></tr>
<tr class="memitem:a99d687331f910fef280e3a0e5f5370c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a99d687331f910fef280e3a0e5f5370c7">remesh_intersections</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;T, const std::map&lt; typename DerivedF::Index, std::vector&lt; std::pair&lt; typename DerivedF::Index, CGAL::Object &gt; &gt; &gt; &amp;offending, bool stitch_all, bool slow_and_more_precise_rounding, Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;VV, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;IM)</td></tr>
<tr class="memdesc:a99d687331f910fef280e3a0e5f5370c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remesh faces according to results of intersection detection and construction (e.g.  <br /></td></tr>
<tr class="separator:a99d687331f910fef280e3a0e5f5370c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169f4ae2fe2c11f7e878b41aa747fc2" id="r_a7169f4ae2fe2c11f7e878b41aa747fc2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVV , typename DerivedFF , typename DerivedIF , typename DerivedJ , typename DerivedIM &gt; </td></tr>
<tr class="memitem:a7169f4ae2fe2c11f7e878b41aa747fc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7169f4ae2fe2c11f7e878b41aa747fc2">remesh_self_intersections</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a> &amp;params, Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;VV, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedIF &gt; &amp;IF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;IM)</td></tr>
<tr class="memdesc:a7169f4ae2fe2c11f7e878b41aa747fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a triangle mesh (V,F) compute a new mesh (VV,FF) which is the same as (V,F) except that any self-intersecting triangles in (V,F) have been subdivided (new vertices and face created) so that the self-intersection contour lies exactly on edges in (VV,FF).  <br /></td></tr>
<tr class="separator:a7169f4ae2fe2c11f7e878b41aa747fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f8fa9920a99cd809e2944afed7c908" id="r_a65f8fa9920a99cd809e2944afed7c908"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedVV , typename DerivedFF , typename DerivedIF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a65f8fa9920a99cd809e2944afed7c908"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a65f8fa9920a99cd809e2944afed7c908">remesh_self_intersections</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a> &amp;params, Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;VV, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedIF &gt; &amp;IF, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a65f8fa9920a99cd809e2944afed7c908"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.IM above is <em>applied</em> to merge duplicated vertices in VV.  <br /></td></tr>
<tr class="separator:a65f8fa9920a99cd809e2944afed7c908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4711ebc19670232979ddfafeea023a6c" id="r_a4711ebc19670232979ddfafeea023a6c"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE , typename DerivedVI , typename DerivedEI , typename DerivedJ , typename DerivedIM &gt; </td></tr>
<tr class="memitem:a4711ebc19670232979ddfafeea023a6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a4711ebc19670232979ddfafeea023a6c">resolve_intersections</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;VI, Eigen::PlainObjectBase&lt; DerivedEI &gt; &amp;EI, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;IM)</td></tr>
<tr class="memdesc:a4711ebc19670232979ddfafeea023a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of possible intersecting segments with endpoints, split segments to overlap only at endpoints.  <br /></td></tr>
<tr class="separator:a4711ebc19670232979ddfafeea023a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfa81a78943385b9146fe53e121b380" id="r_aacfa81a78943385b9146fe53e121b380"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename DerivedV &gt; </td></tr>
<tr class="memitem:aacfa81a78943385b9146fe53e121b380"><td class="memTemplItemLeft" align="right" valign="top">CGAL::Point_2&lt; Kernel &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aacfa81a78943385b9146fe53e121b380">row_to_point</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const typename DerivedV::Index &amp;i)</td></tr>
<tr class="memdesc:aacfa81a78943385b9146fe53e121b380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a row from V and treat as a 2D cgal point (only first two columns of V are used).  <br /></td></tr>
<tr class="separator:aacfa81a78943385b9146fe53e121b380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd33a114c5e272d9d444bea740c4cfc" id="r_a1cd33a114c5e272d9d444bea740c4cfc"><td class="memTemplParams" colspan="2">template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a1cd33a114c5e272d9d444bea740c4cfc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1cd33a114c5e272d9d444bea740c4cfc">segment_segment_squared_distance</a> (const CGAL::Segment_3&lt; Kernel &gt; &amp;S1, const CGAL::Segment_3&lt; Kernel &gt; &amp;S2, CGAL::Point_3&lt; Kernel &gt; &amp;P1, CGAL::Point_3&lt; Kernel &gt; &amp;P2, typename Kernel::FT &amp;d)</td></tr>
<tr class="memdesc:a1cd33a114c5e272d9d444bea740c4cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two segments S1 and S2 find the points on each of closest approach and the squared distance thereof.  <br /></td></tr>
<tr class="separator:a1cd33a114c5e272d9d444bea740c4cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240ec71bf9ed8497cca131ce80e30045" id="r_a240ec71bf9ed8497cca131ce80e30045"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a240ec71bf9ed8497cca131ce80e30045">signed_distance_isosurface</a> (const Eigen::MatrixXd &amp;IV, const Eigen::MatrixXi &amp;IF, const double level, const double angle_bound, const double radius_bound, const double distance_bound, const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a> sign_type, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F)</td></tr>
<tr class="memdesc:a240ec71bf9ed8497cca131ce80e30045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the contour of an iso-level of the signed distance field to a given mesh.  <br /></td></tr>
<tr class="separator:a240ec71bf9ed8497cca131ce80e30045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56339aee719b66761234276a14d7003f" id="r_a56339aee719b66761234276a14d7003f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE , typename DerivedVI , typename DerivedEI , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a56339aee719b66761234276a14d7003f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a56339aee719b66761234276a14d7003f">snap_rounding</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;VI, Eigen::PlainObjectBase&lt; DerivedEI &gt; &amp;EI, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a56339aee719b66761234276a14d7003f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snap a list of possible intersecting segments with endpoints in any precision to <em>the</em> integer grid.  <br /></td></tr>
<tr class="separator:a56339aee719b66761234276a14d7003f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac105fc714db9b51b1c3945c51e6e5a19" id="r_ac105fc714db9b51b1c3945c51e6e5a19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac105fc714db9b51b1c3945c51e6e5a19">string_to_mesh_boolean_type</a> (const std::string &amp;s, <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;type)</td></tr>
<tr class="memdesc:ac105fc714db9b51b1c3945c51e6e5a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to boolean type.  <br /></td></tr>
<tr class="separator:ac105fc714db9b51b1c3945c51e6e5a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb4ded3fe8818156a5f7c540d771835" id="r_a5cb4ded3fe8818156a5f7c540d771835"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a5cb4ded3fe8818156a5f7c540d771835">string_to_mesh_boolean_type</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a5cb4ded3fe8818156a5f7c540d771835"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a5cb4ded3fe8818156a5f7c540d771835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347c87769a3b67d0bee379fb78705679" id="r_a347c87769a3b67d0bee379fb78705679"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedE , typename Kernel , typename DerivedVI , typename DerivedEI , typename DerivedJ , typename DerivedIM &gt; </td></tr>
<tr class="memitem:a347c87769a3b67d0bee379fb78705679"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a347c87769a3b67d0bee379fb78705679">subdivide_segments</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;E, const std::vector&lt; std::vector&lt; CGAL::Point_2&lt; Kernel &gt; &gt; &gt; &amp;steiner, Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;VI, Eigen::PlainObjectBase&lt; DerivedEI &gt; &amp;EI, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J, Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;IM)</td></tr>
<tr class="memdesc:a347c87769a3b67d0bee379fb78705679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert steiner points to subdivide a given set of line segments.  <br /></td></tr>
<tr class="separator:a347c87769a3b67d0bee379fb78705679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5cc8bbbcee4ed4567bc754a4e939c0" id="r_a3b5cc8bbbcee4ed4567bc754a4e939c0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename Kernel &gt; </td></tr>
<tr class="memitem:a3b5cc8bbbcee4ed4567bc754a4e939c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3b5cc8bbbcee4ed4567bc754a4e939c0">submesh_aabb_tree</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; typename Kernel::Triangle_3 &gt;::iterator &gt; &gt; &gt; &amp;tree, std::vector&lt; typename Kernel::Triangle_3 &gt; &amp;triangles, std::vector&lt; bool &gt; &amp;in_I)</td></tr>
<tr class="memdesc:a3b5cc8bbbcee4ed4567bc754a4e939c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree for a submesh indicated by a face selection list I of a full mesh (V,F)  <br /></td></tr>
<tr class="separator:a3b5cc8bbbcee4ed4567bc754a4e939c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745c9671e98e82bb4f285b028c1aa8c9" id="r_a745c9671e98e82bb4f285b028c1aa8c9"><td class="memTemplParams" colspan="2">template&lt;typename Kernel &gt; </td></tr>
<tr class="memitem:a745c9671e98e82bb4f285b028c1aa8c9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a745c9671e98e82bb4f285b028c1aa8c9">triangle_triangle_squared_distance</a> (const CGAL::Triangle_3&lt; Kernel &gt; &amp;T1, const CGAL::Triangle_3&lt; Kernel &gt; &amp;T2, CGAL::Point_3&lt; Kernel &gt; &amp;P1, CGAL::Point_3&lt; Kernel &gt; &amp;P2, typename Kernel::FT &amp;d)</td></tr>
<tr class="memdesc:a745c9671e98e82bb4f285b028c1aa8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two triangles T1 and T2 find the points on each of closest approach and the squared distance thereof.  <br /></td></tr>
<tr class="separator:a745c9671e98e82bb4f285b028c1aa8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c5d9c112aaddddfc00781eb000fddd4" id="r_a2c5d9c112aaddddfc00781eb000fddd4"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename DerivedV , typename DerivedE , typename DerivedH , typename DerivedV2 , typename DerivedF2 &gt; </td></tr>
<tr class="memitem:a2c5d9c112aaddddfc00781eb000fddd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2c5d9c112aaddddfc00781eb000fddd4">triangulate</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedE &gt; &amp;E, const Eigen::MatrixBase&lt; DerivedH &gt; &amp;H, const bool retain_convex_hull, Eigen::PlainObjectBase&lt; DerivedV2 &gt; &amp;V2, Eigen::PlainObjectBase&lt; DerivedF2 &gt; &amp;F2)</td></tr>
<tr class="memdesc:a2c5d9c112aaddddfc00781eb000fddd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triangulate the interior of a polygon using CGAL.  <br /></td></tr>
<tr class="separator:a2c5d9c112aaddddfc00781eb000fddd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dca57f7cfcb9b65b561d5d3ccec99be" id="r_a6dca57f7cfcb9b65b561d5d3ccec99be"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedV , typename DerivedF , typename DerivedD , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a6dca57f7cfcb9b65b561d5d3ccec99be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a6dca57f7cfcb9b65b561d5d3ccec99be">trim_with_solid</a> (const Eigen::PlainObjectBase&lt; DerivedVA &gt; &amp;VA, const Eigen::PlainObjectBase&lt; DerivedFA &gt; &amp;FA, const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;VB, const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;FB, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;Vd, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a6dca57f7cfcb9b65b561d5d3ccec99be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an arbitrary mesh (VA,FA) and the boundary mesh (VB,FB) of a solid (as defined in [Zhou et al.  <br /></td></tr>
<tr class="separator:a6dca57f7cfcb9b65b561d5d3ccec99be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace643f9725b6a5aad6e10cadb57f0de0" id="r_ace643f9725b6a5aad6e10cadb57f0de0"><td class="memTemplParams" colspan="2">template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedV , typename DerivedF , typename DerivedD , typename DerivedJ &gt; </td></tr>
<tr class="memitem:ace643f9725b6a5aad6e10cadb57f0de0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ace643f9725b6a5aad6e10cadb57f0de0">trim_with_solid</a> (const Eigen::PlainObjectBase&lt; DerivedVA &gt; &amp;VA, const Eigen::PlainObjectBase&lt; DerivedFA &gt; &amp;FA, const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;VB, const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;FB, const <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863">TrimWithSolidMethod</a> method, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;Vd, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;D, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:ace643f9725b6a5aad6e10cadb57f0de0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:ace643f9725b6a5aad6e10cadb57f0de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8adecc2e7b09a987748532fb975d2" id="r_a1da8adecc2e7b09a987748532fb975d2"><td class="memTemplParams" colspan="2">template&lt;typename DerivedWV , typename DerivedWE , typename Derivedth , typename DerivedV , typename DerivedF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a1da8adecc2e7b09a987748532fb975d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1da8adecc2e7b09a987748532fb975d2">wire_mesh</a> (const Eigen::MatrixBase&lt; DerivedWV &gt; &amp;WV, const Eigen::MatrixBase&lt; DerivedWE &gt; &amp;WE, const Eigen::MatrixBase&lt; Derivedth &gt; &amp;th, const int poly_size, const bool solid, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a1da8adecc2e7b09a987748532fb975d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a "wire" or "wireframe" or "strut" surface mesh, given a one-dimensional network of straight edges.  <br /></td></tr>
<tr class="separator:a1da8adecc2e7b09a987748532fb975d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc5cdc053c1f25a930d46be790a7c74" id="r_a7dc5cdc053c1f25a930d46be790a7c74"><td class="memTemplParams" colspan="2">template&lt;typename DerivedWV , typename DerivedWE , typename DerivedV , typename DerivedF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a7dc5cdc053c1f25a930d46be790a7c74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7dc5cdc053c1f25a930d46be790a7c74">wire_mesh</a> (const Eigen::MatrixBase&lt; DerivedWV &gt; &amp;WV, const Eigen::MatrixBase&lt; DerivedWE &gt; &amp;WE, const double th, const int poly_size, const bool solid, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a7dc5cdc053c1f25a930d46be790a7c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a7dc5cdc053c1f25a930d46be790a7c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a350d009b191ea77e7bb454a2936d7" id="r_a88a350d009b191ea77e7bb454a2936d7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedWV , typename DerivedWE , typename DerivedV , typename DerivedF , typename DerivedJ &gt; </td></tr>
<tr class="memitem:a88a350d009b191ea77e7bb454a2936d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a88a350d009b191ea77e7bb454a2936d7">wire_mesh</a> (const Eigen::MatrixBase&lt; DerivedWV &gt; &amp;WV, const Eigen::MatrixBase&lt; DerivedWE &gt; &amp;WE, const double th, const int poly_size, Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;J)</td></tr>
<tr class="memdesc:a88a350d009b191ea77e7bb454a2936d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a88a350d009b191ea77e7bb454a2936d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a41dc481531d9dd2585c545308a2937d7" name="a41dc481531d9dd2585c545308a2937d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dc481531d9dd2585c545308a2937d7">&#9670;&#160;</a></span>BinaryUnion</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9facab2376ce17d445c5637c8a4bca36056">MESH_BOOLEAN_TYPE_UNION</a>&gt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a41dc481531d9dd2585c545308a2937d7">igl::copyleft::cgal::BinaryUnion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cad0d59d1e687e9faa8c93e15957b95" name="a3cad0d59d1e687e9faa8c93e15957b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cad0d59d1e687e9faa8c93e15957b95">&#9670;&#160;</a></span>BinaryIntersect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa80c9b3b199544d1f6dae0412534ffc34">MESH_BOOLEAN_TYPE_INTERSECT</a>&gt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a3cad0d59d1e687e9faa8c93e15957b95">igl::copyleft::cgal::BinaryIntersect</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb0880ae718ceaa681706d8b827d54fe" name="adb0880ae718ceaa681706d8b827d54fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0880ae718ceaa681706d8b827d54fe">&#9670;&#160;</a></span>BinaryMinus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa18e150636e973e60713171df46566a80">MESH_BOOLEAN_TYPE_MINUS</a>&gt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#adb0880ae718ceaa681706d8b827d54fe">igl::copyleft::cgal::BinaryMinus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acda076539de2c25a135eda9462171d87" name="acda076539de2c25a135eda9462171d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda076539de2c25a135eda9462171d87">&#9670;&#160;</a></span>BinaryXor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fa6b7ed81a5d01491212a128640544881b">MESH_BOOLEAN_TYPE_XOR</a>&gt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#acda076539de2c25a135eda9462171d87">igl::copyleft::cgal::BinaryXor</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac06a2805099d616ad29e497091315ac0" name="ac06a2805099d616ad29e497091315ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac06a2805099d616ad29e497091315ac0">&#9670;&#160;</a></span>BinaryResolve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1BinaryWindingNumberOperations.html">BinaryWindingNumberOperations</a>&lt;<a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9fad9961481f0ffb8a24865c88921cfe708">MESH_BOOLEAN_TYPE_RESOLVE</a>&gt; <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac06a2805099d616ad29e497091315ac0">igl::copyleft::cgal::BinaryResolve</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca810a2d57eab3749b7a4f9379a9f008" name="aca810a2d57eab3749b7a4f9379a9f008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca810a2d57eab3749b7a4f9379a9f008">&#9670;&#160;</a></span>KeepInside</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aca810a2d57eab3749b7a4f9379a9f008">igl::copyleft::cgal::KeepInside</a> = typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter.html">WindingNumberFilter</a>&lt;<a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce">KEEP_INSIDE</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaab770fd7d59c9d5b18d15351d8c13d1" name="aaab770fd7d59c9d5b18d15351d8c13d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab770fd7d59c9d5b18d15351d8c13d1">&#9670;&#160;</a></span>KeepAll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aaab770fd7d59c9d5b18d15351d8c13d1">igl::copyleft::cgal::KeepAll</a> = typedef <a class="el" href="classigl_1_1copyleft_1_1cgal_1_1WindingNumberFilter.html">WindingNumberFilter</a>&lt;<a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844">KEEP_ALL</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a652b3870ca0cbdd378a3b383ba9bd5f2" name="a652b3870ca0cbdd378a3b383ba9bd5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652b3870ca0cbdd378a3b383ba9bd5f2">&#9670;&#160;</a></span>KeeperType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a652b3870ca0cbdd378a3b383ba9bd5f2">igl::copyleft::cgal::KeeperType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Keep policies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce" name="a652b3870ca0cbdd378a3b383ba9bd5f2a4fe1fa3cfe8bfbb3dd60b8c84f3118ce"></a>KEEP_INSIDE&#160;</td><td class="fielddoc"><p>Keep only inside. </p>
</td></tr>
<tr><td class="fieldname"><a id="a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844" name="a652b3870ca0cbdd378a3b383ba9bd5f2a224588758e6408e9ad5fff0b04142844"></a>KEEP_ALL&#160;</td><td class="fielddoc"><p>Keep everything. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2ed8d1b22fc3cb87822647766b3dc863" name="a2ed8d1b22fc3cb87822647766b3dc863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed8d1b22fc3cb87822647766b3dc863">&#9670;&#160;</a></span>TrimWithSolidMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863">igl::copyleft::cgal::TrimWithSolidMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2ed8d1b22fc3cb87822647766b3dc863af6beb371c912a1daa28342fb54aa5644" name="a2ed8d1b22fc3cb87822647766b3dc863af6beb371c912a1daa28342fb54aa5644"></a>CHECK_EACH_FACE&#160;</td><td class="fielddoc"><p>Resolve intersections only between A and B and then check whether every face in A is inside/outside of B. </p>
<p>(Included for debugging). </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ed8d1b22fc3cb87822647766b3dc863a2fa5c48d2f98ca34cd4cc7a247120d35" name="a2ed8d1b22fc3cb87822647766b3dc863a2fa5c48d2f98ca34cd4cc7a247120d35"></a>CHECK_EACH_PATCH&#160;</td><td class="fielddoc"><p>Resolve intersections only between A and B, then separate into patches of connected faces &mdash; where connected means sharing an edge and <em>not</em> the same original face in A &mdash; then label each patch as inside or outside. </p>
<p>This should always be strictly equivalent in output and strictly fewer FLOPS than CHECK_EACH_FACE. There will be many tiny patches along the intersection of A and B. <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="a2ed8d1b22fc3cb87822647766b3dc863a1c69a30202b872a482875c36d59d9252" name="a2ed8d1b22fc3cb87822647766b3dc863a1c69a30202b872a482875c36d59d9252"></a>RESOLVE_BOTH_AND_RESTORE_THEN_CHECK_EACH_PATCH&#160;</td><td class="fielddoc"><p>Merge A and B into the same mesh and resolve all self-itnersections. </p>
<p>Then "undo" remeshing on faces of A not involved in intersections with B (i.e., self-intersections in A). Then seperate into patches based on connected faces &mdash; where connected means sharing a <em>manifold edge</em> &mdash; then label each aptch as inside or outside. Results in fewer patches than CHECK_EACH_PATCH but finding, meshing and mesh-undoing self-intersections in A can be costly. This could result in different output from CHECK_EACH_PATCH because of shared remeshing with (i.e., faces in A that both intersect B and other faces in A). If A has no self-intersections then I claim the outputs should be the same. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a12c0c03c36999f6c7b35421c59ac9ca4" name="a12c0c03c36999f6c7b35421c59ac9ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c0c03c36999f6c7b35421c59ac9ca4">&#9670;&#160;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>slow_and_more_precise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector version of assign_scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>matrix of scalars </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slow_and_more_precise</td><td>see assign_scalar </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>matrix same size as C</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a5ed0cef244df8ed5e76d2d55af9d57a8" title="Conduct the casting copy: lhs = rhs using slow_and_more_precise rounding if more desired.">assign_scalar</a> </dd></dl>

</div>
</div>
<a id="a76ac4bd4ebabba6c96eb47d91a52bf2b" name="a76ac4bd4ebabba6c96eb47d91a52bf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ac4bd4ebabba6c96eb47d91a52bf2b">&#9670;&#160;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab463bca3955e73d59383a31bdff724db" name="ab463bca3955e73d59383a31bdff724db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab463bca3955e73d59383a31bdff724db">&#9670;&#160;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnScalar , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt; ReturnScalar, DerivedC::RowsAtCompileTime, DerivedC::ColsAtCompileTime, 1, DerivedC::MaxRowsAtCompileTime, DerivedC::MaxColsAtCompileTime &gt; igl::copyleft::cgal::assign </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5ed0cef244df8ed5e76d2d55af9d57a8" name="a5ed0cef244df8ed5e76d2d55af9d57a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed0cef244df8ed5e76d2d55af9d57a8">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RHS , typename LHS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const RHS &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>slow_and_more_precise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LHS &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conduct the casting copy: lhs = rhs using <code>slow_and_more_precise</code> rounding if more desired. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RHS</td><td>right-hand side scalar type </td></tr>
    <tr><td class="paramname">LHS</td><td>left-hand side scalar type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>right-hand side scalar </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slow_and_more_precise</td><td>when appropriate use more elaborate rounding guaranteed to find a closest lhs value in an absolute value sense. Think of <code>slow_and_more_precise=true</code> as "round to closest number" and <code>slow_and_more_precise=false</code> as "round down/up". CGAL's number types are bit mysterious about how exactly rounding is conducted. For example, the rationals created during remesh_intersections on floating point input appear to be tightly rounded up or down so the difference with the <code>slow_and_more_precise=true</code> will be exactly zero 50% of the time and "one floating point unit" (at whatever scale) the other 50% of the time. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lhs</td><td>left-hand side scalar </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9be1cc14112217171bd19402c493b3f6" name="a9be1cc14112217171bd19402c493b3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be1cc14112217171bd19402c493b3f6">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Epeck::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Epeck::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>For legacy reasons, all of these overload uses <code>slow_and_more_precise=true</code>. This is subject to change if we determine it is sufficiently overkill. In that case, we'd create a new non-overloaded function. </p>

</div>
</div>
<a id="abd4577690cb751eced5a7579f08f0573" name="abd4577690cb751eced5a7579f08f0573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4577690cb751eced5a7579f08f0573">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Epeck::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a335662495e808c70886c2e4d908c3e4f" name="a335662495e808c70886c2e4d908c3e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335662495e808c70886c2e4d908c3e4f">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Epeck::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgal</td><td>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f9ac29ce05a74a311e52206293f83f7" name="a6f9ac29ce05a74a311e52206293f83f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9ac29ce05a74a311e52206293f83f7">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eeb4c3f3e9b2e4b546bad7d1864f9ad" name="a7eeb4c3f3e9b2e4b546bad7d1864f9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eeb4c3f3e9b2e4b546bad7d1864f9ad">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a3ec2e0dfa178eeb9a6fb563eda548073" name="a3ec2e0dfa178eeb9a6fb563eda548073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec2e0dfa178eeb9a6fb563eda548073">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0c75726a89edabf3602ab1bdc4b1a6f8" name="a0c75726a89edabf3602ab1bdc4b1a6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c75726a89edabf3602ab1bdc4b1a6f8">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a7a0a277a5e9ae4b929373f8a4b812caa" name="a7a0a277a5e9ae4b929373f8a4b812caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0a277a5e9ae4b929373f8a4b812caa">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a76b2bca21db0d19d293a93ff87246d3a" name="a76b2bca21db0d19d293a93ff87246d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b2bca21db0d19d293a93ff87246d3a">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ab1927287ea1fac749a475615e452d8b3" name="ab1927287ea1fac749a475615e452d8b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1927287ea1fac749a475615e452d8b3">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a268e7b784c30482867d062cdf2bd4235" name="a268e7b784c30482867d062cdf2bd4235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268e7b784c30482867d062cdf2bd4235">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a376e3a13203eae4eb9d3749dfb98e8f7" name="a376e3a13203eae4eb9d3749dfb98e8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376e3a13203eae4eb9d3749dfb98e8f7">&#9670;&#160;</a></span>assign_scalar() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::assign_scalar </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Simple_cartesian&lt; mpq_class &gt;::FT &amp;&#160;</td>
          <td class="paramname"><em>cgal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a5f57dae2a4485cc2651abfb51f55cf0e" name="a5f57dae2a4485cc2651abfb51f55cf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f57dae2a4485cc2651abfb51f55cf0e">&#9670;&#160;</a></span>cell_adjacency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::cell_adjacency </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>per_patch_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::set&lt; std::tuple&lt; typename DerivedC::Scalar, bool, size_t &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacency_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine adjacency of cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">per_patch_cells</td><td>#P by 2 list of cell labels on each side of each patch. Cell labels are assumed to be continuous from 0 to #C. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cells</td><td>number of cells. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">adjacency_list</td><td>#C array of list of adjcent cell information. If cell i and cell j are adjacent via patch x, where i is on the positive side of x, and j is on the negative side. Then, adjacency_list[i] will contain the entry {j, false, x} and adjacency_list[j] will contain the entry {i, true, x} </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a288a0d884f994aadcf7d8058b35113d8" name="a288a0d884f994aadcf7d8058b35113d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288a0d884f994aadcf7d8058b35113d8">&#9670;&#160;</a></span>closest_facet() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename Kernel , typename DerivedR , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::closest_facet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>VFi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; typename Kernel::Triangle_3 &gt;::iterator &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename Kernel::Triangle_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the closest facet for each of the input points. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 array of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 array of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of triangle indices to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 array of query points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumsums of directed edges sharing each unique edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#E list of indices into E (see <code><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">igl::unique_edge_map</a></code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VF</td><td>#V list of lists of incident faces (adjacency list) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VFi</td><td>#V list of lists of index of incidence within incident faces listed in VF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> containing triangles of (V,F(I,:)) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangles</td><td>#I list of cgal triangles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in_I</td><td>#F list of whether in submesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>#P list of closest facet indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of bools indicating on which side of the closest facet each query point lies.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The use of <code>size_t</code> here is a bad idea. These should just be int to avoid nonsense with windows. </dd></dl>

</div>
</div>
<a id="ac948de3c14554d16b33cc16d7131a5f2" name="ac948de3c14554d16b33cc16d7131a5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac948de3c14554d16b33cc16d7131a5f2">&#9670;&#160;</a></span>closest_facet() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedR , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::closest_facet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af97e3b6b93bfa938e1f0a7bc2308ca40" name="af97e3b6b93bfa938e1f0a7bc2308ca40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97e3b6b93bfa938e1f0a7bc2308ca40">&#9670;&#160;</a></span>closest_facet() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedR , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::closest_facet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedR &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a1ccff123c73356ecd24f15f90143a4b7" name="a1ccff123c73356ecd24f15f90143a4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccff123c73356ecd24f15f90143a4b7">&#9670;&#160;</a></span>complex_to_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tr , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::complex_to_mesh </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Complex_2_in_triangulation_3&lt; Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>c2t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a CGAL::Complex_2_in_triangulation_3 to a mesh (V,F) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tr</td><td>CGAL triangulation type, e.g. CGAL::Surface_mesh_default_triangulation_3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c2t3</td><td>2-complex (surface) living in a 3d triangulation (e.g. result of CGAL::make_surface_mesh) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff conversion was successful, failure can ok if CGAL code can't figure out ordering. </dd></dl>

</div>
</div>
<a id="a9135f1c36fb37be3a3dc9a924ef40fe6" name="a9135f1c36fb37be3a3dc9a924ef40fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9135f1c36fb37be3a3dc9a924ef40fe6">&#9670;&#160;</a></span>component_inside_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::component_inside_component </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if connected facet component (V1, F1, I1) is inside of connected facet component (V2, F2, I2). </p>
<dl class="section pre"><dt>Precondition</dt><dd>Both components must represent closed, self-intersection free, non-degenerated surfaces that are the boundary of 3D volumes. In addition, (V1, F1, I1) must not intersect with (V2, F2, I2).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V1</td><td>#V1 by 3 list of vertex position of mesh 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F1</td><td>#F1 by 3 list of triangles indices into V1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I1</td><td>#I1 list of indices into F1, indicate the facets of component </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V2</td><td>#V2 by 3 list of vertex position of mesh 2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F2</td><td>#F2 by 3 list of triangles indices into V2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I2</td><td>#I2 list of indices into F2, indicate the facets of component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff (V1, F1, I1) is entirely inside of (V2, F2, I2). </dd></dl>

</div>
</div>
<a id="ac01406d0fbbda3a765535e66ed8ee95a" name="ac01406d0fbbda3a765535e66ed8ee95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01406d0fbbda3a765535e66ed8ee95a">&#9670;&#160;</a></span>component_inside_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::component_inside_component </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae28edab222791aa6fba773fb1216f592" name="ae28edab222791aa6fba773fb1216f592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28edab222791aa6fba773fb1216f592">&#9670;&#160;</a></span>convex_hull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedW , typename DerivedG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::convex_hull </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points (V), compute the convex hull as a triangle mesh (W,G) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of input points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#W by 3 list of convex hull points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of triangle indices into W </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3d6357a7a4ea861133f2983359ec4ef" name="ac3d6357a7a4ea861133f2983359ec4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d6357a7a4ea861133f2983359ec4ef">&#9670;&#160;</a></span>convex_hull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::convex_hull </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a84ac00710a1dcb3c5d4a26e102f0f422" name="a84ac00710a1dcb3c5d4a26e102f0f422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac00710a1dcb3c5d4a26e102f0f422">&#9670;&#160;</a></span>coplanar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::coplanar </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether all points are on same plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of 3D vertex positions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all points lie on the same plane </dd></dl>

</div>
</div>
<a id="a7a07bdc787f5318cc08c6496b4d72fa7" name="a7a07bdc787f5318cc08c6496b4d72fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a07bdc787f5318cc08c6496b4d72fa7">&#9670;&#160;</a></span>delaunay_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::delaunay_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in 2D, return a Delaunay triangulation of these points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 of faces in Delaunay triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f5b45863dd50fb45ac3cdd481623afe" name="a1f5b45863dd50fb45ac3cdd481623afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f5b45863dd50fb45ac3cdd481623afe">&#9670;&#160;</a></span>extract_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DeriveduE , typename DerivedEMAP , typename DeriveduEC , typename DeriveduEE , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::copyleft::cgal::extract_cells </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedEMAP &gt; &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract connected 3D space partitioned by mesh (V, F). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 array of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 array of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#F list of patch indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of vertex_indices, represents undirected edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into uE. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumsums of directed edges sharing each unique edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#E list of indices into E (see <code><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">igl::unique_edge_map</a></code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cells</td><td>#F by 2 array of cell indices. cells(i,0) represents the cell index on the positive side of face i, and cells(i,1) represents cell index of the negqtive side. By convension cell with index 0 is the infinite cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of cells </dd></dl>

</div>
</div>
<a id="aca7332bc7dbe6723fc063783c66439b1" name="aca7332bc7dbe6723fc063783c66439b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7332bc7dbe6723fc063783c66439b1">&#9670;&#160;</a></span>extract_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::copyleft::cgal::extract_cells </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a57fad6c44f9853281fe023252bf967fa" name="a57fad6c44f9853281fe023252bf967fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fad6c44f9853281fe023252bf967fa">&#9670;&#160;</a></span>extract_cells_single_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DeriveduE , typename DeriveduEC , typename DeriveduEE , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::copyleft::cgal::extract_cells_single_component </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract connected 3D space partitioned by mesh (V,F) composed of <b>possibly multiple components</b> (the name of this function is dubious). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 array of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 array of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#F list of patch indices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of vertex_indices, represents undirected edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEC</td><td>#uE+1 list of cumsums of directed edges sharing each unique edge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uEE</td><td>#E list of indices into E (see <code><a class="el" href="namespaceigl.html#a5ec9f63d03451613c1a56df8308fe4b2" title="Construct relationships between facet &quot;half&quot;-(or rather &quot;viewed&quot;)-edges E to unique edges of the mesh...">igl::unique_edge_map</a></code>) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cells</td><td>#P by 2 array of cell indices. cells(i,0) represents the cell index on the positive side of patch i, and cells(i,1) represents cell index of the negative side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of components </dd></dl>

</div>
</div>
<a id="a2db9c1082a8f9b57e7b7344a328badd7" name="a2db9c1082a8f9b57e7b7344a328badd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db9c1082a8f9b57e7b7344a328badd7">&#9670;&#160;</a></span>extract_feature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedfeature_edges &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::extract_feature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedfeature_edges &gt; &amp;&#160;</td>
          <td class="paramname"><em>feature_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract feature edges based on dihedral angle. </p>
<p>Here, dihedral angle is defined as the angle between surface <b>normals</b> as described in <a href="http://mathworld.wolfram.com/DihedralAngle.html">http://mathworld.wolfram.com/DihedralAngle.html</a></p>
<p>Non-manifold and boundary edges are automatically considered as features.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 array of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 array of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Edges with dihedral angle larger than this are considered as features. Angle is measured in radian. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">feature_edges</td><td>#E by 2 array of edges. Each edge satisfies at least one of the following criteria:<ul>
<li>Edge has dihedral angle larger than tol.</li>
<li>Edge is boundary.</li>
<li>Edge is non-manifold (i.e. it has more than 2 adjacent faces). </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6453a79d93b320a4360444550d13b0ac" name="a6453a79d93b320a4360444550d13b0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6453a79d93b320a4360444550d13b0ac">&#9670;&#160;</a></span>extract_feature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DeriveduE , typename Derivedfeature_edges &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::extract_feature </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; typename DeriveduE::Scalar &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedfeature_edges &gt; &amp;&#160;</td>
          <td class="paramname"><em>feature_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9825eec87220923c563797c7119485e" name="aa9825eec87220923c563797c7119485e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9825eec87220923c563797c7119485e">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedN , typename DerivedQ , typename BetaType , typename DerivedWN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>expansion_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BetaType&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;&#160;</td>
          <td class="paramname"><em>WN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the fast winding number for point data, without known areas. </p>
<p>The areas are calculated using <a class="el" href="namespaceigl.html#a6f2969bd735df2588ce37026375ddefe" title="Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neigh...">igl::knn</a> and <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a1240cef3d039ac518baca44025fe1adc" title="Given a 3D set of points P, each with a list of k-nearest-neighbours, estimate the geodesic voronoi a...">igl::copyleft::cgal::point_areas</a>.</p>
<p>This function performes the precomputation and evaluation all in one. If you need to acess the precomuptation for repeated evaluations, use the two functions designed for exposed precomputation, which are the first two functions see in <a class="el" href="fast__winding__number_8h.html">igl/fast_winding_number.h</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of point locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of point normals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by 3 list of query points for the winding number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>This is a Barnes-Hut style accuracy term that separates near feild from far field. The higher the beta, the more accurate and slower the evaluation. We reccommend using a beta value of 2. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expansion_order</td><td>the order of the taylor expansion. We support 0,1,2. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WN</td><td>#Q by 1 list of windinng number values at each query point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abed4986e59db067d2f048150af7ca39f" name="abed4986e59db067d2f048150af7ca39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed4986e59db067d2f048150af7ca39f">&#9670;&#160;</a></span>fast_winding_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedN , typename DerivedQ , typename DerivedWN &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::fast_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedWN &gt; &amp;&#160;</td>
          <td class="paramname"><em>WN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9139148a9ac6f9b4b152790a827c0427" name="a9139148a9ac6f9b4b152790a827c0427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9139148a9ac6f9b4b152790a827c0427">&#9670;&#160;</a></span>half_space_box() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::half_space_box </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Plane_3&lt; CGAL::Epeck &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; CGAL::Epeck::FT, 8, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>BV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, 12, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a mesh of box (BV,BF) so that it contains the intersection of the half-space under the plane (P) and the bounding box of V, and does not contain any of the half-space above (P). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>plane so that normal points away from half-space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BV</td><td>#BV by 3 list of box vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BF</td><td>#BF b3 list of box triangle indices into BV </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7726e6100f1c5c7645949fa2156cf2a" name="aa7726e6100f1c5c7645949fa2156cf2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7726e6100f1c5c7645949fa2156cf2a">&#9670;&#160;</a></span>half_space_box() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedp , typename Derivedn , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::half_space_box </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedp &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedn &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; CGAL::Epeck::FT, 8, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>BV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, 12, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>3d point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>3d vector of normal of plane pointing away from inside </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad92813e51e83af95eb0961bf8756b557" name="ad92813e51e83af95eb0961bf8756b557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92813e51e83af95eb0961bf8756b557">&#9670;&#160;</a></span>half_space_box() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedequ , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::half_space_box </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedequ &gt; &amp;&#160;</td>
          <td class="paramname"><em>equ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; CGAL::Epeck::FT, 8, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>BV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; int, 12, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>BF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">equ</td><td>plane equation: a*x+b*y+c*z + d = 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ac0ac630b70601fd761c3f55877c178" name="a3ac0ac630b70601fd761c3f55877c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac0ac630b70601fd761c3f55877c178">&#9670;&#160;</a></span>hausdorff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename Kernel , typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::hausdorff </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt;::iterator &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>treeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>TB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scalar &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute lower and upper bounds (l,u) on the Hausdorff distance between a triangle (V) and a pointset (e.g., mesh, triangle soup) given by a distance function handle (dist_to_B). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>3 by 3 list of corner positions so that V.row(i) is the position of the ith corner </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">treeB</td><td>CGAL's <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree containing triangle soup (VB,FB) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TB</td><td>list of CGAL triangles in order of FB (for determining which was found in computation) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">l</td><td>lower bound on Hausdorff distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>upper bound on Hausdorff distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cbee8698ddf7b0868d3b433b6d5bd77" name="a3cbee8698ddf7b0868d3b433b6d5bd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cbee8698ddf7b0868d3b433b6d5bd77">&#9670;&#160;</a></span>incircle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short igl::copyleft::cgal::incircle </td>
          <td>(</td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether point is in a given circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>2D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>2D point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if pd is inside of the oriented circle formed by pa,pb,pc. 0 if pd is co-circular with pa,pb,pc. -1 if pd is outside of the oriented circle formed by pa,pb,pc. </dd></dl>

</div>
</div>
<a id="ada1796699e0d1f0830cc933d704cc918" name="ada1796699e0d1f0830cc933d704cc918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1796699e0d1f0830cc933d704cc918">&#9670;&#160;</a></span>insert_into_cdt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::insert_into_cdt </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Plane_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Constrained_triangulation_plus_2&lt; CGAL::Constrained_Delaunay_triangulation_2&lt; Kernel, CGAL::Triangulation_data_structure_2&lt; CGAL::Triangulation_vertex_base_2&lt; Kernel &gt;, CGAL::Constrained_triangulation_face_base_2&lt; Kernel &gt; &gt;, CGAL::Exact_intersections_tag &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a current 2D constrained Delaunay triangulation (cdt), insert a 3D "object" (e.g., resulting from intersecting two triangles) into the cdt, by projecting it via the given plane (P) and adding appropriate constraints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>CGAL::Object representing a vertex, segment, or (convex) polygon. All vertices should lie on the plane P. If not, then this adds the <em>projection</em> of this object to the cdt and that might not be what you wanted to do. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>plane obj lies on and upon which the cdt is being performed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cdt</td><td>current CDT, see output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cdt</td><td>CDT updated to contain constraints for the given object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a296c297c8c29baf446426fb8e72e4974" name="a296c297c8c29baf446426fb8e72e4974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a296c297c8c29baf446426fb8e72e4974">&#9670;&#160;</a></span>insphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short igl::copyleft::cgal::insphere </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pa</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pb</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pc</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pd</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pe</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether point is in a given sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>3D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>3D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>3D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>3D point on sphere </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pe</td><td>3D point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if pe is inside of the oriented sphere formed by pa,pb,pc,pd, 0 if pe is co-spherical with pa,pb,pc,pd, -1 if pe is outside of the oriented sphere formed by pa,pb,pc,pd. </dd></dl>

</div>
</div>
<a id="aad0ee9bfc55573ac2ac722c5d6e6d8bc" name="aad0ee9bfc55573ac2ac722c5d6e6d8bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0ee9bfc55573ac2ac722c5d6e6d8bc">&#9670;&#160;</a></span>intersect_other() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedIF , typename DerivedVVAB , typename DerivedFFAB , typename DerivedJAB , typename DerivedIMAB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::intersect_other </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIF &gt; &amp;&#160;</td>
          <td class="paramname"><em>IF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVVAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VVAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFFAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FFAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>JAB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIMAB &gt; &amp;&#160;</td>
          <td class="paramname"><em>IMAB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces. </p>
<p>Note that self-intersections are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FA</td><td>#F by 3 list of triangle indices into VA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FB</td><td>#F by 3 list of triangle indices into VB </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>whether to detect only and then whether to only find first intersection </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IF</td><td>#intersecting face pairs by 2 list of intersecting face pairs, indexing FA and FB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VVAB</td><td>#VVAB by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FFAB</td><td>#FFAB by 3 list of triangle indices into VVA </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">JAB</td><td>#FFAB list of indices into [FA;FB] denoting birth triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IMAB</td><td>#VVAB list of indices stitching duplicates (resulting from mesh intersections) together </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a id="a0d884b824ed6773fde6de21ce4178b1a" name="a0d884b824ed6773fde6de21ce4178b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d884b824ed6773fde6de21ce4178b1a">&#9670;&#160;</a></span>intersect_other() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::intersect_other </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>first_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>IF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_only</td><td>whether to only find first intersection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbf85761952ab999a6d3a69e91017ee1" name="acbf85761952ab999a6d3a69e91017ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf85761952ab999a6d3a69e91017ee1">&#9670;&#160;</a></span>intersect_with_half_space() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedp , typename Derivedn , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::intersect_with_half_space </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedp &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedn &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersect a PWN mesh with a half-space. </p>
<p>Point on plane, normal pointing outward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>3d point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>3d vector of normal of plane pointing away from inside </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VC</td><td>#VC by 3 list of vertex positions of boolean result mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FC</td><td>#FC by 3 list of triangle indices into VC </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#FC list of indices into [F;F.rows()+[1;2]] revealing "birth" facet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if mesh_boolean was succsesful </dd></dl>

</div>
</div>
<a id="afc6b67a7451e027f0c39d1ae171fd1dc" name="afc6b67a7451e027f0c39d1ae171fd1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6b67a7451e027f0c39d1ae171fd1dc">&#9670;&#160;</a></span>intersect_with_half_space() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Derivedequ , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::intersect_with_half_space </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedequ &gt; &amp;&#160;</td>
          <td class="paramname"><em>equ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">equ</td><td>plane equation: P(x,y,z) = a*x+b*y+c*z + d = 0, P(x,y,z) &lt; 0 is <em>inside</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28d4989493710230161702638797c2af" name="a28d4989493710230161702638797c2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d4989493710230161702638797c2af">&#9670;&#160;</a></span>intersect_with_half_space() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::intersect_with_half_space </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Plane_3&lt; CGAL::Epeck &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>plane <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d7510126e3d13d597b9c2dbe0bac28" name="a15d7510126e3d13d597b9c2dbe0bac28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d7510126e3d13d597b9c2dbe0bac28">&#9670;&#160;</a></span>lexicographic_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::lexicographic_triangulation </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points in 2D, return a lexicographic triangulation of these points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 of faces in lexicographic triangulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06c593a5aedf52ccb8234edccc484607" name="a06c593a5aedf52ccb8234edccc484607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c593a5aedf52ccb8234edccc484607">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Boolean csg operations on "solid", consistently oriented meshes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td>#VA by 3 list of vertex positions of first mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FA</td><td>#FA by 3 list of triangle indices into VA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td>#VB by 3 list of vertex positions of second mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FB</td><td>#FB by 3 list of triangle indices into VB </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>type of boolean operation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VC</td><td>#VC by 3 list of vertex positions of boolean result mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FC</td><td>#FC by 3 list of triangle indices into VC </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#FC list of indices into [FA;FA.rows()+FB] revealing "birth" facet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if inputs induce a piecewise constant winding number field and type is valid</dd></dl>
<dl class="section see"><dt>See also</dt><dd>mesh_boolean_cork, <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aad0ee9bfc55573ac2ac722c5d6e6d8bc" title="Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces.">intersect_other</a>, <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a7169f4ae2fe2c11f7e878b41aa747fc2" title="Given a triangle mesh (V,F) compute a new mesh (VV,FF) which is the same as (V,F) except that any sel...">remesh_self_intersections</a> </dd></dl>

</div>
</div>
<a id="ada8cdea765193ffb966531a02372dfd6" name="ada8cdea765193ffb966531a02372dfd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8cdea765193ffb966531a02372dfd6">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>type_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_str</td><td>string describing type of boolean operation see mesh_boolean_type_to_funcs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af80e3892da699c718eebaec432e26db5" name="af80e3892da699c718eebaec432e26db5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80e3892da699c718eebaec432e26db5">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>wind_num_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const int, const int)&gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wind_num_op</td><td>function handle for filtering winding numbers from tuples of integer values to [0,1] outside/inside values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>function handle for determining if a patch should be "kept" in the output based on the winding number on either side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cbd1329be2838714aeed904875b7a39" name="a2cbd1329be2838714aeed904875b7a39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbd1329be2838714aeed904875b7a39">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>Flist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>wind_num_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const int, const int)&gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variadic mesh Boolean operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vlist</td><td>k-long list of lists of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Flist</td><td>k-long list of lists of mesh face indices, so that Flist[i] indexes vertices in Vlist[i] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wind_num_op</td><td>function handle for filtering winding numbers from n-tuples of integer values to [0,1] outside/inside values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keep</td><td>function handle for determining if a patch should be "kept" in the output based on the winding number on either side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VC</td><td>#VC by 3 list of vertex positions of boolean result mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FC</td><td>#FC by 3 list of triangle indices into VC </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#FC list of indices into [Flist[0];Flist[1];...;Flist[k]] revealing "birth" facet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff inputs induce a piecewise constant winding number field </dd></dl>

</div>
</div>
<a id="a2365a0f9b66688565308b8c431321390" name="a2365a0f9b66688565308b8c431321390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2365a0f9b66688565308b8c431321390">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>Flist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae3ca56172ae354965d5ec22690a6f488" name="ae3ca56172ae354965d5ec22690a6f488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ca56172ae354965d5ec22690a6f488">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVV , typename DerivedFF , typename Derivedsizes , typename DerivedVC , typename DerivedFC , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedsizes &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>wind_num_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(const int, const int)&gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Given a merged mesh (V,F) and list of sizes of inputs</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of merged mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of merged mesh face indices so that first sizes(0) faces come from the first input, and the next sizes(1) faces come from the second input, and so on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizes</td><td>#inputs list of sizes so that sizes(i) is the #faces in the ith input </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa93f53bb9649aefd700d76e8fbbc628c" name="aa93f53bb9649aefd700d76e8fbbc628c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f53bb9649aefd700d76e8fbbc628c">&#9670;&#160;</a></span>mesh_boolean() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedVC , typename DerivedFC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_boolean </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVC &gt; &amp;&#160;</td>
          <td class="paramname"><em>VC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFC &gt; &amp;&#160;</td>
          <td class="paramname"><em>FC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a4a7a5d1111aea73ba095a0af9bf39153" name="a4a7a5d1111aea73ba095a0af9bf39153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7a5d1111aea73ba095a0af9bf39153">&#9670;&#160;</a></span>mesh_boolean_type_to_funcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::mesh_boolean_type_to_funcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(const Eigen::Matrix&lt; int, 1, Eigen::Dynamic &gt;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>wind_num_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int(const int, const int)&gt; &amp;&#160;</td>
          <td class="paramname"><em>keep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a MeshBooleanType enum to a pair of winding number conversion function and "keep" function used by mesh_boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>MeshBooleanType enum value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">wind_num_op</td><td>function handle for filtering winding numbers from tuples of integer values to [0,1] outside/inside values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">keep</td><td>function handle for determining if a patch should be "kept" in the output based on the winding number on either side</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#ac105fc714db9b51b1c3945c51e6e5a19" title="Convert string to boolean type.">string_to_mesh_boolean_type</a> </dd></dl>

</div>
</div>
<a id="ac9d72d2b7b5a3aa61b67b44df084c7db" name="ac9d72d2b7b5a3aa61b67b44df084c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d72d2b7b5a3aa61b67b44df084c7db">&#9670;&#160;</a></span>mesh_to_cgal_triangle_list()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::mesh_to_cgal_triangle_list </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a mesh (V,F) to a list of CGAL triangles. </p>
<p>@2tparam Kernal CGAL computation and construction kernel (e.g. CGAL::Exact_predicates_exact_constructions_kernel) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#F list of CGAL triangles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02acbbee9fc0e71fecf7e1f3ee5a58a8" name="a02acbbee9fc0e71fecf7e1f3ee5a58a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02acbbee9fc0e71fecf7e1f3ee5a58a8">&#9670;&#160;</a></span>mesh_to_polyhedron()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Polyhedron &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::mesh_to_polyhedron </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polyhedron &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a mesh (V,F) to a CGAL Polyhedron. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Polyhedron</td><td>CGAL Polyhedron type (e.g. Polyhedron_3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poly</td><td>cgal polyhedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only if (V,F) can be converted to a valid polyhedron (i.e. if (V,F) is vertex and edge manifold). </dd></dl>

</div>
</div>
<a id="aae36641a8877fe6384673c10bef5d05c" name="aae36641a8877fe6384673c10bef5d05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae36641a8877fe6384673c10bef5d05c">&#9670;&#160;</a></span>minkowski_sum() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedW , typename DerivedG , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::minkowski_sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>resolve_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Minkowski sum of a closed triangle mesh (V,F) and a set of simplices in 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td>#VA by 3 list of mesh vertices in 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FA</td><td>#FA by 3 list of triangle indices into VA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td>#VB by 3 list of mesh vertices in 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FB</td><td>#FB by ss list of simplex indices into VB, ss&lt;=3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resolve_overlaps</td><td>whether or not to resolve self-union. If false then result may contain self-intersections if input mesh is non-convex. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#W by 3 list of mesh vertices in 3D </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of triangle indices into W </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G by 2 list of indices into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac24439be4f8127484eeecd0dbf9f0ded" name="ac24439be4f8127484eeecd0dbf9f0ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24439be4f8127484eeecd0dbf9f0ded">&#9670;&#160;</a></span>minkowski_sum() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename sType , int sCols, int sOptions, typename dType , int dCols, int dOptions, typename DerivedW , typename DerivedG , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::minkowski_sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; sType, 1, sCols, sOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; dType, 1, dCols, dOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>resolve_overlaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Compute the Minkowski sum of a closed triangle mesh (V,F) and a segment [s,d] in 3D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>segment source endpoint in 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>segment source endpoint in 3D </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7a270ca1724856eb95f5d2a31056f99" name="aa7a270ca1724856eb95f5d2a31056f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a270ca1724856eb95f5d2a31056f99">&#9670;&#160;</a></span>minkowski_sum() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename sType , int sCols, int sOptions, typename dType , int dCols, int dOptions, typename DerivedW , typename DerivedG , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::minkowski_sum </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; sType, 1, sCols, sOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; dType, 1, dCols, dOptions &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8689344acbbb3e7bec33eb425d59cdde" name="a8689344acbbb3e7bec33eb425d59cdde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8689344acbbb3e7bec33eb425d59cdde">&#9670;&#160;</a></span>order_facets_around_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::order_facets_around_edge </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>adj_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a directed edge, sort its adjacent faces. </p>
<p>Assuming the directed edge is (s, d). Sort the adjacent faces clockwise around the axis (d - s), i.e. left-hand rule. An adjacent face is consistently oriented if it contains (d, s) as a directed edge.</p>
<p>For overlapping faces, break the tie using signed face index, smaller signed index comes before the larger signed index. Signed index is computed as (consistent? 1:-1) * (face_index + 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Index of source vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>Index of destination vertex. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">adj_faces</td><td>List of adjacent face signed indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">order</td><td>List of face indices that orders adjacent faces around edge (s, d) clockwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa24fb4d258316354531a7d02652cf1f3" name="aa24fb4d258316354531a7d02652cf1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24fb4d258316354531a7d02652cf1f3">&#9670;&#160;</a></span>order_facets_around_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::order_facets_around_edge </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>adj_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>pivot_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>This function is a wrapper around the one above. Since the ordering is circular, the pivot point is used to define a starting point. So order[0] is the index into adj_face that is immediately after the pivot face (s, d, pivot point) in clockwise order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pivot_point</td><td>A point that forms pivot with edge (s,d) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc6ed199484566caed79fdc9ca79d92a" name="afc6ed199484566caed79fdc9ca79d92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6ed199484566caed79fdc9ca79d92a">&#9670;&#160;</a></span>order_facets_around_edges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename uE2EType , typename uE2oEType , typename uE2CType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt; typenameDerivedV::Scalar, typenameCGAL::Exact_predicates_exact_constructions_kernel::FT &gt;::value, void &gt;::type igl::copyleft::cgal::order_facets_around_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2oEType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2CType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For each undirected edge, sort its adjacent faces. </p>
<p>Assuming the undirected edge is (s, d). Sort the adjacent faces clockwise around the axis (d - s), i.e. left-hand rule. An adjacent face is consistently oriented if it contains (d, s) as a directed edge.</p>
<p>For overlapping faces, break the tie using signed face index, smaller signed index comes before the larger signed index. Signed index is computed as (consistent? 1:-1) * index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#F by 3 list of face normals. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE</td><td>#uE by 2 list of vertex_indices, represents undirected edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">uE2E</td><td>#uE list of lists that maps uE to E. (a one-to-many map) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE2oE</td><td>#uE list of lists that maps uE to an ordered list of E. (a one-to-many map) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uE2C</td><td>#uE list of lists of bools indicates whether each face in uE2oE[i] is consistently orientated as the ordering. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77808bfdbb9a20091bf1403f0df54225" name="a77808bfdbb9a20091bf1403f0df54225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77808bfdbb9a20091bf1403f0df54225">&#9670;&#160;</a></span>order_facets_around_edges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DeriveduE , typename uE2EType , typename uE2oEType , typename uE2CType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typenameDerivedV::Scalar, typenameCGAL::Exact_predicates_exact_constructions_kernel::FT &gt;::value, void &gt;::type igl::copyleft::cgal::order_facets_around_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2oEType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2CType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ac9d848d80df05abbc188abf9410eff26" name="ac9d848d80df05abbc188abf9410eff26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d848d80df05abbc188abf9410eff26">&#9670;&#160;</a></span>order_facets_around_edges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DeriveduE , typename uE2EType , typename uE2oEType , typename uE2CType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::order_facets_around_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; uE2EType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2oEType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2oE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; uE2CType &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE2C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Order faces around each edge. Only exact predicate is used in the algorithm. Normal is not needed. </p>

</div>
</div>
<a id="afc46637c226f5ef8f24214ecf37fa2dc" name="afc46637c226f5ef8f24214ecf37fa2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc46637c226f5ef8f24214ecf37fa2dc">&#9670;&#160;</a></span>orient2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short igl::copyleft::cgal::orient2D </td>
          <td>(</td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a point is above, on, or below a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>2D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>2D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>2D point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if pa,pb,pc,pd forms a triangle of positive area. 0 if pa,pb,pc,pd are coplanar. -1 if pa,pb,pc,pd forms a tet of negative area. </dd></dl>

</div>
</div>
<a id="ad5b50178318855b0ef08301aabb646e1" name="ad5b50178318855b0ef08301aabb646e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b50178318855b0ef08301aabb646e1">&#9670;&#160;</a></span>orient3D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">short igl::copyleft::cgal::orient3D </td>
          <td>(</td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pa</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pb</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pc</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>pd</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests whether a point is above, on, or below a plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pa</td><td>3D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pb</td><td>3D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pc</td><td>3D point on plane </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pd</td><td>3D point to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if pa,pb,pc,pd forms a tet of positive volume. 0 if pa,pb,pc,pd are coplanar. -1 if pa,pb,pc,pd forms a tet of negative volume. </dd></dl>

</div>
</div>
<a id="a8612a06da5a83f2d0eb5234eb996a099" name="a8612a06da5a83f2d0eb5234eb996a099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8612a06da5a83f2d0eb5234eb996a099">&#9670;&#160;</a></span>outer_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::outer_edge </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find an edge that is reachable from infinity without crossing any faces. </p>
<p>Such edge is called "outer edge."</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input mesh must have all self-intersection resolved and no duplicated vertices. The correctness of the output depends on the fact that there is no edge overlap. See cgal::remesh_self_intersections.h for how to obtain such input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of facets to consider </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v1</td><td>index of the first end point of outer edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v2</td><td>index of the second end point of outer edge </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#A list of facets incident to the outer edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af01d429e270d88b1c279c860631ad5a7" name="af01d429e270d88b1c279c860631ad5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d429e270d88b1c279c860631ad5a7">&#9670;&#160;</a></span>outer_facet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedN , typename DerivedI , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::outer_facet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>flipped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a facet that is reachable from infinity without crossing any faces. </p>
<p>Such facet is called "outer facet."</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input mesh must have all self-intersection resolved. I.e there is no duplicated vertices, no overlapping edge and no intersecting faces (the only exception is there could be topologically duplicated faces). See cgal::remesh_self_intersections.h for how to obtain such input.</dd></dl>
<p>This function differ from <a class="el" href="namespaceigl.html#ab8ea262d61548f3946263a5c00ed0192" title="Find a facet that is reachable from infinity without crossing any faces.">igl::outer_facet()</a> in the fact this function is more robust because it does not rely on facet normals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of facets to consider </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#N by 3 list of face normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Index of the outer facet. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flipped</td><td>true iff the normal of f points inwards. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a075bcb6ea0a7e4bd56f56d57255422f7" name="a075bcb6ea0a7e4bd56f56d57255422f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075bcb6ea0a7e4bd56f56d57255422f7">&#9670;&#160;</a></span>outer_facet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::outer_facet </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>flipped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abf86c29b557c7341d5d6a2ae734273d4" name="abf86c29b557c7341d5d6a2ae734273d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf86c29b557c7341d5d6a2ae734273d4">&#9670;&#160;</a></span>outer_hull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedHV , typename DerivedHF , typename DerivedJ , typename Derivedflip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::outer_hull </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedHV &gt; &amp;&#160;</td>
          <td class="paramname"><em>HV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedHF &gt; &amp;&#160;</td>
          <td class="paramname"><em>HF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedflip &gt; &amp;&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the "outer hull" of a piecewise constant winding number induce triangle mesh (V,F). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HV</td><td>#HV by 3 list of output vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">HF</td><td>#HF by 3 list of output triangle indices into HV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#HF list of indices into F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flip</td><td>#HF list of whether facet was flipped when added to HF </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a69c0cfdf86cb14a3a1af742b322257" name="a0a69c0cfdf86cb14a3a1af742b322257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a69c0cfdf86cb14a3a1af742b322257">&#9670;&#160;</a></span>outer_hull_legacy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedG , typename DerivedJ , typename Derivedflip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::outer_hull_legacy </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedG &gt; &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedflip &gt; &amp;&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the "outer hull" of a potentially non-manifold mesh (V,F) whose intersections have been "resolved" (e.g. </p>
<p>using <code>cork</code> or <code>igl::copyleft::cgal::selfintersect</code>). The outer hull is defined to be all facets (regardless of orientation) for which there exists some path from infinity to the face without intersecting any other facets. For solids, this is the surface of the solid. In general this includes any thin "wings" or "flaps". This implementation largely follows Section 3.6 of "Direct
repair of self-intersecting meshes" [Attene 2014].</p>
<dl class="section note"><dt>Note</dt><dd>This doesn't require the input mesh to be piecewise constant winding number, but won't handle multiple non-nested connected components.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of output triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G list of indices into F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flip</td><td>#F list of whether facet was added to G <b>and</b> flipped orientation (false for faces not added to G) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a978bd4e32580644accd9602fafec9c3d" name="a978bd4e32580644accd9602fafec9c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978bd4e32580644accd9602fafec9c3d">&#9670;&#160;</a></span>outer_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename IndexType , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::outer_vertex </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>v_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a vertex that is reachable from infinite without crossing any faces. </p>
<p>Such vertex is called "outer vertex."</p>
<dl class="section pre"><dt>Precondition</dt><dd>The input mesh must have all self-intersection resolved and no duplicated vertices. See cgal::remesh_self_intersections.h for how to obtain such input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of facets to consider </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">v_index</td><td>index of outer vertex </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#A list of facets incident to the outer vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a3a5e1ab834f987bb22bceea2d29f36" name="a1a3a5e1ab834f987bb22bceea2d29f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3a5e1ab834f987bb22bceea2d29f36">&#9670;&#160;</a></span>peel_outer_hull_layers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename Derivedflip &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::copyleft::cgal::peel_outer_hull_layers </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedflip &gt; &amp;&#160;</td>
          <td class="paramname"><em>flip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes necessary generic information for boolean operations by successively "peeling" off the "outer hull" of a mesh (V,F) resulting from "resolving" all (self-)intersections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#F list of which peel Iation a facet belongs </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flip</td><td>#F list of whether a facet's orientation was flipped when facet "peeled" into its associated outer hull layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of peels </dd></dl>

</div>
</div>
<a id="ac1f61d0bdf6d687737bc08b5fa72111a" name="ac1f61d0bdf6d687737bc08b5fa72111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f61d0bdf6d687737bc08b5fa72111a">&#9670;&#160;</a></span>peel_winding_number_layers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t igl::copyleft::cgal::peel_winding_number_layers </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Peel Winding number layers from a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by 1 list of winding numbers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55276c7ddaadbfad9b0ddf0beeb756fe" name="a55276c7ddaadbfad9b0ddf0beeb756fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55276c7ddaadbfad9b0ddf0beeb756fe">&#9670;&#160;</a></span>piecewise_constant_winding_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::piecewise_constant_winding_number </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a given mesh induces a piecewise constant winding number field: Is this mesh valid input to solid set operations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the mesh <em>combinatorially</em> induces a piecewise constant winding number field. </dd></dl>

</div>
</div>
<a id="a1240cef3d039ac518baca44025fe1adc" name="a1240cef3d039ac518baca44025fe1adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1240cef3d039ac518baca44025fe1adc">&#9670;&#160;</a></span>point_areas() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA , typename DerivedT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_areas </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedT &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 3D set of points P, each with a list of k-nearest-neighbours, estimate the geodesic voronoi area associated with each point. </p>
<p>The k nearest neighbours may be known from running igl::knn_octree on the output data from <a class="el" href="namespaceigl.html#a3ff69240d0614e6f4ab20ff15b2f21a4" title="Given a set of 3D points P, generate data structures for a pointerless octree.">igl::octree</a>. We reccomend using a k value between 15 and 20 inclusive for accurate area estimation.</p>
<p>N is used filter the neighbours, to ensure area estimation only occurs using neighbors that are on the same side of the surface (ie for thin sheets), as well as to solve the orientation ambiguity of the tangent plane normal.</p>
<dl class="section note"><dt>Note</dt><dd>This function <em>should</em> be implemented by pre-filtering I, rather than filtering in this function using N. In this case, the function would only take P and I as input.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of point locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#P by k list of k-nearest-neighbor indices into P </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of point normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>#P list of estimated areas </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a6f2969bd735df2588ce37026375ddefe" title="Given a 3D set of points P, an whole number k, and an octree find the indicies of the k nearest neigh...">igl::knn</a> </dd></dl>

</div>
</div>
<a id="a3b9e1a72f57d4b751d6ad9a482a00e36" name="a3b9e1a72f57d4b751d6ad9a482a00e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9e1a72f57d4b751d6ad9a482a00e36">&#9670;&#160;</a></span>point_areas() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedI , typename DerivedN , typename DerivedA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_areas </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedA &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a538a22d0da720af8d4bc8943eeb78ccd" name="a538a22d0da720af8d4bc8943eeb78ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538a22d0da720af8d4bc8943eeb78ccd">&#9670;&#160;</a></span>point_mesh_squared_distance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename DerivedP , typename DerivedV , typename DerivedF , typename DerivedsqrD , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_mesh_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute distances from a set of points P to a triangle mesh (V,F) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Kernal</td><td>CGAL computation and construction kernel (e.g. CGAL::Simple_cartesian&lt;double&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrD</td><td>#P list of smallest squared distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#P list of facet indices corresponding to smallest distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#P by 3 list of closest points</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7079694987005d32d246369f638930a2" name="a7079694987005d32d246369f638930a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7079694987005d32d246369f638930a2">&#9670;&#160;</a></span>point_mesh_squared_distance_precompute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_mesh_squared_distance_precompute </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt;::iterator &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>precomputation for point_mesh_squared_distance </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tree</td><td>CGAL's <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>list of CGAL triangles in order of F (for determining which was found in computation)</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="copyleft_2cgal_2point__mesh__squared__distance_8h.html">include/igl/copyleft/cgal/point_mesh_squared_distance.h</a> </p>

</div>
</div>
<a id="a4b06702d1399da65b7d57a7883a903cd" name="a4b06702d1399da65b7d57a7883a903cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b06702d1399da65b7d57a7883a903cd">&#9670;&#160;</a></span>point_mesh_squared_distance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename DerivedP , typename DerivedsqrD , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_mesh_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt;::iterator &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedsqrD &gt; &amp;&#160;</td>
          <td class="paramname"><em>sqrD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute distances from a set of points P to a triangle mesh (V,F) using precomputed trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>CGAL's <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>list of CGAL triangles in order of F (for determining which was found in computation) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sqrD</td><td>#P list of smallest squared distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#P list of facet indices corresponding to smallest distances </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#P by 3 list of closest points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb0f63485251c67fe5632d5177cf3cf8" name="aeb0f63485251c67fe5632d5177cf3cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0f63485251c67fe5632d5177cf3cf8">&#9670;&#160;</a></span>point_segment_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Segment_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Kernel::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point P1 and segment S2 find the points on each of closest approach and the squared distance thereof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>segment </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td>point on S2 closest to P1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>distance betwee P1 and S2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba6c0e12a671c3facc2b5129904c738e" name="aba6c0e12a671c3facc2b5129904c738e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6c0e12a671c3facc2b5129904c738e">&#9670;&#160;</a></span>point_solid_signed_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedQ , typename DerivedVB , typename DerivedFB , typename DerivedD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_solid_signed_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a set of points (Q) and the boundary mesh (VB,FB) of a solid (as defined in [Zhou et al. </p>
<p>2016], determine the signed squared distance for each point q in Q so that d(q,B) is negative if inside and positive if outside.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q by 3 list of query point positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td>#VB by 3 list of mesh vertex positions of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FB</td><td>#FB by 3 list of mesh triangle indices into VB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#Q list of signed squared distances </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27577e36f63f566d05abe10135706585" name="a27577e36f63f566d05abe10135706585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27577e36f63f566d05abe10135706585">&#9670;&#160;</a></span>point_triangle_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::point_triangle_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Triangle_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Kernel::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a point P1 and triangle T2 find the points on each of closest approach and the squared distance thereof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P1</td><td>point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T2</td><td>triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td>point on T2 closest to P1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>distance betwee P1 and T2 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41473b3f595af6326c481f3be623b95d" name="a41473b3f595af6326c481f3be623b95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41473b3f595af6326c481f3be623b95d">&#9670;&#160;</a></span>points_inside_component() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedP , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::points_inside_component </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if queries points P are inside of connected facet component (V, F, I), where I indicates a subset of facets that forms the component. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The input mesh must be a closed, self-intersection free, non-degenerated surface. Queries points must be either inside or outside of the mesh (i.e. not on the surface of the mesh).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 array of vertex positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 array of triangles. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of triangle indices to consider. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 array of query points. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inside</td><td>#P list of booleans that is true iff the corresponding query point is inside of the mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa361bd05fcdd8ce7cc09059a90a71397" name="aa361bd05fcdd8ce7cc09059a90a71397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa361bd05fcdd8ce7cc09059a90a71397">&#9670;&#160;</a></span>points_inside_component() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::points_inside_component </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedB &gt; &amp;&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9163b384abc034cb8ef2c61e545c1da0" name="a9163b384abc034cb8ef2c61e545c1da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9163b384abc034cb8ef2c61e545c1da0">&#9670;&#160;</a></span>polyhedron_to_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Polyhedron , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::polyhedron_to_mesh </td>
          <td>(</td>
          <td class="paramtype">const Polyhedron &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a CGAL Polyhedron to a mesh (V,F) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Polyhedron</td><td>CGAL Polyhedron type (e.g. Polyhedron_3) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>cgal polyhedron </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6b773fa54359274318604d433dd2e9a" name="ad6b773fa54359274318604d433dd2e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b773fa54359274318604d433dd2e9a">&#9670;&#160;</a></span>projected_cdt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename Index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::projected_cdt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CGAL::Object &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Plane_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CGAL::Point_3&lt; Kernel &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; Index &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of objects (e.g., resulting from intersecting a triangle with many other triangles), construct a constrained Delaunay triangulation on a given plane (P), by inersting constraints for each object projected onto that plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objects</td><td>list of objects. This should lie on the given plane (P), otherwise they are added to the cdt <em>after</em> their non-trivial projection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>plane upon which all objects lie and upon which the CDT is conducted </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>list of vertices of the CDT mesh <em>back on the 3D plane</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faces</td><td>list of list of triangle indices into vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45607f6c08fba2fc4a797244d7c75b81" name="a45607f6c08fba2fc4a797244d7c75b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45607f6c08fba2fc4a797244d7c75b81">&#9670;&#160;</a></span>projected_cdt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::projected_cdt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; CGAL::Object &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Plane_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of vertices of the CDT mesh <em>back on the 3D plane</em>, <b>cast</b> from the number type of Kernel to the number type of DerivedV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a62d282e26f8a1b91722dd9da3b5bd2" name="a7a62d282e26f8a1b91722dd9da3b5bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a62d282e26f8a1b91722dd9da3b5bd2">&#9670;&#160;</a></span>projected_delaunay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::projected_delaunay </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Triangle_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CGAL::Object &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_objects_3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Constrained_triangulation_plus_2&lt; CGAL::Constrained_Delaunay_triangulation_2&lt; Kernel, CGAL::Triangulation_data_structure_2&lt; CGAL::Triangulation_vertex_base_2&lt; Kernel &gt;, CGAL::Constrained_triangulation_face_base_2&lt; Kernel &gt; &gt;, CGAL::Exact_intersections_tag &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cdt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute 2D delaunay triangulation of a given 3d triangle and a list of intersection objects (points,segments,triangles). </p>
<p>CGAL uses an affine projection rather than an isometric projection, so we're not guaranteed that the 2D delaunay triangulation here will be a delaunay triangulation in 3D.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>triangle in 3D </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A_objects_3</td><td>updated list of intersection objects for A </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cdt</td><td>Contrained delaunay triangulation in projected 2D plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab29a1ce9ef6539d66c1400a27db655d0" name="ab29a1ce9ef6539d66c1400a27db655d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29a1ce9ef6539d66c1400a27db655d0">&#9670;&#160;</a></span>propagate_winding_numbers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedL , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::propagate_winding_numbers </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute winding number on each side of the face. </p>
<p>The input mesh could contain multiple connected components. The input mesh must represent the boundary of a valid 3D volume, which means it is closed, consistently oriented and induces integer winding numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">labels</td><td>#F list of facet labels ranging from 0 to k-1. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#F by k*2 list of winding numbers. <code>W(i,j*2)</code> is the winding number on the positive side of facet <code>i</code> with respect to the facets labeled <code>j</code>. Similarly, <code>W(i,j*2+1)</code> is the winding number on the negative side of facet <code>i</code> with respect to the facets labeled <code>j</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff the input induces a piecewise-constant winding number field.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This shouldn't need to be in <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html">igl::copyleft::cgal</a>, it should instead take as input an index of the ambient cell and the winding number vector there. </dd></dl>

</div>
</div>
<a id="a55a2fbf8152086bfb9f61740ebdec358" name="a55a2fbf8152086bfb9f61740ebdec358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a2fbf8152086bfb9f61740ebdec358">&#9670;&#160;</a></span>propagate_winding_numbers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DeriveduE , typename DeriveduEC , typename DeriveduEE , typename DerivedP , typename DerivedC , typename DerivedL , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::propagate_winding_numbers </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEC &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DeriveduEE &gt; &amp;&#160;</td>
          <td class="paramname"><em>uEE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedL &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8359e73ff0ee8149c314d3816b5958f" name="ae8359e73ff0ee8149c314d3816b5958f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8359e73ff0ee8149c314d3816b5958f">&#9670;&#160;</a></span>read_triangle_mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::read_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple wrapper, reads floating point precision but assigns to DerivedV::Scalar which may be a CGAL type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>path to file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>eigen double matrix #V by 3 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>eigen int matrix #F by 3 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a6bd18b073b51beb1500c10c4f2825aba" title="Read mesh from an ascii file with automatic detection of file format among: mesh, msh obj,...">igl::read_triangle_mesh</a> </dd></dl>

</div>
</div>
<a id="a3d3dc739f900eb1f9479e974de035d2c" name="a3d3dc739f900eb1f9479e974de035d2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3dc739f900eb1f9479e974de035d2c">&#9670;&#160;</a></span>relabel_small_immersed_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedC , typename FT , typename DerivedW &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::relabel_small_immersed_cells </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_patches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FT&#160;</td>
          <td class="paramname"><em>vol_threashold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedW &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relabel winding numbers of small immersed cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_patches</td><td>number of patches </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#F list of patch ids. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_cells</td><td>number of cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#P by 2 list of cell ids on each side of each patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vol_threshold</td><td>Volume threshold, cells smaller than this and is completely immersed will be relabeled. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#F by 2 cell labels. W(i,0) is the label on the positive side of face i, W(i,1) is the label on the negative side of face i. W will be modified in place by this method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99d687331f910fef280e3a0e5f5370c7" name="a99d687331f910fef280e3a0e5f5370c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d687331f910fef280e3a0e5f5370c7">&#9670;&#160;</a></span>remesh_intersections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename Kernel , typename DerivedVV , typename DerivedFF , typename DerivedJ , typename DerivedIM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::remesh_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; CGAL::Triangle_3&lt; Kernel &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; typename DerivedF::Index, std::vector&lt; std::pair&lt; typename DerivedF::Index, CGAL::Object &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>offending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stitch_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>slow_and_more_precise_rounding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>IM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remesh faces according to results of intersection detection and construction (e.g. </p>
<p>from <code><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#aad0ee9bfc55573ac2ac722c5d6e6d8bc" title="Given a triangle mesh (VA,FA) and another mesh (VB,FB) find all pairs of intersecting faces.">igl::copyleft::cgal::intersect_other</a></code> or <code><a class="el" href="classigl_1_1copyleft_1_1cgal_1_1SelfIntersectMesh.html" title="Class for computing the self-intersections of a mesh.">igl::copyleft::cgal::SelfIntersectMesh</a></code>)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>#F list of cgal triangles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offending</td><td>#offending map taking face indices into F to pairs of order of first finding and list of intersection objects from all intersections </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stitch_all</td><td>if true, merge all vertices with the same coordinate. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VV</td><td>#VV by 3 list of vertex positions, if stitch_all = false then first #V vertices will always be V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#FF by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IF</td><td>#intersecting face pairs by 2 list of intersecting face pairs, indexing F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#FF list of indices into F denoting birth triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IM</td><td>if stitch_all = true #VV list from 0 to #VV-1 elseif stitch_all = false #VV list of indices into VV of unique vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7169f4ae2fe2c11f7e878b41aa747fc2" name="a7169f4ae2fe2c11f7e878b41aa747fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7169f4ae2fe2c11f7e878b41aa747fc2">&#9670;&#160;</a></span>remesh_self_intersections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVV , typename DerivedFF , typename DerivedIF , typename DerivedJ , typename DerivedIM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::remesh_self_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIF &gt; &amp;&#160;</td>
          <td class="paramname"><em>IF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>IM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a triangle mesh (V,F) compute a new mesh (VV,FF) which is the same as (V,F) except that any self-intersecting triangles in (V,F) have been subdivided (new vertices and face created) so that the self-intersection contour lies exactly on edges in (VV,FF). </p>
<p>New vertices will appear in original faces or on original edges. New vertices on edges are "merged" only across original faces sharing that edge. This means that if the input triangle mesh is a closed manifold the output will be too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>struct of optional parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VV</td><td>#VV by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#FF by 3 list of triangle indices into VV </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IF</td><td>#intersecting face pairs by 2 list of intersecting face pairs, indexing F </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#FF list of indices into F denoting birth triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IM</td><td>#VV list of indices into VV of unique vertices.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md6"></a>
Example.</h4>
<p>// resolve intersections igl::copyleft::cgal::remesh_self_intersections(V,F,params,VV,FF,IF,J,IM); // <em>apply</em> duplicate vertex mapping IM to FF for_each(FF.data(),FF.data()+FF.size(),[&amp;IM](int &amp; a){a=IM(a);}); // remove any vertices now unreferenced after duplicate mapping. igl::remove_unreferenced(VV,FF,SV,SF,UIM); // Now (SV,SF) is ready to extract outer hull igl::copyleft::cgal::outer_hull(SV,SF,G,J,flip); </p>

</div>
</div>
<a id="a65f8fa9920a99cd809e2944afed7c908" name="a65f8fa9920a99cd809e2944afed7c908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f8fa9920a99cd809e2944afed7c908">&#9670;&#160;</a></span>remesh_self_intersections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedVV , typename DerivedFF , typename DerivedIF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::remesh_self_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structigl_1_1copyleft_1_1cgal_1_1RemeshSelfIntersectionsParam.html">RemeshSelfIntersectionsParam</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVV &gt; &amp;&#160;</td>
          <td class="paramname"><em>VV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIF &gt; &amp;&#160;</td>
          <td class="paramname"><em>IF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.IM above is <em>applied</em> to merge duplicated vertices in VV. </p>

</div>
</div>
<a id="a4711ebc19670232979ddfafeea023a6c" name="a4711ebc19670232979ddfafeea023a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4711ebc19670232979ddfafeea023a6c">&#9670;&#160;</a></span>resolve_intersections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedE , typename DerivedVI , typename DerivedEI , typename DerivedJ , typename DerivedIM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::resolve_intersections </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>VI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEI &gt; &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>IM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of possible intersecting segments with endpoints, split segments to overlap only at endpoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of segment indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VI</td><td>#VI by 2 list of output vertex positions, copies of V are always the first #V vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EI</td><td>#EI by 2 list of segment indices into V, #EI ≥ #E </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#EI list of indices into E revealing "parent segments" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IM</td><td>#VI list of indices into VV of unique vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacfa81a78943385b9146fe53e121b380" name="aacfa81a78943385b9146fe53e121b380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa81a78943385b9146fe53e121b380">&#9670;&#160;</a></span>row_to_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename DerivedV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CGAL::Point_2&lt; Kernel &gt; igl::copyleft::cgal::row_to_point </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename DerivedV::Index &amp;&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a row from V and treat as a 2D cgal point (only first two columns of V are used). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>row index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2D cgal point </dd></dl>

</div>
</div>
<a id="a1cd33a114c5e272d9d444bea740c4cfc" name="a1cd33a114c5e272d9d444bea740c4cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd33a114c5e272d9d444bea740c4cfc">&#9670;&#160;</a></span>segment_segment_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::segment_segment_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Segment_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>S1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Segment_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>S2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Kernel::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two segments S1 and S2 find the points on each of closest approach and the squared distance thereof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S1</td><td>first segment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">S2</td><td>second segment </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[oout]</td><td>P1 point on S1 closest to S2 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[oout]</td><td>P2 point on S2 closest to S1 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[oout]</td><td>d distance betwee P1 and S2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the closest approach is unique. </dd></dl>

</div>
</div>
<a id="a240ec71bf9ed8497cca131ce80e30045" name="a240ec71bf9ed8497cca131ce80e30045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240ec71bf9ed8497cca131ce80e30045">&#9670;&#160;</a></span>signed_distance_isosurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::signed_distance_isosurface </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>IF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>angle_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>radius_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>distance_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl.html#a92ae0e8cefa226a1e493b33684b0b02e">SignedDistanceType</a>&#160;</td>
          <td class="paramname"><em>sign_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the contour of an iso-level of the signed distance field to a given mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV by 3 list of input mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IF</td><td>#IF by 3 list of input triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>iso-level to contour in world coords, negative is inside. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">angle_bound</td><td>lower bound on triangle angles (mesh quality) (e.g. 28) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius_bound</td><td>upper bound on triangle size (mesh density?) (e.g. 0.02) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">distance_bound</td><td>cgal mysterious parameter (mesh density?) (e.g. 0.01) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sign_type</td><td>method for computing distance <em>sign</em> (see ../signed_distance.h) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of input mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of input triangle indices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if complex_to_mesh is successful </dd></dl>

</div>
</div>
<a id="a56339aee719b66761234276a14d7003f" name="a56339aee719b66761234276a14d7003f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56339aee719b66761234276a14d7003f">&#9670;&#160;</a></span>snap_rounding()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedE , typename DerivedVI , typename DerivedEI , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::snap_rounding </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>VI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEI &gt; &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Snap a list of possible intersecting segments with endpoints in any precision to <em>the</em> integer grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of segment indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VI</td><td>#VI by 2 list of output integer vertex positions, rounded copies of V are always the first #V vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EI</td><td>#EI by 2 list of segment indices into V, #EI ≥ #E </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#EI list of indices into E revealing "parent segments" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac105fc714db9b51b1c3945c51e6e5a19" name="ac105fc714db9b51b1c3945c51e6e5a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac105fc714db9b51b1c3945c51e6e5a19">&#9670;&#160;</a></span>string_to_mesh_boolean_type() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::string_to_mesh_boolean_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert string to boolean type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>string identifying type, one of the following: "union","intersect","minus","xor","resolve" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>type of boolean operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only on success </dd></dl>

</div>
</div>
<a id="a5cb4ded3fe8818156a5f7c540d771835" name="a5cb4ded3fe8818156a5f7c540d771835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb4ded3fe8818156a5f7c540d771835">&#9670;&#160;</a></span>string_to_mesh_boolean_type() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceigl.html#a16cc7fd8778cd880be528227e0318b9f">MeshBooleanType</a> igl::copyleft::cgal::string_to_mesh_boolean_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Returns type without error handling </p>

</div>
</div>
<a id="a347c87769a3b67d0bee379fb78705679" name="a347c87769a3b67d0bee379fb78705679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347c87769a3b67d0bee379fb78705679">&#9670;&#160;</a></span>subdivide_segments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedE , typename Kernel , typename DerivedVI , typename DerivedEI , typename DerivedJ , typename DerivedIM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::subdivide_segments </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; CGAL::Point_2&lt; Kernel &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>steiner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVI &gt; &amp;&#160;</td>
          <td class="paramname"><em>VI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedEI &gt; &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>IM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert steiner points to subdivide a given set of line segments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of segment indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steiner</td><td>#E list of lists of unsorted steiner points (including endpoints) along the #E original segments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VI</td><td>#VI by 2 list of output vertex positions, copies of V are always the first #V vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">EI</td><td>#EI by 2 list of segment indices into V, #EI ≥ #E </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#EI list of indices into E revealing "parent segments" </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IM</td><td>#VI list of indices into VV of unique vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5cc8bbbcee4ed4567bc754a4e939c0" name="a3b5cc8bbbcee4ed4567bc754a4e939c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5cc8bbbcee4ed4567bc754a4e939c0">&#9670;&#160;</a></span>submesh_aabb_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::submesh_aabb_tree </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::AABB_tree&lt; CGAL::AABB_traits&lt; Kernel, CGAL::AABB_triangle_primitive&lt; Kernel, typename std::vector&lt; typename Kernel::Triangle_3 &gt;::iterator &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename Kernel::Triangle_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an <a class="el" href="classigl_1_1AABB.html" title="Implementation of semi-general purpose axis-aligned bounding box hierarchy.">AABB</a> tree for a submesh indicated by a face selection list I of a full mesh (V,F) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 array of vertices. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 array of faces. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>#I list of triangle indices to consider. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tree</td><td>aabb containing triangles of (V,F(I,:)) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">triangles</td><td>#I list of cgal triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">in_I</td><td>#F list of whether in submesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a745c9671e98e82bb4f285b028c1aa8c9" name="a745c9671e98e82bb4f285b028c1aa8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745c9671e98e82bb4f285b028c1aa8c9">&#9670;&#160;</a></span>triangle_triangle_squared_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::cgal::triangle_triangle_squared_distance </td>
          <td>(</td>
          <td class="paramtype">const CGAL::Triangle_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>T1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CGAL::Triangle_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CGAL::Point_3&lt; Kernel &gt; &amp;&#160;</td>
          <td class="paramname"><em>P2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Kernel::FT &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two triangles T1 and T2 find the points on each of closest approach and the squared distance thereof. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T1</td><td>first triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T2</td><td>second triangle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P1</td><td>point on T1 closest to T2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P2</td><td>point on T2 closest to T1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>distance betwee P1 and T2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the closest approach is unique. </dd></dl>

</div>
</div>
<a id="a2c5d9c112aaddddfc00781eb000fddd4" name="a2c5d9c112aaddddfc00781eb000fddd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c5d9c112aaddddfc00781eb000fddd4">&#9670;&#160;</a></span>triangulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename DerivedV , typename DerivedE , typename DerivedH , typename DerivedV2 , typename DerivedF2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::triangulate </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedE &gt; &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedH &gt; &amp;&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>retain_convex_hull</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>F2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triangulate the interior of a polygon using CGAL. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 2 list of 2D vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 2 list of vertex ids forming unoriented edges of the boundary of the polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td>#H by 2 coordinates of points contained inside holes of the polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">retain_convex_hull</td><td>whether to retain convex hull {true} or trim away all faces reachable from infinite by traversing across non-constrained edges {false}. {true → "c" flag in <code>triangle</code>} </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V2</td><td>#V2 by 2 coordinates of the vertives of the generated triangulation </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F2</td><td>#F2 by 3 list of indices forming the faces of the generated triangulation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl_1_1triangle.html#ae4d5a5fa0ad34c41ec9e3361be3f249a" title="Triangulate the interior of a polygon using the triangle library.">igl::triangle::triangulate</a> </dd></dl>

</div>
</div>
<a id="a6dca57f7cfcb9b65b561d5d3ccec99be" name="a6dca57f7cfcb9b65b561d5d3ccec99be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dca57f7cfcb9b65b561d5d3ccec99be">&#9670;&#160;</a></span>trim_with_solid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedV , typename DerivedF , typename DerivedD , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::trim_with_solid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an arbitrary mesh (VA,FA) and the boundary mesh (VB,FB) of a solid (as defined in [Zhou et al. </p>
<p>2016]), Resolve intersections between A and B subdividing faces of A so that intersections with B exists only along edges and vertices (and coplanar faces). Then determine whether each of these faces is inside or outside of B. This can be used to extract the part of A inside or outside of B.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">VA</td><td>#VA by 3 list of mesh vertex positions of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FA</td><td>#FA by 3 list of mesh triangle indices into VA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VB</td><td>#VB by 3 list of mesh vertex positions of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">FB</td><td>#FB by 3 list of mesh triangle indices into VB </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions of output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">D</td><td>#F list of bools whether face is inside B </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F list of indices into FA revealing birth parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace643f9725b6a5aad6e10cadb57f0de0" name="ace643f9725b6a5aad6e10cadb57f0de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace643f9725b6a5aad6e10cadb57f0de0">&#9670;&#160;</a></span>trim_with_solid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedVA , typename DerivedFA , typename DerivedVB , typename DerivedFB , typename DerivedV , typename DerivedF , typename DerivedD , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::trim_with_solid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVA &gt; &amp;&#160;</td>
          <td class="paramname"><em>VA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFA &gt; &amp;&#160;</td>
          <td class="paramname"><em>FA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedVB &gt; &amp;&#160;</td>
          <td class="paramname"><em>VB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedFB &gt; &amp;&#160;</td>
          <td class="paramname"><em>FB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html#a2ed8d1b22fc3cb87822647766b3dc863">TrimWithSolidMethod</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedD &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">method</td><td>which method for extracting and determining the trim contents. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1da8adecc2e7b09a987748532fb975d2" name="a1da8adecc2e7b09a987748532fb975d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da8adecc2e7b09a987748532fb975d2">&#9670;&#160;</a></span>wire_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedWV , typename DerivedWE , typename Derivedth , typename DerivedV , typename DerivedF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::wire_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedWV &gt; &amp;&#160;</td>
          <td class="paramname"><em>WV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedWE &gt; &amp;&#160;</td>
          <td class="paramname"><em>WE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; Derivedth &gt; &amp;&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>poly_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>solid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a "wire" or "wireframe" or "strut" surface mesh, given a one-dimensional network of straight edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">WV</td><td>#WV by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WE</td><td>#WE by 2 list of edge indices into WV </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">th</td><td>#WE diameter thicknesses of wire edges </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly_size</td><td>number of sides on each wire (e.g., 4 would produce wires by connecting rectangular prisms). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solid</td><td>whether to resolve self-intersections to create a "solid" output mesh (cf., [Zhou et al. 2016] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V by 3 list of output vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F by 3 list of output triangle indices into V </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#F list of indices into [0,#WV+#WE) revealing "birth simplex" of output faces J(j) &lt; #WV means the face corresponds to the J(j)th vertex in WV. J(j) &gt;= #WV means the face corresponds to the (J(j)-#WV)th edge in WE. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dc5cdc053c1f25a930d46be790a7c74" name="a7dc5cdc053c1f25a930d46be790a7c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc5cdc053c1f25a930d46be790a7c74">&#9670;&#160;</a></span>wire_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedWV , typename DerivedWE , typename DerivedV , typename DerivedF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::wire_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedWV &gt; &amp;&#160;</td>
          <td class="paramname"><em>WV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedWE &gt; &amp;&#160;</td>
          <td class="paramname"><em>WE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>poly_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>solid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>uniform th </p>

</div>
</div>
<a id="a88a350d009b191ea77e7bb454a2936d7" name="a88a350d009b191ea77e7bb454a2936d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a350d009b191ea77e7bb454a2936d7">&#9670;&#160;</a></span>wire_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedWV , typename DerivedWE , typename DerivedV , typename DerivedF , typename DerivedJ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::cgal::wire_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedWV &gt; &amp;&#160;</td>
          <td class="paramname"><em>WV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedWE &gt; &amp;&#160;</td>
          <td class="paramname"><em>WE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>poly_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedJ &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Solid == true </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceigl.html">igl</a></li><li class="navelem"><a class="el" href="namespaceigl_1_1copyleft.html">copyleft</a></li><li class="navelem"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html">cgal</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
