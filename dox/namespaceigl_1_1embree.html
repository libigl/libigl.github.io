<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libigl: igl::embree Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libigl
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceigl_1_1embree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">igl::embree Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structigl_1_1embree_1_1EmbreeDevice.html">EmbreeDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep track of embree device instance  <a href="structigl_1_1embree_1_1EmbreeDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple class to wrap Embree's ray tracing functionality.  <a href="classigl_1_1embree_1_1EmbreeIntersector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab0db10673eed92bdb98b52a69046eb2a"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:ab0db10673eed92bdb98b52a69046eb2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#ab0db10673eed92bdb98b52a69046eb2a">ambient_occlusion</a> (const Eigen::MatrixBase&lt; DerivedV &gt; &amp;V, const Eigen::MatrixBase&lt; DerivedF &gt; &amp;F, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:ab0db10673eed92bdb98b52a69046eb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute ambient occlusion per given point.  <br /></td></tr>
<tr class="separator:ab0db10673eed92bdb98b52a69046eb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffda2e4befd6b4388bc7fc6147131fe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:acffda2e4befd6b4388bc7fc6147131fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#acffda2e4befd6b4388bc7fc6147131fe">ambient_occlusion</a> (const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, const Eigen::MatrixBase&lt; DerivedP &gt; &amp;P, const Eigen::MatrixBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="separator:acffda2e4befd6b4388bc7fc6147131fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc213ed6fba98d34eda3f84e08195720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#abc213ed6fba98d34eda3f84e08195720">bone_heat</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXd &amp;C, const Eigen::VectorXi &amp;P, const Eigen::MatrixXi &amp;BE, const Eigen::MatrixXi &amp;CE, Eigen::MatrixXd &amp;W)</td></tr>
<tr class="memdesc:abc213ed6fba98d34eda3f84e08195720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute skinning weights W given a surface mesh (V,F) and an internal skeleton (C,BE) according to "Automatic Rigging" [Baran and Popovic 2007].  <br /></td></tr>
<tr class="separator:abc213ed6fba98d34eda3f84e08195720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445638aff9f180c63695a5b86172fdb1"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedSD , typename Derivedflag &gt; </td></tr>
<tr class="memitem:a445638aff9f180c63695a5b86172fdb1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a445638aff9f180c63695a5b86172fdb1">bone_visible</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;s, const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;d, Eigen::PlainObjectBase&lt; Derivedflag &gt; &amp;flag)</td></tr>
<tr class="memdesc:a445638aff9f180c63695a5b86172fdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether vertices of mesh are "visible" to a given bone, where "visible" is defined as in [Baran &amp; Popovic 07].  <br /></td></tr>
<tr class="separator:a445638aff9f180c63695a5b86172fdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d462713a1a56f7c91fa6b74cfc5906"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedSD , typename Derivedflag &gt; </td></tr>
<tr class="memitem:a58d462713a1a56f7c91fa6b74cfc5906"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a58d462713a1a56f7c91fa6b74cfc5906">bone_visible</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;s, const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;d, Eigen::PlainObjectBase&lt; Derivedflag &gt; &amp;flag)</td></tr>
<tr class="memdesc:a58d462713a1a56f7c91fa6b74cfc5906"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a58d462713a1a56f7c91fa6b74cfc5906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd345c8c661526ebb4bab1605393afe8"><td class="memTemplParams" colspan="2">template&lt;typename ScalarMatrix , typename IndexMatrix &gt; </td></tr>
<tr class="memitem:acd345c8c661526ebb4bab1605393afe8"><td class="memTemplItemLeft" align="right" valign="top">ScalarMatrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#acd345c8c661526ebb4bab1605393afe8">line_mesh_intersection</a> (const ScalarMatrix &amp;V_source, const ScalarMatrix &amp;N_source, const ScalarMatrix &amp;V_target, const IndexMatrix &amp;F_target)</td></tr>
<tr class="memdesc:acd345c8c661526ebb4bab1605393afe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the point cloud V_source onto the triangle mesh V_target,F_target.  <br /></td></tr>
<tr class="separator:acd345c8c661526ebb4bab1605393afe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d8808b728c372e38d88371dee2cf0f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedC &gt; </td></tr>
<tr class="memitem:a50d8808b728c372e38d88371dee2cf0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a50d8808b728c372e38d88371dee2cf0f">reorient_facets_raycast</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, int rays_total, int rays_minimum, bool facet_wise, bool use_parity, bool is_verbose, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I, Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;C)</td></tr>
<tr class="memdesc:a50d8808b728c372e38d88371dee2cf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient each component (identified by C) of a mesh (V,F) using ambient occlusion such that the front side is less occluded than back side, as described in "A Simple Method for Correcting Facet Orientations in
Polygon Meshes Based on Ray Casting" [Takayama et al.  <br /></td></tr>
<tr class="separator:a50d8808b728c372e38d88371dee2cf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7d02a9d43ec8e0735b96166341d68"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedFF , typename DerivedI &gt; </td></tr>
<tr class="memitem:a7dd7d02a9d43ec8e0735b96166341d68"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a7dd7d02a9d43ec8e0735b96166341d68">reorient_facets_raycast</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;FF, Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;I)</td></tr>
<tr class="separator:a7dd7d02a9d43ec8e0735b96166341d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93025c9bea20cc5c7dcf9c3c0606a3df"><td class="memTemplParams" colspan="2">template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a93025c9bea20cc5c7dcf9c3c0606a3df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a93025c9bea20cc5c7dcf9c3c0606a3df">shape_diameter_function</a> (const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a93025c9bea20cc5c7dcf9c3c0606a3df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute shape diamter function per given point.  <br /></td></tr>
<tr class="separator:a93025c9bea20cc5c7dcf9c3c0606a3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628ebea8ce36a70ecb61abd5502b5ba4"><td class="memTemplParams" colspan="2">template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </td></tr>
<tr class="memitem:a628ebea8ce36a70ecb61abd5502b5ba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a628ebea8ce36a70ecb61abd5502b5ba4">shape_diameter_function</a> (const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;V, const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;F, const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;P, const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;N, const int num_samples, Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;S)</td></tr>
<tr class="memdesc:a628ebea8ce36a70ecb61abd5502b5ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a628ebea8ce36a70ecb61abd5502b5ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80724fc46ca35d893a6253133fdf1f20"><td class="memTemplParams" colspan="2">template&lt;typename Derivedobj &gt; </td></tr>
<tr class="memitem:a80724fc46ca35d893a6253133fdf1f20"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a80724fc46ca35d893a6253133fdf1f20">unproject_in_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;obj, std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;hits)</td></tr>
<tr class="memdesc:a80724fc46ca35d893a6253133fdf1f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position <em>inside</em> a given mesh.  <br /></td></tr>
<tr class="separator:a80724fc46ca35d893a6253133fdf1f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f92b1ed81cbd29ef63241517ba0968"><td class="memTemplParams" colspan="2">template&lt;typename Derivedobj &gt; </td></tr>
<tr class="memitem:a63f92b1ed81cbd29ef63241517ba0968"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a63f92b1ed81cbd29ef63241517ba0968">unproject_in_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;obj)</td></tr>
<tr class="memdesc:a63f92b1ed81cbd29ef63241517ba0968"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a63f92b1ed81cbd29ef63241517ba0968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf896ed44c9329729459a291ac33047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a6cf896ed44c9329729459a291ac33047">unproject_onto_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::MatrixXi &amp;F, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, int &amp;fid, Eigen::Vector3f &amp;bc)</td></tr>
<tr class="memdesc:a6cf896ed44c9329729459a291ac33047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unproject a screen location (using the given model, proj and viewport) to find the first hit on a mesh.  <br /></td></tr>
<tr class="separator:a6cf896ed44c9329729459a291ac33047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227bbf88b8e795bea4558ab6018ea732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1embree.html#a227bbf88b8e795bea4558ab6018ea732">unproject_onto_mesh</a> (const Eigen::Vector2f &amp;pos, const Eigen::MatrixXi &amp;F, const Eigen::Matrix4f &amp;model, const Eigen::Matrix4f &amp;proj, const Eigen::Vector4f &amp;viewport, const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;ei, int &amp;fid, int &amp;vid)</td></tr>
<tr class="memdesc:a227bbf88b8e795bea4558ab6018ea732"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a227bbf88b8e795bea4558ab6018ea732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab0db10673eed92bdb98b52a69046eb2a" name="ab0db10673eed92bdb98b52a69046eb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0db10673eed92bdb98b52a69046eb2a">&#9670;&#160;</a></span>ambient_occlusion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::ambient_occlusion </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute ambient occlusion per given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positiosn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into rows of V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of origin normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of ambient occlusion values between 1 (fully occluded) and 0 (not occluded) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acffda2e4befd6b4388bc7fc6147131fe" name="acffda2e4befd6b4388bc7fc6147131fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffda2e4befd6b4388bc7fc6147131fe">&#9670;&#160;</a></span>ambient_occlusion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::ambient_occlusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc213ed6fba98d34eda3f84e08195720" name="abc213ed6fba98d34eda3f84e08195720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc213ed6fba98d34eda3f84e08195720">&#9670;&#160;</a></span>bone_heat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::embree::bone_heat </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>CE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute skinning weights W given a surface mesh (V,F) and an internal skeleton (C,BE) according to "Automatic Rigging" [Baran and Popovic 2007]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh corner indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#C by 3 list of joint locations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P list of point handle indices into C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BE</td><td>#BE by 2 list of bone edge indices into C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CE</td><td>#CE by 2 list of cage edge indices into <b>P</b> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td>#V by #P+#BE matrix of weights. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true only on success. </dd></dl>

</div>
</div>
<a id="a445638aff9f180c63695a5b86172fdb1" name="a445638aff9f180c63695a5b86172fdb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445638aff9f180c63695a5b86172fdb1">&#9670;&#160;</a></span>bone_visible() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedSD , typename Derivedflag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::bone_visible </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedflag &gt; &amp;&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether vertices of mesh are "visible" to a given bone, where "visible" is defined as in [Baran &amp; Popovic 07]. </p>
<p>Instead of checking whether each point can see <em>any</em> of the bone, we just check if each point can see its own projection onto the bone segment. In other words, we project each vertex v onto the bone, projv. Then we check if there are any intersections between the line segment (projv--&gt;v) and the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>row vector of position of start end point of bone </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>row vector of position of dest end point of bone </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">flag</td><td>#V by 1 list of bools (true) visible, (false) obstructed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This checks for hits along the segment which are facing in <em>any</em> direction from the ray. </dd></dl>

</div>
</div>
<a id="a58d462713a1a56f7c91fa6b74cfc5906" name="a58d462713a1a56f7c91fa6b74cfc5906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d462713a1a56f7c91fa6b74cfc5906">&#9670;&#160;</a></span>bone_visible() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedSD , typename Derivedflag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::bone_visible </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedSD &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedflag &gt; &amp;&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ei</td><td><a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html" title="Simple class to wrap Embree&#39;s ray tracing functionality.">EmbreeIntersector</a> for mesh (V,F) should be double sided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd345c8c661526ebb4bab1605393afe8" name="acd345c8c661526ebb4bab1605393afe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd345c8c661526ebb4bab1605393afe8">&#9670;&#160;</a></span>line_mesh_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ScalarMatrix , typename IndexMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ScalarMatrix igl::embree::line_mesh_intersection </td>
          <td>(</td>
          <td class="paramtype">const ScalarMatrix &amp;&#160;</td>
          <td class="paramname"><em>V_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarMatrix &amp;&#160;</td>
          <td class="paramname"><em>N_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarMatrix &amp;&#160;</td>
          <td class="paramname"><em>V_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexMatrix &amp;&#160;</td>
          <td class="paramname"><em>F_target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project the point cloud V_source onto the triangle mesh V_target,F_target. </p>
<p>A ray is casted for every vertex in the direction specified by N_source and its opposite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V_source</td><td>#Vx3 Vertices of the source mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_source</td><td>#Vx3 Normals of the point cloud </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V_target</td><td>#V2x3 Vertices of the target mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F_target</td><td>#F2x3 Faces of the target mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#Vx3 matrix of baricentric coordinate. Each row corresponds to a vertex of the projected mesh and it has the following format: id b1 b2. id is the id of a face of the source mesh. b1 and b2 are the barycentric coordinates wrt the first two edges of the triangle To convert to standard global coordinates, see barycentric_to_global.h </dd></dl>

</div>
</div>
<a id="a50d8808b728c372e38d88371dee2cf0f" name="a50d8808b728c372e38d88371dee2cf0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d8808b728c372e38d88371dee2cf0f">&#9670;&#160;</a></span>reorient_facets_raycast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedI , typename DerivedC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::reorient_facets_raycast </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rays_total</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rays_minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>facet_wise</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_parity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_verbose</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient each component (identified by C) of a mesh (V,F) using ambient occlusion such that the front side is less occluded than back side, as described in "A Simple Method for Correcting Facet Orientations in
Polygon Meshes Based on Ray Casting" [Takayama et al. </p>
<p>2014].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of triangle indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rays_total</td><td>Total number of rays that will be shot </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rays_minimum</td><td>Minimum number of rays that each patch should receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">facet_wise</td><td>Decision made for each face independently, no use of patches (i.e., each face is treated as a patch) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_parity</td><td>Use parity mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_verbose</td><td>Verbose output to cout </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">I</td><td>#F list of whether face has been flipped </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#F list of patch ID (output of bfs_orient &gt; manifold patches) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dd7d02a9d43ec8e0735b96166341d68" name="a7dd7d02a9d43ec8e0735b96166341d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd7d02a9d43ec8e0735b96166341d68">&#9670;&#160;</a></span>reorient_facets_raycast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedFF , typename DerivedI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::reorient_facets_raycast </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFF &gt; &amp;&#160;</td>
          <td class="paramname"><em>FF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedI &gt; &amp;&#160;</td>
          <td class="paramname"><em>I</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">FF</td><td>#F by 3 list of reoriented faces</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md8"></a>
Defaults:</h4>
<p>rays_total = F.rows()*100; rays_minimum = 10; facet_wise = false; use_parity = false; is_verbose = false; </p>

</div>
</div>
<a id="a93025c9bea20cc5c7dcf9c3c0606a3df" name="a93025c9bea20cc5c7dcf9c3c0606a3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93025c9bea20cc5c7dcf9c3c0606a3df">&#9670;&#160;</a></span>shape_diameter_function() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::shape_diameter_function </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute shape diamter function per given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ei</td><td><a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html" title="Simple class to wrap Embree&#39;s ray tracing functionality.">EmbreeIntersector</a> containing (V,F) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P by 3 list of origin points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>#P by 3 list of origin normals </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#P list of shape diamater function values between bounding box diagonal (perfect sphere) and 0 (perfect needle hook) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a628ebea8ce36a70ecb61abd5502b5ba4" name="a628ebea8ce36a70ecb61abd5502b5ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a628ebea8ce36a70ecb61abd5502b5ba4">&#9670;&#160;</a></span>shape_diameter_function() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedV , typename DerivedF , typename DerivedP , typename DerivedN , typename DerivedS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::embree::shape_diameter_function </td>
          <td>(</td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedV &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedF &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedP &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::PlainObjectBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedS &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>Wrapper which builds new <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html" title="Simple class to wrap Embree&#39;s ray tracing functionality.">EmbreeIntersector</a> for (V,F). That's expensive so avoid this if repeatedly calling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of mesh vertex positiosn </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of mesh triangle indices into rows of V </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80724fc46ca35d893a6253133fdf1f20" name="a80724fc46ca35d893a6253133fdf1f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80724fc46ca35d893a6253133fdf1f20">&#9670;&#160;</a></span>unproject_in_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedobj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::embree::unproject_in_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structigl_1_1Hit.html">igl::Hit</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>hits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unproject a screen location (using current opengl viewport, projection, and model view) to a 3D position <em>inside</em> a given mesh. </p>
<p>If the ray through the given screen location (x,y) <em>hits</em> the mesh more than twice then the 3D midpoint between the first two hits is return. If it hits once, then that point is return. If it does not hit the mesh then obj is not set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>screen space coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>model matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>vieweport vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ei</td><td><a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html" title="Simple class to wrap Embree&#39;s ray tracing functionality.">EmbreeIntersector</a> containing (V,F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obj</td><td>3d unprojected mouse point in mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hits</td><td>vector of embree hits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of hits</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Previous prototype did not require model, proj, and viewport. This has been removed. Instead replace with: <pre class="fragment"> Eigen::Matrix4f model,proj;
 Eigen::Vector4f viewport;
 igl::opengl2::model_proj_viewport(model,proj,viewport);
 igl::embree::unproject_in_mesh(Vector2f(x,y),model,proj,viewport,ei,obj,hits);
</pre> </dd></dl>

</div>
</div>
<a id="a63f92b1ed81cbd29ef63241517ba0968" name="a63f92b1ed81cbd29ef63241517ba0968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f92b1ed81cbd29ef63241517ba0968">&#9670;&#160;</a></span>unproject_in_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derivedobj &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int igl::embree::unproject_in_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; Derivedobj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a6cf896ed44c9329729459a291ac33047" name="a6cf896ed44c9329729459a291ac33047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf896ed44c9329729459a291ac33047">&#9670;&#160;</a></span>unproject_onto_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::embree::unproject_onto_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Vector3f &amp;&#160;</td>
          <td class="paramname"><em>bc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unproject a screen location (using the given model, proj and viewport) to find the first hit on a mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>screen space coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 face matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>model matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">proj</td><td>projection matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">viewport</td><td>vieweport vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ei</td><td><a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html" title="Simple class to wrap Embree&#39;s ray tracing functionality.">EmbreeIntersector</a> containing (V,F) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fid</td><td>id of the first face hit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bc</td><td>barycentric coordinates of hit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is a hit </dd></dl>

</div>
</div>
<a id="a227bbf88b8e795bea4558ab6018ea732" name="a227bbf88b8e795bea4558ab6018ea732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227bbf88b8e795bea4558ab6018ea732">&#9670;&#160;</a></span>unproject_onto_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::embree::unproject_onto_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2f &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix4f &amp;&#160;</td>
          <td class="paramname"><em>proj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector4f &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classigl_1_1embree_1_1EmbreeIntersector.html">EmbreeIntersector</a> &amp;&#160;</td>
          <td class="paramname"><em>ei</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>fid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>vid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vid</td><td>vertex id of the closest vertex hit </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceigl.html">igl</a></li><li class="navelem"><a class="el" href="namespaceigl_1_1embree.html">embree</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
