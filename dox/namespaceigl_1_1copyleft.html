<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libigl: igl::copyleft Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libigl<span id="projectnumber">&#160;v2.5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceigl_1_1copyleft.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">igl::copyleft Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceigl_1_1copyleft_1_1cgal" id="r_namespaceigl_1_1copyleft_1_1cgal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1cgal.html">cgal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1copyleft_1_1comiso" id="r_namespaceigl_1_1copyleft_1_1comiso"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1comiso.html">comiso</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceigl_1_1copyleft_1_1tetgen" id="r_namespaceigl_1_1copyleft_1_1tetgen"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft_1_1tetgen.html">tetgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c5920cc7d10f7fc5a4de60dcee97163" id="r_a5c5920cc7d10f7fc5a4de60dcee97163"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedFaces &gt; </td></tr>
<tr class="memitem:a5c5920cc7d10f7fc5a4de60dcee97163"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a5c5920cc7d10f7fc5a4de60dcee97163">marching_cubes</a> (const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;values, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, const unsigned x_res, const unsigned y_res, const unsigned z_res, const double isovalue, Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;vertices, Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;faces)</td></tr>
<tr class="memdesc:a5c5920cc7d10f7fc5a4de60dcee97163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh defined by vertices and faces.  <br /></td></tr>
<tr class="separator:a5c5920cc7d10f7fc5a4de60dcee97163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df017abd3ecc522475b1c761dfcb884" id="r_a2df017abd3ecc522475b1c761dfcb884"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedFaces &gt; </td></tr>
<tr class="memitem:a2df017abd3ecc522475b1c761dfcb884"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a2df017abd3ecc522475b1c761dfcb884">marching_cubes</a> (const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;values, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, const unsigned x_res, const unsigned y_res, const unsigned z_res, Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;vertices, Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;faces)</td></tr>
<tr class="memdesc:a2df017abd3ecc522475b1c761dfcb884"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Overload of the above function where the isovalue defaults to 0.0.  <br /></td></tr>
<tr class="separator:a2df017abd3ecc522475b1c761dfcb884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e085211bca600f67f086f3a489c415" id="r_a94e085211bca600f67f086f3a489c415"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValue , typename DerivedPoint , typename DerivedPoints , typename DerivedVertices , typename DerivedFaces &gt; </td></tr>
<tr class="memitem:a94e085211bca600f67f086f3a489c415"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a94e085211bca600f67f086f3a489c415">marching_cubes</a> (const std::function&lt; DerivedValue(const DerivedPoint &amp;) &gt; &amp;value_fun, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, const unsigned x_res, const unsigned y_res, const unsigned z_res, const double isovalue, Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;vertices, Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;faces)</td></tr>
<tr class="memdesc:a94e085211bca600f67f086f3a489c415"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:a94e085211bca600f67f086f3a489c415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cd861ba98a41b35dcb8c94f147e27f" id="r_a58cd861ba98a41b35dcb8c94f147e27f"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedIndices , typename DerivedFaces &gt; </td></tr>
<tr class="memitem:a58cd861ba98a41b35dcb8c94f147e27f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a58cd861ba98a41b35dcb8c94f147e27f">marching_cubes</a> (const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;values, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, const Eigen::MatrixBase&lt; DerivedIndices &gt; &amp;indices, const double isovalue, Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;vertices, Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;faces)</td></tr>
<tr class="memdesc:a58cd861ba98a41b35dcb8c94f147e27f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform marching cubes reconstruction on the sparse grid cells defined by (indices, points).  <br /></td></tr>
<tr class="separator:a58cd861ba98a41b35dcb8c94f147e27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd17c22c13a6d3000c4d3553c47122fe" id="r_acd17c22c13a6d3000c4d3553c47122fe"><td class="memTemplParams" colspan="2">template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedIndices , typename DerivedFaces &gt; </td></tr>
<tr class="memitem:acd17c22c13a6d3000c4d3553c47122fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#acd17c22c13a6d3000c4d3553c47122fe">marching_cubes</a> (const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;values, const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;points, const Eigen::MatrixBase&lt; DerivedIndices &gt; &amp;indices, Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;vertices, Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;faces)</td></tr>
<tr class="memdesc:acd17c22c13a6d3000c4d3553c47122fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <br /></td></tr>
<tr class="separator:acd17c22c13a6d3000c4d3553c47122fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127b3a99bb9ceb2143b6a5c1a524574a" id="r_a127b3a99bb9ceb2143b6a5c1a524574a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a127b3a99bb9ceb2143b6a5c1a524574a">progressive_hulls</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const size_t max_m, Eigen::MatrixXd &amp;U, Eigen::MatrixXi &amp;G, Eigen::VectorXi &amp;J)</td></tr>
<tr class="memdesc:a127b3a99bb9ceb2143b6a5c1a524574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses edges until desired number of faces is achieved but ensures that new vertices are placed outside all previous meshes as per "progressive hulls" in "Silhouette clipping" [Sander et al.  <br /></td></tr>
<tr class="separator:a127b3a99bb9ceb2143b6a5c1a524574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411d44b5d8f23907ab845053fbf98a2a" id="r_a411d44b5d8f23907ab845053fbf98a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a411d44b5d8f23907ab845053fbf98a2a">progressive_hulls_cost_and_placement</a> (const int e, const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXi &amp;E, const Eigen::VectorXi &amp;EMAP, const Eigen::MatrixXi &amp;EF, const Eigen::MatrixXi &amp;EI, double &amp;cost, Eigen::RowVectorXd &amp;p)</td></tr>
<tr class="memdesc:a411d44b5d8f23907ab845053fbf98a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "cost and placement" compatible with <code><a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a></code> implementing the "progressive hulls" algorithm in "Silhouette clipping" [Sander et al.  <br /></td></tr>
<tr class="separator:a411d44b5d8f23907ab845053fbf98a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed7a42a1c65a33d80828d77d2d940d" id="r_a61ed7a42a1c65a33d80828d77d2d940d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceigl_1_1copyleft.html#a61ed7a42a1c65a33d80828d77d2d940d">quadprog</a> (const Eigen::MatrixXd &amp;G, const Eigen::VectorXd &amp;g0, const Eigen::MatrixXd &amp;CE, const Eigen::VectorXd &amp;ce0, const Eigen::MatrixXd &amp;CI, const Eigen::VectorXd &amp;ci0, Eigen::VectorXd &amp;x)</td></tr>
<tr class="memdesc:a61ed7a42a1c65a33d80828d77d2d940d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a (dense) convex quadratric program.  <br /></td></tr>
<tr class="separator:a61ed7a42a1c65a33d80828d77d2d940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5c5920cc7d10f7fc5a4de60dcee97163" name="a5c5920cc7d10f7fc5a4de60dcee97163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5920cc7d10f7fc5a4de60dcee97163">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedFaces &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>x_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>y_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>z_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh defined by vertices and faces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>#number_of_grid_points x 1 array &ndash; the scalar values of an implicit function defined on the grid points (&lt;0 in the inside of the surface, 0 on the border, &gt;0 outside) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>#number_of_grid_points x 3 array &ndash; 3-D positions of the grid points, ordered in x,y,z order: points[index] = the point at (x,y,z) where : x = (index % (xres -1), y = (index / (xres-1)) %(yres-1), z = index / (xres -1) / (yres -1) ). where x,y,z index x, y, z dimensions i.e. index = x + y*xres + z*xres*yres </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xres</td><td>resolutions of the grid in x dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yres</td><td>resolutions of the grid in y dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">zres</td><td>resolutions of the grid in z dimension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isovalue</td><td>the isovalue of the surface to reconstruct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faces</td><td>#F by 3 list of mesh triangle indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a3e677970b7188cac95bc9f93181f2ed7" title="Performs marching cubes reconstruction on a grid defined by values, and points, and generates a mesh ...">igl::marching_cubes</a> </dd></dl>

</div>
</div>
<a id="a2df017abd3ecc522475b1c761dfcb884" name="a2df017abd3ecc522475b1c761dfcb884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df017abd3ecc522475b1c761dfcb884">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedFaces &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>x_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>y_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>z_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. Overload of the above function where the isovalue defaults to 0.0. </p>

</div>
</div>
<a id="a94e085211bca600f67f086f3a489c415" name="a94e085211bca600f67f086f3a489c415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e085211bca600f67f086f3a489c415">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValue , typename DerivedPoint , typename DerivedPoints , typename DerivedVertices , typename DerivedFaces &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; DerivedValue(const DerivedPoint &amp;) &gt; &amp;&#160;</td>
          <td class="paramname"><em>value_fun</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>x_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>y_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>z_res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value_fun</td><td>a function that takes a 3D point and returns a scalar value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58cd861ba98a41b35dcb8c94f147e27f" name="a58cd861ba98a41b35dcb8c94f147e27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58cd861ba98a41b35dcb8c94f147e27f">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedIndices , typename DerivedFaces &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>isovalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform marching cubes reconstruction on the sparse grid cells defined by (indices, points). </p>
<p>The indices parameter is an nx8 dense array of index values into the points and values arrays. Each row of indices represents a cube for which to generate vertices and faces over.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>#number_of_grid_points x 1 array &ndash; the scalar values of an implicit function defined on the grid points (&lt;0 in the inside of the surface, 0 on the border, &gt;0 outside) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>#number_of_grid_points x 3 array &ndash; 3-D positions of the grid points, ordered in x,y,z order: </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>#cubes x 8 array &ndash; one row for each cube where each value is the index of a vertex in points and a scalar in values. i.e. points[indices[i, j]] = the position of the j'th vertex of the i'th cube </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>#V by 3 list of mesh vertex positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faces</td><td>#F by 3 list of mesh triangle indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The winding direction of the cube indices will affect the output winding of the faces </dd></dl>

</div>
</div>
<a id="acd17c22c13a6d3000c4d3553c47122fe" name="acd17c22c13a6d3000c4d3553c47122fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd17c22c13a6d3000c4d3553c47122fe">&#9670;&#160;</a></span>marching_cubes() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedValues , typename DerivedPoints , typename DerivedVertices , typename DerivedIndices , typename DerivedFaces &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::marching_cubes </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedValues &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedPoints &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixBase&lt; DerivedIndices &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedVertices &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::PlainObjectBase&lt; DerivedFaces &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>
<p>isovalue defaults to 0.0 </p>

</div>
</div>
<a id="a127b3a99bb9ceb2143b6a5c1a524574a" name="a127b3a99bb9ceb2143b6a5c1a524574a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127b3a99bb9ceb2143b6a5c1a524574a">&#9670;&#160;</a></span>progressive_hulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::progressive_hulls </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>max_m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>J</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapses edges until desired number of faces is achieved but ensures that new vertices are placed outside all previous meshes as per "progressive hulls" in "Silhouette clipping" [Sander et al. </p>
<p>2000].</p>
<dl class="section pre"><dt>Precondition</dt><dd>Assumes (V,F) is a closed manifold mesh</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by dim list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of face indices into V. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_m</td><td>desired number of output faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>#U by dim list of output vertex posistions (can be same ref as V) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">G</td><td>#G by 3 list of output face indices into U (can be same ref as G) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">J</td><td>#G list of indices into F of birth faces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if m was reached (otherwise #G &gt; m) </dd></dl>

</div>
</div>
<a id="a411d44b5d8f23907ab845053fbf98a2a" name="a411d44b5d8f23907ab845053fbf98a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411d44b5d8f23907ab845053fbf98a2a">&#9670;&#160;</a></span>progressive_hulls_cost_and_placement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void igl::copyleft::progressive_hulls_cost_and_placement </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>EMAP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>EI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "cost and placement" compatible with <code><a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a></code> implementing the "progressive hulls" algorithm in "Silhouette clipping" [Sander et al. </p>
<p>2000]. This implementation fixes an issue that the original linear program becomes unstable for flat patches by introducing a small quadratic energy term pulling the collapsed edge toward its midpoint. This function is not really meant to be called directly but rather passed to <code><a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a></code> as a handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>index of edge to be collapsed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V by 3 list of vertex positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F by 3 list of faces indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E by 3 list of edges indices into V </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMAP</td><td>#F*3 list of indices into E, mapping each directed edge to unique unique edge in E </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EF</td><td>#E by 2 list of edge flaps, EF(e,0)=f means e=(i--&gt;j) is the edge of F(f,:) opposite the vth corner, where EI(e,0)=v. Similarly EF(e,1) " e=(j-&gt;i) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EI</td><td>#E by 2 list of edge flap corners (see above). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cost</td><td>cost of collapsing edge e </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>position to place collapsed vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceigl.html#a48e2a2c1ae537d160f7767a230be66b3" title="Assumes (V,F) is a manifold mesh (possibly with boundary) collapses edges until desired number of fac...">igl::decimate</a>, <a class="el" href="namespaceigl.html#aa8e3cfdf30adcadd5172a4f0b862bf59" title="Attempt to collapse a given edge of a mesh.">igl::collapse_edge</a> </dd></dl>

</div>
</div>
<a id="a61ed7a42a1c65a33d80828d77d2d940d" name="a61ed7a42a1c65a33d80828d77d2d940d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ed7a42a1c65a33d80828d77d2d940d">&#9670;&#160;</a></span>quadprog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool igl::copyleft::quadprog </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>g0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>CE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ce0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>CI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>ci0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a (dense) convex quadratric program. </p>
<p>Given in the form </p><pre class="fragment"> min  0.5 x G x + g0 x
 s.t. CE' x + ce0  = 0
 and  CI' x + ci0 &gt;= 0
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">G</td><td>#x by #x matrix of quadratic coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g0</td><td>#x vector of linear coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CE</td><td>#x by #CE list of linear equality coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ce0</td><td>#CE list of linear equality right-hand sides </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">CI</td><td>#x by #CI list of linear equality coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ci0</td><td>#CI list of linear equality right-hand sides </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>#x vector of solution values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff success </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceigl.html">igl</a></li><li class="navelem"><a class="el" href="namespaceigl_1_1copyleft.html">copyleft</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
