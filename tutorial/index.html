
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="Simple C++ geometry processing library">
      
      
      
        <link rel="canonical" href="https://libigl.github.io/tutorial/">
      
      
        <link rel="prev" href="..">
      
      
        <link rel="next" href="../python-bindings/">
      
      
      <link rel="icon" href="../favicon.ico">
      <meta name="generator" content="mkdocs-1.5.2, mkdocs-material-9.2.4">
    
    
      
        <title>Tutorial - libigl</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.0e669242.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.85d0ee34.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../css/style.css">
    
      <link rel="stylesheet" href="../css/pygments.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-blue" data-md-color-accent="blue">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter-1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="libigl" class="md-header__button md-logo" aria-label="libigl" data-md-component="logo">
      
  <img src="../logo.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            libigl
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Tutorial
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/libigl/libigl" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    libigl/libigl
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="libigl" class="md-nav__button md-logo" aria-label="libigl" data-md-component="logo">
      
  <img src="../logo.png" alt="logo">

    </a>
    libigl
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/libigl/libigl" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    libigl/libigl
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Tutorial
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Tutorial
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-1" class="md-nav__link">
    Chapter 1
  </a>
  
    <nav class="md-nav" aria-label="Chapter 1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#libigl-design-principles" class="md-nav__link">
    Libigl Design Principles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#downloading-libigl" class="md-nav__link">
    Downloading Libigl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-representation" class="md-nav__link">
    Mesh Representation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#visualizing-surfaces" class="md-nav__link">
    Visualizing Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interaction-with-keyboard-and-mouse" class="md-nav__link">
    Interaction With Keyboard And Mouse
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scalar-field-visualization" class="md-nav__link">
    Scalar Field Visualization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlays" class="md-nav__link">
    Overlays
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#viewer-menu" class="md-nav__link">
    Viewer Menu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-meshes" class="md-nav__link">
    Multiple Meshes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-views" class="md-nav__link">
    Multiple Views
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#viewer-guizmos" class="md-nav__link">
    Viewer Guizmos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#msh-viewer" class="md-nav__link">
    Msh Viewer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matcaps" class="md-nav__link">
    MatCaps
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-discrete-geometric-quantities-and-operators" class="md-nav__link">
    Chapter 2: Discrete Geometric Quantities And Operators
  </a>
  
    <nav class="md-nav" aria-label="Chapter 2: Discrete Geometric Quantities And Operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normals" class="md-nav__link">
    Normals
  </a>
  
    <nav class="md-nav" aria-label="Normals">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#per-face" class="md-nav__link">
    Per-face
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#per-vertex" class="md-nav__link">
    Per-vertex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#per-corner" class="md-nav__link">
    Per-corner
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gaussian-curvature" class="md-nav__link">
    Gaussian Curvature
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#curvature-directions" class="md-nav__link">
    Curvature Directions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gradient" class="md-nav__link">
    Gradient
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplacian" class="md-nav__link">
    Laplacian
  </a>
  
    <nav class="md-nav" aria-label="Laplacian">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mass-matrix" class="md-nav__link">
    Mass Matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative-construction-of-laplacian" class="md-nav__link">
    Alternative Construction Of Laplacian
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exact-discrete-geodesic-distances" class="md-nav__link">
    Exact Discrete Geodesic Distances
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-matrices-and-linear-algebra" class="md-nav__link">
    Chapter 3: Matrices And Linear Algebra
  </a>
  
    <nav class="md-nav" aria-label="Chapter 3: Matrices And Linear Algebra">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    Slice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    Sort
  </a>
  
    <nav class="md-nav" aria-label="Sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#other-matlab-style-functions" class="md-nav__link">
    Other Matlab-style Functions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplace-equation" class="md-nav__link">
    Laplace Equation
  </a>
  
    <nav class="md-nav" aria-label="Laplace Equation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quadratic-energy-minimization" class="md-nav__link">
    Quadratic Energy Minimization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-equality-constraints" class="md-nav__link">
    Linear Equality Constraints
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadratic-programming" class="md-nav__link">
    Quadratic Programming
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigen-decomposition" class="md-nav__link">
    Eigen Decomposition
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-shape-deformation" class="md-nav__link">
    Chapter 4: Shape Deformation
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4: Shape Deformation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation" class="md-nav__link">
    Biharmonic Deformation
  </a>
  
    <nav class="md-nav" aria-label="Biharmonic Deformation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-surfaces" class="md-nav__link">
    Biharmonic Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation-fields" class="md-nav__link">
    Biharmonic Deformation Fields
  </a>
  
    <nav class="md-nav" aria-label="Biharmonic Deformation Fields">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" class="md-nav__link">
    Relationship To "differential Coordinates" And Laplacian Surface Editing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polyharmonic-deformation" class="md-nav__link">
    Polyharmonic Deformation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bounded-biharmonic-weights" class="md-nav__link">
    Bounded Biharmonic Weights
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dual-quaternion-skinning" class="md-nav__link">
    Dual Quaternion Skinning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#as-rigid-as-possible" class="md-nav__link">
    As-rigid-as-possible
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fast-automatic-skinning-transformations" class="md-nav__link">
    Fast Automatic Skinning Transformations
  </a>
  
    <nav class="md-nav" aria-label="Fast Automatic Skinning Transformations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arap-with-grouped-edge-sets" class="md-nav__link">
    Arap With Grouped Edge-sets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-coordinates" class="md-nav__link">
    Biharmonic Coordinates
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#direct-delta-mush" class="md-nav__link">
    Direct Delta Mush
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-deformation-with-kelvinlet" class="md-nav__link">
    Mesh Deformation with Kelvinlet
  </a>
  
    <nav class="md-nav" aria-label="Mesh Deformation with Kelvinlet">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-quick-primer-on-linear-elastostatics-25" class="md-nav__link">
    A quick primer on linear elastostatics 25
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regularized-kelvinlets" class="md-nav__link">
    Regularized kelvinlets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-parametrization" class="md-nav__link">
    Chapter 5: Parametrization
  </a>
  
    <nav class="md-nav" aria-label="Chapter 5: Parametrization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#harmonic-parametrization" class="md-nav__link">
    Harmonic Parametrization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#least-squares-conformal-maps" class="md-nav__link">
    Least Squares Conformal Maps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#as-rigid-as-possible-parametrization" class="md-nav__link">
    As-rigid-as-possible Parametrization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n-rotationally-symmetric-tangent-fields" class="md-nav__link">
    N-rotationally Symmetric Tangent Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#global-seamless-integer-grid-parametrization" class="md-nav__link">
    Global, Seamless Integer-grid Parametrization
  </a>
  
    <nav class="md-nav" aria-label="Global, Seamless Integer-grid Parametrization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#combing-and-cutting" class="md-nav__link">
    Combing And Cutting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poisson-parametrization" class="md-nav__link">
    Poisson Parametrization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anisotropic-remeshing" class="md-nav__link">
    Anisotropic Remeshing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#planarization" class="md-nav__link">
    Planarization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-6-external-libraries" class="md-nav__link">
    Chapter 6: External Libraries
  </a>
  
    <nav class="md-nav" aria-label="Chapter 6: External Libraries">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#state-serialization" class="md-nav__link">
    State Serialization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mixing-matlab-code" class="md-nav__link">
    Mixing Matlab Code
  </a>
  
    <nav class="md-nav" aria-label="Mixing Matlab Code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#saving-a-matlab-workspace" class="md-nav__link">
    Saving A Matlab Workspace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dumping-eigen-matrices-to-copy-and-paste-into-matlab" class="md-nav__link">
    Dumping Eigen Matrices To Copy And Paste Into Matlab
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#calling-libigl-functions-from-matlab" class="md-nav__link">
    Calling Libigl Functions From Matlab
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triangulation-of-closed-polygons" class="md-nav__link">
    Triangulation Of Closed Polygons
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tetrahedralization-of-closed-surfaces" class="md-nav__link">
    Tetrahedralization Of Closed Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#baking-ambient-occlusion" class="md-nav__link">
    Baking Ambient Occlusion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#screen-capture" class="md-nav__link">
    Screen Capture
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#off-screen-rendering-using-ray-tracing-with-embree" class="md-nav__link">
    Off-screen rendering using ray tracing with Embree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean-operations-on-meshes" class="md-nav__link">
    Boolean Operations On Meshes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#csg-tree" class="md-nav__link">
    Csg Tree
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-7-miscellaneous" class="md-nav__link">
    Chapter 7: Miscellaneous
  </a>
  
    <nav class="md-nav" aria-label="Chapter 7: Miscellaneous">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mesh-statistics" class="md-nav__link">
    Mesh Statistics
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generalized-winding-number" class="md-nav__link">
    Generalized Winding Number
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-decimation" class="md-nav__link">
    Mesh Decimation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signed-distances" class="md-nav__link">
    Signed Distances
  </a>
  
    <nav class="md-nav" aria-label="Signed Distances">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#point-location" class="md-nav__link">
    Point Location
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#closest-points" class="md-nav__link">
    Closest Points
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signed-distance" class="md-nav__link">
    Signed Distance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marching-cubes" class="md-nav__link">
    Marching Cubes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#facet-orientation" class="md-nav__link">
    Facet Orientation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#swept-volume" class="md-nav__link">
    Swept Volume
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#picking" class="md-nav__link">
    Picking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scalable-locally-injective-maps" class="md-nav__link">
    Scalable Locally Injective Maps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#simplicial-complex-augmentation-framework-for-bijective-maps" class="md-nav__link">
    Simplicial Complex Augmentation Framework For Bijective Maps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subdivision-surfaces" class="md-nav__link">
    Subdivision Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-smoothing" class="md-nav__link">
    Data Smoothing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shapeup-projections" class="md-nav__link">
    Shapeup Projections
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marching-tetrahedra" class="md-nav__link">
    Marching Tetrahedra
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implicit-function-meshing" class="md-nav__link">
    Implicit Function Meshing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#heat-method-for-fast-geodesic-distance-approximation" class="md-nav__link">
    Heat Method For Fast Geodesic Distance Approximation
  </a>
  
    <nav class="md-nav" aria-label="Heat Method For Fast Geodesic Distance Approximation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#intrinsic-delaunay-triangulation" class="md-nav__link">
    Intrinsic Delaunay Triangulation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fast-winding-number-for-soups-and-clouds" class="md-nav__link">
    Fast Winding Number For Soups And Clouds
  </a>
  
    <nav class="md-nav" aria-label="Fast Winding Number For Soups And Clouds">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#soups" class="md-nav__link">
    Soups
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clouds" class="md-nav__link">
    Clouds
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterative-closest-point" class="md-nav__link">
    Iterative Closest Point
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exploded-view" class="md-nav__link">
    Exploded View
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blue-noise-surface-sampling" class="md-nav__link">
    Blue Noise Surface Sampling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector-field-smoothing" class="md-nav__link">
    Vector Field Smoothing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector-parallel-transport" class="md-nav__link">
    Vector Parallel Transport
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outlook-for-continuing-development" class="md-nav__link">
    Outlook For Continuing Development
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#past-libigl-courses-at-conferences" class="md-nav__link">
    Past Libigl Courses At Conferences
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    References
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../python-bindings/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Python Bindings
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Compilation
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Compilation
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../example-project/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Example Project
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../static-library/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Static Library
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../third-party/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    External Dependencies
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Contributing
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../style-guidelines/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Style Guidelines
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../bug-report/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Bug Report
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../before-submitting-pull-request/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Creating a Pull Request
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../unit-tests/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Unit Tests
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
        
          <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Misc
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6">
            <span class="md-nav__icon md-icon"></span>
            Misc
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../matlab-to-eigen/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Matlab-libigl Cheatsheet
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../coding-guidelines/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Coding Tips
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_3" >
        
          <label class="md-nav__link" for="__nav_6_3" id="__nav_6_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    File Formats
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_6_3">
            <span class="md-nav__icon md-icon"></span>
            File Formats
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../file-formats/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Index
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../file-formats/bf/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    bf
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../file-formats/dmat/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    dmat
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../file-formats/rbr/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    rbr
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../file-formats/tgf/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    tgf
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../file-formats/xml/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    xml
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../website/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Building the Website
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../rewritten-history/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Rewritten History
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
        
          <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    About
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_8">
            <span class="md-nav__icon md-icon"></span>
            About
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    <li class="md-nav__item">
      <a href="../license/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    License
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
    <li class="md-nav__item">
      <a href="../dox/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Detailed Documentation
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter-1" class="md-nav__link">
    Chapter 1
  </a>
  
    <nav class="md-nav" aria-label="Chapter 1">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#libigl-design-principles" class="md-nav__link">
    Libigl Design Principles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#downloading-libigl" class="md-nav__link">
    Downloading Libigl
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-representation" class="md-nav__link">
    Mesh Representation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#visualizing-surfaces" class="md-nav__link">
    Visualizing Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interaction-with-keyboard-and-mouse" class="md-nav__link">
    Interaction With Keyboard And Mouse
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scalar-field-visualization" class="md-nav__link">
    Scalar Field Visualization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#overlays" class="md-nav__link">
    Overlays
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#viewer-menu" class="md-nav__link">
    Viewer Menu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-meshes" class="md-nav__link">
    Multiple Meshes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-views" class="md-nav__link">
    Multiple Views
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#viewer-guizmos" class="md-nav__link">
    Viewer Guizmos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#msh-viewer" class="md-nav__link">
    Msh Viewer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#matcaps" class="md-nav__link">
    MatCaps
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-2-discrete-geometric-quantities-and-operators" class="md-nav__link">
    Chapter 2: Discrete Geometric Quantities And Operators
  </a>
  
    <nav class="md-nav" aria-label="Chapter 2: Discrete Geometric Quantities And Operators">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#normals" class="md-nav__link">
    Normals
  </a>
  
    <nav class="md-nav" aria-label="Normals">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#per-face" class="md-nav__link">
    Per-face
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#per-vertex" class="md-nav__link">
    Per-vertex
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#per-corner" class="md-nav__link">
    Per-corner
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gaussian-curvature" class="md-nav__link">
    Gaussian Curvature
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#curvature-directions" class="md-nav__link">
    Curvature Directions
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gradient" class="md-nav__link">
    Gradient
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplacian" class="md-nav__link">
    Laplacian
  </a>
  
    <nav class="md-nav" aria-label="Laplacian">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mass-matrix" class="md-nav__link">
    Mass Matrix
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alternative-construction-of-laplacian" class="md-nav__link">
    Alternative Construction Of Laplacian
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exact-discrete-geodesic-distances" class="md-nav__link">
    Exact Discrete Geodesic Distances
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-3-matrices-and-linear-algebra" class="md-nav__link">
    Chapter 3: Matrices And Linear Algebra
  </a>
  
    <nav class="md-nav" aria-label="Chapter 3: Matrices And Linear Algebra">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#slice" class="md-nav__link">
    Slice
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sort" class="md-nav__link">
    Sort
  </a>
  
    <nav class="md-nav" aria-label="Sort">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#other-matlab-style-functions" class="md-nav__link">
    Other Matlab-style Functions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#laplace-equation" class="md-nav__link">
    Laplace Equation
  </a>
  
    <nav class="md-nav" aria-label="Laplace Equation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quadratic-energy-minimization" class="md-nav__link">
    Quadratic Energy Minimization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#linear-equality-constraints" class="md-nav__link">
    Linear Equality Constraints
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quadratic-programming" class="md-nav__link">
    Quadratic Programming
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eigen-decomposition" class="md-nav__link">
    Eigen Decomposition
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-4-shape-deformation" class="md-nav__link">
    Chapter 4: Shape Deformation
  </a>
  
    <nav class="md-nav" aria-label="Chapter 4: Shape Deformation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation" class="md-nav__link">
    Biharmonic Deformation
  </a>
  
    <nav class="md-nav" aria-label="Biharmonic Deformation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#biharmonic-surfaces" class="md-nav__link">
    Biharmonic Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-deformation-fields" class="md-nav__link">
    Biharmonic Deformation Fields
  </a>
  
    <nav class="md-nav" aria-label="Biharmonic Deformation Fields">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" class="md-nav__link">
    Relationship To "differential Coordinates" And Laplacian Surface Editing
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#polyharmonic-deformation" class="md-nav__link">
    Polyharmonic Deformation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bounded-biharmonic-weights" class="md-nav__link">
    Bounded Biharmonic Weights
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dual-quaternion-skinning" class="md-nav__link">
    Dual Quaternion Skinning
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#as-rigid-as-possible" class="md-nav__link">
    As-rigid-as-possible
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fast-automatic-skinning-transformations" class="md-nav__link">
    Fast Automatic Skinning Transformations
  </a>
  
    <nav class="md-nav" aria-label="Fast Automatic Skinning Transformations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#arap-with-grouped-edge-sets" class="md-nav__link">
    Arap With Grouped Edge-sets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#biharmonic-coordinates" class="md-nav__link">
    Biharmonic Coordinates
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#direct-delta-mush" class="md-nav__link">
    Direct Delta Mush
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-deformation-with-kelvinlet" class="md-nav__link">
    Mesh Deformation with Kelvinlet
  </a>
  
    <nav class="md-nav" aria-label="Mesh Deformation with Kelvinlet">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#a-quick-primer-on-linear-elastostatics-25" class="md-nav__link">
    A quick primer on linear elastostatics 25
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#regularized-kelvinlets" class="md-nav__link">
    Regularized kelvinlets
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-5-parametrization" class="md-nav__link">
    Chapter 5: Parametrization
  </a>
  
    <nav class="md-nav" aria-label="Chapter 5: Parametrization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#harmonic-parametrization" class="md-nav__link">
    Harmonic Parametrization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#least-squares-conformal-maps" class="md-nav__link">
    Least Squares Conformal Maps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#as-rigid-as-possible-parametrization" class="md-nav__link">
    As-rigid-as-possible Parametrization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n-rotationally-symmetric-tangent-fields" class="md-nav__link">
    N-rotationally Symmetric Tangent Fields
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#global-seamless-integer-grid-parametrization" class="md-nav__link">
    Global, Seamless Integer-grid Parametrization
  </a>
  
    <nav class="md-nav" aria-label="Global, Seamless Integer-grid Parametrization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#combing-and-cutting" class="md-nav__link">
    Combing And Cutting
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poisson-parametrization" class="md-nav__link">
    Poisson Parametrization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#anisotropic-remeshing" class="md-nav__link">
    Anisotropic Remeshing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#planarization" class="md-nav__link">
    Planarization
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-6-external-libraries" class="md-nav__link">
    Chapter 6: External Libraries
  </a>
  
    <nav class="md-nav" aria-label="Chapter 6: External Libraries">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#state-serialization" class="md-nav__link">
    State Serialization
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mixing-matlab-code" class="md-nav__link">
    Mixing Matlab Code
  </a>
  
    <nav class="md-nav" aria-label="Mixing Matlab Code">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#saving-a-matlab-workspace" class="md-nav__link">
    Saving A Matlab Workspace
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dumping-eigen-matrices-to-copy-and-paste-into-matlab" class="md-nav__link">
    Dumping Eigen Matrices To Copy And Paste Into Matlab
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#calling-libigl-functions-from-matlab" class="md-nav__link">
    Calling Libigl Functions From Matlab
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#triangulation-of-closed-polygons" class="md-nav__link">
    Triangulation Of Closed Polygons
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tetrahedralization-of-closed-surfaces" class="md-nav__link">
    Tetrahedralization Of Closed Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#baking-ambient-occlusion" class="md-nav__link">
    Baking Ambient Occlusion
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#screen-capture" class="md-nav__link">
    Screen Capture
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#off-screen-rendering-using-ray-tracing-with-embree" class="md-nav__link">
    Off-screen rendering using ray tracing with Embree
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#boolean-operations-on-meshes" class="md-nav__link">
    Boolean Operations On Meshes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#csg-tree" class="md-nav__link">
    Csg Tree
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-7-miscellaneous" class="md-nav__link">
    Chapter 7: Miscellaneous
  </a>
  
    <nav class="md-nav" aria-label="Chapter 7: Miscellaneous">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#mesh-statistics" class="md-nav__link">
    Mesh Statistics
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#generalized-winding-number" class="md-nav__link">
    Generalized Winding Number
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mesh-decimation" class="md-nav__link">
    Mesh Decimation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signed-distances" class="md-nav__link">
    Signed Distances
  </a>
  
    <nav class="md-nav" aria-label="Signed Distances">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#point-location" class="md-nav__link">
    Point Location
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#closest-points" class="md-nav__link">
    Closest Points
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#signed-distance" class="md-nav__link">
    Signed Distance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marching-cubes" class="md-nav__link">
    Marching Cubes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#facet-orientation" class="md-nav__link">
    Facet Orientation
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#swept-volume" class="md-nav__link">
    Swept Volume
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#picking" class="md-nav__link">
    Picking
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#scalable-locally-injective-maps" class="md-nav__link">
    Scalable Locally Injective Maps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#simplicial-complex-augmentation-framework-for-bijective-maps" class="md-nav__link">
    Simplicial Complex Augmentation Framework For Bijective Maps
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#subdivision-surfaces" class="md-nav__link">
    Subdivision Surfaces
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-smoothing" class="md-nav__link">
    Data Smoothing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#shapeup-projections" class="md-nav__link">
    Shapeup Projections
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marching-tetrahedra" class="md-nav__link">
    Marching Tetrahedra
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#implicit-function-meshing" class="md-nav__link">
    Implicit Function Meshing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#heat-method-for-fast-geodesic-distance-approximation" class="md-nav__link">
    Heat Method For Fast Geodesic Distance Approximation
  </a>
  
    <nav class="md-nav" aria-label="Heat Method For Fast Geodesic Distance Approximation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#intrinsic-delaunay-triangulation" class="md-nav__link">
    Intrinsic Delaunay Triangulation
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fast-winding-number-for-soups-and-clouds" class="md-nav__link">
    Fast Winding Number For Soups And Clouds
  </a>
  
    <nav class="md-nav" aria-label="Fast Winding Number For Soups And Clouds">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#soups" class="md-nav__link">
    Soups
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clouds" class="md-nav__link">
    Clouds
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#iterative-closest-point" class="md-nav__link">
    Iterative Closest Point
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exploded-view" class="md-nav__link">
    Exploded View
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#blue-noise-surface-sampling" class="md-nav__link">
    Blue Noise Surface Sampling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector-field-smoothing" class="md-nav__link">
    Vector Field Smoothing
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector-parallel-transport" class="md-nav__link">
    Vector Parallel Transport
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#outlook-for-continuing-development" class="md-nav__link">
    Outlook For Continuing Development
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#past-libigl-courses-at-conferences" class="md-nav__link">
    Past Libigl Courses At Conferences
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#references" class="md-nav__link">
    References
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1>libigl tutorial</h1>

<p><img alt="" src="../images/libigl-logo.jpg" /></p>
<p>Libigl is an open source C++ library for geometry processing research and development.  Dropping the heavy data structures of tradition geometry libraries, libigl is a simple header-only library of encapsulated functions. This combines the rapid prototyping familiar to Matlab or Python programmers with the performance and versatility of C++.  The tutorial is a self-contained, hands-on introduction to libigl.  Via interactive, step-by-step examples, we demonstrate how to accomplish common geometry processing tasks such as computation of differential quantities and operators, real-time deformation, parametrization, numerical optimization and remeshing. Each section of the lecture notes links to a cross-platform example application.</p>
<h2 id="chapter-1">Chapter 1<a class="headerlink" href="#chapter-1" title="Permanent link">&para;</a></h2>
<p>We introduce libigl with a series of self-contained examples. The purpose of
each example is to showcase a feature of libigl while applying to a practical
problem in geometry processing. In this chapter, we will present the basic
concepts of libigl and introduce a simple mesh viewer that allows to
visualize a surface mesh and its attributes. All the tutorial examples are
cross-platform and can be compiled on MacOSX, Linux and Windows.</p>
<h3 id="libigl-design-principles">Libigl Design Principles<a class="headerlink" href="#libigl-design-principles" title="Permanent link">&para;</a></h3>
<p>Before getting into the examples, we summarize the main design principles in
libigl:</p>
<ol>
<li>
<p><strong>No complex data types.</strong> We mostly use matrices and vectors. This greatly
  favors code reusability and forces the function authors to expose all the
  parameters used by the algorithm.  </p>
</li>
<li>
<p><strong>Minimal dependencies.</strong> We use external libraries only when necessary and
  we wrap them in a small set of functions.</p>
</li>
<li>
<p><strong>Header-only.</strong> It is straight forward to use our library since it is only
  one additional include directory in your project. (if you are worried about
  compilation speed, it is also possible to build the library as a <a href="../static-library/">static library</a>)</p>
</li>
<li>
<p><strong>Function encapsulation.</strong> Every function (including its full
  implementation) is contained in a pair of .h/.cpp files with the same name of
  the function.</p>
</li>
</ol>
<h3 id="downloading-libigl">Downloading Libigl<a class="headerlink" href="#downloading-libigl" title="Permanent link">&para;</a></h3>
<p>libigl can be downloaded from our <a href="https://github.com/libigl/libigl">github
repository</a> or cloned with git:</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/libigl/libigl.git
</code></pre></div>
<p>The core libigl functionality only depends on the C++ Standard Library and
Eigen. <em>Optional dependencies</em> will be downloaded upon issuing <code>cmake</code>, below.</p>
<p>To build all the examples in the tutorial (and tests), you can use the CMakeLists.txt in
the root folder:</p>
<div class="highlight"><pre><span></span><code><span class="nb">cd</span><span class="w"> </span>libigl/
mkdir<span class="w"> </span>build
<span class="nb">cd</span><span class="w"> </span>build
cmake<span class="w"> </span>../
make
</code></pre></div>
<div class="admonition note">
<p class="admonition-title">Note about CGAL</p>
<p>The <em>optional</em> dependency <a href="https://www.cgal.org">CGAL</a> has been notoriously difficult to setup (as it also depends on boost/gmp/mpfr). By default, it will only be enabled on Linux/macOS if GMP and MPFR are installed system-wide. On Windows, all its dependencies will be downloaded by CMake, thus requiring no setup on your part.</p>
</div>
<p>The examples can also be built independently using the CMakeLists.txt
inside each example folder.</p>
<div class="admonition note">
<p class="admonition-title">Note for linux users</p>
<p>Many linux distributions do not include gcc and the basic development tools
in their default installation. On Ubuntu, you need to install the following packages:</p>
<div class="highlight"><pre><span></span><code>sudo<span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>git<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>build-essential<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>cmake<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libx11-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>mesa-common-dev<span class="w"> </span>libgl1-mesa-dev<span class="w"> </span>libglu1-mesa-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libxrandr-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libxi-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libxmu-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libblas-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libxinerama-dev<span class="w"> </span><span class="se">\</span>
<span class="w">  </span>libxcursor-dev
</code></pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note for Windows users</p>
<p>libigl only supports the Microsoft Visual Studio 2015 compiler and later, in <strong>64bit</strong> mode.
It will not work with a 32bit build and it will not work with older versions of visual studio.</p>
</div>
<p>A few examples in Chapter 5 requires the <a href="http://www.graphics.rwth-aachen.de/software/comiso">CoMiSo
solver</a>. We provide a
mirror of CoMISo that works out of the box with libigl. A copy will be
downloaded automatically by CMake the first time you build the libigl root
project. You can build the tutorials as usual and libigl will automatically
find and compile CoMISo.</p>
<p><em>Note 1</em>: CoMISo is distributed under the GPL3 license, it does impose restrictions on commercial usage.</p>
<p><em>Note 2</em>: CoMISo requires a blas implementation. We use the built-in blas in macosx and linux, and we bundle a precompiled binary for VS2015 64 bit. Do NOT compile the tutorials
in 32 bit on windows.</p>
<div class="admonition tip">
<p class="admonition-title">Libigl Example Project</p>
<p>We provide a <a href="../example-project">blank project example</a> showing how to use libigl and CMake.
<strong>This is the recommended way of using libigl in your project</strong>.
Feel free and encouraged to use this repository as a template to start a new personal project using libigl.</p>
</div>
<h3 id="mesh-representation">Mesh Representation<a class="headerlink" href="#mesh-representation" title="Permanent link">&para;</a></h3>
<p>libigl uses the <a href="http://eigen.tuxfamily.org/">Eigen</a> library to encode vector
and matrices. We suggest that you keep the
<a href="http://eigen.tuxfamily.org/dox/group__QuickRefPage.html">dense</a> and
<a href="http://eigen.tuxfamily.org/dox/group__SparseQuickRefPage.html">sparse</a> quick
reference guides at hand while you read the examples in this tutorial.</p>
<p>A triangular mesh is encoded as a pair of matrices:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">F</span><span class="p">;</span>
</code></pre></div>
<p><code>V</code> is a #N by 3 matrix which stores the coordinates of the vertices. Each
row stores the coordinate of a vertex, with its x,y and z coordinates in the first,
second and third column, respectively. The matrix <code>F</code> stores the triangle
connectivity: each line of <code>F</code> denotes a triangle whose 3 vertices are
represented as indices pointing to rows of <code>V</code>.</p>
<figure>
<p><img alt="" src="../images/VF.png" />
  </p>
<figcaption>
    A simple mesh made of 2 triangles and 4 vertices.
  </figcaption>
</figure>
<p>Note that the order of the vertex indices in <code>F</code> determines the orientation of
the triangles and it should thus be consistent for the entire surface.
This simple representation has many advantages:</p>
<ol>
<li>it is memory efficient and cache friendly</li>
<li>the use of indices instead of pointers greatly simplifies debugging</li>
<li>the data can be trivially copied and serialized</li>
</ol>
<p>libigl provides input [output] functions to read [write] many common mesh formats.
The IO functions are contained in the files read*.h and write*.h. As a general
rule each libigl function is contained in a pair of .h/.cpp files with the same name.
By default, the .h files include the corresponding cpp files, making the library header-only.</p>
<p>Reading a mesh from a file requires a single libigl function call:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">readOFF</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span><span class="w"> </span><span class="s">&quot;/cube.off&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span>
</code></pre></div>
<p>The function reads the mesh cube.off and it fills the provided <code>V</code> and <code>F</code> matrices.
Similarly, a mesh can be written in an OBJ file using:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">writeOBJ</span><span class="p">(</span><span class="s">&quot;cube.obj&quot;</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">);</span>
</code></pre></div>
<p><a href="https://github.com/libigl/libigl/tree/main/tutorial/101_FileIO/main.cpp">Example 101</a> contains a simple mesh
converter from OFF to OBJ format.</p>
<h3 id="visualizing-surfaces">Visualizing Surfaces<a class="headerlink" href="#visualizing-surfaces" title="Permanent link">&para;</a></h3>
<p>Libigl provides an glfw-based OpenGL 3.2 viewer to visualize surfaces, their
properties and additional debugging information.</p>
<p>The following code (<a href="https://github.com/libigl/libigl/tree/main/tutorial/102_DrawMesh/main.cpp">Example 102</a>) is a basic skeleton
for all the examples that will be used in the tutorial.
It is a standalone application that loads a mesh and uses the viewer to
render it.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;igl/readOFF.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;igl/opengl/glfw/Viewer.h&gt;</span>

<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">F</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Load a mesh in OFF format</span>
<span class="w">  </span><span class="n">igl</span><span class="o">::</span><span class="n">readOFF</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span><span class="w"> </span><span class="s">&quot;/bunny.off&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Plot the mesh</span>
<span class="w">  </span><span class="n">igl</span><span class="o">::</span><span class="n">opengl</span><span class="o">::</span><span class="n">glfw</span><span class="o">::</span><span class="n">Viewer</span><span class="w"> </span><span class="n">viewer</span><span class="p">;</span>
<span class="w">  </span><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_mesh</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span>
<span class="w">  </span><span class="n">viewer</span><span class="p">.</span><span class="n">launch</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>The function <code>set_mesh</code> copies the mesh into the viewer.
<code>Viewer.launch()</code>  creates a window, an OpenGL context and it starts the draw loop.
The default camera motion mode is 2-axis (<code>ROTATION_TYPE_TWO_AXIS_VALUATOR_FIXED_UP</code>), 
which can be changed to 3-axis trackball style by adding this line:
<div class="highlight"><pre><span></span><code>  viewer.core().set_rotation_type(igl::opengl::ViewerCore::ROTATION_TYPE_TRACKBALL);
</code></pre></div>
Additional properties can be plotted on the mesh (as we will see later),
and it is possible to extend the viewer with standard OpenGL code.
Please see the documentation in
<a href="https://github.com/libigl/libigl/tree/main/include/igl/opengl/glfw/Viewer.h">Viewer.h</a> for more details.</p>
<figure>
<p><img alt="" src="../images/102_DrawMesh.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/102_DrawMesh/main.cpp">Example 102</a>) loads and draws a mesh.
  </figcaption>
</figure>
<h3 id="interaction-with-keyboard-and-mouse">Interaction With Keyboard And Mouse<a class="headerlink" href="#interaction-with-keyboard-and-mouse" title="Permanent link">&para;</a></h3>
<p>Keyboard and mouse events triggers callbacks that can be registered in the
viewer. The viewer supports the following callbacks:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_pre_draw</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_post_draw</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_mouse_down</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">button</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">modifier</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_mouse_up</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">button</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">modifier</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_mouse_move</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mouse_x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mouse_y</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_mouse_scroll</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">delta_y</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_key_down</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">modifiers</span><span class="p">);</span>
<span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">callback_key_up</span><span class="p">)(</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">modifiers</span><span class="p">);</span>
</code></pre></div>
<p>A keyboard callback can be used to visualize multiple meshes or different
stages of an algorithm, as demonstrated in <a href="https://github.com/libigl/libigl/tree/main/tutorial/103_Events/main.cpp">Example 103</a>, where
the keyboard callback changes the visualized mesh depending on the key pressed:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">key_down</span><span class="p">(</span><span class="n">igl</span><span class="o">::</span><span class="n">opengl</span><span class="o">::</span><span class="n">glfw</span><span class="o">::</span><span class="n">Viewer</span><span class="o">&amp;</span><span class="w"> </span><span class="n">viewer</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">modifier</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;1&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_mesh</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="w"> </span><span class="n">F1</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">align_camera_center</span><span class="p">(</span><span class="n">V1</span><span class="p">,</span><span class="n">F1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;2&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_mesh</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="w"> </span><span class="n">F2</span><span class="p">);</span>
<span class="w">    </span><span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">align_camera_center</span><span class="p">(</span><span class="n">V2</span><span class="p">,</span><span class="n">F2</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The callback is registered in the viewer as follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">callback_key_down</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key_down</span><span class="p">;</span>
</code></pre></div>
<p>Note that the mesh is cleared before using set_mesh. This has to be called
every time the number of vertices or faces of the plotted mesh changes. Every
callback returns a boolean value that tells the viewer if the event has been
handled by the plugin, or if the viewer should process it normally. This is
useful, for example, to disable the default mouse event handling if you want to
control the camera directly in your code.</p>
<p>The viewer can be extended using plugins, which are classes that implements all
the viewer&rsquo;s callbacks. See the
<a href="https://github.com/libigl/libigl/tree/main/include/igl/opengl/glfw/ViewerPlugin.h">Viewer_plugin</a> for more details.</p>
<h3 id="scalar-field-visualization">Scalar Field Visualization<a class="headerlink" href="#scalar-field-visualization" title="Permanent link">&para;</a></h3>
<p>Colors can be associated to faces or vertices using the
<code>set_colors</code> function:</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_colors</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
</code></pre></div>
<p><code>C</code> is a #C by 3 matrix with one RGB color per row. <code>C</code> must have as many rows
as the number of faces <strong>or</strong> the number of vertices of the mesh.  Depending on
the size of <code>C</code>, the viewer applies the color to the faces or to the vertices.
In Example 104, the colors of mesh vertices are set according to their Cartesian
coordinates.</p>
<figure>
<p><img alt="" src="../images/104_Colors.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/104_Colors/main.cpp">Example 104</a>) Set the colors of a mesh. 
  </figcaption>
</figure>
<p>Per-Vertex scalar fields can be directly visualized using <code>set_data</code> function:</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_data</span><span class="p">(</span><span class="n">D</span><span class="p">);</span>
</code></pre></div>
<p><code>D</code> is a #V by 1 vector with one value corresponding to each vertex. <code>set_data</code>
will color according to linearly interpolating the <em>data</em> within a triangle (in
the <a href="https://en.wikipedia.org/wiki/Shader#Types">fragment shader</a>) and use this
interpolated data to look up a color in a colormap (stored as a texture). The
colormap defaults to <code>igl::COLOR_MAP_TYPE_VIRIDIS</code> with 21 discrete intervals.
A custom colormap may be set with <code>set_colormap</code>.</p>
<h3 id="overlays">Overlays<a class="headerlink" href="#overlays" title="Permanent link">&para;</a></h3>
<p>In addition to plotting the surface, the viewer supports the visualization of
points, lines and text labels: these overlays can be very helpful while
developing geometric processing algorithms to plot debug information.</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">add_points</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">RowVector3d</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">));</span>
</code></pre></div>
<p>Draws a point of color r,g,b for each row of P. The point is placed at the coordinates specified in each row of P, which is a #P by 3 matrix. Size of the points (in pixels) can be changed globally by setting <code>viewer.data().point_size</code>.</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">add_edges</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span><span class="n">P2</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">RowVector3d</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">));</span>
</code></pre></div>
<p>Draws a line of color r,g,b for each row of P1 and P2, which connects the 3D point in to the point in P2. Both P1 and P2 are of size #P by 3.</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">add_label</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">str</span><span class="p">);</span>
</code></pre></div>
<p>Draws a label containing the string str at the position p, which is a vector of length 3.</p>
<p>These functions are demonstrate in <a href="https://github.com/libigl/libigl/tree/main/tutorial/105_Overlays/main.cpp">Example 105</a> where
the bounding box of a mesh is plotted using lines and points.
Using matrices to encode the mesh and its attributes allows to write short and
efficient code for many operations, avoiding to write for loops. For example,
the bounding box of a mesh can be found by taking the colwise maximum and minimum of <code>V</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">.</span><span class="n">colwise</span><span class="p">().</span><span class="n">minCoeff</span><span class="p">();</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="p">.</span><span class="n">colwise</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">();</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/105_Overlays.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/105_Overlays/main.cpp">Example 105</a>) The bounding box of a mesh is shown using overlays.
  </figcaption>
</figure>
<h3 id="viewer-menu">Viewer Menu<a class="headerlink" href="#viewer-menu" title="Permanent link">&para;</a></h3>
<p>As of latest version, the viewer uses a new menu and completely replaces
<a href="http://anttweakbar.sourceforge.net/doc/">AntTweakBar</a> and
<a href="https://github.com/wjakob/nanogui">nanogui</a> with <a href="https://github.com/ocornut/imgui">Dear ImGui</a>. To extend the default menu of the
viewer and to expose more user defined variables you have to implement a custom interface, as in <a href="https://github.com/libigl/libigl/tree/main/tutorial/106_ViewerMenu/main.cpp">Example 106</a>:
<div class="highlight"><pre><span></span><code><span class="c1">// Add content to the default menu window</span>
<span class="n">menu</span><span class="p">.</span><span class="n">callback_draw_viewer_menu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Draw parent menu content</span>
<span class="w">  </span><span class="n">menu</span><span class="p">.</span><span class="n">draw_viewer_menu</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Add new group</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ImGui</span><span class="o">::</span><span class="n">CollapsingHeader</span><span class="p">(</span><span class="s">&quot;New Group&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ImGuiTreeNodeFlags_DefaultOpen</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Expose variable directly ...</span>
<span class="w">    </span><span class="n">ImGui</span><span class="o">::</span><span class="n">InputFloat</span><span class="p">(</span><span class="s">&quot;float&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">floatVariable</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// ... or using a custom callback</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">boolVariable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ImGui</span><span class="o">::</span><span class="n">Checkbox</span><span class="p">(</span><span class="s">&quot;bool&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">boolVariable</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// do something</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;boolVariable: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">boolVariable</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Expose an enumeration type</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Orientation</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Up</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">Down</span><span class="p">,</span><span class="w"> </span><span class="n">Left</span><span class="p">,</span><span class="w"> </span><span class="n">Right</span><span class="w"> </span><span class="p">};</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">Orientation</span><span class="w"> </span><span class="n">dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Up</span><span class="p">;</span>
<span class="w">    </span><span class="n">ImGui</span><span class="o">::</span><span class="n">Combo</span><span class="p">(</span><span class="s">&quot;Direction&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">dir</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;Up</span><span class="se">\0</span><span class="s">Down</span><span class="se">\0</span><span class="s">Left</span><span class="se">\0</span><span class="s">Right</span><span class="se">\0\0</span><span class="s">&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// We can also use a std::vector&lt;std::string&gt; defined dynamically</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num_choices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">choices</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">idx_choice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ImGui</span><span class="o">::</span><span class="n">InputInt</span><span class="p">(</span><span class="s">&quot;Num letters&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">num_choices</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">num_choices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span><span class="w"> </span><span class="n">num_choices</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">num_choices</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="n">choices</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">choices</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_choices</span><span class="p">);</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_choices</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">        </span><span class="n">choices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;A&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">idx_choice</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">num_choices</span><span class="p">)</span>
<span class="w">        </span><span class="n">idx_choice</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_choices</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ImGui</span><span class="o">::</span><span class="n">Combo</span><span class="p">(</span><span class="s">&quot;Letter&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">idx_choice</span><span class="p">,</span><span class="w"> </span><span class="n">choices</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Add a button</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ImGui</span><span class="o">::</span><span class="n">Button</span><span class="p">(</span><span class="s">&quot;Print Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ImVec2</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="mi">0</span><span class="p">)))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div></p>
<p>If you need a separate new menu window implement:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Draw additional windows</span>
<span class="n">menu</span><span class="p">.</span><span class="n">callback_draw_custom_window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">]()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Define next window position + size</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">SetNextWindowPos</span><span class="p">(</span><span class="n">ImVec2</span><span class="p">(</span><span class="mf">180.f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">menu</span><span class="p">.</span><span class="n">menu_scaling</span><span class="p">(),</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="n">ImGuiSetCond_FirstUseEver</span><span class="p">);</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">SetNextWindowSize</span><span class="p">(</span><span class="n">ImVec2</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">),</span><span class="w"> </span><span class="n">ImGuiSetCond_FirstUseEver</span><span class="p">);</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">Begin</span><span class="p">(</span>
<span class="w">      </span><span class="s">&quot;New Window&quot;</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">      </span><span class="n">ImGuiWindowFlags_NoSavedSettings</span>
<span class="w">  </span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Expose the same variable directly ...</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">PushItemWidth</span><span class="p">(</span><span class="mi">-80</span><span class="p">);</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">DragFloat</span><span class="p">(</span><span class="s">&quot;float&quot;</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">floatVariable</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">3.0</span><span class="p">);</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">PopItemWidth</span><span class="p">();</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;bunny&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">InputText</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">str</span><span class="p">);</span>

<span class="w">  </span><span class="n">ImGui</span><span class="o">::</span><span class="n">End</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/106_ViewerMenu.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/106_ViewerMenu/main.cpp">Example 106</a>) The UI of the viewer can be easily customized.
  </figcaption>
</figure>
<h3 id="multiple-meshes">Multiple Meshes<a class="headerlink" href="#multiple-meshes" title="Permanent link">&para;</a></h3>
<p>Libigl&rsquo;s <code>igl::opengl::glfw::Viewer</code> provides basic support for rendering
multiple meshes.</p>
<p>Which mesh is <em>selected</em> is controlled via the <code>viewer.selected_data_index</code>
field. By default the index is set to <code>0</code>, so in the typical case of a single mesh
<code>viewer.data()</code> returns the <code>igl::ViewerData</code> corresponding to the one
and only mesh.</p>
<figure>
<p><img alt="" src="../images/multiple-meshes.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/107_MultipleMeshes/main.cpp">Example 107</a>) The <code>igl::opengl::glfw::Viewer</code> can render multiple meshes, each with its own attributes like colors.
  </figcaption>
</figure>
<h3 id="multiple-views">Multiple Views<a class="headerlink" href="#multiple-views" title="Permanent link">&para;</a></h3>
<p>Libigl&rsquo;s <code>igl::opengl::glfw::Viewer</code> provides basic support for rendering meshes with multiple views.</p>
<p>A new view core can be added to the viewer using the <code>Viewer::append_core()</code> method.
There can be a maximum of 31 cores created through the life of any viewer.
Each core is assigned an <code>unsigned int</code> <strong>id</strong> that is guaranteed to be unique.
A core can be accessed by its id calling the <code>Viewer::core(id)</code> method.</p>
<p>When there are more than one view core, the user is responsible for specifying each
viewport&rsquo;s size and position by setting their <code>viewport</code> attribute. The user must also
indicates how to resize each viewport when the size of the window changes. For example:</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">callback_post_resize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">igl</span><span class="o">::</span><span class="n">opengl</span><span class="o">::</span><span class="n">glfw</span><span class="o">::</span><span class="n">Viewer</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">core</span><span class="p">(</span><span class="w"> </span><span class="n">left_view</span><span class="p">).</span><span class="n">viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="w">  </span><span class="n">v</span><span class="p">.</span><span class="n">core</span><span class="p">(</span><span class="n">right_view</span><span class="p">).</span><span class="n">viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4f</span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">h</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>Note that the viewport currently hovered by the mouse can be selected using the
<code>Viewer::selected_core_index()</code> method, and the selected view core can then be
accessed by calling <code>viewer.core_list[viewer.selected_core_index]</code>.</p>
<p>Finally, the visibility of a mesh on a given view core is controlled by a bitmask flag per mesh.
This property can be easily controlled by calling the method</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">mesh_id</span><span class="p">).</span><span class="n">set_visible</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">view_id</span><span class="p">);</span>
</code></pre></div>
<p>When appending a new mesh or a new view core, an optional argument controls the visibility
of the existing objects with respect to the new mesh/view. Please refer to the documentation
of <code>Viewer::append_mesh()</code> and <code>Viewer::append_core()</code> for more details.</p>
<figure>
<p><img alt="" src="../images/108_MultipleViews.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/108_MultipleViews/main.cpp">Example 108</a>) The <code>igl::opengl::glfw::Viewer</code> can render the same scene using multiple views, each with its own attributes like colors, and individual mesh visibility.
  </figcaption>
</figure>
<h3 id="viewer-guizmos">Viewer Guizmos<a class="headerlink" href="#viewer-guizmos" title="Permanent link">&para;</a></h3>
<div class="admonition bug">
<p class="admonition-title">Bug</p>
<p>It is currently not possible to have more than one ImGui-related viewer plugin active at the same time (that includes <code>ImGuiMenu</code>, <code>ImGuizmoPlugin</code> and <code>SelectionPlugin</code>). Please follow <a class="magiclink magiclink-github magiclink-issue" href="https://github.com/libigl/libigl/issues/1656" title="GitHub Issue: libigl/libigl #1656">#1656</a> for more information.</p>
</div>
<p>The viewer integrates with <a href="https://github.com/CedricGuillemet/ImGuizmo">ImGuizmo</a> to provide 
widgets for manipulating a mesh. Mesh manipulations consist of translations, rotations, 
and scaling, where <code>W,w</code>, <code>E,e</code>, and <code>R,r</code> can be used to toggle between them, respectively. </p>
<p>First, register the <code>ImGuizmoPlugin</code> plugin with the Viewer:
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;igl/opengl/glfw/imgui/ImGuizmoPlugin.h&gt;</span>

<span class="c1">// ImGuizmoPlugin replaces the ImGuiMenu plugin entirely</span>
<span class="n">igl</span><span class="o">::</span><span class="n">opengl</span><span class="o">::</span><span class="n">glfw</span><span class="o">::</span><span class="n">imgui</span><span class="o">::</span><span class="n">ImGuizmoPlugin</span><span class="w"> </span><span class="n">plugin</span><span class="p">;</span>
<span class="n">vr</span><span class="p">.</span><span class="n">plugins</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plugin</span><span class="p">);</span>
</code></pre></div></p>
<p>On initialization, ImGuizmo must be provided with the mesh centroid, as shown in <a href="https://github.com/libigl/libigl/tree/main/tutorial/109_ImGuizmo/main.cpp">Example 109</a>:</p>
<p><div class="highlight"><pre><span></span><code><span class="c1">// Initialize ImGuizmo at mesh centroid</span>
<span class="n">plugin</span><span class="p">.</span><span class="n">T</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">  </span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">colwise</span><span class="p">().</span><span class="n">maxCoeff</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">V</span><span class="p">.</span><span class="n">colwise</span><span class="p">().</span><span class="n">minCoeff</span><span class="p">()).</span><span class="n">transpose</span><span class="p">().</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
</code></pre></div>
To apply the mesh manipulations invoked by the guizmos, the resulting transformation matrix 
is computed and applied to the input geometric data explicitly through the viewer&rsquo;s API: </p>
<div class="highlight"><pre><span></span><code><span class="c1">// Update can be applied relative to this remembered initial transform</span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span><span class="w"> </span><span class="n">T0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plugin</span><span class="p">.</span><span class="n">T</span><span class="p">;</span>
<span class="c1">// Attach callback to apply imguizmo&#39;s transform to mesh</span>
<span class="n">plugin</span><span class="p">.</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4f</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4d</span><span class="w"> </span><span class="n">TT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="n">T0</span><span class="p">.</span><span class="n">inverse</span><span class="p">()).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">().</span><span class="n">transpose</span><span class="p">();</span>
<span class="w">  </span><span class="n">vr</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_vertices</span><span class="p">(</span>
<span class="w">    </span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">rowwise</span><span class="p">().</span><span class="n">homogeneous</span><span class="p">()</span><span class="o">*</span><span class="n">TT</span><span class="p">).</span><span class="n">rowwise</span><span class="p">().</span><span class="n">hnormalized</span><span class="p">());</span>
<span class="w">  </span><span class="n">vr</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">compute_normals</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div>
<p><center><figure markdown>
  <img alt="" src="../images/109_ImGuizmo.png" />
  <figcaption markdown="span">
    ([Example 109](https://github.com/libigl/libigl/tree/main/tutorial/109_ImGuizmo/main.cpp)) The Libigl Viewer integrates with ImGuizmo to provide transformation widgets.
  </figcaption></p>
<p></figure>
</center></p>
<h3 id="msh-viewer">Msh Viewer<a class="headerlink" href="#msh-viewer" title="Permanent link">&para;</a></h3>
<p>Libigl can read mixed meshes stored in <a href="https://gmsh.info/doc/texinfo/gmsh.html#MSH-file-format-version-2-_0028Legacy_0029">Gmsh <code>.msh</code> version 2</a> file format.
These files can contain mixture of different meshes, as well as additional scalar and vector fields defined on element level and vertex level.</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">X</span><span class="p">;</span><span class="w"> </span><span class="c1">// Vertex coorinates (Xx3)</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">Tri</span><span class="p">;</span><span class="w"> </span><span class="c1">// Triangular elements (Yx3)</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">Tet</span><span class="p">;</span><span class="w"> </span><span class="c1">// Tetrahedral elements (Zx4)</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXi</span><span class="w"> </span><span class="n">TriTag</span><span class="p">;</span><span class="w"> </span><span class="c1">// Integer tags defining triangular submeshes</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXi</span><span class="w"> </span><span class="n">TetTag</span><span class="p">;</span><span class="w"> </span><span class="c1">// Integer tags defining tetrahedral submeshes</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">XFields</span><span class="p">;</span><span class="w"> </span><span class="c1">// headers (names) of fields defined on vertex level</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">EFields</span><span class="p">;</span><span class="w"> </span><span class="c1">// headers (names) of fields defined on element level</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">XF</span><span class="p">;</span><span class="w">   </span><span class="c1">// fields defined on vertex </span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TriF</span><span class="p">;</span><span class="w"> </span><span class="c1">// fields defined on triangular elements</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">TetF</span><span class="p">;</span><span class="w"> </span><span class="c1">// fields defined on tetrahedral elements</span>

<span class="c1">// loading mixed mesh from Gmsh file</span>
<span class="n">igl</span><span class="o">::</span><span class="n">readMSH</span><span class="p">(</span><span class="s">&quot;hand.msh&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">Tri</span><span class="p">,</span><span class="w"> </span><span class="n">Tet</span><span class="p">,</span><span class="w"> </span><span class="n">TriTag</span><span class="p">,</span><span class="w"> </span><span class="n">TetTag</span><span class="p">,</span><span class="w"> </span><span class="n">XFields</span><span class="p">,</span><span class="w"> </span><span class="n">XF</span><span class="p">,</span><span class="w"> </span><span class="n">EFields</span><span class="p">,</span><span class="w"> </span><span class="n">TriF</span><span class="p">,</span><span class="w"> </span><span class="n">TetF</span><span class="p">);</span>
</code></pre></div>
<p>The interactive viewer is unable to directly draw tetrahedra though. So for visualization purposes each tetrahedron
can be converted to four triangles.</p>
<figure>
<p><img alt="" src="../images/110_MshView.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/110_MshView/main.cpp">Example 110</a>) Shows a slice of tetrahedral mesh with scalar field defined on element level
  </figcaption>
</figure>
<h3 id="matcaps">MatCaps<a class="headerlink" href="#matcaps" title="Permanent link">&para;</a></h3>
<p>MatCaps (material captures), also known as environment maps, are a simple
image-based rendering technique to achieve complex lighting without a complex
shader program.</p>
<p>Using offline rendering or even a painting program, an image of a rendered
unit sphere is created, such as this image of a sphere with a
<a href="https://en.wikipedia.org/wiki/Jade">jade</a> material viewed under <a href="https://en.wikipedia.org/wiki/Three-point_lighting">studio
lighting</a>:</p>
<p><img alt="" src="../images/jade.png" /></p>
<p>The position <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> of each point on the sphere is also its unit normal
vector <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{n}} = \mathbf{p}</span><script type="math/tex">\hat{\mathbf{n}} = \mathbf{p}</script></span>. The idea of matcaps is to use this image
of the sphere as a lookup table keyed on an input normal value and outputting
the rgb color: <span class="arithmatex"><span class="MathJax_Preview">I(\hat{\mathbf{n}}) \rightarrow (r,g,b)</span><script type="math/tex">I(\hat{\mathbf{n}}) \rightarrow (r,g,b)</script></span>.</p>
<p>When rendering a non-spherical shape, in the fragment shader we compute the
normal vector <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{n}}</span><script type="math/tex">\hat{\mathbf{n}}</script></span> and then use its <span class="arithmatex"><span class="MathJax_Preview">x-</span><script type="math/tex">x-</script></span> and <span class="arithmatex"><span class="MathJax_Preview">y-</span><script type="math/tex">y-</script></span> components as
texture coordinates to look up the corresponding point in the matcap image. In
this way, there is no lighting model or lighting computation done in the
fragment shader, it is simply a texture lookup, but rather than requiring a
UV-mapping (parameterization) of the model, we use the per-fragment normals. By
using the normal relative to the camera&rsquo;s coordinate system we get view
dependent complex lighting &ldquo;for free&rdquo;:</p>
<figure>
<p><img alt="" src="../images/armadillo-jade-matcap.gif" />
  </p>
<figcaption>
    <a href="https://github.com/libigl/libigl/tree/main/tutorial/111_MatCap/main.cpp">Example 111</a> demonstrates using a jade matcap to add complex lighting to the libigl viewer.
  </figcaption>
</figure>
<p>In libigl, if the rgba data for a matcap image is stored in <code>R</code>,<code>G</code>,<code>B</code>, and <code>A</code>
(as output, e.g., by <code>igl::png::readPNG</code>) then this can be attached to the 
<code>igl::opengl::ViewerData</code> by setting it as the texture data and then turning on
matcap rendering:</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_texture</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">use_matcap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</code></pre></div>
<h2 id="chapter-2-discrete-geometric-quantities-and-operators">Chapter 2: Discrete Geometric Quantities And Operators<a class="headerlink" href="#chapter-2-discrete-geometric-quantities-and-operators" title="Permanent link">&para;</a></h2>
<p>This chapter illustrates a few discrete quantities that libigl can compute on a
mesh and the libigl functions that construct popular discrete differential
geometry operators. It also provides an introduction to basic drawing and
coloring routines of our viewer.</p>
<h3 id="normals">Normals<a class="headerlink" href="#normals" title="Permanent link">&para;</a></h3>
<p>Surface normals are a basic quantity necessary for rendering a surface. There
are a variety of ways to compute and store normals on a triangle mesh. <a href="https://github.com/libigl/libigl/tree/main/tutorial/201_Normals/main.cpp">Example
201</a> demonstrates how to compute and visualize normals
with libigl.</p>
<h4 id="per-face">Per-face<a class="headerlink" href="#per-face" title="Permanent link">&para;</a></h4>
<p>Normals are well defined on each triangle of a mesh as the vector orthogonal to
triangle&rsquo;s plane. These piecewise-constant normals produce piecewise-flat
renderings: the surface appears non-smooth and reveals its underlying
discretization.</p>
<h4 id="per-vertex">Per-vertex<a class="headerlink" href="#per-vertex" title="Permanent link">&para;</a></h4>
<p>Normals can be computed and stored on vertices, and interpolated in the interior of the triangles to produce smooth renderings (<a href="http://en.wikipedia.org/wiki/Phong_shading">Phong shading</a>).
Most techniques for computing per-vertex normals take an average of incident face normals. The main difference between these techniques is their weighting scheme: Uniform
weighting is heavily biased by the discretization choice, whereas area-based
or angle-based weighting is more forgiving.</p>
<p>The typical half-edge style computation of area-based weights has this structure:</p>
<div class="highlight"><pre><span></span><code><span class="n">N</span><span class="p">.</span><span class="n">setZero</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vertices</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">face</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">incident_faces</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">N</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">face</span><span class="p">.</span><span class="n">area</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">face</span><span class="p">.</span><span class="n">normal</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">N</span><span class="p">.</span><span class="n">rowwise</span><span class="p">().</span><span class="n">normalize</span><span class="p">();</span>
</code></pre></div>
<p>At first glance, it might seem inefficient to loop over incident faces&mdash;and thus constructing the per-vertex normals&mdash; without using an half-edge data structure. However, per-vertex normals may be <em>throwing</em> each face normal to
running sums on its corner vertices:</p>
<div class="highlight"><pre><span></span><code><span class="n">N</span><span class="p">.</span><span class="n">setZero</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">F</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span><span class="n">f</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="n">c</span><span class="o">++</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">N</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">area</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">face_normal</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
<span class="n">N</span><span class="p">.</span><span class="n">rowwise</span><span class="p">().</span><span class="n">normalize</span><span class="p">();</span>
</code></pre></div>
<h4 id="per-corner">Per-corner<a class="headerlink" href="#per-corner" title="Permanent link">&para;</a></h4>
<p>Storing normals per-corner is an efficient and convenient way of supporting both
smooth and sharp (e.g. creases and corners) rendering. This format is common to
OpenGL and the .obj mesh file format. Often such normals are tuned by the mesh
designer, but creases and corners can also be computed automatically. Libigl
implements a simple scheme which computes corner normals as averages of
normals of faces incident on the corresponding vertex which do not deviate by more than a specified dihedral angle (e.g. 20).</p>
<figure>
<p><img alt="" src="../images/fandisk-normals.png" />
  </p>
<figcaption>
    The <code>Normals</code> example computes per-face (left), per-vertex (middle) and per-corner (right) normals
  </figcaption>
</figure>
<h3 id="gaussian-curvature">Gaussian Curvature<a class="headerlink" href="#gaussian-curvature" title="Permanent link">&para;</a></h3>
<p>Gaussian curvature on a continuous surface is defined as the product of the
principal curvatures:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">k_G = k_1 k_2.</span><script type="math/tex">k_G = k_1 k_2.</script></span></p>
<p>As an <em>intrinsic</em> measure, it depends on the metric and
not the surface&rsquo;s embedding.</p>
<p>Intuitively, Gaussian curvature tells how locally spherical or <em>elliptic</em> the
surface is ( <span class="arithmatex"><span class="MathJax_Preview">k_G&gt;0</span><script type="math/tex">k_G>0</script></span> ), how locally saddle-shaped or <em>hyperbolic</em> the surface
is ( <span class="arithmatex"><span class="MathJax_Preview">k_G&lt;0</span><script type="math/tex">k_G<0</script></span> ), or how locally cylindrical or <em>parabolic</em> ( <span class="arithmatex"><span class="MathJax_Preview">k_G=0</span><script type="math/tex">k_G=0</script></span> ) the
surface is.</p>
<p>In the discrete setting, one definition for a &ldquo;discrete Gaussian curvature&rdquo;
on a triangle mesh is via a vertex&rsquo;s <em>angular deficit</em>:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">k_G(v_i) = 2 - \sum\limits_{j\in N(i)}_{ij},</span><script type="math/tex">k_G(v_i) = 2 - \sum\limits_{j\in N(i)}_{ij},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">N(i)</span><script type="math/tex">N(i)</script></span> are the triangles incident on vertex <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and <span class="arithmatex"><span class="MathJax_Preview">_{ij}</span><script type="math/tex">_{ij}</script></span> is the angle
at vertex <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> in triangle <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span> <sup id="fnref:meyer_2003"><a class="footnote-ref" href="#fn:meyer_2003">3</a></sup>.</p>
<p>Just like the continuous analog, our discrete Gaussian curvature reveals
elliptic, hyperbolic and parabolic vertices on the domain, as demonstrated in <a href="https://github.com/libigl/libigl/tree/main/tutorial/202_GaussianCurvature/main.cpp">Example 202</a>.</p>
<figure>
<p><img alt="" src="../images/bumpy-gaussian-curvature.jpg" />
  </p>
<figcaption>
    The <code>GaussianCurvature</code> example computes discrete Gaussian curvature and visualizes it in pseudocolor.
  </figcaption>
</figure>
<h3 id="curvature-directions">Curvature Directions<a class="headerlink" href="#curvature-directions" title="Permanent link">&para;</a></h3>
<p>The two principal curvatures <span class="arithmatex"><span class="MathJax_Preview">(k_1,k_2)</span><script type="math/tex">(k_1,k_2)</script></span> at a point on a surface measure how
much the surface bends in different directions. The directions of maximum and
minimum (signed) bending are called principal directions and are always
orthogonal.</p>
<p>Mean curvature is defined as the average of principal curvatures:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">H = \frac{1}{2}(k_1 + k_2).</span><script type="math/tex">H = \frac{1}{2}(k_1 + k_2).</script></span></p>
<p>One way to extract mean curvature is by examining the Laplace-Beltrami operator
applied to the surface positions. The result is a so-called mean-curvature
normal:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">-\Delta \mathbf{x} = H \mathbf{n}.</span><script type="math/tex">-\Delta \mathbf{x} = H \mathbf{n}.</script></span></p>
<p>It is easy to compute this on a discrete triangle mesh in libigl using the
cotangent Laplace-Beltrami operator <sup id="fnref2:meyer_2003"><a class="footnote-ref" href="#fn:meyer_2003">3</a></sup>.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;igl/cotmatrix.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;igl/massmatrix.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;igl/invert_diag.h&gt;</span>
<span class="p">...</span>
<span class="n">MatrixXd</span><span class="w"> </span><span class="n">HN</span><span class="p">;</span>
<span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">Minv</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">igl</span><span class="o">::</span><span class="n">MASSMATRIX_TYPE_VORONOI</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">invert_diag</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">Minv</span><span class="p">);</span>
<span class="n">HN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">Minv</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">V</span><span class="p">);</span>
<span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HN</span><span class="p">.</span><span class="n">rowwise</span><span class="p">().</span><span class="n">norm</span><span class="p">();</span><span class="w"> </span><span class="c1">//up to sign</span>
</code></pre></div>
<p>Combined with the angle defect definition of discrete Gaussian curvature, one
can define principal curvatures and use least squares fitting to find
directions <sup id="fnref3:meyer_2003"><a class="footnote-ref" href="#fn:meyer_2003">3</a></sup>.</p>
<p>Alternatively, a robust method for determining principal curvatures is via
quadric fitting <sup id="fnref:panozzo_2010"><a class="footnote-ref" href="#fn:panozzo_2010">5</a></sup>. In the neighborhood around every vertex, a
best-fit quadric is found and principal curvature values and directions are
analytically computed on this quadric (<a href="https://github.com/libigl/libigl/tree/main/tutorial/203_CurvatureDirections/main.cpp">Example
203</a>).</p>
<figure>
<p><img alt="" src="../images/fertility-principal-curvature.jpg" />
  </p>
<figcaption>
    The <code>CurvatureDirections</code> example computes principal curvatures via quadric fitting and visualizes mean curvature in pseudocolor and principal directions with a cross field.
  </figcaption>
</figure>
<h3 id="gradient">Gradient<a class="headerlink" href="#gradient" title="Permanent link">&para;</a></h3>
<p>Scalar functions on a surface can be discretized as a piecewise linear function
with values defined at each mesh vertex:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x}) \approx \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i,</span><script type="math/tex">f(\mathbf{x}) \approx \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i,</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is a piecewise linear hat function defined by the mesh so that
for each triangle <span class="arithmatex"><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is <em>the</em> linear function which is one only at
vertex <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> and zero at the other corners.</p>
<figure>
<p><img alt="" src="../images/hat-function.jpg" />
  </p>
<figcaption>
    Hat function <span class="arithmatex"><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is one at vertex <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, zero at all other vertices, and linear on incident triangles.
  </figcaption>
</figure>
<p>Thus gradients of such piecewise linear functions are simply sums of gradients
of the hat functions:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\nabla f(\mathbf{x}) \approx
 \nabla \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i =
 \sum\limits_{i=1}^n \nabla \phi_i(\mathbf{x})\, f_i.</span><script type="math/tex">\nabla f(\mathbf{x}) \approx
 \nabla \sum\limits_{i=1}^n \phi_i(\mathbf{x})\, f_i =
 \sum\limits_{i=1}^n \nabla \phi_i(\mathbf{x})\, f_i.</script></span></p>
<p>This reveals that the gradient is a linear function of the vector of <span class="arithmatex"><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span>
values. Because the <span class="arithmatex"><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> are linear in each triangle, their gradients are
<em>constant</em> in each triangle. Thus our discrete gradient operator can be written
as a matrix multiplication taking vertex values to triangle values:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\nabla f \approx \mathbf{G}\,\mathbf{f},</span><script type="math/tex">\nabla f \approx \mathbf{G}\,\mathbf{f},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span> is <span class="arithmatex"><span class="MathJax_Preview">n\times 1</span><script type="math/tex">n\times 1</script></span> and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}</span><script type="math/tex">\mathbf{G}</script></span> is an <span class="arithmatex"><span class="MathJax_Preview">md\times n</span><script type="math/tex">md\times n</script></span> sparse
matrix. This matrix <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}</span><script type="math/tex">\mathbf{G}</script></span> can be derived geometrically, e.g.
ch. 2<sup id="fnref:jacobson_thesis_2013"><a class="footnote-ref" href="#fn:jacobson_thesis_2013">1</a></sup>.
Libigl&rsquo;s <code>grad</code> function computes <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}</span><script type="math/tex">\mathbf{G}</script></span> for
triangle and tetrahedral meshes (<a href="https://github.com/libigl/libigl/tree/main/tutorial/204_Gradient/main.cpp">Example 204</a>):</p>
<figure>
<p><img alt="" src="../images/cheburashka-gradient.jpg" />
  </p>
<figcaption>
    The <code>Gradient</code> example computes gradients of an input function on a mesh and visualizes the vector field.
  </figcaption>
</figure>
<h3 id="laplacian">Laplacian<a class="headerlink" href="#laplacian" title="Permanent link">&para;</a></h3>
<p>The discrete Laplacian is an essential geometry processing tool. Many
interpretations and flavors of the Laplace and Laplace-Beltrami operator exist.</p>
<p>In open Euclidean space, the <em>Laplace</em> operator is the usual divergence of
gradient (or equivalently the Laplacian of a function is the trace of its
Hessian):</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\Delta f =
 \frac{\partial^2 f}{\partial x^2} +
 \frac{\partial^2 f}{\partial y^2} +
 \frac{\partial^2 f}{\partial z^2}.</span><script type="math/tex">\Delta f =
 \frac{\partial^2 f}{\partial x^2} +
 \frac{\partial^2 f}{\partial y^2} +
 \frac{\partial^2 f}{\partial z^2}.</script></span></p>
<p>The <em>Laplace-Beltrami</em> operator generalizes this to surfaces.</p>
<p>When considering piecewise-linear functions on a triangle mesh, a discrete
Laplacian may be derived in a variety of ways. The most popular in geometry
processing is the so-called ``cotangent Laplacian&rsquo;&rsquo; <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>, arising
simultaneously from FEM, DEC and applying divergence theorem to vertex
one-rings. As a linear operator taking vertex values to vertex values, the
Laplacian <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">n\times n</span><script type="math/tex">n\times n</script></span> matrix with elements:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">L_{ij} = \begin{cases}j \in N(i) &amp;\cot \alpha_{ij} + \cot \beta_{ij},\\
j \notin N(i) &amp; 0,\\
i = j &amp; -\sum\limits_{k\neq i} L_{ik},
\end{cases}</span><script type="math/tex">L_{ij} = \begin{cases}j \in N(i) &\cot \alpha_{ij} + \cot \beta_{ij},\\
j \notin N(i) & 0,\\
i = j & -\sum\limits_{k\neq i} L_{ik},
\end{cases}</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">N(i)</span><script type="math/tex">N(i)</script></span> are the vertices adjacent to (neighboring) vertex <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, and
<span class="arithmatex"><span class="MathJax_Preview">\alpha_{ij},\beta_{ij}</span><script type="math/tex">\alpha_{ij},\beta_{ij}</script></span> are the angles opposite to edge <span class="arithmatex"><span class="MathJax_Preview">{ij}</span><script type="math/tex">{ij}</script></span>.
This formula leads to a typical half-edge style implementation for
constructing <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span>:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">vertices</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">one_ring</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">triangle_on_edge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cot</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
<span class="w">      </span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">cot</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Similarly as before, it may seem to loop over one-rings without having an half-edge data structure. However, this is not the case, since the Laplacian may be built by summing together contributions for each triangle, much in spirit with its FEM discretization
of the Dirichlet energy (sum of squared gradients):</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="p">(</span><span class="n">triangle</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">triangles</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">edge</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cot</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="n">L</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cot</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="n">L</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">cot</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
<span class="w">    </span><span class="n">L</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">cot</span><span class="p">(</span><span class="n">angle</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Libigl implements discrete &ldquo;cotangent&rdquo; Laplacians for triangles meshes and
tetrahedral meshes, building both with fast geometric rules rather than &ldquo;by the
book&rdquo; FEM construction which involves many (small) matrix inversions, cf.
<sup id="fnref:sharf_2007"><a class="footnote-ref" href="#fn:sharf_2007">6</a></sup>.</p>
<p>The operator applied to mesh vertex positions amounts to smoothing by <em>flowing</em>
the surface along the mean curvature normal direction (<a href="https://github.com/libigl/libigl/tree/main/tutorial/205_Laplacian/main.cpp">Example 205</a>). Note that this is equivalent to minimizing surface area.</p>
<figure>
<p><img alt="" src="../images/cow-curvature-flow.jpg" />
  </p>
<figcaption>
    The <code>Laplacian</code> example computes conformalized mean curvature flow using the cotangent Laplacian <sup id="fnref:kazhdan_2012"><a class="footnote-ref" href="#fn:kazhdan_2012">2</a></sup>.
  </figcaption>
</figure>
<h4 id="mass-matrix">Mass Matrix<a class="headerlink" href="#mass-matrix" title="Permanent link">&para;</a></h4>
<p>The mass matrix <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> is another <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> matrix which takes vertex
values to vertex values. From an FEM point of view, it is a discretization of
the inner-product: it accounts for the area around each vertex. Consequently,
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> is often a diagonal matrix, such that <span class="arithmatex"><span class="MathJax_Preview">M_{ii}</span><script type="math/tex">M_{ii}</script></span> is the barycentric
or voronoi area around vertex <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span> in the mesh <sup id="fnref4:meyer_2003"><a class="footnote-ref" href="#fn:meyer_2003">3</a></sup>. The inverse of
this matrix is also very useful as it transforms integrated quantities into
point-wise quantities, e.g.:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\Delta f \approx \mathbf{M}^{-1} \mathbf{L} \mathbf{f}.</span><script type="math/tex">\Delta f \approx \mathbf{M}^{-1} \mathbf{L} \mathbf{f}.</script></span></p>
<p>In general, when encountering squared quantities integrated over the surface,
the mass matrix will be used as the discretization of the inner product when
sampling function values at vertices:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\int_S x\, y\ dA \approx \mathbf{x}^T\mathbf{M}\,\mathbf{y}.</span><script type="math/tex">\int_S x\, y\ dA \approx \mathbf{x}^T\mathbf{M}\,\mathbf{y}.</script></span></p>
<p>An alternative mass matrix <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">md \times md</span><script type="math/tex">md \times md</script></span> matrix which takes
triangle vector values to triangle vector values. This matrix represents an
inner-product accounting for the area associated with each triangle (i.e. the
triangles true area).</p>
<h4 id="alternative-construction-of-laplacian">Alternative Construction Of Laplacian<a class="headerlink" href="#alternative-construction-of-laplacian" title="Permanent link">&para;</a></h4>
<p>An alternative construction of the discrete cotangent Laplacian is by
&ldquo;squaring&rdquo; the discrete gradient operator. This may be derived by applying
Green&rsquo;s identity (ignoring boundary conditions for the moment):</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\int_S \|\nabla f\|^2 dA = \int_S f \Delta f dA</span><script type="math/tex">\int_S \|\nabla f\|^2 dA = \int_S f \Delta f dA</script></span></p>
<p>Or in matrix form which is immediately translatable to code:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}^T \mathbf{G}^T \mathbf{T} \mathbf{G} \mathbf{f} =
  \mathbf{f}^T \mathbf{M} \mathbf{M}^{-1} \mathbf{L} \mathbf{f} =
  \mathbf{f}^T \mathbf{L} \mathbf{f}.</span><script type="math/tex">\mathbf{f}^T \mathbf{G}^T \mathbf{T} \mathbf{G} \mathbf{f} =
  \mathbf{f}^T \mathbf{M} \mathbf{M}^{-1} \mathbf{L} \mathbf{f} =
  \mathbf{f}^T \mathbf{L} \mathbf{f}.</script></span></p>
<p>So we have that <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L} = \mathbf{G}^T \mathbf{T} \mathbf{G}</span><script type="math/tex">\mathbf{L} = \mathbf{G}^T \mathbf{T} \mathbf{G}</script></span>. This also
hints that we may consider <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}^T</span><script type="math/tex">\mathbf{G}^T</script></span> as a discrete <em>divergence</em> operator,
since the Laplacian is the divergence of the gradient. Naturally, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}^T</span><script type="math/tex">\mathbf{G}^T</script></span> is
a <span class="arithmatex"><span class="MathJax_Preview">n \times md</span><script type="math/tex">n \times md</script></span> sparse matrix which takes vector values stored at triangle faces
to scalar divergence values at vertices.</p>
<h3 id="exact-discrete-geodesic-distances">Exact Discrete Geodesic Distances<a class="headerlink" href="#exact-discrete-geodesic-distances" title="Permanent link">&para;</a></h3>
<p>The discrete geodesic distance between two points is the length of the shortest
path between then restricted to the surface. For triangle meshes, such a path is
made of a set of segments which can be either edges of the mesh or crossing a
triangle.</p>
<p>Libigl includes a wrapper for the exact geodesic algorithm <sup id="fnref:mitchell_1987"><a class="footnote-ref" href="#fn:mitchell_1987">4</a></sup>
developed by Danil Kirsanov (<a href="https://code.google.com/archive/p/geodesic/">https://code.google.com/archive/p/geodesic/</a>),
exposing it through an Eigen-based API. The function 
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">exact_geodesic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">VS</span><span class="p">,</span><span class="n">FS</span><span class="p">,</span><span class="n">VT</span><span class="p">,</span><span class="n">FT</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
</code></pre></div>
computes the closest geodesic distances of each vertex in VT or face in FT, from
the source vertices VS or faces FS of the input mesh V,F. The output is written
in the vector d, which lists first the distances for the vertices in VT, and
then for the faces in FT. For example, if you want to compute the distance from
the vertex with id <code>vid</code>, to all vertices of F you can use:
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXi</span><span class="w"> </span><span class="n">VS</span><span class="p">,</span><span class="n">FS</span><span class="p">,</span><span class="n">VT</span><span class="p">,</span><span class="n">FT</span><span class="p">;</span>
<span class="c1">// The selected vertex is the source</span>
<span class="n">VS</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">VS</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">vid</span><span class="p">;</span>
<span class="c1">// All vertices are the targets</span>
<span class="n">VT</span><span class="p">.</span><span class="n">setLinSpaced</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">rows</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="n">V</span><span class="p">.</span><span class="n">rows</span><span class="p">()</span><span class="mi">-1</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">exact_geodesic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">VS</span><span class="p">,</span><span class="n">FS</span><span class="p">,</span><span class="n">VT</span><span class="p">,</span><span class="n">FT</span><span class="p">,</span><span class="n">d</span><span class="p">);</span>
</code></pre></div></p>
<figure>
<p><img alt="" src="https://github.com/libigl/libigl/tree/main/tutorial/206_GeodesicDistance/main.cpp" />
  </p>
<figcaption>
    [Example 206
  </figcaption>
</figure>
<p>allows to
interactively pick the source vertex and displays the distance using a periodic
color pattern.](images/geodesicdistance.jpg)</p>
<h2 id="chapter-3-matrices-and-linear-algebra">Chapter 3: Matrices And Linear Algebra<a class="headerlink" href="#chapter-3-matrices-and-linear-algebra" title="Permanent link">&para;</a></h2>
<p>Libigl relies heavily on the Eigen library for dense and sparse linear algebra
routines. Besides geometry processing routines, libigl has linear algebra
routines which bootstrap Eigen and make it feel even more similar to a high-level
algebra library such as Matlab.</p>
<h3 id="slice">Slice<a class="headerlink" href="#slice" title="Permanent link">&para;</a></h3>
<p>A very familiar and powerful routine in Matlab is array slicing. This allows
reading from or writing to a possibly non-contiguous sub-matrix. Let&rsquo;s consider
the Matlab code:</p>
<div class="highlight"><pre><span></span><code><span class="n">B</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</code></pre></div>
<p>If <code>A</code> is a <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> matrix and <code>R</code> is a <span class="arithmatex"><span class="MathJax_Preview">j</span><script type="math/tex">j</script></span>-long list of row-indices
(between 1 and <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span>) and <code>C</code> is a <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-long list of column-indices, then as a
result <code>B</code> will be a <span class="arithmatex"><span class="MathJax_Preview">j \times k</span><script type="math/tex">j \times k</script></span> matrix drawing elements from <code>A</code> according to
<code>R</code> and <code>C</code>. In libigl, the same functionality is provided by the <code>slice</code>
function (<a href="https://github.com/libigl/libigl/tree/main/tutorial/301_Slice/main.cpp">Example 301</a>):</p>
<div class="highlight"><pre><span></span><code><span class="n">VectorXi</span><span class="w"> </span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="p">;</span>
<span class="n">MatrixXd</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">igl</span><span class="o">::</span><span class="n">slice</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">B</span><span class="p">);</span>
</code></pre></div>
<p>Note that <code>A</code> and <code>B</code> could also be sparse matrices.</p>
<p>Similarly, consider the Matlab code:</p>
<div class="highlight"><pre><span></span><code><span class="n">A</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="p">)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">B</span><span class="p">;</span>
</code></pre></div>
<p>Now, the selection is on the left-hand side so the <span class="arithmatex"><span class="MathJax_Preview">j \times k</span><script type="math/tex">j \times k</script></span> matrix  <code>B</code> is
being <em>written into</em> the submatrix of <code>A</code> determined by <code>R</code> and <code>C</code>. This
functionality is provided in libigl using <code>slice_into</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">slice_into</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/decimated-knight-slice-color.png" />
  </p>
<figcaption>
    The example <code>Slice</code> shows how to use <code>igl::slice</code> to change the colors for triangles on a mesh.
  </figcaption>
</figure>
<h3 id="sort">Sort<a class="headerlink" href="#sort" title="Permanent link">&para;</a></h3>
<p>Matlab and other higher-level languages make it very easy to extract indices of
sorting and comparison routines. For example in Matlab, one can write:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="n">I</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="s">&#39;ascend&#39;</span><span class="p">);</span>
</code></pre></div>
<p>so if <code>X</code> is a <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> matrix then <code>Y</code> will also be an <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> matrix
with entries sorted along dimension <code>1</code> in <code>'ascend'</code>ing order. The second
output <code>I</code> is a <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> matrix of indices such that <code>Y(i,j) =
X(I(i,j),j);</code>. That is, <code>I</code> reveals how <code>X</code> is sorted into <code>Y</code>.</p>
<p>This same functionality is supported in libigl:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</code></pre></div>
<p>Similarly, sorting entire rows can be accomplished in Matlab using:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">Y</span><span class="p">,</span><span class="n">I</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sortrows</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="s">&#39;ascend&#39;</span><span class="p">);</span>
</code></pre></div>
<p>where now <code>I</code> is a <span class="arithmatex"><span class="MathJax_Preview">m</span><script type="math/tex">m</script></span> vector of indices such that <code>Y = X(I,:)</code>.</p>
<p>In libigl, this is supported with</p>
<p><div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">sortrows</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</code></pre></div>
where again <code>I</code> reveals the index of sort so that it can be reproduced with
<code>igl::slice(X,I,1,Y)</code>.</p>
<p>Analogous functions are available in libigl for: <code>max</code>, <code>min</code>, and <code>unique</code>.</p>
<figure>
<p><img alt="" src="../images/decimated-knight-sort-color.png" />
  </p>
<figcaption>
    The example <code>Sort</code> shows how to use <code>igl::sortrows</code> to pseudocolor triangles according to their barycenters&rsquo; sorted order (<a href="https://github.com/libigl/libigl/tree/main/tutorial/302_Sort/main.cpp">Example 302</a>).
  </figcaption>
</figure>
<h4 id="other-matlab-style-functions">Other Matlab-style Functions<a class="headerlink" href="#other-matlab-style-functions" title="Permanent link">&para;</a></h4>
<p>Libigl implements a variety of other routines with the same api and
functionality as common Matlab functions.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><code>igl::all</code></td>
<td style="text-align: left;">Whether all elements are non-zero (true)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::any</code></td>
<td style="text-align: left;">Whether any elements are non-zero (true)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::cat</code></td>
<td style="text-align: left;">Concatenate two matrices (especially useful for dealing with Eigen sparse matrices)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::ceil</code></td>
<td style="text-align: left;">Round entries up to nearest integer</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::cumsum</code></td>
<td style="text-align: left;">Cumulative sum of matrix elements</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::colon</code></td>
<td style="text-align: left;">Act like Matlab&rsquo;s <code>:</code>, similar to Eigen&rsquo;s <code>LinSpaced</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::components</code></td>
<td style="text-align: left;">Connected components of graph (cf. Matlab&rsquo;s <code>graphconncomp</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::count</code></td>
<td style="text-align: left;">Count non-zeros in rows or columns</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::cross</code></td>
<td style="text-align: left;">Cross product per-row</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::cumsum</code></td>
<td style="text-align: left;">Cumulative summation</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::dot</code></td>
<td style="text-align: left;">dot product per-row</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::eigs</code></td>
<td style="text-align: left;">Solve sparse eigen value problem</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::find</code></td>
<td style="text-align: left;">Find subscripts of non-zero entries</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::floor</code></td>
<td style="text-align: left;">Round entries down to nearest integer</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::histc</code></td>
<td style="text-align: left;">Counting occurrences for building a histogram</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::hsv_to_rgb</code></td>
<td style="text-align: left;">Convert HSV colors to RGB (cf. Matlab&rsquo;s <code>hsv2rgb</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::intersect</code></td>
<td style="text-align: left;">Set intersection of matrix elements.</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::isdiag</code></td>
<td style="text-align: left;">Determine whether matrix is diagonal</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::ismember</code></td>
<td style="text-align: left;">Determine whether elements in A occur in B</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::jet</code></td>
<td style="text-align: left;">Quantized colors along the rainbow.</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::max</code></td>
<td style="text-align: left;">Compute maximum entry per row or column</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::median</code></td>
<td style="text-align: left;">Compute the median per column</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::min</code></td>
<td style="text-align: left;">Compute minimum entry per row or column</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::mod</code></td>
<td style="text-align: left;">Compute per element modulo</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::mode</code></td>
<td style="text-align: left;">Compute the mode per column</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::null</code></td>
<td style="text-align: left;">Compute the null space basis of a matrix</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::nchoosek</code></td>
<td style="text-align: left;">Compute all k-size combinations of n-long vector</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::orth</code></td>
<td style="text-align: left;">Orthogonalization of a basis</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::parula</code></td>
<td style="text-align: left;">Generate a quantized colormap from blue to yellow</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::pinv</code></td>
<td style="text-align: left;">Compute Moore-Penrose pseudoinverse</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::randperm</code></td>
<td style="text-align: left;">Generate a random permutation of [0,&hellip;,n-1]</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::rgb_to_hsv</code></td>
<td style="text-align: left;">Convert RGB colors to HSV (cf. Matlab&rsquo;s <code>rgb2hsv</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::repmat</code></td>
<td style="text-align: left;">Repeat a matrix along columns and rows</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::round</code></td>
<td style="text-align: left;">Per-element round to whole number</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::setdiff</code></td>
<td style="text-align: left;">Set difference of matrix elements</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::setunion</code></td>
<td style="text-align: left;">Set union of matrix elements</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::setxor</code></td>
<td style="text-align: left;">Set exclusive &ldquo;or&rdquo; of matrix elements</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::slice</code></td>
<td style="text-align: left;">Slice parts of matrix using index lists: (cf. Matlab&rsquo;s <code>B = A(I,J)</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::slice_mask</code></td>
<td style="text-align: left;">Slice parts of matrix using boolean masks: (cf. Matlab&rsquo;s <code>B = A(M,N)</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::slice_into</code></td>
<td style="text-align: left;">Slice left-hand side of matrix assignment using index lists (cf. Matlab&rsquo;s <code>B(I,J) = A</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::sort</code></td>
<td style="text-align: left;">Sort elements or rows of matrix</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::speye</code></td>
<td style="text-align: left;">Identity as sparse matrix</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::sum</code></td>
<td style="text-align: left;">Sum along columns or rows (of sparse matrix)</td>
</tr>
<tr>
<td style="text-align: left;"><code>igl::unique</code></td>
<td style="text-align: left;">Extract unique elements or rows of matrix</td>
</tr>
</tbody>
</table>
<h3 id="laplace-equation">Laplace Equation<a class="headerlink" href="#laplace-equation" title="Permanent link">&para;</a></h3>
<p>A common linear system in geometry processing is the Laplace equation:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">z = 0</span><script type="math/tex">z = 0</script></span></p>
<p>subject to some boundary conditions, for example Dirichlet boundary conditions
(fixed value):</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\left.z\right|_{\partial{S}} = z_{bc}</span><script type="math/tex">\left.z\right|_{\partial{S}} = z_{bc}</script></span></p>
<p>In the discrete setting, the linear system can be written as:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{L} \mathbf{z} = \mathbf{0}</span><script type="math/tex">\mathbf{L} \mathbf{z} = \mathbf{0}</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span> is the <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> discrete Laplacian and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> is a
vector of per-vertex values. Most of <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> correspond to interior
vertices and are unknown, but some of <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> represent values at boundary
vertices. Their values are known so we may move their corresponding terms to
the right-hand side.</p>
<p>Conceptually, this is very easy if we have sorted <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> so that interior
vertices come first and then boundary vertices:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} &amp; \mathbf{L}_{in,b}\\
 \mathbf{L}_{b,in} &amp; \mathbf{L}_{b,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \left(\begin{array}{c}
 \mathbf{0}_{in}\\
 \mathbf{z}_{bc}\end{array}\right)
</div>
<script type="math/tex; mode=display">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} & \mathbf{L}_{in,b}\\
 \mathbf{L}_{b,in} & \mathbf{L}_{b,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \left(\begin{array}{c}
 \mathbf{0}_{in}\\
 \mathbf{z}_{bc}\end{array}\right)
</script>
</div>
<p>The bottom block of equations is no longer meaningful so we&rsquo;ll only consider
the top block:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} &amp; \mathbf{L}_{in,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \mathbf{0}_{in}
</div>
<script type="math/tex; mode=display">
 \left(\begin{array}{cc}
 \mathbf{L}_{in,in} & \mathbf{L}_{in,b}\end{array}\right)
 \left(\begin{array}{c}
 \mathbf{z}_{in}\\
 \mathbf{z}_{b}\end{array}\right) =
 \mathbf{0}_{in}
</script>
</div>
<p>We can move the known values to the right-hand side:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \mathbf{L}_{in,in}
 \mathbf{z}_{in} = -
 \mathbf{L}_{in,b}
 \mathbf{z}_{b}
</div>
<script type="math/tex; mode=display">
 \mathbf{L}_{in,in}
 \mathbf{z}_{in} = -
 \mathbf{L}_{in,b}
 \mathbf{z}_{b}
</script>
</div>
<p>Finally we can solve this equation for the unknown values at interior vertices
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_{in}</span><script type="math/tex">\mathbf{z}_{in}</script></span>.</p>
<p>However, our vertices will often not be sorted in this way. One option would be to sort <code>V</code>,
then proceed as above and then <em>unsort</em> the solution <code>Z</code> to match <code>V</code>. However,
this solution is not very general.</p>
<p>With array slicing no explicit sort is needed. Instead we can <em>slice-out</em>
submatrix blocks (<span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}_{in,in}</span><script type="math/tex">\mathbf{L}_{in,in}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}_{in,b}</span><script type="math/tex">\mathbf{L}_{in,b}</script></span>, etc.) and follow
the linear algebra above directly. Then we can slice the solution <em>into</em> the
rows of <code>Z</code> corresponding to the interior vertices (<a href="https://github.com/libigl/libigl/tree/main/tutorial/303_LaplaceEquation/main.cpp">Example 303</a>).</p>
<figure>
<p><img alt="" src="../images/camelhead-laplace-equation.jpg" />
  </p>
<figcaption>
    The <code>LaplaceEquation</code> example solves a Laplace equation with Dirichlet boundary conditions.
  </figcaption>
</figure>
<h4 id="quadratic-energy-minimization">Quadratic Energy Minimization<a class="headerlink" href="#quadratic-energy-minimization" title="Permanent link">&para;</a></h4>
<p>The same Laplace equation may be equivalently derived by minimizing Dirichlet
energy subject to the same boundary conditions:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathop{\text{minimize }}_z \frac{1}{2}\int\limits_S \|\nabla z\|^2 dA</span><script type="math/tex">\mathop{\text{minimize }}_z \frac{1}{2}\int\limits_S \|\nabla z\|^2 dA</script></span></p>
<p>On our discrete mesh, recall that this becomes</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{G}^T \mathbf{D}
 \mathbf{G} \mathbf{z} \rightarrow \mathop{\text{minimize }}_\mathbf{z} \mathbf{z}^T \mathbf{L} \mathbf{z}</span><script type="math/tex">\mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{G}^T \mathbf{D}
 \mathbf{G} \mathbf{z} \rightarrow \mathop{\text{minimize }}_\mathbf{z} \mathbf{z}^T \mathbf{L} \mathbf{z}</script></span></p>
<p>The general problem of minimizing some energy over a mesh subject to fixed
value boundary conditions is so wide spread that libigl has a dedicated api for
solving such systems.</p>
<p>Let us consider a general quadratic minimization problem subject to different
common constraints:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
 \mathbf{z}^T \mathbf{B} + \text{constant},
</div>
<script type="math/tex; mode=display">
 \mathop{\text{minimize }}_\mathbf{z}  \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
 \mathbf{z}^T \mathbf{B} + \text{constant},
</script>
</div>
<p>subject to</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \mathbf{z}_b = \mathbf{z}_{bc} \text{ and } \mathbf{A}_{eq} \mathbf{z} =
 \mathbf{B}_{eq},
</div>
<script type="math/tex; mode=display">
 \mathbf{z}_b = \mathbf{z}_{bc} \text{ and } \mathbf{A}_{eq} \mathbf{z} =
 \mathbf{B}_{eq},
</script>
</div>
<p>where</p>
<ul>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{Q}</span><script type="math/tex">\mathbf{Q}</script></span> is a (usually sparse) <span class="arithmatex"><span class="MathJax_Preview">n \times n</span><script type="math/tex">n \times n</script></span> positive semi-definite
    matrix of quadratic coefficients (Hessian),</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}</span><script type="math/tex">\mathbf{B}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">n \times 1</span><script type="math/tex">n \times 1</script></span> vector of linear coefficients,</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_b</span><script type="math/tex">\mathbf{z}_b</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">|b| \times 1</span><script type="math/tex">|b| \times 1</script></span> portion of
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> corresponding to boundary or <em>fixed</em> vertices,</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_{bc}</span><script type="math/tex">\mathbf{z}_{bc}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">|b| \times 1</span><script type="math/tex">|b| \times 1</script></span> vector of known values corresponding to
    <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_b</span><script type="math/tex">\mathbf{z}_b</script></span>,</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{eq}</span><script type="math/tex">\mathbf{A}_{eq}</script></span> is a (usually sparse) <span class="arithmatex"><span class="MathJax_Preview">m \times n</span><script type="math/tex">m \times n</script></span> matrix of linear
    equality constraint coefficients (one row per constraint), and</li>
<li><span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}_{eq}</span><script type="math/tex">\mathbf{B}_{eq}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">m \times 1</span><script type="math/tex">m \times 1</script></span> vector of linear equality constraint
    right-hand side values.</li>
</ul>
<p>This specification is overly general as we could write <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}_b =
\mathbf{z}_{bc}</span><script type="math/tex">\mathbf{z}_b =
\mathbf{z}_{bc}</script></span> as rows of <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{eq} \mathbf{z} =
\mathbf{B}_{eq}</span><script type="math/tex">\mathbf{A}_{eq} \mathbf{z} =
\mathbf{B}_{eq}</script></span>, but these fixed value constraints appear so often that they
merit a dedicated place in the API.</p>
<p>In libigl, solving such quadratic optimization problems is split into two
routines: precomputation and solve. Precomputation only depends on the
quadratic coefficients, known value indices and linear constraint coefficients:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">min_quad_with_fixed_data</span><span class="w"> </span><span class="n">mqwf</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">min_quad_with_fixed_precompute</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">Aeq</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="n">mqwf</span><span class="p">);</span>
</code></pre></div>
<p>The output is a struct <code>mqwf</code> which contains the system matrix factorization
and is used during solving with arbitrary linear terms, known values, and
constraint in the right-hand sides:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">min_quad_with_fixed_solve</span><span class="p">(</span><span class="n">mqwf</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">Beq</span><span class="p">,</span><span class="n">Z</span><span class="p">);</span>
</code></pre></div>
<p>The output <code>Z</code> is a <span class="arithmatex"><span class="MathJax_Preview">n \times 1</span><script type="math/tex">n \times 1</script></span> vector of solutions with fixed values
correctly placed to match the mesh vertices <code>V</code>.</p>
<h3 id="linear-equality-constraints">Linear Equality Constraints<a class="headerlink" href="#linear-equality-constraints" title="Permanent link">&para;</a></h3>
<p>We saw above that <code>min_quad_with_fixed_*</code> in libigl provides a compact way to
solve general quadratic programs. Let&rsquo;s consider another example, this time
with active linear equality constraints. Specifically let&rsquo;s solve the
<code>bi-Laplace equation</code> or equivalently minimize the Laplace energy:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \Delta^2 z = 0 \leftrightarrow \mathop{\text{minimize }}\limits_z \frac{1}{2}
 \int\limits_S (\Delta z)^2 dA
</div>
<script type="math/tex; mode=display">
 \Delta^2 z = 0 \leftrightarrow \mathop{\text{minimize }}\limits_z \frac{1}{2}
 \int\limits_S (\Delta z)^2 dA
</script>
</div>
<p>subject to fixed value constraints and a linear equality constraint:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">z_{a} = 1, z_{b} = -1</span><script type="math/tex">z_{a} = 1, z_{b} = -1</script></span> and <span class="arithmatex"><span class="MathJax_Preview">z_{c} = z_{d}</span><script type="math/tex">z_{c} = z_{d}</script></span>.</p>
<p>Notice that we can rewrite the last constraint in the familiar form from above:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">z_{c} - z_{d} = 0.</span><script type="math/tex">z_{c} - z_{d} = 0.</script></span></p>
<p>Now we can assembly <code>Aeq</code> as a <span class="arithmatex"><span class="MathJax_Preview">1 \times n</span><script type="math/tex">1 \times n</script></span> sparse matrix with a coefficient
<span class="arithmatex"><span class="MathJax_Preview">1</span><script type="math/tex">1</script></span> in the column corresponding to vertex <span class="arithmatex"><span class="MathJax_Preview">c</span><script type="math/tex">c</script></span> and a <span class="arithmatex"><span class="MathJax_Preview">-1</span><script type="math/tex">-1</script></span> at <span class="arithmatex"><span class="MathJax_Preview">d</span><script type="math/tex">d</script></span>. The right-hand
side <code>Beq</code> is simply zero.</p>
<p>Internally, <code>min_quad_with_fixed_*</code> solves using the Lagrange Multiplier
method. This method adds additional variables for each linear constraint (in
general a <span class="arithmatex"><span class="MathJax_Preview">m \times 1</span><script type="math/tex">m \times 1</script></span> vector of variables <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>) and then solves the
saddle problem:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
  \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\, \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
  \mathbf{z}^T \mathbf{B} + \text{constant} + \lambda^T\left(\mathbf{A}_{eq}
 \mathbf{z} - \mathbf{B}_{eq}\right)
</div>
<script type="math/tex; mode=display">
  \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\, \frac{1}{2}\mathbf{z}^T \mathbf{Q} \mathbf{z} +
  \mathbf{z}^T \mathbf{B} + \text{constant} + \lambda^T\left(\mathbf{A}_{eq}
 \mathbf{z} - \mathbf{B}_{eq}\right)
</script>
</div>
<p>This can be rewritten in a more familiar form by stacking <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> and
<span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> into one <span class="arithmatex"><span class="MathJax_Preview">(m+n) \times 1</span><script type="math/tex">(m+n) \times 1</script></span> vector of unknowns:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\,
 \frac{1}{2}
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{cc}
  \mathbf{Q}      &amp; \mathbf{A}_{eq}^T\\
  \mathbf{A}_{eq} &amp; 0
  \end{array}
 \right)
 \left(
  \begin{array}{c}
  \mathbf{z}\\
  \lambda
  \end{array}
 \right) +
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{c}
  \mathbf{B}\\
  -\mathbf{B}_{eq}
  \end{array}
  \right)
  + \text{constant}
</div>
<script type="math/tex; mode=display">
 \mathop{\text{find saddle }}_{\mathbf{z},\lambda}\,
 \frac{1}{2}
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{cc}
  \mathbf{Q}      & \mathbf{A}_{eq}^T\\
  \mathbf{A}_{eq} & 0
  \end{array}
 \right)
 \left(
  \begin{array}{c}
  \mathbf{z}\\
  \lambda
  \end{array}
 \right) +
 \left(
  \mathbf{z}^T
  \lambda^T
 \right)
 \left(
  \begin{array}{c}
  \mathbf{B}\\
  -\mathbf{B}_{eq}
  \end{array}
  \right)
  + \text{constant}
</script>
</div>
<p>Differentiating with respect to <span class="arithmatex"><span class="MathJax_Preview">\left( \mathbf{z}^T \lambda^T \right)</span><script type="math/tex">\left( \mathbf{z}^T \lambda^T \right)</script></span> reveals
a linear system and we can solve for <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span> and <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span>. The only
difference from the straight quadratic <em>minimization</em> system, is that this
saddle problem system will not be positive definite. Thus, we must use a
different factorization technique (LDLT rather than LLT): libigl&rsquo;s
<code>min_quad_with_fixed_precompute</code> automatically chooses the correct solver in
the presence of linear equality constraints (<a href="https://github.com/libigl/libigl/tree/main/tutorial/304_LinearEqualityConstraints/main.cpp">Example 304</a>).</p>
<figure>
<p><img alt="" src="../images/cheburashka-biharmonic-leq.jpg" />
  </p>
<figcaption>
    The example <code>LinearEqualityConstraints</code> first solves with just fixed value constraints (left: 1 and -1 on the left hand and foot respectively), then solves with an additional linear equality constraint (right: points on right hand and foot constrained to be equal).
  </figcaption>
</figure>
<h3 id="quadratic-programming">Quadratic Programming<a class="headerlink" href="#quadratic-programming" title="Permanent link">&para;</a></h3>
<p>We can generalize the quadratic optimization in the previous section even more
by allowing inequality constraints. Specifically box constraints (lower and
upper bounds):</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{l} \le \mathbf{z} \le \mathbf{u},</span><script type="math/tex">\mathbf{l} \le \mathbf{z} \le \mathbf{u},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{l},\mathbf{u}</span><script type="math/tex">\mathbf{l},\mathbf{u}</script></span> are <span class="arithmatex"><span class="MathJax_Preview">n \times 1</span><script type="math/tex">n \times 1</script></span> vectors of lower and upper
bounds
and general linear inequality constraints:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{ieq} \mathbf{z} \le \mathbf{B}_{ieq},</span><script type="math/tex">\mathbf{A}_{ieq} \mathbf{z} \le \mathbf{B}_{ieq},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}_{ieq}</span><script type="math/tex">\mathbf{A}_{ieq}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">k \times n</span><script type="math/tex">k \times n</script></span> matrix of linear coefficients and
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{B}_{ieq}</span><script type="math/tex">\mathbf{B}_{ieq}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">k \times 1</span><script type="math/tex">k \times 1</script></span> matrix of constraint right-hand sides.</p>
<p>Again, we are overly general as the box constraints could be written as
rows of the linear inequality constraints, but bounds appear frequently enough
to merit a dedicated api.</p>
<p>Libigl implements its own active set routine for solving <em>quadratric programs</em>
(QPs). This algorithm works by iteratively &ldquo;activating&rdquo; violated inequality
constraints by enforcing them as equalities and &ldquo;deactivating&rdquo; constraints
which are no longer needed.</p>
<p>After deciding which constraints are active at each iteration, the problem
reduces to a quadratic minimization subject to linear <em>equality</em> constraints,
and the method from the previous section is invoked. This is repeated until convergence.</p>
<p>Currently the implementation is efficient for box constraints and sparse
non-overlapping linear inequality constraints.</p>
<p>Unlike alternative interior-point methods, the active set method benefits from
a warm-start (initial guess for the solution vector <span class="arithmatex"><span class="MathJax_Preview">\mathbf{z}</span><script type="math/tex">\mathbf{z}</script></span>).</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">active_set_params</span><span class="w"> </span><span class="n">as</span><span class="p">;</span>
<span class="c1">// Z is optional initial guess and output</span>
<span class="n">igl</span><span class="o">::</span><span class="n">active_set</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">Aeq</span><span class="p">,</span><span class="n">Beq</span><span class="p">,</span><span class="n">Aieq</span><span class="p">,</span><span class="n">Bieq</span><span class="p">,</span><span class="n">lx</span><span class="p">,</span><span class="n">ux</span><span class="p">,</span><span class="n">as</span><span class="p">,</span><span class="n">Z</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/cheburashka-multiscale-biharmonic-kernels.jpg" />
  </p>
<figcaption>
     <a href="https://github.com/libigl/libigl/tree/main/tutorial/305_QuadraticProgramming/main.cpp">Example 305</a> uses an active set solver to optimize discrete biharmonic kernels <sup id="fnref:rustamov_2011"><a class="footnote-ref" href="#fn:rustamov_2011">9</a></sup> at multiple scales .
  </figcaption>
</figure>
<h3 id="eigen-decomposition">Eigen Decomposition<a class="headerlink" href="#eigen-decomposition" title="Permanent link">&para;</a></h3>
<p>Libigl has rudimentary support for extracting eigen pairs of a generalized
eigen value problem:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">Ax = \lambda B x</span><script type="math/tex">Ax = \lambda B x</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is a sparse symmetric matrix and <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is a sparse positive definite
matrix. Most commonly in geometry processing, we let <span class="arithmatex"><span class="MathJax_Preview">A=L</span><script type="math/tex">A=L</script></span> the cotangent
Laplacian and <span class="arithmatex"><span class="MathJax_Preview">B=M</span><script type="math/tex">B=M</script></span> the per-vertex mass matrix (e.g. <sup id="fnref:vallet_2008"><a class="footnote-ref" href="#fn:vallet_2008">10</a></sup>).
Typically applications will make use of the <em>low frequency</em> eigen modes.
Analogous to the Fourier decomposition, a function <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> on a surface can be
represented via its spectral decomposition of the eigen modes of the
Laplace-Beltrami:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">f = \sum\limits_{i=1}^\infty a_i \phi_i</span><script type="math/tex">f = \sum\limits_{i=1}^\infty a_i \phi_i</script></span></p>
<p>where each <span class="arithmatex"><span class="MathJax_Preview">\phi_i</span><script type="math/tex">\phi_i</script></span> is an eigen function satisfying: <span class="arithmatex"><span class="MathJax_Preview">\Delta \phi_i = \lambda_i
\phi_i</span><script type="math/tex">\Delta \phi_i = \lambda_i
\phi_i</script></span> and <span class="arithmatex"><span class="MathJax_Preview">a_i</span><script type="math/tex">a_i</script></span> are scalar coefficients. For a discrete triangle mesh, a
completely analogous decomposition exists, albeit with finite sum:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{f} = \sum\limits_{i=1}^n a_i \phi_i</span><script type="math/tex">\mathbf{f} = \sum\limits_{i=1}^n a_i \phi_i</script></span></p>
<p>where now a column vector of values at vertices <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f} \in \mathcal{R}^n</span><script type="math/tex">\mathbf{f} \in \mathcal{R}^n</script></span>
specifies a piecewise linear function and <span class="arithmatex"><span class="MathJax_Preview">\phi_i \in \mathcal{R}^n</span><script type="math/tex">\phi_i \in \mathcal{R}^n</script></span> is an
eigen vector satisfying:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{L} \phi_i = \lambda_i \mathbf{M} \phi_i</span><script type="math/tex">\mathbf{L} \phi_i = \lambda_i \mathbf{M} \phi_i</script></span>.</p>
<p>Note that Vallet &amp; Levy <sup id="fnref2:vallet_2008"><a class="footnote-ref" href="#fn:vallet_2008">10</a></sup> propose solving a symmetrized
<em>standard</em> eigen problem <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}^{-1/2}\mathbf{L}\mathbf{M}^{-1/2} \phi_i
= \lambda_i \phi_i</span><script type="math/tex">\mathbf{M}^{-1/2}\mathbf{L}\mathbf{M}^{-1/2} \phi_i
= \lambda_i \phi_i</script></span>. Libigl implements a generalized eigen problem solver so
this unnecessary symmetrization can be avoided.</p>
<p>Often the sum above is <em>truncated</em> to the first <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> eigen vectors. If the low
frequency modes are chosen, i.e. those corresponding to small <span class="arithmatex"><span class="MathJax_Preview">\lambda_i</span><script type="math/tex">\lambda_i</script></span>
values, then this truncation effectively <em>regularizes</em> <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span> to smooth,
slowly changing functions over the mesh (e.g. <sup id="fnref:hildebrandt_2011"><a class="footnote-ref" href="#fn:hildebrandt_2011">8</a></sup>). Modal
analysis and model subspaces have been used frequently in real-time deformation
(e.g. <sup id="fnref:barbic_2005"><a class="footnote-ref" href="#fn:barbic_2005">7</a></sup>).</p>
<p>In <a href="https://github.com/libigl/libigl/tree/main/tutorial/306_EigenDecomposition/main.cpp">Example 306</a>), the first 5 eigen vectors
of the discrete Laplace-Beltrami operator are computed and displayed in
pseudo-color atop the beetle. Eigen vectors are computed using <code>igl::eigs</code>
(mirroring MATLAB&rsquo;s <code>eigs</code>). The 5 eigen vectors are placed into the columns
of <code>U</code> and the eigen values are placed into the entries of <code>S</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="p">,</span><span class="n">M</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">massmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">igl</span><span class="o">::</span><span class="n">MASSMATRIX_TYPE_DEFAULT</span><span class="p">,</span><span class="n">M</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">U</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">S</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">eigs</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">igl</span><span class="o">::</span><span class="n">EIGS_TYPE_SM</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">S</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/beetle-eigen-decomposition.gif" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/306_EigenDecomposition/main.cpp">Example 306</a>) Low frequency eigen vectors of the discrete Laplace-Beltrami operator vary smoothly and slowly over the <em>Beetle</em>.
  </figcaption>
</figure>
<!-- Hide h4+ from toc  -->
<style>.md-nav--secondary .md-nav__list .md-nav__list .md-nav__list { display: none }</style>

<h2 id="chapter-4-shape-deformation">Chapter 4: Shape Deformation<a class="headerlink" href="#chapter-4-shape-deformation" title="Permanent link">&para;</a></h2>
<p>Modern mesh-based shape deformation methods satisfy user deformation
constraints at handles (selected vertices or regions on the mesh) and propagate
these handle deformations to the rest of shape <em>smoothly</em> and <em>without removing
or distorting details</em>. Libigl provides implementations of a variety of
state-of-the-art deformation techniques, ranging from quadratic mesh-based
energy minimizers, to skinning methods, to non-linear elasticity-inspired
techniques.</p>
<h3 id="biharmonic-deformation">Biharmonic Deformation<a class="headerlink" href="#biharmonic-deformation" title="Permanent link">&para;</a></h3>
<p>The period of research between 2000 and 2010 produced a collection of
techniques that cast the problem of handle-based shape deformation as a
quadratic energy minimization problem or equivalently the solution to a linear
partial differential equation.</p>
<p>There are many flavors of these techniques, but a prototypical subset are those
that consider solutions to the bi-Laplace equation, that is a biharmonic
function <sup id="fnref:botsch_2004"><a class="footnote-ref" href="#fn:botsch_2004">11</a></sup>. This fourth-order PDE provides sufficient
flexibility in boundary conditions to ensure <span class="arithmatex"><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span> continuity at handle
constraints (in the limit under refinement) <sup id="fnref:jacobson_mixed_2010"><a class="footnote-ref" href="#fn:jacobson_mixed_2010">15</a></sup>.</p>
<h4 id="biharmonic-surfaces">Biharmonic Surfaces<a class="headerlink" href="#biharmonic-surfaces" title="Permanent link">&para;</a></h4>
<p>Let us first begin our discussion of biharmonic <em>deformation</em>, by considering
biharmonic <em>surfaces</em>. We will casually define biharmonic surfaces as surface
whose <em>position functions</em> are biharmonic with respect to some initial
parameterization:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\Delta^2 \mathbf{x}' = 0</span><script type="math/tex">\Delta^2 \mathbf{x}' = 0</script></span></p>
<p>and subject to some handle constraints, conceptualized as &ldquo;boundary
conditions&rdquo;:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}'_{b} = \mathbf{x}_{bc}.</span><script type="math/tex">\mathbf{x}'_{b} = \mathbf{x}_{bc}.</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}'</span><script type="math/tex">\mathbf{x}'</script></span> is the unknown 3D position of a point on the surface. So we
are asking that the bi-Laplacian of each of spatial coordinate function to be
zero.</p>
<p>In libigl, one can solve a biharmonic problem with <code>igl::harmonic</code>
and setting <span class="arithmatex"><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span> (<em>bi</em>-harmonic):</p>
<div class="highlight"><pre><span></span><code><span class="c1">// U_bc contains deformation of boundary vertices b</span>
<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">U_bc</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</code></pre></div>
<p>This produces a smooth surface that interpolates the handle constraints, but all
original details on the surface will be <em>smoothed away</em>. Most obviously, if the
original surface is not already biharmonic, then giving all handles the
identity deformation (keeping them at their rest positions) will <strong>not</strong>
reproduce the original surface. Rather, the result will be the biharmonic
surface that does interpolate those handle positions.</p>
<p>Thus, we may conclude that this is not an intuitive technique for shape
deformation.</p>
<h4 id="biharmonic-deformation-fields">Biharmonic Deformation Fields<a class="headerlink" href="#biharmonic-deformation-fields" title="Permanent link">&para;</a></h4>
<p>Now we know that one useful property for a deformation technique is &ldquo;rest pose
reproduction&rdquo;: applying no deformation to the handles should apply no
deformation to the shape.</p>
<p>To guarantee this by construction we can work with <em>deformation fields</em> (ie.
displacements)
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span> rather
than directly with positions <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>. Then the deformed positions can be
recovered as</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}' = \mathbf{x}+\mathbf{d}.</span><script type="math/tex">\mathbf{x}' = \mathbf{x}+\mathbf{d}.</script></span></p>
<p>A smooth deformation field <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span> which interpolates the deformation
fields of the handle constraints will impose a smooth deformed shape
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}'</span><script type="math/tex">\mathbf{x}'</script></span>. Naturally, we consider <em>biharmonic deformation fields</em>:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\Delta^2 \mathbf{d} = 0</span><script type="math/tex">\Delta^2 \mathbf{d} = 0</script></span></p>
<p>subject to the same handle constraints, but rewritten in terms of their implied
deformation field at the boundary (handles):</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}_b = \mathbf{x}_{bc} - \mathbf{x}_b.</span><script type="math/tex">\mathbf{d}_b = \mathbf{x}_{bc} - \mathbf{x}_b.</script></span></p>
<p>Again we can use <code>igl::harmonic</code> with <span class="arithmatex"><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span>, but this time solve for the
deformation field and then recover the deformed positions:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// U_bc contains deformation of boundary vertices b</span>
<span class="n">D_bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">U_bc</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">igl</span><span class="o">::</span><span class="n">slice</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">D_bc</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
<span class="n">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">V</span><span class="o">+</span><span class="n">D</span><span class="p">;</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/max-biharmonic.jpg" />
  </p>
<figcaption>
    The <a href="https://github.com/libigl/libigl/tree/main/tutorial/401_BiharmonicDeformation/main.cpp">BiharmonicDeformation</a> example deforms a statue&rsquo;s head as a <em>biharmonic surface</em> (top) and using a <em>biharmonic displacements</em> (bottom).
  </figcaption>
</figure>
<h5 id="relationship-to-differential-coordinates-and-laplacian-surface-editing">Relationship To &ldquo;differential Coordinates&rdquo; And Laplacian Surface Editing<a class="headerlink" href="#relationship-to-differential-coordinates-and-laplacian-surface-editing" title="Permanent link">&para;</a></h5>
<p>Biharmonic functions (whether positions or displacements) are solutions to the
bi-Laplace equation, but also minimizers of the &ldquo;Laplacian energy&rdquo;. For
example, for displacements <span class="arithmatex"><span class="MathJax_Preview">\mathbf{d}</span><script type="math/tex">\mathbf{d}</script></span>, the energy reads</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\int\limits_S \|\Delta \mathbf{d}\|^2 dA,</span><script type="math/tex">\int\limits_S \|\Delta \mathbf{d}\|^2 dA,</script></span></p>
<p>where we define <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{d}</span><script type="math/tex">\Delta \mathbf{d}</script></span> to simply apply the Laplacian
coordinate-wise.</p>
<p>By linearity of the Laplace(-Beltrami) operator we can reexpress this energy in
terms of the original positions <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and the unknown positions
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}' = \mathbf{x} - \mathbf{d}</span><script type="math/tex">\mathbf{x}' = \mathbf{x} - \mathbf{d}</script></span>:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\int\limits_S \|\Delta (\mathbf{x}' - \mathbf{x})\|^2 dA = \int\limits_S
 \|\Delta \mathbf{x}' - \Delta \mathbf{x})\|^2 dA.</span><script type="math/tex">\int\limits_S \|\Delta (\mathbf{x}' - \mathbf{x})\|^2 dA = \int\limits_S
 \|\Delta \mathbf{x}' - \Delta \mathbf{x})\|^2 dA.</script></span></p>
<p>In the early work of Sorkine et al., the quantities <span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{x}'</span><script type="math/tex">\Delta \mathbf{x}'</script></span> and
<span class="arithmatex"><span class="MathJax_Preview">\Delta \mathbf{x}</span><script type="math/tex">\Delta \mathbf{x}</script></span> were dubbed &ldquo;differential coordinates&rdquo; <sup id="fnref:sorkine_2004"><a class="footnote-ref" href="#fn:sorkine_2004">21</a></sup>.
Their deformations (without linearized rotations) is thus equivalent to
biharmonic deformation fields.</p>
<h3 id="polyharmonic-deformation">Polyharmonic Deformation<a class="headerlink" href="#polyharmonic-deformation" title="Permanent link">&para;</a></h3>
<p>We can generalize biharmonic deformation by considering different powers of
the Laplacian, resulting in a series of PDEs of the form:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\Delta^k \mathbf{d} = 0.</span><script type="math/tex">\Delta^k \mathbf{d} = 0.</script></span></p>
<p>with <span class="arithmatex"><span class="MathJax_Preview">k\in{1,2,3,\dots}</span><script type="math/tex">k\in{1,2,3,\dots}</script></span>. The choice of <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> determines the level of continuity
at the handles. In particular, <span class="arithmatex"><span class="MathJax_Preview">k=1</span><script type="math/tex">k=1</script></span> implies <span class="arithmatex"><span class="MathJax_Preview">C^0</span><script type="math/tex">C^0</script></span> at the boundary, <span class="arithmatex"><span class="MathJax_Preview">k=2</span><script type="math/tex">k=2</script></span>
implies <span class="arithmatex"><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span>, <span class="arithmatex"><span class="MathJax_Preview">k=3</span><script type="math/tex">k=3</script></span> implies <span class="arithmatex"><span class="MathJax_Preview">C^2</span><script type="math/tex">C^2</script></span> and in general <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span> implies <span class="arithmatex"><span class="MathJax_Preview">C^{k-1}</span><script type="math/tex">C^{k-1}</script></span>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="c1">// or 1,3,4,...</span>
<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">Z</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/bump-k-harmonic.jpg" />
  </p>
<figcaption>
    The <a href="https://github.com/libigl/libigl/tree/main/tutorial/402_PolyharmonicDeformation/main.cpp">PolyharmonicDeformation</a> example deforms a flat domain (left) into a bump as a solution to various <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>-harmonic PDEs.
  </figcaption>
</figure>
<h3 id="bounded-biharmonic-weights">Bounded Biharmonic Weights<a class="headerlink" href="#bounded-biharmonic-weights" title="Permanent link">&para;</a></h3>
<p>In computer animation, shape deformation is often referred to as &ldquo;skinning&rdquo;.
Constraints are posed as relative rotations of internal rigid &ldquo;bones&rdquo; inside a
character. The deformation method, or skinning method, determines how the
surface of the character (i.e. its skin) should move as a function of the bone
rotations.</p>
<p>The most popular technique is linear blend skinning. Each point on the shape
computes its new location as a linear combination of bone transformations:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}' = \sum\limits_{i = 1}^m w_i(\mathbf{x}) \mathbf{T}_i
 \left(\begin{array}{c}\mathbf{x}_i\\1\end{array}\right),</span><script type="math/tex">\mathbf{x}' = \sum\limits_{i = 1}^m w_i(\mathbf{x}) \mathbf{T}_i
 \left(\begin{array}{c}\mathbf{x}_i\\1\end{array}\right),</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">w_i(\mathbf{x})</span><script type="math/tex">w_i(\mathbf{x})</script></span> is the scalar <em>weight function</em> of the ith bone evaluated at
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}_i</span><script type="math/tex">\mathbf{T}_i</script></span> is the bone transformation as a <span class="arithmatex"><span class="MathJax_Preview">4 \times 3</span><script type="math/tex">4 \times 3</script></span>
matrix.</p>
<p>This formula is embarassingly parallel (computation at one point does not
depend on shared data need by computation at another point). It is often
implemented as a vertex shader. The weights and rest positions for each vertex
are sent as vertex shader <em>attributes</em> and bone transformations are sent as
<em>uniforms</em>. Then vertices are transformed within the vertex shader, just in
time for rendering.</p>
<p>As the skinning formula is linear (hence its name), we can write it as matrix
multiplication:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}' = \mathbf{M} \mathbf{T},</span><script type="math/tex">\mathbf{X}' = \mathbf{M} \mathbf{T},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> is <span class="arithmatex"><span class="MathJax_Preview">n \times 3</span><script type="math/tex">n \times 3</script></span> stack of deformed positions as row
vectors, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}</span><script type="math/tex">\mathbf{M}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">n \times m\cdot dim</span><script type="math/tex">n \times m\cdot dim</script></span> matrix containing weights and
rest positions and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{T}</span><script type="math/tex">\mathbf{T}</script></span> is a <span class="arithmatex"><span class="MathJax_Preview">m\cdot (dim+1) \times dim</span><script type="math/tex">m\cdot (dim+1) \times dim</script></span> stack of
transposed bone transformations.</p>
<p>Traditionally, the weight functions <span class="arithmatex"><span class="MathJax_Preview">w_j</span><script type="math/tex">w_j</script></span> are painted manually by skilled
rigging professionals. Modern techniques now exist to compute weight functions
automatically given the shape and a description of the skeleton (or in general
any handle structure such as a cage, collection of points, selected regions,
etc.).</p>
<p>Bounded biharmonic weights are one such technique that casts weight computation
as a constrained optimization problem <sup id="fnref:jacobson_2011"><a class="footnote-ref" href="#fn:jacobson_2011">13</a></sup>. The weights enforce
smoothness by minimizing the familiar Laplacian energy:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\sum\limits_{i = 1}^m \int_S (\Delta w_i)^2 dA</span><script type="math/tex">\sum\limits_{i = 1}^m \int_S (\Delta w_i)^2 dA</script></span></p>
<p>subject to constraints which enforce interpolation of handle constraints:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">w_i(\mathbf{x}) = \begin{cases} 1 &amp; \text{ if } \mathbf{x} \in H_i\\ 0 &amp;
 \text{ otherwise } \end{cases},</span><script type="math/tex">w_i(\mathbf{x}) = \begin{cases} 1 & \text{ if } \mathbf{x} \in H_i\\ 0 &
 \text{ otherwise } \end{cases},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">H_i</span><script type="math/tex">H_i</script></span> is the ith handle, and constraints which enforce non-negativity,
parition of unity and encourage sparsity:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">0\le w_i \le 1</span><script type="math/tex">0\le w_i \le 1</script></span> and <span class="arithmatex"><span class="MathJax_Preview">\sum\limits_{i=1}^m w_i = 1.</span><script type="math/tex">\sum\limits_{i=1}^m w_i = 1.</script></span></p>
<p>This is a quadratic programming problem and libigl solves it using its active
set solver or by calling out to <a href="http://www.mosek.com">Mosek</a>.</p>
<figure>
<p><img alt="" src="../images/hand-bbw.jpg" />
  </p>
<figcaption>
    The example <a href="https://github.com/libigl/libigl/tree/main/tutorial/403_BoundedBiharmonicWeights/main.cpp">BoundedBiharmonicWeights</a> computes weights for a tetrahedral mesh given a skeleton (top) and then animates a linear blend skinning deformation (bottom).
  </figcaption>
</figure>
<h3 id="dual-quaternion-skinning">Dual Quaternion Skinning<a class="headerlink" href="#dual-quaternion-skinning" title="Permanent link">&para;</a></h3>
<p>Even with high quality weights, linear blend skinning is limited. In
particular, it suffers from known artifacts stemming from blending rotations
as matrices: a weight combination of rotation matrices is not necessarily a
rotation. Consider an equal blend between rotating by <span class="arithmatex"><span class="MathJax_Preview">-\pi/2</span><script type="math/tex">-\pi/2</script></span> and by <span class="arithmatex"><span class="MathJax_Preview">\pi/2</span><script type="math/tex">\pi/2</script></span>
about the <span class="arithmatex"><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>-axis. Intuitively one might expect to get the identity matrix,
but instead the blend is a degenerate matrix scaling the <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span class="arithmatex"><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>
coordinates by zero:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">0.5\left(\begin{array}{ccc}0&amp;-1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{array}\right)+
 0.5\left(\begin{array}{ccc}0&amp;1&amp;0\\-1&amp;0&amp;0\\0&amp;0&amp;1\end{array}\right)=
 \left(\begin{array}{ccc}0&amp;0&amp;0\\0&amp;0&amp;0\\0&amp;0&amp;1\end{array}\right)</span><script type="math/tex">0.5\left(\begin{array}{ccc}0&-1&0\\1&0&0\\0&0&1\end{array}\right)+
 0.5\left(\begin{array}{ccc}0&1&0\\-1&0&0\\0&0&1\end{array}\right)=
 \left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&1\end{array}\right)</script></span></p>
<p>In practice, this means the shape shrinks and collapses in regions where bone
weights overlap: near joints.</p>
<p>Dual quaternion skinning presents a solution <sup id="fnref:kavan_2008"><a class="footnote-ref" href="#fn:kavan_2008">17</a></sup>. This method
represents rigid transformations as a pair of unit quaternions,
<span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{q}}</span><script type="math/tex">\hat{\mathbf{q}}</script></span>. The linear blend skinning formula is replaced with a
linear blend of dual quaternions:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}' =
 \cfrac{\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}}
 {\left\|\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}\right\|}
 \mathbf{x},</span><script type="math/tex">\mathbf{x}' =
 \cfrac{\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}}
 {\left\|\sum\limits_{i=1}^m w_i(\mathbf{x})\hat{\mathbf{q}_i}\right\|}
 \mathbf{x},</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{q}_i}</span><script type="math/tex">\hat{\mathbf{q}_i}</script></span> is the dual quaternion representation of the rigid
transformation of bone <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>. The normalization forces the result of the linear
blending to again be a unit dual quaternion and thus also a rigid
transformation.</p>
<p>Like linear blend skinning, dual quaternion skinning is best performed in the
vertex shader. The only difference being that bone transformations are sent as
dual quaternions rather than affine transformation matrices.  Libigl supports
CPU-side dual quaternion skinning with the <code>igl::dqs</code> function, which takes a
more traditional representation of rigid transformations as input and
internally converts to the dual quaternion representation before blending:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// vQ is a list of rotations as quaternions</span>
<span class="c1">// vT is a list of translations</span>
<span class="n">igl</span><span class="o">::</span><span class="n">dqs</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">vQ</span><span class="p">,</span><span class="n">vT</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/arm-dqs.jpg" />
  </p>
<figcaption>
    The example <a href="https://github.com/libigl/libigl/tree/main/tutorial/404_DualQuaternionSkinning/main.cpp">DualQuaternionSkinning</a> compares linear blend skinning (top) to dual quaternion skinning (bottom), highlighting LBS&rsquo;s candy wrapper effect (middle) and joint collapse (right).
  </figcaption>
</figure>
<h3 id="as-rigid-as-possible">As-rigid-as-possible<a class="headerlink" href="#as-rigid-as-possible" title="Permanent link">&para;</a></h3>
<p>Skinning and other linear methods for deformation are inherently limited.
Difficult arises especially when large rotations are imposed by the handle
constraints.</p>
<p>In the context of energy-minimization approaches, the problem stems from
comparing positions (our displacements) in the coordinate frame of the
undeformed shape. These quadratic energies are at best invariant to global
rotations of the entire shape, but not smoothly varying local rotations. Thus
linear techniques will not produce non-trivial bending and twisting.</p>
<p>Furthermore, when considering solid shapes (e.g. discretized with tetrahedral
meshes) linear methods struggle to maintain local volume, and they often suffer from
shrinking and bulging artifacts.</p>
<p>Non-linear deformation techniques present a solution to these problems.
They work by comparing the deformation of a mesh
vertex to its rest position <em>rotated</em> to a new coordinate frame which best
matches the deformation. The non-linearity stems from the mutual dependence of
the deformation and the best-fit rotation. These techniques are often labeled
&ldquo;as-rigid-as-possible&rdquo; as they penalize the sum of all local deformations&rsquo;
deviations from rotations.</p>
<p>To arrive at such an energy, let&rsquo;s consider a simple per-triangle energy:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">E_\text{linear}(\mathbf{X}') = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right) -
 \left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2</span><script type="math/tex">E_\text{linear}(\mathbf{X}') = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right) -
 \left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> are the mesh&rsquo;s unknown deformed vertex positions, <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> is a
triangle in a list of triangles <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>, <span class="arithmatex"><span class="MathJax_Preview">a_t</span><script type="math/tex">a_t</script></span> is the area of triangle <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> and
<span class="arithmatex"><span class="MathJax_Preview">\{i,j\}</span><script type="math/tex">\{i,j\}</script></span> is an edge in triangle <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>. Thus, this energy measures the norm of
change between an edge vector in the original mesh <span class="arithmatex"><span class="MathJax_Preview">\left(\mathbf{x}_i -
\mathbf{x}_j\right)</span><script type="math/tex">\left(\mathbf{x}_i -
\mathbf{x}_j\right)</script></span> and the unknown mesh <span class="arithmatex"><span class="MathJax_Preview">\left(\mathbf{x}'_i -
\mathbf{x}'_j\right)</span><script type="math/tex">\left(\mathbf{x}'_i -
\mathbf{x}'_j\right)</script></span>.</p>
<p>This energy is <strong>not</strong> rotation invariant. If we rotate the mesh by 90 degrees
the change in edge vectors not aligned with the axis of rotation will be large,
despite the overall deformation being perfectly rigid.</p>
<p>So, the &ldquo;as-rigid-as-possible&rdquo; solution is to append auxiliary variables
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{R}_t</span><script type="math/tex">\mathbf{R}_t</script></span>
for each triangle <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> which are constrained to be rotations. Then the energy is
rewritten, this time comparing deformed edge vectors to their rotated rest
counterparts:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">E_\text{arap}(\mathbf{X}',\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}) = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right)-
 \mathbf{R}_t\left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2.</span><script type="math/tex">E_\text{arap}(\mathbf{X}',\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}) = \sum\limits_{t \in T} a_t \sum\limits_{\{i,j\}
 \in t} w_{ij} \left\|
 \left(\mathbf{x}'_i - \mathbf{x}'_j\right)-
 \mathbf{R}_t\left(\mathbf{x}_i - \mathbf{x}_j\right)\right\|^2.</script></span></p>
<p>The separation into the primary vertex position variables <span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> and the
rotations <span class="arithmatex"><span class="MathJax_Preview">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</span><script type="math/tex">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</script></span> lead to strategy for
optimization, too. If the rotations <span class="arithmatex"><span class="MathJax_Preview">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</span><script type="math/tex">\{\mathbf{R}_1,\dots,\mathbf{R}_{|T|}\}</script></span>
are held fixed then the energy is quadratic in the remaining variables
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> and can be optimized by solving a (sparse) global linear system.
Alternatively, if <span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> are held fixed then each rotation is the
solution to a localized <em>Procrustes</em> problem (found via <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> SVD or
polar decompostion). These two steps&mdash;local and global&mdash;each weakly decrease
the energy, thus we may safely iterate them until convergence.</p>
<p>The different flavors of &ldquo;as-rigid-as-possible&rdquo; depend on the dimension and
codimension of the domain and the edge-sets <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span>. The proposed surface
manipulation technique by Sorkine and Alexa <sup id="fnref:sorkine_2007"><a class="footnote-ref" href="#fn:sorkine_2007">22</a></sup>, considers <span class="arithmatex"><span class="MathJax_Preview">T</span><script type="math/tex">T</script></span> to
be the set of sets of edges emanating from each vertex (spokes). Later, Chao et
al.  derived the relationship between &ldquo;as-rigid-as-possible&rdquo; mesh energies and
co-rotational elasticity considering 0-codimension elements as edge-sets:
triangles in 2D and tetrahedra in 3D <sup id="fnref:chao_2010"><a class="footnote-ref" href="#fn:chao_2010">12</a></sup>. They also showed how
Sorkine and Alexa&rsquo;s edge-sets are not a discretization of a continuous energy,
proposing instead edge-sets for surfaces containing all edges of elements
incident on a vertex (spokes and rims). They show that this amounts to
measuring bending, albeit in a discretization-dependent way.</p>
<p>Libigl, supports these common flavors. Selecting one is a matter of setting the
energy type before the precompuation phase:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">ARAPData</span><span class="w"> </span><span class="n">arap_data</span><span class="p">;</span>
<span class="n">arap_data</span><span class="p">.</span><span class="n">energy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">igl</span><span class="o">::</span><span class="n">ARAP_ENERGY_TYPE_SPOKES</span><span class="p">;</span>
<span class="c1">//arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS;</span>
<span class="c1">//arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS; //triangles or tets</span>
<span class="n">igl</span><span class="o">::</span><span class="n">arap_precomputation</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">arap_data</span><span class="p">);</span>
</code></pre></div>
<p>Just like <code>igl::min_quad_with_fixed_*</code>, this precomputation phase only depends
on the mesh, fixed vertex indices <code>b</code> and the energy parameters. To solve with
certain constraints on the positions of vertices in <code>b</code>, we may call:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">arap_solve</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span><span class="n">arap_data</span><span class="p">,</span><span class="n">U</span><span class="p">);</span>
</code></pre></div>
<p>which uses <code>U</code> as an initial guess and then computes the solution into it.</p>
<p>Libigl&rsquo;s implementation of as-rigid-as-possible deformation takes advantage of
the highly optimized singular value decomposition code from McAdams et al.
<sup id="fnref:mcadams_2011"><a class="footnote-ref" href="#fn:mcadams_2011">20</a></sup> which leverages SSE intrinsics.</p>
<figure>
<p><img alt="" src="../images/decimated-knight-arap.jpg" />
  </p>
<figcaption>
    The example <a href="https://github.com/libigl/libigl/tree/main/tutorial/405_AsRigidAsPossible/main.cpp">AsRigidAsPossible</a> deforms a surface as if it were made of an elastic material
  </figcaption>
</figure>
<p>The concept of local rigidity will be revisited shortly in the context of
surface parameterization.</p>
<h3 id="fast-automatic-skinning-transformations">Fast Automatic Skinning Transformations<a class="headerlink" href="#fast-automatic-skinning-transformations" title="Permanent link">&para;</a></h3>
<p>Non-linear optimization is, unsurprisingly, slower than its linear cousins. In
the case of the as-rigid-as-possible optimization, the bottleneck is typically
the large number of polar decompositions necessary to recover best fit
rotations for each edge-set (i.e. for each triangle, tetrahedron, or vertex
cell). Even if this code is optimized, the number of primary degrees of freedom
is tied to the discretization level, despite the deformations&rsquo; low frequency
behavior.</p>
<p>This invites two routes toward fast non-linear optimization. First, is it
necessary (or even advantageous) to find so many best-fit rotations? Second,
can we reduce the degrees of freedom to better reflect the frequency of the
desired deformations.</p>
<p>Taken in turn, these optimizations culminate in a method which optimizes over
the space of linear blend skinning deformations spanned by high-quality weights
(i.e. manually painted ones or bounded biharmonic weights). This space is a
low-dimensional subspace of all possible mesh deformations, captured by writing
linear blend skinning in matrix form:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}' = \mathbf{M}\mathbf{T}</span><script type="math/tex">\mathbf{X}' = \mathbf{M}\mathbf{T}</script></span></p>
<p>where the mesh vertex positions in the <span class="arithmatex"><span class="MathJax_Preview">n \times 3</span><script type="math/tex">n \times 3</script></span> matrix <span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> are
replaced by a linear combination of a small number of degrees of freedom in the
<span class="arithmatex"><span class="MathJax_Preview">(3+1)m \times 3</span><script type="math/tex">(3+1)m \times 3</script></span> stack of transposed &ldquo;handle&rdquo; transformations. Swapping in
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}\mathbf{T}</span><script type="math/tex">\mathbf{M}\mathbf{T}</script></span> for <span class="arithmatex"><span class="MathJax_Preview">\mathbf{X}'</span><script type="math/tex">\mathbf{X}'</script></span> in the ARAP energies above immediately
sees performance gains during the global solve step as <span class="arithmatex"><span class="MathJax_Preview">m &lt;&lt; n</span><script type="math/tex">m << n</script></span>.</p>
<p>The complexity of the local step&mdash;fitting rotations&mdash;is still bound
to the original mesh discretization. However, if the skinning is well behaved,
we can make the assumption that places on the shape with similar skinning
weights will deform similarly and thus imply similar best-fit rotations.
Therefore, we cluster edge-sets according to their representation in
<em>weight-space</em>: where a vertex <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> takes the coordinates
<span class="arithmatex"><span class="MathJax_Preview">[w_1(\mathbf{x}),w_2(\mathbf{x}),\dots,w_m(\mathbf{x})]</span><script type="math/tex">[w_1(\mathbf{x}),w_2(\mathbf{x}),\dots,w_m(\mathbf{x})]</script></span>. The number of
clustered edge-sets show diminishing returns on the deformation quality so we
may choose a small number of clusters, proportional to the number of skinning
weight functions (rather than the number of discrete mesh vertices).</p>
<p>This proposed deformation model <sup id="fnref:jacobson_2012"><a class="footnote-ref" href="#fn:jacobson_2012">14</a></sup>, can simultaneously be seen as a
fast, subspace optimization for ARAP and as an automatic method for finding
<em>the best</em> skinning transformation degrees of freedom.</p>
<p>A variety of user interfaces are supported via linear equality constraints on
the skinning transformations associated with handles. To fix a transformation
entirely we simply add the constraint:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\left(\begin{array}{cccc}
 1 &amp; 0 &amp; 0 &amp; 0\\
 0 &amp; 1 &amp; 0 &amp; 0\\
 0 &amp; 0 &amp; 1 &amp; 0\\
 0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{T}}_i^T,</span><script type="math/tex">\left(\begin{array}{cccc}
 1 & 0 & 0 & 0\\
 0 & 1 & 0 & 0\\
 0 & 0 & 1 & 0\\
 0 & 0 & 0 & 1\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{T}}_i^T,</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{T}}_i^T</span><script type="math/tex">\hat{\mathbf{T}}_i^T</script></span> is the <span class="arithmatex"><span class="MathJax_Preview">(3+1) \times 3</span><script type="math/tex">(3+1) \times 3</script></span> transposed fixed
transformation for handle <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<p>To fix only the origin of a handle, we add a constraint requiring the
transformation to interpolate a point in space (typically the centroid of all
points with <span class="arithmatex"><span class="MathJax_Preview">w_i = 1</span><script type="math/tex">w_i = 1</script></span>:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}'^T\mathbf{T}_i^T = \mathbf{c}^T,</span><script type="math/tex">\mathbf{c}'^T\mathbf{T}_i^T = \mathbf{c}^T,</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}^T</span><script type="math/tex">\mathbf{c}^T</script></span> is the <span class="arithmatex"><span class="MathJax_Preview">1 \times (3+1)</span><script type="math/tex">1 \times (3+1)</script></span> position of the point at rest in
transposed homogeneous coordinates, and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}'^T</span><script type="math/tex">\mathbf{c}'^T</script></span> the point given by the
user.</p>
<p>We can similarly fix just the linear part of the transformation at a handle,
freeing the translation component (producing a &ldquo;chickenhead&rdquo; effect):</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\left(\begin{array}{cccc}
 1&amp;0&amp;0&amp;0\\
 0&amp;1&amp;0&amp;0\\
 0&amp;0&amp;1&amp;0\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{L}}_i^T,</span><script type="math/tex">\left(\begin{array}{cccc}
 1&0&0&0\\
 0&1&0&0\\
 0&0&1&0\end{array}\right)
 \mathbf{T}_i^T = \hat{\mathbf{L}}_i^T,</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\hat{\mathbf{L}}_i^T</span><script type="math/tex">\hat{\mathbf{L}}_i^T</script></span> is the fixed <span class="arithmatex"><span class="MathJax_Preview">3 \times 3</span><script type="math/tex">3 \times 3</script></span> linear part of the
transformation at handle <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>.</p>
<p>And lastly we can allow the user to entirely <em>free</em> the transformation&rsquo;s
degrees of freedom, delegating the optimization to find the best possible
values for all elements. To do this, we simply abstain from adding a
corresponding constraint.</p>
<h4 id="arap-with-grouped-edge-sets">Arap With Grouped Edge-sets<a class="headerlink" href="#arap-with-grouped-edge-sets" title="Permanent link">&para;</a></h4>
<p>Being a subspace method, an immediate disadvantage is the reduced degrees of
freedom. This brings performance, but in some situations limits behavior too
much. In such cases one can use the skinning subspace to build an effective
clustering of rotation edge-sets for a traditional ARAP optimization: forgoing
the subspace substitution. This has a two-fold effect. The cost of the
rotation fitting, local step drastically reduces, and the deformations are
&ldquo;regularized&rdquo; according the clusters. From a high level point of view, if the
clusters are derived from skinning weights, then they will discourage bending,
especially along isolines of the weight functions. If handles are not known in
advance, one could also cluster according to a &ldquo;geodesic embedding&rdquo; like the
biharmonic distance embedding.</p>
<p>In this light, we can think of the &ldquo;spokes+rims&rdquo; style surface ARAP as a (slight and
redundant) clustering of the per-triangle edge-sets.</p>
<figure>
<p><img alt="" src="../images/armadillo-fast.jpg" />
  </p>
<figcaption>
    The example <a href="https://github.com/libigl/libigl/tree/main/tutorial/406_FastAutomaticSkinningTransformations/main.cpp">FastAutomaticSkinningTransformations</a> compares a full (slow) ARAP deformation on a detailed shape (left of middle), to ARAP with grouped rotation edge sets (right of middle), to the very fast subpsace method (right).
  </figcaption>
</figure>
<h3 id="biharmonic-coordinates">Biharmonic Coordinates<a class="headerlink" href="#biharmonic-coordinates" title="Permanent link">&para;</a></h3>
<p>Linear blend skinning (as <a href="#bounded-biharmonic-weights">above</a>) deforms a mesh by
propagating <em>full affine transformations</em> at handles (bones, points, regions,
etc.) to the rest of the shape via weights. Another deformation framework,
called &ldquo;generalized barycentric coordinates&rdquo;, is a special case of linear blend
skinning <sup id="fnref:jacobson_skinning_course_2014"><a class="footnote-ref" href="#fn:jacobson_skinning_course_2014">16</a></sup>: transformations are restricted to
<em>pure translations</em> and weights are required to retain <em>affine precision</em>. This
latter requirement means that we can write the rest-position of any vertex in
the mesh as the weighted combination of the control handle locations:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i,</span><script type="math/tex">\mathbf{x} = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i,</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}_i</span><script type="math/tex">\mathbf{c}_i</script></span> is the rest position of the <span class="arithmatex"><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>th control point. This
simplifies the deformation formula at run-time. We can simply take the new
position of each point of the shape to be the weighted combination of the
<em>translated</em> control point positions:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}' = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i'.</span><script type="math/tex">\mathbf{x}' = \sum\limits_{i=1}^m w_i(\mathbf{x}) * \mathbf{c}_i'.</script></span></p>
<p>There are <em>many</em> different flavors of &ldquo;generalized barycentric coordinates&rdquo;
(see table in &ldquo;Automatic Methods&rdquo; section,
<sup id="fnref2:jacobson_skinning_course_2014"><a class="footnote-ref" href="#fn:jacobson_skinning_course_2014">16</a></sup>). The vague goal of &ldquo;generalized barycentric
coordinates&rdquo; is to capture as many properties of simplicial barycentric
coordinates (e.g. for triangles in 2D and tetrahedral in 3D) for larger sets of
points or polyhedra. Some generalized barycentric coordinates can be computed
in closed form; others require optimization-based precomputation. Nearly all
flavors require connectivity information describing how the control points form
a external polyhedron around the input shape: a cage. However, a recent
techinique does not require a cage <sup id="fnref:wang_bc_2015"><a class="footnote-ref" href="#fn:wang_bc_2015">23</a></sup>. This method ensures
affine precision during optimization over weights of a smoothness energy with
affine functions in its kernel:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathop{\text{min}}_\mathbf{W}\,\, \text{trace}(\frac{1}{2}\mathbf{W}^T \mathbf{A}
 \mathbf{W}), \text{subject to: } \mathbf{C} = \mathbf{W}\mathbf{C}</span><script type="math/tex">\mathop{\text{min}}_\mathbf{W}\,\, \text{trace}(\frac{1}{2}\mathbf{W}^T \mathbf{A}
 \mathbf{W}), \text{subject to: } \mathbf{C} = \mathbf{W}\mathbf{C}</script></span></p>
<p>subject to interpolation constraints at selected vertices. If <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> has
affine functions in its kernel&mdash;that is, if <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}\mathbf{V} = 0</span><script type="math/tex">\mathbf{A}\mathbf{V} = 0</script></span>&mdash;then
the weights <span class="arithmatex"><span class="MathJax_Preview">\mathbf{W}</span><script type="math/tex">\mathbf{W}</script></span> will retain affine precision and we&rsquo;ll have that:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{V} = \mathbf{W}\mathbf{C}</span><script type="math/tex">\mathbf{V} = \mathbf{W}\mathbf{C}</script></span></p>
<p>the matrix form of the equality above. The proposed way to define <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span>
is to construct a matrix <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> that measures the Laplacian at all
interior vertices <em>and at all boundary vertices</em>. The <em>usual</em> definition of the
discrete Laplacian (e.g. what libigl returns from <code>igl::cotmatrix</code>), measures
the Laplacian of a function for interior vertices, but measures the Laplacian
of a function <em>minus</em> the normal derivative of a function for boundary
vertices. Thus, we can let:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{K} = \mathbf{L} + \mathbf{N}</span><script type="math/tex">\mathbf{K} = \mathbf{L} + \mathbf{N}</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}</span><script type="math/tex">\mathbf{L}</script></span> is the <em>usual</em> Laplacian and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{N}</span><script type="math/tex">\mathbf{N}</script></span> is matrix that
computes normal derivatives of a piecewise-linear function at boundary vertices
of a mesh. Then <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> is taken as quadratic form computing the square of
the integral-average of <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> applied to a function and integrated over
the mesh:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{A} = (\mathbf{M}^{-1}\mathbf{K})^2_\mathbf{M} = \mathbf{K}^T \mathbf{M}^{-1}
 \mathbf{K}.</span><script type="math/tex">\mathbf{A} = (\mathbf{M}^{-1}\mathbf{K})^2_\mathbf{M} = \mathbf{K}^T \mathbf{M}^{-1}
 \mathbf{K}.</script></span></p>
<p>Since the Laplacian <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> is a second-order derivative it measures zero on affine
functions, thus <span class="arithmatex"><span class="MathJax_Preview">\mathbf{A}</span><script type="math/tex">\mathbf{A}</script></span> has affine functions in its null space. A short
derivation proves that this implies <span class="arithmatex"><span class="MathJax_Preview">\mathbf{W}</span><script type="math/tex">\mathbf{W}</script></span> will be affine precise (see
<sup id="fnref2:wang_bc_2015"><a class="footnote-ref" href="#fn:wang_bc_2015">23</a></sup>).</p>
<p>Minimizers of this &ldquo;squared Laplacian&rdquo; energy are in some sense <em>discrete
biharmonic functions</em>. Thus they&rsquo;re dubbed &ldquo;biharmonic coordinates&rdquo; (not the
same as <em>bounded biharmonic weights</em>, which are <em>not</em> generalized barycentric
coordinates).</p>
<p>In libigl, one can compute biharmonic coordinates given a mesh <code>(V,F)</code> and a
list <code>S</code> of selected control points or control regions (which act like skinning
handles):</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">biharmonic_coordinates</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">W</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/octopus-biharmonic-coordinates-physics.gif" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/407_BiharmonicCoordinates/main.cpp">Example 407</a>) shows a physics simulation on a coarse orange mesh. The vertices of this mesh become control points for a biharmonic coordinates deformation of the blue high-resolution mesh.
  </figcaption>
</figure>
<h3 id="direct-delta-mush">Direct Delta Mush<a class="headerlink" href="#direct-delta-mush" title="Permanent link">&para;</a></h3>
<p>To produce a smooth deformation, linear blend skinning requires smooth skinning
weights. These could be painted manually or computed automatically (e.g., using
<a href="#bounded-biharmonic-weights">Bounded Biharmonic Weights</a> <sup id="fnref2:jacobson_2011"><a class="footnote-ref" href="#fn:jacobson_2011">13</a></sup>).
Even still, linear blend skinning suffers from shrinkage and collapse artifacts
due to its inherent linearity (see <a href="#dual-quaternion-skinning">earlier</a>). &ldquo;Direct
Delta Mush&rdquo; <sup id="fnref:le_2019"><a class="footnote-ref" href="#fn:le_2019">18</a></sup> skinning attempts to solve both of these issues by providing a
direct skinning method that takes as input a rig with piecewise-constant weight
functions (weights are either <span class="arithmatex"><span class="MathJax_Preview">=0</span><script type="math/tex">=0</script></span> or <span class="arithmatex"><span class="MathJax_Preview">=1</span><script type="math/tex">=1</script></span> everywhere). <em>Direct</em> delta mush is
an adaptation of a less performant method called simply &ldquo;Delta Mush&rdquo;
<sup id="fnref:mancewicz_2014"><a class="footnote-ref" href="#fn:mancewicz_2014">19</a></sup>. The computation of Delta Mush separates into &ldquo;bind pose&rdquo;
precomputation and runtime evaluation. </p>
<p>At bind time, Laplacian smoothing is conducted on the bind pose, moving each
vertex from its rest position <span class="arithmatex"><span class="MathJax_Preview">\mathbf{v}_i</span><script type="math/tex">\mathbf{v}_i</script></span> to a new position
<span class="arithmatex"><span class="MathJax_Preview">\tilde{\mathbf{v}}_i</span><script type="math/tex">\tilde{\mathbf{v}}_i</script></span>. The &ldquo;delta&rdquo; describing undoing this smoothing procedure,
is computed and stored in a local coordinate frame associated with the vertex:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\delta_i = \mathbf{T}_i^{-1} (\mathbf{v}_i - \tilde{\mathbf{v}}_i).</span><script type="math/tex">\delta_i = \mathbf{T}_i^{-1} (\mathbf{v}_i - \tilde{\mathbf{v}}_i).</script></span></p>
<p>At run time, the mesh is deformed using linear blend skinning and
piecewise-constant weights. Near bones, the deformation is perfectly rigid,
while near joints where bones meet, the mesh <em>tears apart</em> with a sudden change
to the next rigid transformation. The same amount of Laplacian smoothing is
applied at run time to this posed mesh. Moving each vertex to a location
<span class="arithmatex"><span class="MathJax_Preview">\tilde{\mathbf{u}}_i</span><script type="math/tex">\tilde{\mathbf{u}}_i</script></span>. A local frame <span class="arithmatex"><span class="MathJax_Preview">\mathbf{S}_i</span><script type="math/tex">\mathbf{S}_i</script></span> is computed at this
location and the cached <em>deltas</em> are adding in this resolved frame to restore
the shape&rsquo;s original details:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_i = \tilde{\mathbf{u}}_i + \mathbf{S}_i \delta_i.</span><script type="math/tex">\mathbf{u}_i = \tilde{\mathbf{u}}_i + \mathbf{S}_i \delta_i.</script></span></p>
<p>The key insight of &ldquo;Delta Mush&rdquo; is that Laplacian smoothing acts similarly on
the rest and posed models.</p>
<p>The key insight of &ldquo;Direct Delta Mush&rdquo; is that this process of Laplacian
smoothing at runtime is <em>nearly linear</em> and local frames can be computed in a
embarrassingly parallel fashion using SVD (cf. <a href="#as-rigid-as-possible">ARAP</a>).</p>
<p>Direct delta mush moves the smoothing step into precomputation, resulting in
&ldquo;vector-valued&rdquo; skinning weights per-vertex per-bone, stored in a matrix
<span class="arithmatex"><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span>. In libigl, for a mesh <code>(V,F)</code> and (e.g., piecewise-constant) weights
<code>W</code> this precomputation is computed using:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">direct_delta_mush_precomputation</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="n">Wsparse</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">lambda</span><span class="p">,</span><span class="w"> </span><span class="n">kappa</span><span class="p">,</span><span class="w"> </span><span class="n">alpha</span><span class="p">,</span><span class="w"> </span><span class="n">Omega</span><span class="p">);</span>
</code></pre></div>
<p>the parameters <code>p, lambda, kappa, alpha</code> control the smoothness and compactness
of the resulting deformation. The precomputation&rsquo;s output is the matrix <code>Omega</code>.</p>
<p>At runtime, <span class="arithmatex"><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> is used to deform the mesh to its final locations. In
libigl, this is computed using:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">direct_delta_mush</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">T_list</span><span class="p">,</span><span class="w"> </span><span class="n">Omega</span><span class="p">,</span><span class="w"> </span><span class="n">U</span><span class="p">);</span>
</code></pre></div>
<p>where <code>T_list</code> is the input pose (affine) transformations associated with each
bone and the final locations are stored in <code>U</code>.</p>
<figure>
<p><img alt="" src="../images/elephant-ddm.gif" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/408_DirectDeltaMush/main.cpp">Example 408</a>) Direct Delta Mush. (left) input piecewise-rigid skinning, (middle) skeleton animation, (right) smooth Direct Delta Mush skinning
  </figcaption>
</figure>
<h3 id="mesh-deformation-with-kelvinlet">Mesh Deformation with Kelvinlet<a class="headerlink" href="#mesh-deformation-with-kelvinlet" title="Permanent link">&para;</a></h3>
<p>Kelvinlets<sup id="fnref:pixar_2017"><a class="footnote-ref" href="#fn:pixar_2017">24</a></sup> is a technique for real-time physically based volume sculpting of
virtual elastic materials. The technique treats meshes as fluids made of
compressible materials and deforms them by advecting points along a displacement
field. It relies on analytical solutions to the equations of elasticity.</p>
<h4 id="a-quick-primer-on-linear-elastostatics-25">A quick primer on linear elastostatics <sup id="fnref:slaughter_2002"><a class="footnote-ref" href="#fn:slaughter_2002">25</a></sup><a class="headerlink" href="#a-quick-primer-on-linear-elastostatics-25" title="Permanent link">&para;</a></h4>
<p>The equilibrium state of linear elasticity is determined by a displacement field
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{u} : R^3 \rightarrow  R^3</span><script type="math/tex">\mathbf{u} : R^3 \rightarrow  R^3</script></span> that minimizes the elastic potential energy </p>
<p><span class="arithmatex"><span class="MathJax_Preview">E(\mathbf{u}) = \frac{\mu}{2}\left\|\nabla\mathbf{u}\right\|^2  +
 \frac{\mu}{2(1-2\nu)}\left\|\nabla \cdot \mathbf{u}\right\|^2 - \langle\mathbf{b},
 \mathbf{u}\rangle</span><script type="math/tex">E(\mathbf{u}) = \frac{\mu}{2}\left\|\nabla\mathbf{u}\right\|^2  +
 \frac{\mu}{2(1-2\nu)}\left\|\nabla \cdot \mathbf{u}\right\|^2 - \langle\mathbf{b},
 \mathbf{u}\rangle</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mu</span><script type="math/tex">\mu</script></span> is the elastic shear modulus,  <span class="arithmatex"><span class="MathJax_Preview">\nu</span><script type="math/tex">\nu</script></span> is the Poisson ratio, and
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}</span><script type="math/tex">\mathbf{b}</script></span> represents the external body forces.</p>
<p>The first term controls the smoothness of the displacement field, the second
term penalizes infinitesimal volume change, and the last term indicates the
external body forces to be counteracted.</p>
<p>One can associate the optimal displacement field with the solution to the
critical point of the above equation, also known as the Navier-Cauchy equation:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mu\Delta\mathbf{u} + \frac{\mu}{(1 - 2\nu)}\nabla(\nabla \cdot \mathbf{u}) +
\mathbf{b} = 0</span><script type="math/tex">\mu\Delta\mathbf{u} + \frac{\mu}{(1 - 2\nu)}\nabla(\nabla \cdot \mathbf{u}) +
\mathbf{b} = 0</script></span></p>
<p>The Kelvinlet is the solution to the Navier-Cauchy equation in the case of a
concentrated body load due to a force vector <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span> at a point
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{0}</span><script type="math/tex">\mathbf{x}_{0}</script></span>, i.e., where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{b}(\mathbf{x}) = \mathbf{f}
\delta(\mathbf{x}  \mathbf{x}_{0})</span><script type="math/tex">\mathbf{b}(\mathbf{x}) = \mathbf{f}
\delta(\mathbf{x}  \mathbf{x}_{0})</script></span> and can be written as:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(\mathbf{r}) = \left[ \frac{(a - b)}{r}I +
\frac{\mathbf{b}}{\mathit{r}^3}\mathbf{r}\mathbf{r}^{t}\right] \mathbf{f} \equiv
\mathbf{K}(\mathbf{r})\mathbf{f}</span><script type="math/tex">\mathbf{u}(\mathbf{r}) = \left[ \frac{(a - b)}{r}I +
\frac{\mathbf{b}}{\mathit{r}^3}\mathbf{r}\mathbf{r}^{t}\right] \mathbf{f} \equiv
\mathbf{K}(\mathbf{r})\mathbf{f}</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{K}</span><script type="math/tex">\mathbf{K}</script></span> is the Kelvinlet function, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r} = \mathbf{x}  \mathbf{x}_{0}</span><script type="math/tex">\mathbf{r} = \mathbf{x}  \mathbf{x}_{0}</script></span> is the relative position vector
from the load location <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{0}</span><script type="math/tex">\mathbf{x}_{0}</script></span> to an observation point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>,
<span class="arithmatex"><span class="MathJax_Preview">\mathit{r}</span><script type="math/tex">\mathit{r}</script></span> is the norm of <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}</span><script type="math/tex">\mathbf{r}</script></span>, <span class="arithmatex"><span class="MathJax_Preview">a = \frac{1}{4\pi\mu}</span><script type="math/tex">a = \frac{1}{4\pi\mu}</script></span> and <span class="arithmatex"><span class="MathJax_Preview">b = \frac{a}{(1-\nu)}</span><script type="math/tex">b = \frac{a}{(1-\nu)}</script></span></p>
<p>The displacement field <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}(\mathbf{x}  \mathbf{x}_{0})</span><script type="math/tex">\mathbf{u}(\mathbf{x}  \mathbf{x}_{0})</script></span> deforms a point
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> in a linear elastic material to <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x} + \mathbf{u}(\mathbf{x}
 \mathbf{x}_{0})</span><script type="math/tex">\mathbf{x} + \mathbf{u}(\mathbf{x}
 \mathbf{x}_{0})</script></span>. The associated deformation gradient is then defined by a
<span class="arithmatex"><span class="MathJax_Preview">33</span><script type="math/tex">33</script></span> matrix of the form <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}(\mathbf{x}  \mathbf{x}_{0}) = \mathbf{I} +
\nabla\mathbf{u}(\mathbf{x}  \mathbf{x}_{0})</span><script type="math/tex">\mathbf{G}(\mathbf{x}  \mathbf{x}_{0}) = \mathbf{I} +
\nabla\mathbf{u}(\mathbf{x}  \mathbf{x}_{0})</script></span>.</p>
<p>This gradient <span class="arithmatex"><span class="MathJax_Preview">\mathbf{G}(\mathbf{r})</span><script type="math/tex">\mathbf{G}(\mathbf{r})</script></span> determines the different properties of
the displacement field <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u(\mathbf{r})}</span><script type="math/tex">\mathbf{u(\mathbf{r})}</script></span>. For instance, the skew-symmetric
part of <span class="arithmatex"><span class="MathJax_Preview">\nabla\mathbf{u}(\mathbf{r})</span><script type="math/tex">\nabla\mathbf{u}(\mathbf{r})</script></span> indicates the rotation induced by
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{u(\mathbf{r})}</span><script type="math/tex">\mathbf{u(\mathbf{r})}</script></span>, while its symmetric part corresponds to the elastic
strain and determines the stretching. The strain tensor can also be decomposed
into a trace term that represents the scaling of the volume of the
elastic medium, and a traceless term that represents the pinching
deformation.</p>
<p>This forms the fundamentals of the Kelvinlet brushes. </p>
<h4 id="regularized-kelvinlets">Regularized kelvinlets<a class="headerlink" href="#regularized-kelvinlets" title="Permanent link">&para;</a></h4>
<p>The concentrated body load at a single point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{0}</span><script type="math/tex">\mathbf{x}_{0}</script></span> introduces a
singularity to the Kelvinlet solution at <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}_{0}</span><script type="math/tex">\mathbf{x}_{0}</script></span>. For this reason, the
kelvinlet equation is modified to:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{u_{\epsilon}}(\mathbf{r}) = \left[ \frac{(a - b)}{r_{\epsilon}}I +
\frac{\mathbf{b}}{\mathit{r_{\epsilon}}^3}\mathbf{r_{\epsilon}}\mathbf{r_{\epsilon}}^{t}
+ \frac{a}{2}\frac{\epsilon^2}{r_{\epsilon}^3}I\right] \equiv
\mathbf{K_{\epsilon}}(\mathbf{r})\mathbf{f}</span><script type="math/tex">\mathbf{u_{\epsilon}}(\mathbf{r}) = \left[ \frac{(a - b)}{r_{\epsilon}}I +
\frac{\mathbf{b}}{\mathit{r_{\epsilon}}^3}\mathbf{r_{\epsilon}}\mathbf{r_{\epsilon}}^{t}
+ \frac{a}{2}\frac{\epsilon^2}{r_{\epsilon}^3}I\right] \equiv
\mathbf{K_{\epsilon}}(\mathbf{r})\mathbf{f}</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{r}_{\epsilon} = \sqrt{r^2 + \epsilon^2}</span><script type="math/tex">\mathbf{r}_{\epsilon} = \sqrt{r^2 + \epsilon^2}</script></span> is the regularized
distance, <span class="arithmatex"><span class="MathJax_Preview">\epsilon &gt; 0</span><script type="math/tex">\epsilon > 0</script></span> is the radius of the sculpting brush.</p>
<p>Thus, given a force vector <span class="arithmatex"><span class="MathJax_Preview">\mathbf{f}</span><script type="math/tex">\mathbf{f}</script></span>, the displacement for any point in <span class="arithmatex"><span class="MathJax_Preview">R^3</span><script type="math/tex">R^3</script></span>
can be calculated, thus defining the physically based space deformation. In
practice, the force vector is parameterized in terms of the brush tip
displacement <span class="arithmatex"><span class="MathJax_Preview">\mathbf{\bar{u}}</span><script type="math/tex">\mathbf{\bar{u}}</script></span>. To this end, we can expand the regularized kelvinlet
equation with the constraint <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\epsilon}(0) = \mathbf{\bar{u}}</span><script type="math/tex">\mathbf{u}_{\epsilon}(0) = \mathbf{\bar{u}}</script></span> 
to end up with <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u_{\epsilon}} = c\epsilon\mathbf{K_{\epsilon}}(\mathbf{r})\mathbf{\bar{u}}</span><script type="math/tex">\mathbf{u_{\epsilon}} = c\epsilon\mathbf{K_{\epsilon}}(\mathbf{r})\mathbf{\bar{u}}</script></span> 
where <span class="arithmatex"><span class="MathJax_Preview">c = 2/(3a - 2b)</span><script type="math/tex">c = 2/(3a - 2b)</script></span></p>
<p>Kelvinlets of different radial scales can be linearly combined to construct
brushes with arbitrarily fast decays:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}_{\epsilon_{1},..\epsilon_{n}}(\mathbf{r}) = c \left( \sum_{i}
 \frac{w_{i}}{\epsilon_{i}}\right)^{-1} \left[\sum_{i}
 w_{i}\mathbf{K_{\epsilon_{i}}}(\mathbf{r})  \right] \mathbf{\bar{u}}</span><script type="math/tex">\mathbf{u}_{\epsilon_{1},..\epsilon_{n}}(\mathbf{r}) = c \left( \sum_{i}
 \frac{w_{i}}{\epsilon_{i}}\right)^{-1} \left[\sum_{i}
 w_{i}\mathbf{K_{\epsilon_{i}}}(\mathbf{r})  \right] \mathbf{\bar{u}}</script></span></p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">w_{i}</span><script type="math/tex">w_{i}</script></span> are weights and <span class="arithmatex"><span class="MathJax_Preview">\epsilon_{i} &lt; \epsilon_{i+1}</span><script type="math/tex">\epsilon_{i} < \epsilon_{i+1}</script></span>. 
Due to the superposition principle, these compound brushes still satisfy the
Navier-Cauchy equation.</p>
<p>Regularized kelvinlets can further be extended by replacing the vector-based
load distribution with a matrix-based distribution to achieve non-affine
transformations like twist, pinch, and scale as described earlier.</p>
<p>In libigl, this is computed using:</p>
<p><div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">KelvinletParams</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">brushParams</span><span class="p">{</span><span class="n">brushRadius</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="p">,</span><span class="w"> </span><span class="n">brushType</span><span class="p">};</span>
<span class="n">igl</span><span class="o">::</span><span class="n">kelvinlets</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">origin</span><span class="p">,</span><span class="w"> </span><span class="n">forceVec</span><span class="p">,</span><span class="w"> </span><span class="n">forceMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">brushParams</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>
</code></pre></div>
where <code>brushRadius, scale, brushType</code> correspond to <span class="arithmatex"><span class="MathJax_Preview">\epsilon</span><script type="math/tex">\epsilon</script></span>, the falloff, and operation(grab, pinch, scale, twist).</p>
<figure>
<p><img alt="" src="../images/kelvinlets.gif" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/409_Kelvinlets/main.cpp">Example 409</a>) pinch, twist, grab and scale in action
  </figcaption>
</figure>
<h2 id="chapter-5-parametrization">Chapter 5: Parametrization<a class="headerlink" href="#chapter-5-parametrization" title="Permanent link">&para;</a></h2>
<p>In computer graphics, we denote as surface parametrization a map from the
surface to \(\mathbf{R}^2\). It is usually encoded by a new set of 2D
coordinates for each vertex of the mesh (and possibly also by a new set of
faces in one to one correspondence with the faces of the original surface).
Note that
this definition is the <em>inverse</em> of the classical differential geometry
definition.</p>
<p>A parametrization has many applications, ranging from texture mapping to
surface remeshing. Many algorithms have been proposed, and they can be broadly
divided in four families:</p>
<ol>
<li>
<p><strong>Single patch, fixed boundary</strong>: these algorithm can parametrize a
disk-like part of the surface given fixed 2D positions for its boundary. These
algorithms are efficient and simple, but they usually produce high-distortion maps due to the fixed boundary.</p>
</li>
<li>
<p><strong>Single patch, free boundary:</strong> these algorithms let the boundary
deform freely, greatly reducing the map distortion. Care should be taken to
prevent the border from self-intersecting.</p>
</li>
<li>
<p><strong>Global parametrization</strong>: these algorithms work on meshes with arbitrary
genus. They initially cut the mesh in multiple patches that can be separately parametrized. The generated maps are discontinuous on the cuts (often referred as <em>seams</em>).</p>
</li>
<li>
<p><strong>Global seamless parametrization</strong>: these are global parametrization algorithm that hides the seams, making the parametrization &ldquo;continuous&rdquo;, under specific assumptions that we will discuss later.</p>
</li>
</ol>
<h3 id="harmonic-parametrization">Harmonic Parametrization<a class="headerlink" href="#harmonic-parametrization" title="Permanent link">&para;</a></h3>
<p>Harmonic parametrization <sup id="fnref:eck_2005"><a class="footnote-ref" href="#fn:eck_2005">28</a></sup> is a single patch, fixed boundary parametrization
algorithm that computes the 2D coordinates of the flattened mesh as two
harmonic functions.</p>
<p>The algorithm is divided in 3 steps:</p>
<ol>
<li>Detect of the boundary vertices</li>
<li>Map the boundary vertices to a circle</li>
<li>Compute two harmonic functions (one for u and one for the v coordinate). The harmonic functions use the fixed vertices on the circle as boundary constraints.</li>
</ol>
<p>The algorithm can be coded using libigl as follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXi</span><span class="w"> </span><span class="n">bnd</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">boundary_loop</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">bnd</span><span class="p">);</span>

<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">bnd_uv</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">map_vertices_to_circle</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">bnd</span><span class="p">,</span><span class="n">bnd_uv</span><span class="p">);</span>

<span class="n">igl</span><span class="o">::</span><span class="n">harmonic</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">bnd</span><span class="p">,</span><span class="n">bnd_uv</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">V_uv</span><span class="p">);</span>
</code></pre></div>
<p>where <code>bnd</code> contains the indices of the boundary vertices, bnd_uv their position on the UV plane, and &ldquo;1&rdquo; denotes that we want to compute an harmonic function (2 will be for biharmonic, 3 for triharmonic, etc.). Note that each of the three
functions is designed to be reusable in other parametrization algorithms.</p>
<p>A UV parametrization can be visualized in the viewer with:</p>
<div class="highlight"><pre><span></span><code><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">().</span><span class="n">set_uv</span><span class="p">(</span><span class="n">V_uv</span><span class="p">);</span>
</code></pre></div>
<p>The UV coordinates are then used to apply a procedural checkerboard texture to the
mesh (<a href="https://github.com/libigl/libigl/tree/main/tutorial/501_HarmonicParam/main.cpp">Example 501</a>).</p>
<figure>
<p><img alt="" src="../images/501_HarmonicParam.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/501_HarmonicParam/main.cpp">Example 501</a>) Harmonic parametrization. (left) mesh with texture, (right) UV parametrization with texture
  </figcaption>
</figure>
<h3 id="least-squares-conformal-maps">Least Squares Conformal Maps<a class="headerlink" href="#least-squares-conformal-maps" title="Permanent link">&para;</a></h3>
<p>Least squares conformal maps parametrization <sup id="fnref:levy_2002"><a class="footnote-ref" href="#fn:levy_2002">29</a></sup> minimizes the
conformal (angular) distortion of the parametrization. Differently from
harmonic parametrization, it does not need to have a fixed boundary.</p>
<p>LSCM minimizes the following energy:</p>
<p>\[ E_{LSCM}(\mathbf{u},\mathbf{v}) = \int_X \frac{1}{2}| \nabla \mathbf{u}^{\perp} - \nabla \mathbf{v} |^2 dA \]</p>
<p>which can be rewritten in matrix form as <sup id="fnref:mullen_2008"><a class="footnote-ref" href="#fn:mullen_2008">32</a></sup>:</p>
<p>\[ E_{LSCM}(\mathbf{u},\mathbf{v}) = \frac{1}{2} [\mathbf{u},\mathbf{v}]^t (L_c - 2A) [\mathbf{u},\mathbf{v}] \]</p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">L_c</span><script type="math/tex">L_c</script></span> is the cotangent Laplacian matrix and <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is a matrix such that
<span class="arithmatex"><span class="MathJax_Preview">[\mathbf{u},\mathbf{v}]^t A  [\mathbf{u},\mathbf{v}]</span><script type="math/tex">[\mathbf{u},\mathbf{v}]^t A  [\mathbf{u},\mathbf{v}]</script></span> is equal to the <a href="http://en.wikipedia.org/wiki/Vector_area">vector
area</a> of the mesh.</p>
<p>Using libigl, this matrix energy can be written in a few lines of code. The
cotangent matrix can be computed using <code>igl::cotmatrix</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
</code></pre></div>
<p>Note that we want to apply the Laplacian matrix to the u and v coordinates at
the same time, thus we need to extend it taking the left
Kronecker product with a 2x2 identity matrix:</p>
<div class="highlight"><pre><span></span><code><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L_flat</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">repdiag</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">L_flat</span><span class="p">);</span>
</code></pre></div>
<p>The area matrix is computed with <code>igl::vector_area_matrix</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">vector_area_matrix</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>
</code></pre></div>
<p>The final energy matrix is <span class="arithmatex"><span class="MathJax_Preview">L_{flat} - 2A</span><script type="math/tex">L_{flat} - 2A</script></span>. Note that in this
case we do not need to fix the boundary. To remove the null space of the energy and make the minimum unique, it is sufficient to fix two arbitrary
vertices to two arbitrary positions. The full source code is provided in <a href="https://github.com/libigl/libigl/tree/main/tutorial/502_LSCMParam/main.cpp">Example 502</a>.</p>
<figure>
<p><img alt="" src="../images/502_LSCMParam.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/502_LSCMParam/main.cpp">Example 502</a>) LSCM parametrization. (left) mesh with texture, (right) UV parametrization
  </figcaption>
</figure>
<h3 id="as-rigid-as-possible-parametrization">As-rigid-as-possible Parametrization<a class="headerlink" href="#as-rigid-as-possible-parametrization" title="Permanent link">&para;</a></h3>
<p>As-rigid-as-possible parametrization <sup id="fnref:liu_2008"><a class="footnote-ref" href="#fn:liu_2008">31</a></sup> is a powerful single-patch,
non-linear algorithm to compute a parametrization that strives to preserve
distances (and thus angles). The idea is very similar to ARAP surface
deformation: each triangle is mapped to the plane trying to preserve its
original shape, up to a rigid rotation.</p>
<p>The algorithm can be implemented reusing the functions discussed in the
deformation chapter: <code>igl::arap_precomputation</code> and <code>igl::arap_solve</code>. The only
difference is that the optimization has to be done in 2D instead of 3D and that
we need to compute a starting point. While for 3D deformation the optimization
is bootstrapped with the original mesh, this is not the case for ARAP
parametrization since the starting point must be a 2D mesh. In <a href="https://github.com/libigl/libigl/tree/main/tutorial/503_ARAPParam/main.cpp">Example
503</a>, we initialize the optimization with harmonic
parametrization. Similarly to LSCM, the boundary is free to deform to minimize
the distortion.</p>
<figure>
<p><img alt="" src="../images/503_ARAPParam.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/503_ARAPParam/main.cpp">Example 503</a>) As-Rigid-As-Possible parametrization. (left) mesh with texture, (right) UV parametrization with texture
  </figcaption>
</figure>
<h3 id="n-rotationally-symmetric-tangent-fields">N-rotationally Symmetric Tangent Fields<a class="headerlink" href="#n-rotationally-symmetric-tangent-fields" title="Permanent link">&para;</a></h3>
<p>The design of tangent fields is a basic tool used to design guidance fields for
uniform quadrilateral and hexahedral remeshing. Libigl contains an
implementation of all the state-of-the-art algorithms to design N-RoSy fields
and their generalizations.</p>
<p>In libigl, tangent unit-length vector fields are piece-wise constant on the
faces of a triangle mesh, and they are described by one or more vectors per-face. The function</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">nrosy</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">b_soft</span><span class="p">,</span><span class="n">b_soft_weight</span><span class="p">,</span><span class="n">bc_soft</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span>
<span class="w">           </span><span class="n">output_field</span><span class="p">,</span><span class="n">output_singularities</span><span class="p">);</span>
</code></pre></div>
<p>creates a smooth unit-length vector field (N=1) starting from a sparse set of
constrained faces, whose indices are listed in b and their constrained value is
specified in bc. The functions supports soft_constraints (b_soft,
b_soft_weight, bc_soft), and returns the interpolated field for each face of
the triangle mesh (output_field), plus the singularities of the field
(output_singularities).</p>
<figure>
<p><img alt="" src="../images/504_vector_field.png" />
  </p>
<figcaption>
    Design of a unit-length vector field
  </figcaption>
</figure>
<p>The singularities are vertices where the field vanishes (highlighted in red in
the figure above). <code>igl::nrosy</code> can also generate N-RoSy fields <sup id="fnref:levy_2008"><a class="footnote-ref" href="#fn:levy_2008">30</a></sup>,
which are a generalization of vector fields where in every face the vector is
defined up to a constant rotation of <span class="arithmatex"><span class="MathJax_Preview">2\pi / N</span><script type="math/tex">2\pi / N</script></span>. As can be observed in
the following figure, the singularities of the fields generated with different
N are of different types and they appear in different positions.</p>
<figure>
<p><img alt="" src="../images/504_nrosy_field.png" />
  </p>
<figcaption>
    Design of a 2-,4- and 9-RoSy field
  </figcaption>
</figure>
<p>We demonstrate how to call and plot N-RoSy fields in <a href="https://github.com/libigl/libigl/tree/main/tutorial/504_NRosyDesign/main.cpp">Example
504</a>, where the degree of the field can be change
pressing the number keys. <code>igl::nrosy</code> implements the algorithm proposed in
<sup id="fnref:bommes_2009"><a class="footnote-ref" href="#fn:bommes_2009">26</a></sup>. N-RoSy fields can also be interpolated with many other algorithms,
see the library <a href="https://github.com/avaxman/libdirectional">libdirectional</a> for
a reference implementation of the most popular ones. For a complete categorization
of fields used in various applications see Vaxman et al. 2016 <sup id="fnref:vaxman_2016"><a class="footnote-ref" href="#fn:vaxman_2016">34</a></sup>.</p>
<h3 id="global-seamless-integer-grid-parametrization">Global, Seamless Integer-grid Parametrization<a class="headerlink" href="#global-seamless-integer-grid-parametrization" title="Permanent link">&para;</a></h3>
<p>The previous parametrization methods were focusing on creating parametrizations
of surface patches aimed at texture mapping or baking of other surface
properties such as normals and high-frequency details. Global, seamless
parametrization aims at parametrizing complex shapes with a parametrization
that is aligned with a given set of directions for the purpose of surface
remeshing. In libigl, we provide a reference  implementation of the pipeline
proposed in the mixed integer quadrangulation paper <sup id="fnref2:bommes_2009"><a class="footnote-ref" href="#fn:bommes_2009">26</a></sup>.</p>
<p>The first step involves the design of a 4-RoSy field (sometimes called <em>cross</em>
field) that describes the alignment of the edges of the desired quadrilateral
remeshing. The field constraints are usually manually specified or extracted
from the principal curvature directions. In <a href="https://github.com/libigl/libigl/tree/main/tutorial/506_FrameField/main.cpp">Example
506</a>, we simply fix one face in a random direction.</p>
<figure>
<p><img alt="" src="../images/505_MIQ_1.png" />
  </p>
<figcaption>
    Initial cross field prescribing the edge alignment.
  </figcaption>
</figure>
<h4 id="combing-and-cutting">Combing And Cutting<a class="headerlink" href="#combing-and-cutting" title="Permanent link">&para;</a></h4>
<p>Given the cross field, we now want to cut the surface so that it becomes
homeomorphic to a disk. While this could be done directly on the cross-field, we
opt to perform this operation on its bisector field (a copy of the field
rotated by 45 degrees) since it is more stable and generic. Working on the
bisectors allow us to take as input generalized, non-orthogonal and non-unit
length cross fields.</p>
<p>We thus rotate the field,</p>
<figure>
<p><img alt="" src="../images/505_MIQ_2.png" />
  </p>
<figcaption>
    Bisector field.
  </figcaption>
</figure>
<p>and we remove the rotation ambiguity by assigning to each face a u and a v
direction. The assignment is done with a breadth-first search starting from a
random face.</p>
<figure>
<p><img alt="" src="../images/505_MIQ_3.png" />
  </p>
<figcaption>
    Combed bisector field.
  </figcaption>
</figure>
<p>You can imagine this process as combing a hairy surface: you will be able to
comb part of it, but at some point you will not be able to consistently comb
the entire surface (<a href="http://en.wikipedia.org/wiki/Hairy_ball_theorem">Hairy ball
theorem</a>). The discontinuities
in the combing define the cut graph:</p>
<figure>
<p><img alt="" src="../images/505_MIQ_4.png" />
  </p>
<figcaption>
    Cut graph.
  </figcaption>
</figure>
<p>Finally, we rotate the combed field by 45 degrees to undo the initial degrees
rotation:</p>
<figure>
<p><img alt="" src="../images/505_MIQ_5.png" />
  </p>
<figcaption>
    Combed cross field.
  </figcaption>
</figure>
<p>The combed cross field can be seen as the ideal Jacobian of the parametrization
that will be computed in the next section.</p>
<h4 id="poisson-parametrization">Poisson Parametrization<a class="headerlink" href="#poisson-parametrization" title="Permanent link">&para;</a></h4>
<p>The mesh is cut along the seams and a parametrization is computed trying to
find two scalar functions whose gradient matches the combed cross field
directions. This is a classical Poisson problem, that is solved minimizing the
following quadratic energy:</p>
<p>\[ E(\mathbf{u},\mathbf{v}) = |\nabla \mathbf{u} - X_u|^2 + |\nabla \mathbf{v} - X_v|^2 \]</p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">X_u</span><script type="math/tex">X_u</script></span> and <span class="arithmatex"><span class="MathJax_Preview">X_u</span><script type="math/tex">X_u</script></span> denotes the combed cross field. Solving this
problem generates a parametrization whose u and v isolines are aligned with the
input cross field.</p>
<figure>
<p><img alt="" src="../images/505_MIQ_8.png" />
  </p>
<figcaption>
    Poisson parametrization.
  </figcaption>
</figure>
<p>We hide the seams by adding integer constraints to the Poisson problem
that align the isolines on both sides of each seam <sup id="fnref3:bommes_2009"><a class="footnote-ref" href="#fn:bommes_2009">26</a></sup>.</p>
<figure>
<p><img alt="" src="../images/505_MIQ_7.png" />
  </p>
<figcaption>
    Seamless Poisson parametrization.
  </figcaption>
</figure>
<p>Note that this parametrization can only be used for remeshing purposes, since
it contains many overlaps.</p>
<figure>
<p><img alt="" src="../images/505_MIQ_6.png" />
  </p>
<figcaption>
    Seamless Poisson parametrization (in 2D).
  </figcaption>
</figure>
<p>A quad mesh can be extracted from this parametrization using
<a href="https://github.com/hcebke/libQEx">libQEx</a> (not included in libigl).
The full pipeline is implemented in <a href="https://github.com/libigl/libigl/tree/main/tutorial/505_MIQ/main.cpp">Example 505</a>.</p>
<h3 id="anisotropic-remeshing">Anisotropic Remeshing<a class="headerlink" href="#anisotropic-remeshing" title="Permanent link">&para;</a></h3>
<p>Anisotropic and non-uniform quad remeshing is important to concentrate the
elements in the regions with more details. It is possible to extend the MIQ
quad meshing framework to generate anisotropic quad meshes using a mesh
deformation approach <sup id="fnref:panozzo_2014"><a class="footnote-ref" href="#fn:panozzo_2014">33</a></sup>.</p>
<p>The input of the anisotropic remeshing algorithm is a sparse set of constraints
that define the shape and scale of the desired quads. This can be encoded as a
frame field, which is a pair of non-orthogonal and non-unit length vectors. The
frame field can be interpolated by decomposing it in a 4-RoSy field and a
unique affine transformation. The two parts can then be interpolated
separately, using <code>igl::nrosy</code> for the cross field, and an harmonic interpolant
for the affine part.</p>
<figure>
<p><img alt="" src="../images/506_FrameField_1.png" />
  </p>
<figcaption>
    Interpolation of a frame field. Colors on the vectors denote the desired scale. The red faces contains the frame field constraints.
  </figcaption>
</figure>
<p>After the interpolation, the surface is warped to transform each frame into an
orthogonal and unit length cross (i.e. removing the scaling and skewness from
the frame). This deformation defines a new embedding (and a new metric) for the
surface.</p>
<figure>
<p><img alt="" src="../images/506_FrameField_2.png" />
  </p>
<figcaption>
    The surface is deformed to transform the frame field in a cross field.
  </figcaption>
</figure>
<p>The deformed surface can the be isotropically remeshed using the MIQ algorithm
that has been presented in the previous section.</p>
<figure>
<p><img alt="" src="../images/506_FrameField_3.png" />
  </p>
<figcaption>
    The deformed surface is isotropically remeshed.
  </figcaption>
</figure>
<p>The UV coordinates of the deformed surface can then be used to transport the
parametrization to the original surface, where the isolines will trace a quad
mesh whose elements are similar to the shape prescribed in the input frame
field.</p>
<figure>
<p><img alt="" src="../images/506_FrameField_4.png" />
  </p>
<figcaption>
    The global parametrization is lifted to the original surface to create the anisotropic quad meshing.
  </figcaption>
</figure>
<p>Our implementation (<a href="https://github.com/libigl/libigl/tree/main/tutorial/506_FrameField/main.cpp">Example 506</a>) uses MIQ to
generate the UV parametrization, but other algorithms could be applied: the
only desiderata is that the generated quad mesh should be as isotropic as
possible.</p>
<h3 id="planarization">Planarization<a class="headerlink" href="#planarization" title="Permanent link">&para;</a></h3>
<p>A quad mesh can be transformed in a planar quad mesh with Shape-Up
<sup id="fnref:bouaziz_2012"><a class="footnote-ref" href="#fn:bouaziz_2012">27</a></sup>, a local/global approach that uses the global step to enforce
surface continuity and the local step to enforce planarity.</p>
<p><a href="https://github.com/libigl/libigl/tree/main/tutorial/507_Planarization/main.cpp">Example 507</a> planarizes a quad mesh until it
satisfies a user-given planarity threshold.</p>
<figure>
<p><img alt="" src="../images/509_Planarization.png" />
  </p>
<figcaption>
    A non-planar quad mesh (left) is planarized using the libigl function igl::planarize (right). The colors represent the planarity of the quads.
  </figcaption>
</figure>
<h2 id="chapter-6-external-libraries">Chapter 6: External Libraries<a class="headerlink" href="#chapter-6-external-libraries" title="Permanent link">&para;</a></h2>
<p>An additional positive side effect of using matrices as basic types is that it
is easy to exchange data between libigl and other software and libraries.</p>
<h3 id="state-serialization">State Serialization<a class="headerlink" href="#state-serialization" title="Permanent link">&para;</a></h3>
<p>Geometry processing applications often require a considerable amount of
computational time and/or manual input. Serializing the state of the application
is a simple strategy to greatly increase the development efficiency. It allows
to quickly start debugging just before the crash happens, avoiding to wait for
the precomputation to take place every time and it also makes your experiments
reproducible, allowing to quickly test algorithms variants on the same input
data.</p>
<p>Serialization is often not considered in geometry processing due to the extreme
difficulty in serializing pointer-based data structures, such as an half-edge
data structure (<a href="http://openmesh.org">OpenMesh</a>, <a href="http://www.cgal.org">CGAL</a>),
or a pointer based indexed structure
(<a href="http://vcg.isti.cnr.it/~cignoni/newvcglib/html/">VCG</a>).</p>
<p>In libigl, serialization is much simpler, since the majority of the functions
use basic types, and pointers are used in very rare cases (usually to interface
with external libraries). Libigl bundles a simple and self-contained binary and
XML serialization framework, that drastically reduces the overhead required to
add serialization to your applications.</p>
<p>To de-/serialize a set of variables use the following method:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;igl/serialize.h&quot;</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.002</span><span class="p">,</span><span class="mf">5.3</span><span class="p">};</span>

<span class="c1">// use overwrite = true for the first serialization to create or overwrite an</span>
<span class="c1">// existing file</span>
<span class="n">igl</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;filename&quot;</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="c1">// append following serialization to existing file</span>
<span class="n">igl</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="s">&quot;Number&quot;</span><span class="p">,</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="s">&quot;VectorName&quot;</span><span class="p">,</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>

<span class="c1">// deserialize back to variables</span>
<span class="n">igl</span><span class="o">::</span><span class="n">deserialize</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">deserialize</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="s">&quot;Number&quot;</span><span class="p">,</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">deserialize</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="s">&quot;VectorName&quot;</span><span class="p">,</span><span class="s">&quot;filename&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Currently all fundamental data types (bool, int, float, double, &hellip;) are
supported, as well as std::string, basic <code>STL</code> containers, dense and sparse
Eigen matrices and nestings of those.  Some limitations apply to pointers.
Currently, loops or many to one type of link structures are not handled
correctly. Each pointer is assumed to point to a different independent object.
Uninitialized pointers must be set to <code>nullptr</code> before de-/serialization to
avoid memory leaks. Cross-platform issues like little-, big-endianess is
currently not supported.  To make user defined types serializable, just derive
from <code>igl::Serializable</code> and trivially implementing the <code>InitSerialization</code>
method.</p>
<p>Assume that the state of your application is a mesh and a set of integer ids:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;igl/serialize.h&quot;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">igl</span><span class="o">::</span><span class="n">Serializable</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">V</span><span class="p">;</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">F</span><span class="p">;</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ids</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">InitSerialization</span><span class="p">()</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">V</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;V&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">F</span><span class="w">  </span><span class="p">,</span><span class="w"> </span><span class="s">&quot;F&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;ids&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>
<p>If you need more control over the serialization of your types, you can override
the following functions or directly inherit from the interface
<code>igl::SerializableBase</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="nf">Serializable::PreSerialization</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Serializable::PostSerialization</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="nf">Serializable::PreDeserialization</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Serializable::PostDeserialization</span><span class="p">();</span>
</code></pre></div>
<p>Alternatively, if you want a non-intrusive way of serializing your state you can
overload the following functions:</p>
<div class="highlight"><pre><span></span><code><span class="k">namespace</span><span class="w"> </span><span class="nn">igl</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">namespace</span><span class="w"> </span><span class="nn">serialization</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">serialize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="o">::</span><span class="n">igl</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">V</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;V&quot;</span><span class="p">),</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">      </span><span class="o">::</span><span class="n">igl</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">F</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;F&quot;</span><span class="p">),</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">      </span><span class="o">::</span><span class="n">igl</span><span class="o">::</span><span class="n">serialize</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">ids</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;ids&quot;</span><span class="p">),</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">deserialize</span><span class="p">(</span><span class="n">State</span><span class="o">&amp;</span><span class="w"> </span><span class="n">obj</span><span class="p">,</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="o">::</span><span class="n">igl</span><span class="o">::</span><span class="n">deserialize</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">V</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;V&quot;</span><span class="p">),</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">      </span><span class="o">::</span><span class="n">igl</span><span class="o">::</span><span class="n">deserialize</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">F</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;F&quot;</span><span class="p">),</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">      </span><span class="o">::</span><span class="n">igl</span><span class="o">::</span><span class="n">deserialize</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">ids</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;ids&quot;</span><span class="p">),</span><span class="n">buffer</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Equivalently, you can use the following macros:</p>
<div class="highlight"><pre><span></span><code><span class="n">SERIALIZE_TYPE</span><span class="p">(</span><span class="n">State</span><span class="p">,</span>
<span class="w"> </span><span class="n">SERIALIZE_MEMBER</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="w"> </span><span class="n">SERIALIZE_MEMBER</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
<span class="w"> </span><span class="n">SERIALIZE_MEMBER_NAME</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span><span class="s">&quot;ids&quot;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>
<p>All the former code is for binary serialization which is especially useful if
you have to handle larger data where the loading and saving times become more
important.  For cases where you want to read and edit the serialized data by
hand we provide a serialization to XML files which is based on the library
<a href="https://github.com/leethomason/tinyxml2">tinyxml2</a>.  There you also have the
option to create a partial binary serialization of your data by using the binary
parameter, exposed in the function <code>serialize_xml()</code>:</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;igl/xml/serialize_xml.h&quot;</span>

<span class="kt">int</span><span class="w"> </span><span class="n">number</span><span class="p">;</span>

<span class="c1">// binary = false, overwrite = true</span>
<span class="n">igl</span><span class="o">::</span><span class="n">serialize_xml</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="s">&quot;VectorXML&quot;</span><span class="p">,</span><span class="n">xmlFile</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="c1">// binary = true, overwrite = true</span>
<span class="n">igl</span><span class="o">::</span><span class="n">serialize_xml</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="s">&quot;VectorBin&quot;</span><span class="p">,</span><span class="n">xmlFile</span><span class="p">,</span><span class="nb">true</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">deserialize_xml</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="s">&quot;VectorXML&quot;</span><span class="p">,</span><span class="n">xmlFile</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">deserialize_xml</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="s">&quot;VectorBin&quot;</span><span class="p">,</span><span class="n">xmlFile</span><span class="p">);</span>
</code></pre></div>
<p>For user defined types derive from <code>XMLSerializable</code>.</p>
<p>The code snippets above are extracted from <a href="https://github.com/libigl/libigl/tree/main/tutorial/601_Serialization/main.cpp">Example
601</a>. We strongly suggest that you make the entire
state of your application always serializable since it will save you a lot of
troubles when you will be preparing figures for a scientific report. It is very
common to have to do small changes to figures, and being able to serialize the
entire state just before you take screenshots will save you many painful hours
before a submission deadline.</p>
<h3 id="mixing-matlab-code">Mixing Matlab Code<a class="headerlink" href="#mixing-matlab-code" title="Permanent link">&para;</a></h3>
<p>Libigl can be interfaced with Matlab to offload numerically heavy computation
to a Matlab script. The major advantage of this approach is that you will be
able to develop efficient and complex user-interfaces in C++, while exploring
the syntax and fast protototyping features of matlab. In particular, the use of
an external Matlab script in a libigl application allows to change the Matlab
code while the C++ application is running, greatly increasing coding
efficiency.</p>
<p>We demonstrate how to integrate Matlab in a libigl application in <a href="https://github.com/libigl/libigl/tree/main/tutorial/602_Matlab/main.cpp">Example
602</a>. The example uses Matlab to compute the
Eigenfunctions of the discrete Laplacian operator, relying on libigl for mesh
IO, visualization and for computing the Laplacian operator.</p>
<p>Libigl can connect to an existing instance of Matlab (or launching a new one on
Linux/MacOSX) using:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">mlinit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">);</span>
</code></pre></div>
<p>The cotangent Laplacian is computed using igl::cotmatrix and uploaded to the
Matlab workspace:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">mlsetmatrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="s">&quot;L&quot;</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
</code></pre></div>
<p>It is now possible to use any Matlab function on the data. For example, we can
see the sparsity pattern of L using spy:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">mleval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="s">&quot;spy(L)&quot;</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/602_Matlab_1.png" />
  </p>
<figcaption>
    The Matlab spy function is called from a libigl-based application.
  </figcaption>
</figure>
<p>The results of Matlab computations can be returned back to the C++ application</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">mleval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="s">&quot;[EV,~] = eigs(-L,10,&#39;sm&#39;)&quot;</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">mlgetmatrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="s">&quot;EV&quot;</span><span class="p">,</span><span class="n">EV</span><span class="p">);</span>
</code></pre></div>
<p>and plotted using the libigl viewer.</p>
<figure>
<p><img alt="" src="../images/602_Matlab_2.gif" />
  </p>
<figcaption>
    Eigenfunctions of the Laplacian computed in Matlab, plotted in the libigl viewer.
  </figcaption>
</figure>
<h4 id="saving-a-matlab-workspace">Saving A Matlab Workspace<a class="headerlink" href="#saving-a-matlab-workspace" title="Permanent link">&para;</a></h4>
<p>To aid debugging, libigl also supplies functions to write Matlab <code>.mat</code>
&ldquo;Workspaces&rdquo;. This C++ snippet saves a mesh and it&rsquo;s sparse Laplacian matrix to
a file:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">readOFF</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span><span class="w"> </span><span class="s">&quot;/fertility.off&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">MatlabWorkspace</span><span class="w"> </span><span class="n">mw</span><span class="p">;</span>
<span class="n">mw</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="s">&quot;V&quot;</span><span class="p">);</span>
<span class="n">mw</span><span class="p">.</span><span class="n">save_index</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="s">&quot;F&quot;</span><span class="p">);</span>
<span class="n">mw</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s">&quot;L&quot;</span><span class="p">);</span>
<span class="n">mw</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;fertility.mat&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Then this workspace can be loaded into a Matlab IDE:</p>
<div class="highlight"><pre><span></span><code><span class="nb">load</span><span class="w"> </span><span class="n">fertility</span><span class="p">.</span><span class="n">mat</span>
</code></pre></div>
<p>The <code>igl::MatlabWorkspace</code> depends on Matlab libraries to compile and run,
but&mdash;in contrast to the engine routines above&mdash;will avoid launching a Matlab
instance upon execution.</p>
<h4 id="dumping-eigen-matrices-to-copy-and-paste-into-matlab">Dumping Eigen Matrices To Copy And Paste Into Matlab<a class="headerlink" href="#dumping-eigen-matrices-to-copy-and-paste-into-matlab" title="Permanent link">&para;</a></h4>
<p>Eigen supplies a sophisticated API for printing its matrix types to the screen.
Libigl has wrapped up a particularly useful formatting which makes it simple to
copy standard output from a C++ program into a Matlab IDE. The code:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">readOFF</span><span class="p">(</span><span class="n">TUTORIAL_SHARED_PATH</span><span class="w"> </span><span class="s">&quot;/2triangles.off&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">);</span>
<span class="n">igl</span><span class="o">::</span><span class="n">cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">igl</span><span class="o">::</span><span class="n">matlab_format</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="s">&quot;V&quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">igl</span><span class="o">::</span><span class="n">matlab_format</span><span class="p">((</span><span class="n">F</span><span class="p">.</span><span class="n">array</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">eval</span><span class="p">(),</span><span class="s">&quot;F&quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">igl</span><span class="o">::</span><span class="n">matlab_format</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="s">&quot;L&quot;</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div>
<p>produces the output:</p>
<div class="highlight"><pre><span></span><code><span class="n">V</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">0</span>
<span class="p">];</span>
<span class="n">F</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span>
<span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span>
<span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">3</span>
<span class="p">];</span>
<span class="n">LIJV</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span>
<span class="n">1</span><span class="w">  </span><span class="s">1</span><span class="w">    </span><span class="o">-</span><span class="mf">0.7071067811865476</span>
<span class="n">2</span><span class="w">  </span><span class="s">1</span><span class="w">     </span><span class="s">0.7071067811865475</span>
<span class="n">3</span><span class="w">  </span><span class="s">1</span><span class="w">  </span><span class="s">1.570092458683775e-16</span>
<span class="n">1</span><span class="w">  </span><span class="s">2</span><span class="w">     </span><span class="s">0.7071067811865475</span>
<span class="n">2</span><span class="w">  </span><span class="s">2</span><span class="w">     </span><span class="o">-</span><span class="mf">1.638010440969447</span>
<span class="n">3</span><span class="w">  </span><span class="s">2</span><span class="w">     </span><span class="s">0.6422285251880865</span>
<span class="n">4</span><span class="w">  </span><span class="s">2</span><span class="w">     </span><span class="s">0.2886751345948129</span>
<span class="n">1</span><span class="w">  </span><span class="s">3</span><span class="w">  </span><span class="s">1.570092458683775e-16</span>
<span class="n">2</span><span class="w">  </span><span class="s">3</span><span class="w">     </span><span class="s">0.6422285251880865</span>
<span class="n">3</span><span class="w">  </span><span class="s">3</span><span class="w">    </span><span class="o">-</span><span class="mf">0.9309036597828995</span>
<span class="n">4</span><span class="w">  </span><span class="s">3</span><span class="w">     </span><span class="s">0.2886751345948129</span>
<span class="n">2</span><span class="w">  </span><span class="s">4</span><span class="w">     </span><span class="s">0.2886751345948129</span>
<span class="n">3</span><span class="w">  </span><span class="s">4</span><span class="w">     </span><span class="s">0.2886751345948129</span>
<span class="n">4</span><span class="w">  </span><span class="s">4</span><span class="w">    </span><span class="o">-</span><span class="mf">0.5773502691896258</span>
<span class="p">];</span>
<span class="n">L</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">sparse</span><span class="p">(</span><span class="n">LIJV</span><span class="p">(:,</span><span class="mi">1</span><span class="p">),</span><span class="n">LIJV</span><span class="p">(:,</span><span class="mi">2</span><span class="p">),</span><span class="n">LIJV</span><span class="p">(:,</span><span class="mi">3</span><span class="p">));</span>
</code></pre></div>
<p>which is easily copied and pasted into Matlab for debugging, etc.</p>
<h3 id="calling-libigl-functions-from-matlab">Calling Libigl Functions From Matlab<a class="headerlink" href="#calling-libigl-functions-from-matlab" title="Permanent link">&para;</a></h3>
<p>It is also possible to call libigl functions from matlab, compiling them as MEX
functions. This can be used to offload to C++ code the computationally
intensive parts of a Matlab application.</p>
<p>We provide a wrapper for <code>igl::readOBJ</code> in <a href="https://github.com/libigl/libigl/tree/main/tutorial/603_MEX/compileMEX.m">Example 603</a>.
We plan to provide wrappers for all our functions in the future, if you are
interested in this feature (or if you want to help implementing it) please let
us know.</p>
<h3 id="triangulation-of-closed-polygons">Triangulation Of Closed Polygons<a class="headerlink" href="#triangulation-of-closed-polygons" title="Permanent link">&para;</a></h3>
<p>The generation of high-quality triangle and tetrahedral meshes is a very common
task in geometry processing. We provide wrappers in libigl to
<a href="http://www.cs.cmu.edu/~quake/triangle.html">triangle</a> and
<a href="http://wias-berlin.de/software/tetgen/">Tetgen</a>.</p>
<p>A triangle mesh with a given boundary can be created with:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">triangulate</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">V2</span><span class="p">,</span><span class="n">F2</span><span class="p">,</span><span class="s">&quot;a0.005q&quot;</span><span class="p">);</span>
</code></pre></div>
<p>where <code>E</code> is a set of boundary edges (#E by 2), <code>H</code> is a set of 2D positions of
points contained in holes of the triangulation (#H by 2) and (<code>V2</code>,<code>F2</code>) is the
generated triangulation. Additional parameters can be passed to <code>triangle</code>, to
control the quality: <code>"a0.005q"</code> enforces a bound on the maximal area of the
triangles and a minimal angle of 20 degrees. In <a href="https://github.com/libigl/libigl/tree/main/tutorial/604_Triangle/main.cpp">Example
604</a>, the interior of a square (excluded a smaller square
in its interior) is triangulated.</p>
<figure>
<p><img alt="" src="../images/604_Triangle.png" />
  </p>
<figcaption>
    Triangulation of the interior of a polygon.
  </figcaption>
</figure>
<h3 id="tetrahedralization-of-closed-surfaces">Tetrahedralization Of Closed Surfaces<a class="headerlink" href="#tetrahedralization-of-closed-surfaces" title="Permanent link">&para;</a></h3>
<p>Similarly, the interior of a closed manifold surface can be tetrahedralized
using the function <code>igl::tetrahedralize</code> which wraps the Tetgen library (<a href="https://github.com/libigl/libigl/tree/main/tutorial/605_Tetgen/main.cpp">Example
605</a>):</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">tetrahedralize</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="s">&quot;pq1.414&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">TV</span><span class="p">,</span><span class="n">TT</span><span class="p">,</span><span class="n">TF</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/605_Tetgen.png" />
  </p>
<figcaption>
    Tetrahedralization of the interior of a surface mesh.
  </figcaption>
</figure>
<h3 id="baking-ambient-occlusion">Baking Ambient Occlusion<a class="headerlink" href="#baking-ambient-occlusion" title="Permanent link">&para;</a></h3>
<p><a href="http://en.wikipedia.org/wiki/Ambient_occlusion">Ambient occlusion</a> is a
rendering technique used to calculate the exposure of each point in a surface
to ambient lighting. It is usually encoded as a scalar (normalized between 0
and 1) associated with the vertice of a mesh.</p>
<p>Formally, ambient occlusion is defined as:</p>
<p>\[ A_p = \frac{1}{\pi} \int_\omega V_{p,\omega}(n \cdot \omega) d\omega \]</p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">V_{p,\omega}</span><script type="math/tex">V_{p,\omega}</script></span> is the visibility function at  p, defined to be zero if p
is occluded in the direction <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span> and one otherwise, and <span class="arithmatex"><span class="MathJax_Preview">d\omega</span><script type="math/tex">d\omega</script></span> is the
infinitesimal solid angle step of the integration variable <span class="arithmatex"><span class="MathJax_Preview">\omega</span><script type="math/tex">\omega</script></span>.</p>
<p>The integral is usually approximated by casting rays in random directions
around each vertex. This approximation can be computed using the function:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">ambient_occlusion</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">V_samples</span><span class="p">,</span><span class="n">N_samples</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="n">AO</span><span class="p">);</span>
</code></pre></div>
<p>that given a scene described in <code>V</code> and <code>F</code>, computes the ambient occlusion of
the points in <code>V_samples</code> whose associated normals are <code>N_samples</code>. The
number of casted rays can be controlled (usually at least 300-500 rays are
required to get a smooth result) and the result is returned in <code>AO</code>, as a
single scalar for each sample.</p>
<p>Ambient occlusion can be used to darken the surface colors, as shown in
<a href="https://github.com/libigl/libigl/tree/main/tutorial/606_AmbientOcclusion/main.cpp">Example 606</a></p>
<figure>
<p><img alt="" src="../images/606_AmbientOcclusion.png" />
  </p>
<figcaption>
    A mesh rendered without (left) and with (right) ambient occlusion.
  </figcaption>
</figure>
<h3 id="screen-capture">Screen Capture<a class="headerlink" href="#screen-capture" title="Permanent link">&para;</a></h3>
<p>Libigl supports read and writing to .png files via the
<a href="http://nothings.org/stb_image.h">stb image</a> code.</p>
<p>With the viewer used in this tutorial, it is possible to render the scene in a
memory buffer using the function, <code>igl::opengl::ViewerCore::draw_buffer</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Allocate temporary buffers for 1280x800 image</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>

<span class="c1">// Draw the scene in the buffers</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">draw_buffer</span><span class="p">(</span><span class="n">viewer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="nb">false</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>

<span class="c1">// Save it to a PNG</span>
<span class="n">igl</span><span class="o">::</span><span class="n">png</span><span class="o">::</span><span class="n">writePNG</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="s">&quot;out.png&quot;</span><span class="p">);</span>
</code></pre></div>
<p>In <a href="https://github.com/libigl/libigl/tree/main/tutorial/607_ScreenCapture/main.cpp">Example 607</a> a scene is rendered in a temporary
png and used to texture a quadrilateral.</p>
<h3 id="off-screen-rendering-using-ray-tracing-with-embree">Off-screen rendering using ray tracing with Embree<a class="headerlink" href="#off-screen-rendering-using-ray-tracing-with-embree" title="Permanent link">&para;</a></h3>
<p>If libigl is compiled without OpenGL support, or when the interactive viewer is not
practical, it is still possible to render view in memory using <a href="https://www.embree.org/">Embree</a>
library. Currently only triangular meshes are supported. The usage is very similar to the <a href="#screen-capture">Screen Capture</a> tutorial.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Create embree renderer object</span>
<span class="n">igl</span><span class="o">::</span><span class="n">embree</span><span class="o">::</span><span class="n">EmbreeRenderer</span><span class="w"> </span><span class="n">er</span><span class="p">;</span>
<span class="c1">// Specify mesh, tell embree to optimize for static scene</span>
<span class="n">er</span><span class="p">.</span><span class="n">set_mesh</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="nb">true</span><span class="p">);</span>

<span class="c1">// Specify scalar data, use JET color map to convert to colors</span>
<span class="n">er</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">igl</span><span class="o">::</span><span class="n">COLOR_MAP_TYPE_JET</span><span class="p">);</span>

<span class="c1">// Since the render is not interactive, need to specify scene parameters</span>
<span class="c1">// the default view is identical to the interactive viewer</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix3d</span><span class="w"> </span><span class="n">rot_matrix</span><span class="p">;</span>

<span class="c1">// Specify rotation matrix:</span>
<span class="c1">//     10 degrees around X axis</span>
<span class="c1">//      5 degrees around Y axis</span>
<span class="c1">//      4 degrees around Z axis</span>
<span class="n">rot_matrix</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisd</span><span class="p">(</span><span class="w"> </span><span class="mi">10</span><span class="o">*</span><span class="n">igl</span><span class="o">::</span><span class="n">PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitX</span><span class="p">())</span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisd</span><span class="p">(</span><span class="w">  </span><span class="mi">5</span><span class="o">*</span><span class="n">igl</span><span class="o">::</span><span class="n">PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitY</span><span class="p">())</span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">AngleAxisd</span><span class="p">(</span><span class="w">  </span><span class="mi">4</span><span class="o">*</span><span class="n">igl</span><span class="o">::</span><span class="n">PI</span><span class="o">/</span><span class="mf">180.0</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="o">::</span><span class="n">UnitZ</span><span class="p">());</span>
<span class="n">er</span><span class="p">.</span><span class="n">set_rot</span><span class="p">(</span><span class="n">rot_matrix</span><span class="p">);</span>

<span class="c1">// Specify relative zoom factor</span>
<span class="n">er</span><span class="p">.</span><span class="n">set_zoom</span><span class="p">(</span><span class="mf">1.5</span><span class="p">);</span>
<span class="c1">// Request orthographic projection</span>
<span class="n">er</span><span class="p">.</span><span class="n">set_orthographic</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

<span class="c1">// Allocate temporary buffers for 1280x800 image</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">G</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="p">,</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Dynamic</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">(</span><span class="mi">1280</span><span class="p">,</span><span class="mi">800</span><span class="p">);</span>

<span class="c1">// Render view</span>
<span class="n">er</span><span class="p">.</span><span class="n">render_buffer</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>

<span class="c1">// Save it to a PNG</span>
<span class="n">igl</span><span class="o">::</span><span class="n">png</span><span class="o">::</span><span class="n">writePNG</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">png_file</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/608_RayTrace.png" />
  </p>
<figcaption>
    Fertility statue showing curvature as scalar field, rendered with embree
  </figcaption>
</figure>
<p>In <a href="https://github.com/libigl/libigl/tree/main/tutorial/608_RayTrace/main.cpp">Example 608</a> a scene is rendered in a memory
buffer and saved as png file.</p>
<h3 id="boolean-operations-on-meshes">Boolean Operations On Meshes<a class="headerlink" href="#boolean-operations-on-meshes" title="Permanent link">&para;</a></h3>
<p>Constructive solid geometry (CSG) is a technique to define a complex surface as
the result of a number of set operations on solid regions of space: union,
intersection, set difference, symmetric difference, complement. Typically, CSG
libraries represent the inputs and outputs to these operations <em>implicitly</em>:
the solid <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> is defined as the open set of points <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> for which some
function <span class="arithmatex"><span class="MathJax_Preview">a(\mathbf{x})</span><script type="math/tex">a(\mathbf{x})</script></span> &ldquo;returns true&rdquo;. The surface of this shape is the
<em>closure</em> of all points <span class="arithmatex"><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> in <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span>.</p>
<p>With this sort of representation, boolean
operations are straightforward. For example, the union of solids <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> and <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span>
is simply</p>
<p><span class="arithmatex"><span class="MathJax_Preview">A \cup B = \{\mathbf{x} \left.\right|
  a(\mathbf{x}) \text{ or } b(\mathbf{x})\},</span><script type="math/tex">A \cup B = \{\mathbf{x} \left.\right|
  a(\mathbf{x}) \text{ or } b(\mathbf{x})\},</script></span></p>
<p>the intersection is</p>
<p><span class="arithmatex"><span class="MathJax_Preview">A \cap B = \{\mathbf{x} \left.\right|
  a(\mathbf{x}) \text{ and } b(\mathbf{x})\},</span><script type="math/tex">A \cap B = \{\mathbf{x} \left.\right|
  a(\mathbf{x}) \text{ and } b(\mathbf{x})\},</script></span></p>
<p>the difference <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> <em>minus</em> <span class="arithmatex"><span class="MathJax_Preview">B</span><script type="math/tex">B</script></span> is</p>
<p><span class="arithmatex"><span class="MathJax_Preview">A \setminus B = \{\mathbf{x} \left.\right|
  a(\mathbf{x}) \text{ and _not_ } b(\mathbf{x})\},</span><script type="math/tex">A \setminus B = \{\mathbf{x} \left.\right|
  a(\mathbf{x}) \text{ and _not_ } b(\mathbf{x})\},</script></span></p>
<p>and the symmetric difference (XOR) is</p>
<p><span class="arithmatex"><span class="MathJax_Preview">A \triangle B = \{\mathbf{x} \left.\right|
  \text{either } a(\mathbf{x}) \text{ or } b(\mathbf{x}) \text{ but not both }\}.</span><script type="math/tex">A \triangle B = \{\mathbf{x} \left.\right|
  \text{either } a(\mathbf{x}) \text{ or } b(\mathbf{x}) \text{ but not both }\}.</script></span></p>
<p>Stringing together many of these operations, one can design quite complex
shapes. A typical CSG library might only keep explicit <em>base-case</em>
representations of canonical shapes: half-spaces, quadrics, etc.</p>
<p>In libigl, we currently do <em>not</em> have an implicit surface representation.
Instead we expect our users to be working with <em>explicit</em> triangle mesh
<em>boundary representations</em> of solid shapes. CSG operations are much hard to
compute robustly with boundary representations, but are nonetheless useful.</p>
<p>To compute a boolean operation on a triangle mesh with vertices <code>VA</code> and
triangles <code>FA</code> and another mesh <code>VB</code> and <code>FB</code>, libigl first computes a unified
&ldquo;mesh arrangement&rdquo; (see <sup id="fnref:zhou_2016"><a class="footnote-ref" href="#fn:zhou_2016">36</a></sup>[]) with vertices <code>V</code> and triangles <code>F</code> where all triangle-triangle
intersections have been &ldquo;resolved&rdquo;. That is, edges and vertices are added
exactly at the intersection lines, so the resulting <em>non-manifold</em> mesh <code>(V,F)</code>
has no self-intersections.</p>
<p>Then libigl labels each &ldquo;cell&rdquo; bounded by surfaces of the arrangement according
to its <em>winding number vector</em>: winding number with respect to each input mesh
<span class="arithmatex"><span class="MathJax_Preview">(w_A,w_B)</span><script type="math/tex">(w_A,w_B)</script></span>. Finally, according to the desired operation (e.g. union,
intersection) the boundary of the corresponding cells are extracted.</p>
<p>Calling libigl&rsquo;s boolean operations is simple. To compute the union of
<code>(VA,FA)</code> and <code>(VB,FB)</code> into a new mesh <code>(VC,FC)</code>, use:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">copyleft</span><span class="o">::</span><span class="n">cgal</span><span class="o">::</span><span class="n">mesh_boolean</span><span class="p">(</span><span class="n">VA</span><span class="p">,</span><span class="n">FA</span><span class="p">,</span><span class="n">VB</span><span class="p">,</span><span class="n">FB</span><span class="p">,</span><span class="n">MESH_BOOLEAN_TYPE_UNION</span><span class="p">,</span><span class="n">VC</span><span class="p">,</span><span class="n">FC</span><span class="p">);</span>
</code></pre></div>
<p>The following figure shows each boolean operation on two meshes.</p>
<figure>
<p><img alt="" src="../images/cheburashka-knight-boolean.jpg" />
  </p>
<figcaption>
    The example <a href="https://github.com/libigl/libigl/tree/main/tutorial/609_Boolean/main.cpp">Boolean</a> conducts boolean operations on the <em>Cheburashka</em> (red) and <em>Knight</em> (green). From left to right: union, intersection, set minus, symmetric difference (XOR), &ldquo;resolve&rdquo;. Bottom row reveals inner surfaces, darker color indicates back-facing triangles.
  </figcaption>
</figure>
<p>The union, symmetric difference and &ldquo;resolve&rdquo; have the same outward
appearance, but differ in their treatment of internal structures. The union has
no internal surfaces: the triangles are not included in the output. The
symmetric difference is the same set of triangles as the &ldquo;resolve&rdquo;, but
internal surfaces have been reversed in orientation, indicating that the solid
result of the operation. The &ldquo;resolve&rdquo; operation is not really a boolean
operation, it is simply the result of resolving all intersections and gluing
together coincident vertices, maintaining original triangle orientations.</p>
<p>Libigl also provides a wrapper <code>igl::copyleft::cork::mesh_boolean</code> to the
<a href="https://github.com/gilbo/cork">cork</a>, which is typically faster, but is not
always robust.</p>
<h3 id="csg-tree">Csg Tree<a class="headerlink" href="#csg-tree" title="Permanent link">&para;</a></h3>
<p>The <a href="#boolean-operations-on-meshes">previous section</a> discusses using
<code>igl::copyleft::cgal::mesh_boolean</code> to compute the result of a <em>single</em> boolean
operation on two input triangle meshes. When employing constructive solid
geometry (CSG) as a modeling paradigm, shapes are represented as the result of
many such binary operations. The sequence is stored in a binary tree.</p>
<p>Libigl uses exact arithmetic internally to construct the intermediary boolean
results robustly. &ldquo;Rounding&rdquo; this result to floating point (even double
precision) would cause problems if re-injected into a further boolean
operation. To facilitate CSG tree operations and encourage callers <em>not</em> to
call <code>igl::copyleft::cgal::mesh_boolean</code> multiple times explicitly, libigl implements
a class <code>igl::copyleft::cgal::CSGTree</code>. Leaf nodes of this class are simply &ldquo;solid&rdquo;
meshes (otherwise good input to <code>igl::copyleft::cgal::mesh_boolean</code>). Interior nodes
of the tree combine two children with a boolean operation. Using the intializer
list constructor it is easy to hard-code specific tree constructions. Here&rsquo;s an
example taking the <em>intersection</em> of a cube A and sphere B <em>minus</em> the <em>union</em>
of three cylinders:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Compute result of (A  B) \ ((C  D)  E)</span>
<span class="n">igl</span><span class="o">::</span><span class="n">copyleft</span><span class="o">::</span><span class="n">cgal</span><span class="o">::</span><span class="n">CSGTree</span><span class="o">&lt;</span><span class="n">MatrixXi</span><span class="o">&gt;</span><span class="w"> </span><span class="n">CSGTree</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="n">VA</span><span class="p">,</span><span class="n">FA</span><span class="p">},{</span><span class="n">VB</span><span class="p">,</span><span class="n">FB</span><span class="p">},</span><span class="s">&quot;i&quot;</span><span class="p">},{</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">{</span><span class="n">VC</span><span class="p">,</span><span class="n">FC</span><span class="p">},{</span><span class="n">VD</span><span class="p">,</span><span class="n">FD</span><span class="p">},</span><span class="s">&quot;u&quot;</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="n">VE</span><span class="p">,</span><span class="n">FE</span><span class="p">},</span><span class="s">&quot;u&quot;</span><span class="p">},</span><span class="s">&quot;m&quot;</span><span class="p">};</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/cube-sphere-cylinders-csg-tree.jpg" />
  </p>
<figcaption>
    A CSG Tree represents a shape as a combination of binary boolean operations
  </figcaption>
</figure>
<p>Example <a href="https://github.com/libigl/libigl/tree/main/tutorial/610_CSGTree/main.cpp">610</a> computes each intermediary CSG result and
then the final composite.</p>
<figure>
<p><img alt="" src="../images/cube-sphere-cylinders-csg.gif" />
  </p>
<figcaption>
    Example <a href="https://github.com/libigl/libigl/tree/main/tutorial/610_CSGTree/main.cpp">610</a> computes  complex CSG Tree operation on 5 input meshes.
  </figcaption>
</figure>
<h2 id="chapter-7-miscellaneous">Chapter 7: Miscellaneous<a class="headerlink" href="#chapter-7-miscellaneous" title="Permanent link">&para;</a></h2>
<p>Libigl contains a <em>wide</em> variety of geometry processing tools and functions for
dealing with meshes and the linear algebra related to them: far too many to
discuss in this introductory tutorial. We&rsquo;ve pulled out a couple of the
interesting functions in this chapter to highlight.</p>
<h3 id="mesh-statistics">Mesh Statistics<a class="headerlink" href="#mesh-statistics" title="Permanent link">&para;</a></h3>
<p>Libigl contains various mesh statistics, including face angles, face areas and
the detection of singular vertices, which are vertices with more or less than 6
neighbours in triangulations or 4 in quadrangulations.</p>
<p>The example <a href="https://github.com/libigl/libigl/tree/main/tutorial/701_Statistics/main.cpp">Statistics</a> computes these quantities and
does a basic statistic analysis that allows to estimate the isometry and
regularity of a mesh:</p>
<div class="highlight"><pre><span></span><code>Irregular<span class="w"> </span>vertices:
<span class="m">136</span>/2400<span class="w"> </span><span class="o">(</span><span class="m">5</span>.67%<span class="o">)</span>
Areas<span class="w"> </span><span class="o">(</span>Min/Max<span class="o">)</span>/Avg_Area<span class="w"> </span>Sigma:
<span class="m">0</span>.01/5.33<span class="w"> </span><span class="o">(</span><span class="m">0</span>.87<span class="o">)</span>
Angles<span class="w"> </span><span class="k">in</span><span class="w"> </span>degrees<span class="w"> </span><span class="o">(</span>Min/Max<span class="o">)</span><span class="w"> </span>Sigma:
<span class="m">17</span>.21/171.79<span class="w"> </span><span class="o">(</span><span class="m">15</span>.36<span class="o">)</span>
</code></pre></div>
<p>The first row contains the number and percentage of irregular vertices, which
is particularly important for quadrilateral meshes when they are used to define
subdivision surfaces: every singular point will result in a point of the
surface that is only C^1.</p>
<p>The second row reports the area of the minimal element, maximal element and the
standard deviation.  These numbers are normalized by the mean area, so in the
example above 5.33 max area means that the biggest face is 5 times larger than
the average face. An ideal isotropic mesh would have both min and max area
close to 1.</p>
<p>The third row measures the face angles, which should be close to 60 degrees (90
for quads) in a perfectly regular triangulation. For FEM purposes, the closer
the angles are to 60 degrees the more stable will the optimization be. In this
case, it is clear that the mesh is of bad quality and it will probably result
in artifacts if used for solving PDEs.</p>
<h3 id="generalized-winding-number">Generalized Winding Number<a class="headerlink" href="#generalized-winding-number" title="Permanent link">&para;</a></h3>
<p>The problem of tetrahedralizing the interior of closed watertight surface mesh
is a difficult, but well-posed problem (see our <a href="#tetrahedralization-of-closed-surfaces">Tetgen wrappers</a>).  But
black-box tet-meshers like TetGen will <em>refuse</em> input triangle meshes with
self-intersections, open boundaries, non-manifold edges from multiple connected
components.
The problem is two-fold: self-intersections present contradictory facet
constraints and self-intersections/open-boundaries/non-manifold edges make the
problem of determining inside from outside ill-posed without further
assumptions.</p>
<p>The first problem is <em>easily</em> solved by &ldquo;resolving&rdquo; all self-intersections.
That is, meshing intersecting triangles so that intersects occur exactly at
edges and vertices. This is accomplished using <code>igl::selfintersect</code>.</p>
<p>TetGen can usually tetrahedralize the convex hull of this &ldquo;resolved&rdquo; mesh, and
then the problem becomes determining which of these tets are <em>inside</em> the input
mesh and which are outside. That is, which should be kept and which should be
removed.</p>
<p>The &ldquo;Generalized Winding Number&rdquo; is a robust method for determined
inside and outside for troublesome meshes <sup id="fnref:jacobson_2013"><a class="footnote-ref" href="#fn:jacobson_2013">40</a></sup>.  The generalized
winding number with respect to <code>(V,F)</code> at some point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p} \in
\mathcal{R}^3</span><script type="math/tex">\mathbf{p} \in
\mathcal{R}^3</script></span> is defined as scalar function:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
 w(\mathbf{p}) = \sum\limits_{f_i\in F} \frac{1}{4\pi}\Omega_{f_i}(\mathbf{p})
</div>
<script type="math/tex; mode=display">
 w(\mathbf{p}) = \sum\limits_{f_i\in F} \frac{1}{4\pi}\Omega_{f_i}(\mathbf{p})
</script>
</div>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\Omega_{f_i}</span><script type="math/tex">\Omega_{f_i}</script></span> is the <em>solid angle</em> subtended by <span class="arithmatex"><span class="MathJax_Preview">f_i</span><script type="math/tex">f_i</script></span> (the ith face in
<code>F</code>) at the point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>. This solid angle contribution is a simple,
closed-form expression involving <code>atan2</code> and some dot-products.</p>
<p>If <code>(V,F)</code> <em>does</em> form a closed watertight surface, then <span class="arithmatex"><span class="MathJax_Preview">w(\mathbf{p})=1</span><script type="math/tex">w(\mathbf{p})=1</script></span> if
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> lies inside <code>(V,F)</code> and <span class="arithmatex"><span class="MathJax_Preview">w(\mathbf{p})=0</span><script type="math/tex">w(\mathbf{p})=0</script></span> if outside <code>(V,F)</code>.  If
<code>(V,F)</code> is closed but overlaps itself then <span class="arithmatex"><span class="MathJax_Preview">w(\mathbf{p})</span><script type="math/tex">w(\mathbf{p})</script></span> is an integer value
counting how many (signed) times <code>(V,F)</code> <em>wraps</em> around <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span>.  Finally,
if <code>(V,F)</code> is not closed or not even manifold (but at least consistently
oriented), then <span class="arithmatex"><span class="MathJax_Preview">w(\mathbf{p})</span><script type="math/tex">w(\mathbf{p})</script></span> tends smoothly toward 1 as <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> is
<em>more</em> inside <code>(V,F)</code>, and toward 0 as <span class="arithmatex"><span class="MathJax_Preview">\mathbf{p}</span><script type="math/tex">\mathbf{p}</script></span> is more outside.</p>
<figure>
<p><img alt="" src="../images/big-sigcat-winding-number.gif" />
  </p>
<figcaption>
    Example <a href="https://github.com/libigl/libigl/tree/main/tutorial/702_WindingNumber/main.cpp">702</a> computes the generalized winding number function for a tetrahedral mesh inside a cat with holes and self intersections (gold). The silver mesh is surface of the extracted interior tets, and slices show the winding number function on all tets in the convex hull: blue (~0), green (~1), yellow (~2).
  </figcaption>
</figure>
<h3 id="mesh-decimation">Mesh Decimation<a class="headerlink" href="#mesh-decimation" title="Permanent link">&para;</a></h3>
<p>The study of mesh simplification or <em>decimation</em> is nearly as old as meshes
themselves. Given a high resolution mesh with too many triangles, find a &ldquo;well
approximating&rdquo; low resolution mesh with far fewer triangles. By now there are a
variety of different paradigms for solving this problem and state-of-the-art
methods are fairly advanced.</p>
<p>One family of mesh decimation methods operates by successively remove elements
from the mesh. In particular, Hoppe advocates for successively remove or rather
collapsing edges <sup id="fnref:hoppe_1996"><a class="footnote-ref" href="#fn:hoppe_1996">39</a></sup>[]. The generic form of this technique is to
construct a sequence of n meshes from the initial high-resolution mesh <span class="arithmatex"><span class="MathJax_Preview">M_0</span><script type="math/tex">M_0</script></span> to
the lowest resolution mesh <span class="arithmatex"><span class="MathJax_Preview">M_n</span><script type="math/tex">M_n</script></span> by collapsing a single edge:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">M_0 \mathop{\longrightarrow}_\text{edge collapse}
  M_1 \mathop{\longrightarrow}_\text{edge collapse}
  \dots \mathop{\longrightarrow}_\text{edge collapse}
  M_{n-1} \mathop{\longrightarrow}_\text{edge collapse} M_n.</span><script type="math/tex">M_0 \mathop{\longrightarrow}_\text{edge collapse}
  M_1 \mathop{\longrightarrow}_\text{edge collapse}
  \dots \mathop{\longrightarrow}_\text{edge collapse}
  M_{n-1} \mathop{\longrightarrow}_\text{edge collapse} M_n.</script></span></p>
<p>Hoppe&rsquo;s original method and subsequent follow-up works propose various ways to
choose the next edge to collapse in this sequence. Using a cost-based paradigm,
one can maintain a priority queue of edges based on their &ldquo;cost&rdquo; (how much
&ldquo;worse&rdquo; will my approximation be if I remove this edge?). The cheapest edge is
collapsed and costs of neighboring edges are updated.</p>
<p>In order to maintain the topology (e.g. if the mesh is combinatorially as
sphere or a torus etc.), one should assign infinite cost to edges whose
collapse would alter the mesh topology. Indeed this happens if and only if the
number of mutual neighbors of the endpoints of the collapsing edge is not
exactly two!</p>
<p>If there exists a third shared vertex, then another face will be removed, but 2
edges will be removed. This can result in unwanted holes or non-manifold
&ldquo;flaps&rdquo;.</p>
<figure>
<p><img alt="" src="../images/edge-collapse.jpg" />
  </p>
<figcaption>
    A valid edge collapse and an invalid edge collapse.
  </figcaption>
</figure>
<blockquote>
<p>There is also a one-off condition that no edges of a tetrahedron should be
collapsed.</p>
</blockquote>
<p>Because libigl (purposefully) does not center its implementations around a
dynamic mesh data structure (e.g. half-edge datastructure), support for
topology changes are limited. Nonetheless, libigl has support for isolated edge
collapses, sequences of edge-collapses (each in O(log) time) and priority queue
based decimation.</p>
<p>The simplest is <code>igl::decimation</code>. By calling</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">decimate</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="mi">1000</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">G</span><span class="p">);</span>
</code></pre></div>
<p>the mesh <code>(V,F)</code> will be decimated to a new mesh <code>(U,G)</code> so that <code>G</code> has at
most <code>1000</code> faces. This uses default (naive) criteria for determining the cost
of an edge collapse and the placement of the merged vertex. Shortest edges are
collapsed first, and merged vertices are placed at edge midpoints.</p>
<p>One can also provide function handles (<code>c++</code> lambda functions are convenient
here) <code>cost_and_placement</code> and <code>stopping_condition</code> for determining the
cost/placement of an edge collapse and the stopping condition respectively. For
example, the default version above is implemented as:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">decimate</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">shortest_edge_and_midpoint</span><span class="p">,</span><span class="n">max_m</span><span class="p">,</span><span class="n">U</span><span class="p">,</span><span class="n">G</span><span class="p">);</span>
</code></pre></div>
<p>where <code>shortest_edge_and_midpoint</code> assign the edge&rsquo;s length as cost and its
midpoint as the merged vertex placement and <code>max_m</code> counts the current number
of faces (valid collapses decrease count by 2) and returns <code>true</code> if the count
drops below <code>m=1000</code>.</p>
<p>One can also scratch deeper inside the decimation loop and call
<code>igl::collapse_edge</code> directly. In order to operate efficiently, this routine
needs more than the usual <code>(V,F)</code> mesh representation. We need <code>E</code> a list of
edge indices, where <code>E.row(i) --&gt; [s,d]</code>; we need <code>EMAP</code> which maps the
&ldquo;half&rdquo;-edges of each triangle in <code>F</code> to its corresponding edge in <code>E</code> so that
<code>E.row(EMAP(f+i*F.rows)) --&gt; [s,d]</code> if the edge across from the ith corner of the
fth face is <code>[s,d]</code> (up to orientation); we need <code>EF</code> and <code>EI</code> which keep track
of the faces incident on each edge and across from which corner of those faces
the edges appears, so that <code>EF(e,o) = f</code> and <code>EI(e,o) = i</code> means that the edge
<code>E.row(e) --&gt; [s,d]</code> appears in the fth face across from its ith corner (for
<code>o=0</code> the edge orientations should match, for <code>o=1</code> the orientations are
opposite).</p>
<p>When a collapse occurs, the sizes of the <code>F</code>,<code>E</code>, etc. matrices do not change.
Rather rows corresponding to &ldquo;removed&rdquo; faces and edges are set to a special
constant value <code>IGL_COLLAPSE_EDGE_NULL</code>. Doing this ensures that we&rsquo;re able to
remove edges in truly constant time O(1).</p>
<blockquote>
<p>Conveniently <code>IGL_COLLAPSE_EDGE_NULL==0</code>. This means most OPENGL style renderings of <code>F</code>
will simply draw a bunch of 0-area triangles at the first vertex.</p>
</blockquote>
<p>The following will collapse the first
edge and place its merged vertex at the origin:</p>
<p><div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">collapse_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">RowVector3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">EMAP</span><span class="p">,</span><span class="n">EF</span><span class="p">,</span><span class="n">EI</span><span class="p">);</span>
</code></pre></div>
If valid, then <code>V</code>,<code>F</code>,<code>E</code>,<code>EF</code>,<code>EI</code> are adjusted accordingly.</p>
<p>This is powerful, but low level. To build a decimator around this you&rsquo;d need to
keep track which edges are left to collapse and which to collapse next.
Fortunately, libigl also exposes a priority queue based edge collapse with
function handles to adjust costs and placements.</p>
<p>The priority queue is implemented as a (ordered) set <code>Q</code> or (cost,edge index)
pairs and a list of iterators <code>Qit</code> so that <code>Qit[e]</code> reveals the iterator in
<code>Q</code> corresponding to the eth edge. Placements are stored in a #E list of
positions <code>C</code>. When the following is called:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">collapse_edge</span><span class="p">(</span><span class="n">cost_and_placement</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">EMAP</span><span class="p">,</span><span class="n">EF</span><span class="p">,</span><span class="n">EI</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">Qit</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</code></pre></div>
<p>the lowest cost edge collapse according to <code>Q</code> is attempted. If valid, then
<code>V</code>,<code>F</code>,etc. are adjusted accordingly and that edge is &ldquo;popped&rdquo; from <code>Q</code>. Using
<code>Qit</code> its neighboring edges are also popped from <code>Q</code> and re-inserted after
updating their costs according to <code>cost_and_placement</code>, new placements are
remembered in <code>C</code>. If not valid, then the edge is &ldquo;popped&rdquo; from <code>Q</code> and
reinserted with infinite cost.</p>
<figure>
<p><img alt="" src="../images/fertility-edge-collapse.gif" />
  </p>
<figcaption>
    Example 703 conducts edge collapses on the fertility model.
  </figcaption>
</figure>
<p>The <a href="https://github.com/libigl/libigl/tree/main/tutorial/703_Decimation/main.cpp">Example 703</a> demonstrates using this priority
queue based approach with the simple shortest-edge-midpoint cost/placement
strategy discussed above.</p>
<h3 id="signed-distances">Signed Distances<a class="headerlink" href="#signed-distances" title="Permanent link">&para;</a></h3>
<p>In the <a href="#generalized-winding-number">Generalized Winding Number section</a>, we
examined a robust method for determining whether points lie inside or outside
of a given triangle soup mesh. Libigl complements this algorithm with
accelerated signed and unsigned distance queries and &ldquo;in element&rdquo; queries for
planar triangle meshes and 3D tetrahedral meshes. These routines make use of
libigl&rsquo;s general purpose axis-aligned bounding box hierarchy (<code>igl/AABB.h</code>).
This class is lightweight and&mdash;by design&mdash;does not store a copy of the mesh
(taking it as inputs to its member functions instead).</p>
<h4 id="point-location">Point Location<a class="headerlink" href="#point-location" title="Permanent link">&para;</a></h4>
<p>For tetrahedral meshes, this is useful for &ldquo;in element&rdquo; or &ldquo;point location&rdquo;
queries: given a point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}\in\mathcal{R}^3</span><script type="math/tex">\mathbf{q}\in\mathcal{R}^3</script></span> and a tetrahedral mesh
<span class="arithmatex"><span class="MathJax_Preview">(V,T)</span><script type="math/tex">(V,T)</script></span> determine in which tetrahedron <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> lies. This is accomplished
in libigl for a tet mesh <code>V,T</code> and a list of query points in the rows of <code>Q</code>
via the <code>igl::in_element()</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Initialize AABB tree</span>
<span class="n">igl</span><span class="o">::</span><span class="n">AABB</span><span class="o">&lt;</span><span class="n">MatrixXd</span><span class="p">,</span><span class="mi">3</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="n">tree</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">T</span><span class="p">);</span>
<span class="n">VectorXi</span><span class="w"> </span><span class="n">I</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">in_element</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">tree</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</code></pre></div>
<p>the resulting vector <code>I</code> is a list of indices into <code>T</code> revealing the <em>first</em>
tetrahedron found to contain the corresponding point in <code>Q</code>.</p>
<p>For overlapping meshes, a point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> may belong to more than one
tetrahedron. In those cases, one can find them all (not just the first) by
using the <code>igl::in_element</code> overload with a <code>SparseMatrix</code> as the output:</p>
<div class="highlight"><pre><span></span><code><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">I</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">in_element</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">T</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">tree</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</code></pre></div>
<p>now each row of <code>I</code> reveals whether each tet contains the corresponding row in
<code>Q</code>: <code>I(q,e)!=0</code> means that point <code>q</code> is in element <code>e</code>.</p>
<h4 id="closest-points">Closest Points<a class="headerlink" href="#closest-points" title="Permanent link">&para;</a></h4>
<p>For Triangle meshes, we use the AABB tree to accelerate point-mesh closest
point queries: given a mesh <span class="arithmatex"><span class="MathJax_Preview">(V,F)</span><script type="math/tex">(V,F)</script></span> and a query point
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}\in\mathcal{R}^3</span><script type="math/tex">\mathbf{q}\in\mathcal{R}^3</script></span> find the closest point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c} \in (V,F)</span><script type="math/tex">\mathbf{c} \in (V,F)</script></span>
(where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span> is not necessarily a vertex of <span class="arithmatex"><span class="MathJax_Preview">(V,F)</span><script type="math/tex">(V,F)</script></span>). This is
accomplished for a triangle mesh <code>V,F</code> and a list of points in the rows of <code>P</code>
via <code>igl::point_mesh_squared_distance</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">VectorXd</span><span class="w"> </span><span class="n">sqrD</span><span class="p">;</span>
<span class="n">VectorXi</span><span class="w"> </span><span class="n">I</span><span class="p">;</span>
<span class="n">MatrixXd</span><span class="w"> </span><span class="n">C</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">point_mesh_squared_distance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">sqrD</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</code></pre></div>
<p>the output <code>sqrD</code> contains the (unsigned) squared distance from each point in
<code>P</code> to its closest point given in <code>C</code> which lies on the element in <code>F</code> given by
<code>I</code> (e.g. from which one could recover barycentric coordinates, using
<code>igl::barycentric_coordinates</code>).</p>
<p>If the mesh <code>V,F</code> is static, but the point set <code>P</code> is changing dynamically then
it&rsquo;s best to reuse the AABB hierarchy that&rsquo;s being built during
<code>igl::point_mesh_squared_distance</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">AABB</span><span class="w"> </span><span class="n">tree</span><span class="p">;</span>
<span class="n">tree</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">);</span>
<span class="n">tree</span><span class="p">.</span><span class="n">squared_distance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">sqrD</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
<span class="p">...</span><span class="w"> </span><span class="c1">// P changes, but (V,F) does not</span>
<span class="n">tree</span><span class="p">.</span><span class="n">squared_distance</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="n">sqrD</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</code></pre></div>
<h4 id="signed-distance">Signed Distance<a class="headerlink" href="#signed-distance" title="Permanent link">&para;</a></h4>
<p>Finally, from the closest point or the winding number it&rsquo;s possible to <em>sign</em>
this distance. In <code>igl::signed_distance</code> we provide two methods for signing:
the so-called &ldquo;pseudo-normal test&rdquo; <sup id="fnref:baerentzen_2005"><a class="footnote-ref" href="#fn:baerentzen_2005">37</a></sup>[] and the generalized
winding number <sup id="fnref2:jacobson_2013"><a class="footnote-ref" href="#fn:jacobson_2013">40</a></sup>[].</p>
<p>The pseudo-normal test (see also <code>igl::pseudonormal_test</code>) assumes the input
mesh is a watertight (closed, non-self-intersecting, manifold) mesh. Then given
a query point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> and its closest point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c} \in (V,F)</span><script type="math/tex">\mathbf{c} \in (V,F)</script></span>, it
carefully chooses an outward normal <span class="arithmatex"><span class="MathJax_Preview">\mathbf{n}</span><script type="math/tex">\mathbf{n}</script></span> at <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span> so that
<span class="arithmatex"><span class="MathJax_Preview">\text{sign}(\mathbf{q}-\mathbf{c})\cdot \mathbf{n}</span><script type="math/tex">\text{sign}(\mathbf{q}-\mathbf{c})\cdot \mathbf{n}</script></span> reveals whether
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{q}</span><script type="math/tex">\mathbf{q}</script></span> is inside <span class="arithmatex"><span class="MathJax_Preview">(V,F)</span><script type="math/tex">(V,F)</script></span>: -1, or outside: +1. This is a fast <span class="arithmatex"><span class="MathJax_Preview">O(1)</span><script type="math/tex">O(1)</script></span> test
once <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span> is located, but may fail if <code>V,F</code> is not watertight.</p>
<p>An alternative is to use the <a href="#generalized-winding-number">generalized winding
number</a> to determine the sign. This is very robust to
unclean meshes <code>V,F</code> but slower: something like <span class="arithmatex"><span class="MathJax_Preview">O(\sqrt{n})</span><script type="math/tex">O(\sqrt{n})</script></span> once <span class="arithmatex"><span class="MathJax_Preview">\mathbf{c}</span><script type="math/tex">\mathbf{c}</script></span>
is located.</p>
<p>In either case, the interface via <code>igl::signed_distance</code> is:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Choose type of signing to use</span>
<span class="n">igl</span><span class="o">::</span><span class="n">SignedDistanceType</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIGNED_DISTANCE_TYPE_PSEUDONORMAL</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">signed_distance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">sign_type</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">N</span><span class="p">);</span>
</code></pre></div>
<p>the outputs are as above for <code>igl::point_mesh_squared_distance</code> but now <code>S</code>
contains signed (unsquared) distances and the extra output <code>N</code> (only set when
<code>type == SIGNED_DISTANCE_TYPE_PSEUDON</code>) contains the normals used for signing
with the pseudo-normal test.</p>
<figure>
<p><img alt="" src="../images/bunny-signed-distance.gif" />
  </p>
<figcaption>
    Example <a href="https://github.com/libigl/libigl/tree/main/tutorial/704_SignedDistance/main.cpp">704</a> computes signed distance on slices through the bunny.
  </figcaption>
</figure>
<h3 id="marching-cubes">Marching Cubes<a class="headerlink" href="#marching-cubes" title="Permanent link">&para;</a></h3>
<p>Often 3D data is captured as scalar field defined over space <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x}) :
\mathcal{R}^3 \rightarrow \mathcal{R}</span><script type="math/tex">f(\mathbf{x}) :
\mathcal{R}^3 \rightarrow \mathcal{R}</script></span>. Lurking within this field,
<em>iso-surfaces</em> of the scalar field are often salient geometric objects. The
iso-surface at value <span class="arithmatex"><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is composed of all points <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> in
<span class="arithmatex"><span class="MathJax_Preview">\mathcal{R}^3</span><script type="math/tex">\mathcal{R}^3</script></span> such that <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x}) = v</span><script type="math/tex">f(\mathbf{x}) = v</script></span>. A core problem in geometry
processing is to extract an iso-surface as a triangle mesh for further
mesh-based processing or visualization. This is referred to as iso-contouring.</p>
<p>&ldquo;Marching Cubes&rdquo; <sup id="fnref:lorensen_1987"><a class="footnote-ref" href="#fn:lorensen_1987">42</a></sup> is a <a href="https://en.wikipedia.org/wiki/Marching_cubes">famous
method</a> for iso-contouring
tri-linear functions <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> on a regular lattice (aka grid). The core idea of this
method is to contour the iso-surface passing through each cell  (if it does at
all) with a predefined topology (aka connectivity) chosen from a look up table
depending on the function values at each vertex of the cell. The method
iterates (&ldquo;marches&rdquo;) over all cells (&ldquo;cubes&rdquo;) in the grid and stitches together
the final, watertight mesh.</p>
<p>In libigl, <code>igl::marching_cubes</code> constructs a triangle mesh <code>(V,F)</code> from an
input scalar field <code>S</code> sampled at vertex locations <code>GV</code> of a <code>nx</code> by <code>ny</code> by
<code>nz</code> regular grid:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">marching_cubes</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">GV</span><span class="p">,</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="../images/armadillo-marching-cubes.jpg" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/705_MarchingCubes/main.cpp">Example 705</a>) samples signed distance to the input mesh (left) and then reconstructs the surface using marching cubes to contour the 0-level set (center). For comparison, clamping this signed distance field to an indicator function and contouring reveals serious aliasing artifacts.
  </figcaption>
</figure>
<h3 id="facet-orientation">Facet Orientation<a class="headerlink" href="#facet-orientation" title="Permanent link">&para;</a></h3>
<p>Models from the web occasionally arrive <em>unorientated</em> in the sense that
the orderings of each triangles vertices do not consistently agree. Determining
a consistent facet orientation for a mesh is essential for two-sided lighting
(e.g., a cloth with red velvet on one side and gold silk on the other side) and
for inside-outside determination(e.g., using <a href="#generalized-winding-number">generalized winding
numbers</a>).</p>
<p>For (open) surfaces representing two-sided sheets, libigl provides a routine to
force consistent orientations within each orientable patch
(<code>igl::orientable_patches</code>) of a mesh:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">bfs_orient</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="n">FF</span><span class="p">,</span><span class="n">C</span><span class="p">);</span>
</code></pre></div>
<p>This simple routine will use breadth-first search on each patch of the mesh to
enforce a consistent facet orientation in the output faces <code>FF</code>.</p>
<p>For (closed or nearly closed) surfaces representing the boundary of a solid
object, libigl provides a routine to reorient faces so that the vertex ordering
corresponds to a counter-clockwise ordering of the vertices with a
right-hand-rule normal pointing outward. This method <sup id="fnref:takayama14"><a class="footnote-ref" href="#fn:takayama14">45</a></sup>[] assumes
that <a href="https://www.reddit.com/r/askscience/comments/32otgx/which_as_a_is_more_empty_an_atom_or_the_universe/">most of the universe is
empty</a>.
That is, most points in space are outside of the solid object than inside.
Points are sampled over surface patches. For each sample point, rays are shot
into both hemispheres to compute average of the (distance weighted) ambient
occlusion on each side. A patch is oriented so that the outward side is <em>less
occluded</em> (lighter, i.e., facing more void space).</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">embree</span><span class="o">::</span><span class="n">reorient_facets_raycast</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">FF</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
</code></pre></div>
<p>The boolean vector <code>I</code> reveals which rows of <code>F</code> have been flipped in <code>FF</code>.</p>
<figure>
<p><img alt="" src="../images/truck-facet-orientation.jpg" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/706_FacetOrientation/main.cpp">Example 706</a>) loads a truck model with inconsistent orientations (back facing triangles shown darker). Orientable patches are uniquely colored and then oriented to face outward (middle left). Alternatively, each individual triangle is considered a &ldquo;patch&rdquo; (middle right) and oriented outward independently.
  </figcaption>
</figure>
<h3 id="swept-volume">Swept Volume<a class="headerlink" href="#swept-volume" title="Permanent link">&para;</a></h3>
<p>The swept volume <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span> of a moving solid object <span class="arithmatex"><span class="MathJax_Preview">A</span><script type="math/tex">A</script></span> can be defined as any point in
space such that at one moment in time the point lies inside the solid. In other
words, it is the union of the solid object transformed by the rigid motion
<span class="arithmatex"><span class="MathJax_Preview">f(t)</span><script type="math/tex">f(t)</script></span> over time:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">S = \bigcup \limits_{t\in [0,1]} f(t) A.</span><script type="math/tex">S = \bigcup \limits_{t\in [0,1]} f(t) A.</script></span></p>
<p>The surface of the swept volume of a solid bounded by a triangle mesh
undergoing a rigid motion with non-trivial rotation is <em><strong>not</strong></em> a surface
exactly representably by triangle mesh: it will be a piecewise-ruled surface.</p>
<p>To see this, consider the surface swept by a single edge&rsquo;s line segment as it
performs a screw motion.</p>
<p>This means that if we&rsquo;d like to the surface of the swept volume of a triangle
mesh undergoing a rigid motion and we&rsquo;d like the output to be another triangle
mesh, then we&rsquo;re going to have to be happy with some amount of approximation
error.</p>
<p>With this in mind, the simplest method for computing an approximate swept
volume is by exploiting an alternative definition of the swept volume based on
signed distances:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">S = \left\{ \mathbf{p}\ \middle| \ d(\mathbf{p},\partial S) &lt; 0 \right\} = \left\{ \mathbf{p}\
\middle|\
\min\limits_{t \in [0,1]} d(\mathbf{p},f(t)\ \partial A) &lt; 0 \right\}</span><script type="math/tex">S = \left\{ \mathbf{p}\ \middle| \ d(\mathbf{p},\partial S) < 0 \right\} = \left\{ \mathbf{p}\
\middle|\
\min\limits_{t \in [0,1]} d(\mathbf{p},f(t)\ \partial A) < 0 \right\}</script></span></p>
<p>If <span class="arithmatex"><span class="MathJax_Preview">\partial A</span><script type="math/tex">\partial A</script></span> is a triangle mesh, then we can approximate this by 1)
discretizing time at a finite step of steps <span class="arithmatex"><span class="MathJax_Preview">[0,\Delta t,2\Delta t, \dots, 1]</span><script type="math/tex">[0,\Delta t,2\Delta t, \dots, 1]</script></span>
and by 2) discretizing space with a regular grid and representing the distance
field using trilinear interpolation of grid values. Finally the output mesh,
<span class="arithmatex"><span class="MathJax_Preview">\partial S</span><script type="math/tex">\partial S</script></span> is approximated by contouring using Marching Cubes
<sup id="fnref2:lorensen_1987"><a class="footnote-ref" href="#fn:lorensen_1987">42</a></sup>.</p>
<p>This method is similar to one described by Schroeder et al. in 1994
<sup id="fnref:schroeder_1994"><a class="footnote-ref" href="#fn:schroeder_1994">44</a></sup>, and the one used in conjunction with boolean operations by
Garg et al. 2016 <sup id="fnref:garg_2016"><a class="footnote-ref" href="#fn:garg_2016">38</a></sup>.</p>
<p>In libigl, if your input solid&rsquo;s surface is represented by <code>(V,F)</code> then the
output surface mesh will be <code>(SV,SF)</code> after calling:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">copyleft</span><span class="o">::</span><span class="n">swept_volume</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">num_time_steps</span><span class="p">,</span><span class="n">grid_size</span><span class="p">,</span><span class="n">isolevel</span><span class="p">,</span><span class="n">SV</span><span class="p">,</span><span class="n">SF</span><span class="p">);</span>
</code></pre></div>
<p>The <code>isolevel</code> parameter can be set to zero to approximate the exact swept
volume, greater than zero to approximate a positive offset of the swept volume
or less than zero to approximate a negative offset.</p>
<figure>
<p><img alt="" src="../images/bunny-swept-volume.gif" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/707_SweptVolume/main.cpp">Example 707</a>) computes the surface of the swept volume (silver) of the bunny model undergoing a rigid motion (gold).
  </figcaption>
</figure>
<h3 id="picking">Picking<a class="headerlink" href="#picking" title="Permanent link">&para;</a></h3>
<p>Picking vertices and faces using the mouse is very common in geometry
processing applications. While this might seem a simple operation, its
implementation is not straightforward. Libigl contains a function that solves this problem using the
<a href="https://software.intel.com/en-us/articles/embree-photo-realistic-ray-tracing-kernels">Embree</a>
raycaster. Its usage is demonstrated in <a href="https://github.com/libigl/libigl/tree/main/tutorial/708_Picking/main.cpp">Example 708</a>:</p>
<div class="highlight"><pre><span></span><code><span class="kt">bool</span><span class="w"> </span><span class="n">hit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">igl</span><span class="o">::</span><span class="n">unproject_onto_mesh</span><span class="p">(</span>
<span class="w">  </span><span class="n">Vector2f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span>
<span class="w">  </span><span class="n">F</span><span class="p">,</span>
<span class="w">  </span><span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">model</span><span class="p">,</span>
<span class="w">  </span><span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">proj</span><span class="p">,</span>
<span class="w">  </span><span class="n">viewer</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">viewport</span><span class="p">,</span>
<span class="w">  </span><span class="o">*</span><span class="n">ei</span><span class="p">,</span>
<span class="w">  </span><span class="n">fid</span><span class="p">,</span>
<span class="w">  </span><span class="n">bc</span><span class="p">);</span>
</code></pre></div>
<p>This function casts a ray from the view plane in the view direction. Variables
<code>x</code> and <code>y</code> are
the mouse screen coordinates; <code>view</code>, <code>model</code>, <code>proj</code> are the view, model and
projection matrix respectively; <code>viewport</code> is the viewport in OpenGL format;
<code>ei</code>
contains a <a href="http://en.wikipedia.org/wiki/Bounding_volume_hierarchy">Bounding Volume
Hierarchy</a> constructed
by Embree, and <code>fid</code> and <code>bc</code> are the picked face and barycentric coordinate of the picked position, respectively.</p>
<figure>
<p><img alt="" src="../images/708_Picking.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/708_Picking/main.cpp">Example 708</a>) Picking via ray casting. The selected faces are colored in red.
  </figcaption>
</figure>
<h3 id="scalable-locally-injective-maps">Scalable Locally Injective Maps<a class="headerlink" href="#scalable-locally-injective-maps" title="Permanent link">&para;</a></h3>
<p>The Scalable Locally Injective Maps <sup id="fnref:rabinovich_2016"><a class="footnote-ref" href="#fn:rabinovich_2016">43</a></sup> algorithm allows to
compute locally injective maps on massive datasets. The algorithm shares many
similarities with ARAP, but uses a reweighting scheme to minimize arbitrary
distortion energies, including those that prevent the introduction of flips.</p>
<p><a href="https://github.com/libigl/libigl/tree/main/tutorial/709_SLIM/main.cpp">Example 709</a> contains three demos: (1) an example of large
scale 2D parametrization, (2) an example of 2D deformation with soft
constraints, and (3) an example of 3D deformation with soft constraints. The
implementation in libigl is self-contained and relies on Eigen for the solution
of the linear system used in the global step. An optimized version that relies
on Pardiso is available
<a href="https://github.com/MichaelRabinovich/Scalable-Locally-Injective-Mappings">here</a>.</p>
<figure>
<p><img alt="" src="../images/slim.png" />
  </p>
<figcaption>
    A locally injective parametrization of a mesh with 50k faces is computed using the SLIM algorithm in 10 iterations.
  </figcaption>
</figure>
<h3 id="simplicial-complex-augmentation-framework-for-bijective-maps">Simplicial Complex Augmentation Framework For Bijective Maps<a class="headerlink" href="#simplicial-complex-augmentation-framework-for-bijective-maps" title="Permanent link">&para;</a></h3>
<p>The Simplicial Complex Augmentation Framework  <sup id="fnref:jiang_2017"><a class="footnote-ref" href="#fn:jiang_2017">49</a></sup> algorithm allows to
compute bijective maps efficiently and robustly.
The algorithm constructed a scaffold structure to take advantage of efficient locally injective mapping algorithms like SLIM, guarantees a overlapping free map with low distortion while being efficient and scalable.</p>
<p><a href="https://github.com/libigl/libigl/tree/main/tutorial/710_SCAF/main.cpp">Example 710</a> contains a demo of bijective parameterizing a camel mesh.</p>
<p><img alt="A bijective parametrization of a mesh
using the SCAF algorithm in 10 iterations." src="../images/simplicial_complex_augmentation_framework.png" /></p>
<h3 id="subdivision-surfaces">Subdivision Surfaces<a class="headerlink" href="#subdivision-surfaces" title="Permanent link">&para;</a></h3>
<p>Given a coarse mesh (aka cage) with vertices <code>V</code> and faces <code>F</code>, one can create a
higher-resolution mesh with more vertices and faces by <em>subdividing</em> every
face. That is, each coarse triangle in the input is replaced by many smaller
triangles. Libigl has three different methods for subdividing a triangle mesh.</p>
<p>An &ldquo;in plane&rdquo; subdivision method will not change the point set or carrier
surface of the mesh. New vertices are added on the planes of existing triangles
and vertices surviving from the original mesh are not moved.</p>
<p>By adding new faces, a subdivision algorithm changes the <em>combinatorics</em> of the
mesh. The change in combinatorics and the formula for positioning the
high-resolution vertices is called the &ldquo;subdivision rule&rdquo;.</p>
<p>For example, in the <em>in plane</em> subdivision method of <code>igl::upsample</code>, vertices
are added at the midpoint of every edge: <span class="arithmatex"><span class="MathJax_Preview">v_{ab} = \frac{1}{2}(v_a + v_b)</span><script type="math/tex">v_{ab} = \frac{1}{2}(v_a + v_b)</script></span> and
each triangle <span class="arithmatex"><span class="MathJax_Preview">(i_a,i_b,i_c)</span><script type="math/tex">(i_a,i_b,i_c)</script></span> is replaced with four triangles:
<span class="arithmatex"><span class="MathJax_Preview">(i_a,i_{ab},i_{ca})</span><script type="math/tex">(i_a,i_{ab},i_{ca})</script></span>, <span class="arithmatex"><span class="MathJax_Preview">(i_b,i_{bc},i_{ab})</span><script type="math/tex">(i_b,i_{bc},i_{ab})</script></span>, <span class="arithmatex"><span class="MathJax_Preview">(i_{ab},i_{bc},i_{ca})</span><script type="math/tex">(i_{ab},i_{bc},i_{ca})</script></span>, and
<span class="arithmatex"><span class="MathJax_Preview">(i_{bc},i_{c},i_{ca})</span><script type="math/tex">(i_{bc},i_{c},i_{ca})</script></span>. This process may be applied recursively, resulting in
a finer and finer mesh.</p>
<p>The subdivision method of <code>igl::loop</code> is not in plane. The vertices of the
refined mesh are moved to weight combinations of their neighbors: the mesh is
smoothed as it is refined <sup id="fnref:loop_1987"><a class="footnote-ref" href="#fn:loop_1987">41</a></sup>. This and other <em>smooth subdivision</em>
methods can be understood as generalizations of spline curves to surfaces. In
particular the Loop subdivision method will converge to a <span class="arithmatex"><span class="MathJax_Preview">C^1</span><script type="math/tex">C^1</script></span> surface as we
consider the limit of recursive applications of subdivision. Away from
&ldquo;irregular&rdquo; or &ldquo;extraordinary&rdquo; vertices (vertices of the original cage with
valence not equal to 6), the surface is <span class="arithmatex"><span class="MathJax_Preview">C^2</span><script type="math/tex">C^2</script></span>. The combinatorics (connectivity
and number of faces) of <code>igl::loop</code> and <code>igl::upsample</code> are identical: the only
difference is that the vertices have been smoothed in <code>igl::loop</code>.</p>
<p>Finally, libigl also implements a form of <em>in plane</em> &ldquo;false barycentric
subdivision&rdquo; in <code>igl::false_barycentric_subdivision</code>. This method simply adds
the barycenter of every triangle as a new vertex <span class="arithmatex"><span class="MathJax_Preview">v_{abc}</span><script type="math/tex">v_{abc}</script></span> and replaces each
triangle with three triangles <span class="arithmatex"><span class="MathJax_Preview">(i_a,i_b,i_{abc})</span><script type="math/tex">(i_a,i_b,i_{abc})</script></span>, <span class="arithmatex"><span class="MathJax_Preview">(i_b,i_c,i_{abc})</span><script type="math/tex">(i_b,i_c,i_{abc})</script></span>, and
<span class="arithmatex"><span class="MathJax_Preview">(i_c,i_a,i_{abc})</span><script type="math/tex">(i_c,i_a,i_{abc})</script></span>. In contrast to <code>igl::upsample</code>, this method will create
triangles with smaller and smaller internal angles and new vertices will sample
the carrier surfaces with extreme bias.</p>
<figure>
<p><img alt="" src="../images/decimated-knight-subdivision.gif" />
  </p>
<figcaption>
    The original coarse mesh and three different subdivision methods: <code>igl::upsample</code>, <code>igl::loop</code> and <code>igl::false_barycentric_subdivision</code>.
  </figcaption>
</figure>
<h3 id="data-smoothing">Data Smoothing<a class="headerlink" href="#data-smoothing" title="Permanent link">&para;</a></h3>
<p>A noisy function <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> defined on a surface <span class="arithmatex"><span class="MathJax_Preview">\Omega</span><script type="math/tex">\Omega</script></span> can be smoothed using an
energy minimization that balances a smoothing term <span class="arithmatex"><span class="MathJax_Preview">E_S</span><script type="math/tex">E_S</script></span> with a quadratic
fitting term:</p>
<p><span class="arithmatex"><span class="MathJax_Preview">u = \operatorname{argmin}_u \alpha E_S(u) + (1-\alpha)\int_\Omega ||u-f||^2 dx</span><script type="math/tex">u = \operatorname{argmin}_u \alpha E_S(u) + (1-\alpha)\int_\Omega ||u-f||^2 dx</script></span></p>
<p>The parameter <span class="arithmatex"><span class="MathJax_Preview">\alpha</span><script type="math/tex">\alpha</script></span> determines how aggressively the function is smoothed.</p>
<p>A classical choice for the smoothness energy is the Laplacian energy of the
function with zero Neumann boundary conditions, which is a form of the
biharmonic energy. It is constructed using the cotangent Laplacian <code>L</code> and
the mass matrix <code>M</code>: <code>QL = L'*(M\L)</code>. Because of the implicit zero Neumann
boundary conditions however, the function behavior is significantly warped at
the boundary if <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> does not have zero normal gradient at the boundary.</p>
<p>In <sup id="fnref:stein_2018"><a class="footnote-ref" href="#fn:stein_2018">51</a></sup> it is suggested to use the Biharmonic energy with natural
Hessian boundary conditions instead, which corresponds to the Hessian energy
with the matrix <code>QH = H'*(M2\H)</code>, where <code>H</code> is a finite element Hessian and
<code>M2</code> is a stacked mass matrix. The matrices <code>H</code> and <code>QH</code> are implemented in
libigl as <code>igl::hessian</code> and <code>igl::hessian_energy</code> respectively. An example
of how to use the function is given in <a href="https://github.com/libigl/libigl/tree/main/tutorial/712_DataSmoothing/main.cpp">Example 712</a>.</p>
<p>In the following image the differences between the Laplacian energy with
zero Neumann boundary conditions and the Hessian energy can be clearly seen:
whereas the zero Neumann boundary condition in the third image bias the isolines
of the function to be perpendicular to the boundary, the Hessian energy gives
an unbiased result.</p>
<figure>
<p><img alt="" src="../images/712_beetles.jpg" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/712_DataSmoothing/main.cpp">Example 712</a>) From left to right: a function on the beetle mesh, the function with added noise, the result of smoothing with the Laplacian energy and zero Neumann boundary conditions, and the result of smoothing with the Hessian energy.
  </figcaption>
</figure>
<h3 id="shapeup-projections">Shapeup Projections<a class="headerlink" href="#shapeup-projections" title="Permanent link">&para;</a></h3>
<p>Our input is a set of points <span class="arithmatex"><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> (not necessarily part of any mesh), and a set of constraints <span class="arithmatex"><span class="MathJax_Preview">S=\left\{S_1,S_2,...S_m\right\}</span><script type="math/tex">S=\left\{S_1,S_2,...S_m\right\}</script></span>, where each constraint is defined on a different, and sparse, subset of <span class="arithmatex"><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span>. We wish to create a new set of points <span class="arithmatex"><span class="MathJax_Preview">P</span><script type="math/tex">P</script></span> that are close to the original set <span class="arithmatex"><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> (each point with corresponding indices), while adhering to the constraints. Other objectives, such as smoothness, can be employed. The constraints can be nonlinear, which makes the problem nonconvex, difficult, and without a guaranteed global optimum. A very popular lightweight approach to such problems is a local-global iterative algorithm, comprising these two steps:</p>
<p>For iteration <span class="arithmatex"><span class="MathJax_Preview">k</span><script type="math/tex">k</script></span>:
1. <em>Local step</em>: compute the projections of the set <span class="arithmatex"><span class="MathJax_Preview">P_{k-1}</span><script type="math/tex">P_{k-1}</script></span> onto <span class="arithmatex"><span class="MathJax_Preview">S</span><script type="math/tex">S</script></span>, individually per constraint; that would mean fragmenting each point that appears in multiple constraints. That can be a nonlinear operation, but if the constraints are sparse, it is a a set of many small systems.
2. <em>Global step</em>: integrate the set <span class="arithmatex"><span class="MathJax_Preview">P_k</span><script type="math/tex">P_k</script></span> to be as close as possible to the projected fragmented set, with auxiliary objective functions possible. That results in a global, but quadratic objective function. Moreover, the resulting linear system has a constant matrix, and therefore can be pre-factored.</p>
<p>The version we implement in libigl is the general version described by <sup id="fnref2:bouaziz_2012"><a class="footnote-ref" href="#fn:bouaziz_2012">27</a></sup>, and is in two files: <code>&lt;igl/shapeup.h&gt;</code> and <code>&lt;igl/shapeup_local_projections.h&gt;</code>. A demo implementing regularity constraints (creating a mesh in which each face is as regular as possible) is in <a href="https://github.com/libigl/libigl/tree/main/tutorial/713_Shapeup/main.cpp">Example 713</a>. </p>
<p>The local step is instantiated by a function of type <code>igl::shapeup_projection_function</code>. The global step is done by two functions: <code>igl::shapeup_precomputation()</code>, which precomputes the matrices required for the global step, and <code>igl::shapeup_solve()</code>, which solves the problem, according to the initial solution <span class="arithmatex"><span class="MathJax_Preview">P_0</span><script type="math/tex">P_0</script></span> and the input local projection function. The data struct <code>igl::ShapeUpData</code> contains the information necessary to run the algorithm, and can be configured; for instance, the self-explanatory variable <code>Maxiterations</code>.</p>
<p>The global step minimizes the following energy:</p>
<div class="arithmatex">
<div class="MathJax_Preview">
  E_{total}=\lambda_{shape}E_{shape}+\lambda_{close}E_{close}+\lambda_{smooth}E_{smooth},
</div>
<script type="math/tex; mode=display">
  E_{total}=\lambda_{shape}E_{shape}+\lambda_{close}E_{close}+\lambda_{smooth}E_{smooth},
</script>
</div>
<p>where the <span class="arithmatex"><span class="MathJax_Preview">\lambda</span><script type="math/tex">\lambda</script></span> coefficients are encoded in <code>igl::ShapeUpData</code>, and can be updated <strong>prior</strong> to calling <code>igl::shapeup_precomputation()</code>. The <span class="arithmatex"><span class="MathJax_Preview">E_{shape}</span><script type="math/tex">E_{shape}</script></span> component is the integration energy (fitting <span class="arithmatex"><span class="MathJax_Preview">P_k</span><script type="math/tex">P_k</script></span> to the local projections). The <span class="arithmatex"><span class="MathJax_Preview">E_{close}</span><script type="math/tex">E_{close}</script></span> component is adherence to positional constraints, given by <code>b</code> and <code>bc</code> parameters. The <span class="arithmatex"><span class="MathJax_Preview">E_{smooth}</span><script type="math/tex">E_{smooth}</script></span> component is an optional objective function, to minimize differences (in the Dirichlet sense) between points, encodes by &ldquo;edges&rdquo; in parameter <code>E</code>. Both <span class="arithmatex"><span class="MathJax_Preview">E_{close}</span><script type="math/tex">E_{close}</script></span> and <span class="arithmatex"><span class="MathJax_Preview">E_{shape}</span><script type="math/tex">E_{shape}</script></span> are also weighted by <code>wClose</code> and <code>wShape</code> function parameters, respectively.</p>
<figure>
<p><img alt="" src="../images/713_ShapeUp.png" />
  </p>
<figcaption>
    (<a href="https://github.com/libigl/libigl/tree/main/tutorial/713_ShapeUp/main.cpp">Example 713</a>) The half-tunnel mesh (left) has been optimized to be almost perfectly regular (right). The color scale is between <span class="arithmatex"><span class="MathJax_Preview">\lbrack 0,0.05 \rbrack</span><script type="math/tex">\lbrack 0,0.05 \rbrack</script></span>, measuring the average normalized deviation of the angles of each face from <span class="arithmatex"><span class="MathJax_Preview">90^{\circ}</span><script type="math/tex">90^{\circ}</script></span>.
  </figcaption>
</figure>
<h3 id="marching-tetrahedra">Marching Tetrahedra<a class="headerlink" href="#marching-tetrahedra" title="Permanent link">&para;</a></h3>
<p>Often 3D data is captured as scalar field defined over space <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x}) :
\mathcal{R}^3 \rightarrow \mathcal{R}</span><script type="math/tex">f(\mathbf{x}) :
\mathcal{R}^3 \rightarrow \mathcal{R}</script></span>. Lurking within this field,
<em>iso-surfaces</em> of the scalar field are often salient geometric objects. The
iso-surface at value <span class="arithmatex"><span class="MathJax_Preview">v</span><script type="math/tex">v</script></span> is composed of all points <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> in
<span class="arithmatex"><span class="MathJax_Preview">\mathcal{R}^3</span><script type="math/tex">\mathcal{R}^3</script></span> such that <span class="arithmatex"><span class="MathJax_Preview">f(\mathbf{x}) = v</span><script type="math/tex">f(\mathbf{x}) = v</script></span>. A core problem in geometry
processing is to extract an iso-surface as a triangle mesh for further
mesh-based processing or visualization. This is referred to as iso-contouring.</p>
<p>&ldquo;Marching Tetrahedra&rdquo; <sup id="fnref:treece_1999"><a class="footnote-ref" href="#fn:treece_1999">46</a></sup> is a <a href="https://en.wikipedia.org/wiki/Marching_tetrahedra">famous
method</a> for iso-contouring
tri-linear functions <span class="arithmatex"><span class="MathJax_Preview">f</span><script type="math/tex">f</script></span> on a 3D simplicial complex (aka a tet mesh). The core idea of this
method is to contour the iso-surface passing through each cell  (if it does at
all) with a predefined topology (aka connectivity) chosen from a look up table
depending on the function values at each vertex of the cell. The method
iterates (&ldquo;marches&rdquo;) over all cells (&ldquo;tetrahedra&rdquo;) in the complex and stitches together
the final mesh.</p>
<p>In libigl, <code>igl::marching_tets</code> constructs a triangle mesh <code>(V,F)</code> approximating the iso-level set
for the value <code>isovalue</code> from an input scalar field <code>S</code> sampled at the vertices of a tet mesh locations <code>(TV, TT)</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">marching_tets</span><span class="p">(</span><span class="n">TV</span><span class="p">,</span><span class="n">TT</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">isovalue</span><span class="w"> </span><span class="p">,</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">);</span>
</code></pre></div>
<h3 id="implicit-function-meshing">Implicit Function Meshing<a class="headerlink" href="#implicit-function-meshing" title="Permanent link">&para;</a></h3>
<div class="admonition todo">
<p class="admonition-title">715_MeshImplicitFunction</p>
<p><em>Entry Missing</em></p>
</div>
<h3 id="heat-method-for-fast-geodesic-distance-approximation">Heat Method For Fast Geodesic Distance Approximation<a class="headerlink" href="#heat-method-for-fast-geodesic-distance-approximation" title="Permanent link">&para;</a></h3>
<p>In the <a href="#exact-discrete-geodesic-distances">Exact Discrete Geodesic Distances</a>
example above, geodesic distances are computed <em>exactly</em>. This is an expensive
operation: <span class="arithmatex"><span class="MathJax_Preview">O(n log(n))</span><script type="math/tex">O(n log(n))</script></span> for a mesh with <span class="arithmatex"><span class="MathJax_Preview">n</span><script type="math/tex">n</script></span> edges. In 2013, Crane et al.
<sup id="fnref:crane_2013"><a class="footnote-ref" href="#fn:crane_2013">47</a></sup> proposed a method to compute <em>approximate</em> geodesic distances much
faster by solving heat equation on the surface, filtering the result and then
reconstructing a smooth solution by solving a Poisson equation. The method
begins with the observation of Varadhan that the geodesic distance
<span class="arithmatex"><span class="MathJax_Preview">d(\mathbf{x},\mathbf{y})</span><script type="math/tex">d(\mathbf{x},\mathbf{y})</script></span> between two points <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span> is
equal to the square root of the logarithm of the heat diffused from <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>
to <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span> after a time <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>:</p>
<p>\[
d(\mathbf{x},\mathbf{y}) = \lim_{t0} \sqrt{ -4 t \log k_{t,\mathbf{x}} (\mathbf{y}) },
\]
where <span class="arithmatex"><span class="MathJax_Preview">k_{t,\mathbf{x}}</span><script type="math/tex">k_{t,\mathbf{x}}</script></span> is the <em>heat kernel</em>. We can think of this heat
diffusion problem as placing a hot needle on <span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span> and then after <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>
seconds, measuring the temperature at point <span class="arithmatex"><span class="MathJax_Preview">\mathbf{y}</span><script type="math/tex">\mathbf{y}</script></span>.</p>
<p>On triangle meshes we know how to solve the heat equation for any finite time <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>:</p>
<p>\[
(-\mathbf{L}+\frac{1}{t}\mathbf{M}) \mathbf{u} = _{x},
\]</p>
<p>where <span class="arithmatex"><span class="MathJax_Preview">\mathbf{L}  \mathbb{R}^{nn}</span><script type="math/tex">\mathbf{L}  \mathbb{R}^{nn}</script></span> is the discrete Laplacian matrix,
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{M}  \mathbb{R}^{nn}</span><script type="math/tex">\mathbf{M}  \mathbb{R}^{nn}</script></span> is the discrete mass matrix, <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u} 
\mathbb{R}^n</span><script type="math/tex">\mathbf{u} 
\mathbb{R}^n</script></span> are the resulting temperatures at each vertex, and <span class="arithmatex"><span class="MathJax_Preview">_x 
\mathbb{R}^n</span><script type="math/tex">_x 
\mathbb{R}^n</script></span> is a vector of all zeros except a one at the vertex at the source
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{x}</span><script type="math/tex">\mathbf{x}</script></span>.</p>
<p>If we had sufficient numerical accuracy and precision, we could simply evaluate
<span class="arithmatex"><span class="MathJax_Preview">\sqrt{-4 t \log u}</span><script type="math/tex">\sqrt{-4 t \log u}</script></span> for a small time parameter <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span>. The problem observed by
Crane et al. is that our numerical accuracy of the <em>value</em> of <span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span> is
far from sufficient. However, the <em>direction</em> of the gradient <span class="arithmatex"><span class="MathJax_Preview"> \mathbf{u}</span><script type="math/tex"> \mathbf{u}</script></span> is
surprisingly accurate. Hence, their idea is to acquire the gradient of
<span class="arithmatex"><span class="MathJax_Preview">\mathbf{u}</span><script type="math/tex">\mathbf{u}</script></span>, normalize these vectors to get a gradient <em>direction</em> (unit
vector). And then solve a Poisson equation to integrate these directions into
actual distance values.</p>
<p>This method involves inverting <span class="arithmatex"><span class="MathJax_Preview">nn</span><script type="math/tex">nn</script></span> sparse matrices (a <span class="arithmatex"><span class="MathJax_Preview">O(n^{1.\cdots})</span><script type="math/tex">O(n^{1.\cdots})</script></span>
operation), but if Cholesky factorizations are used then the factorization is
precomputation that can be <em>reused</em> even if the source of the geodesic distances
is changed. For a new source, only back-substitution needs to be performed.</p>
<p>In libigl, you can compute approximate geodesic distances for a mesh (<code>V</code>,<code>F</code>)
from a list of source vertex indices <code>gamma</code> into a vector <code>D</code> using this method
via two steps:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">HeatGeodesicsData</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">heat_geodesics_precompute</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">igl</span><span class="o">::</span><span class="n">heat_geodesics_solve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
</code></pre></div>
<figure>
<p><img alt="" src="https://github.com/libigl/libigl/tree/main/tutorial/716_HeatGeodesics/main.cpp" />)
  </p>
<figcaption>
    ([Example 716
  </figcaption>
</figure>
<p>loads a
mesh and computes approximate geodesics distances from wherever the user
clicks.](images/heat-geodesic-beetle.gif)</p>
<h4 id="intrinsic-delaunay-triangulation">Intrinsic Delaunay Triangulation<a class="headerlink" href="#intrinsic-delaunay-triangulation" title="Permanent link">&para;</a></h4>
<p>The original heat method for geodesic distances works well on regular, unbiased
meshes: i.e., where the finite-element cotangent and mass matrices are
well-behaved. For poor quality meshes, however, this method may show arbitrarily
poor results. Increasing the time parameter <span class="arithmatex"><span class="MathJax_Preview">t</span><script type="math/tex">t</script></span> can reduce this instability but
but simultaneously smoothes the resulting approximate distances.</p>
<p>Instead, one avenue of improvement is to employ the so-called <em>intrinsic
Delaunay triangulation</em> discrete Laplace operator <sup id="fnref:bobenko_2005"><a class="footnote-ref" href="#fn:bobenko_2005">48</a></sup>.</p>
<p>Since the cotangent Laplacian only depends on the edge-lengths of a triangle
mesh, this new operator will be constructed by <em>intrinsically</em> flipping edges
and recording changes to edge-lengths. Edges are flipped until every edge is
locally Delaunay (i.e., its corresponding cotangent weights are positive).</p>
<p>You can compute the intrinsic Delaunay triangulation of mesh (<code>V</code>,<code>F</code>) in libigl
using:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">edge_lengths</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">l_intrinsic</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">F_intrinsic</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">intrinsic_delaunay_triangulation</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">l_intrinsic</span><span class="p">,</span><span class="n">F_intrinsic</span><span class="p">);</span>
</code></pre></div>
<p>Notice that the mesh vertex positions <code>V</code> are not used, since this is a purely
intrinsic operation. The method inputs and outputs edge-lengths and triangle
indices.</p>
<p>You may construct the intrinsic Delaunay cotangent Laplacian matrix directly
using:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">L</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">intrinsic_delaunay_cotmatrix</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">L</span><span class="p">);</span>
</code></pre></div>
<p>And finally you can compute heat geodesics using this matrix via:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">HeatGeodesicsData</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="n">data</span><span class="p">.</span><span class="n">use_intrinsic_delaunay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">heat_geodesics_precompute</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">data</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">igl</span><span class="o">::</span><span class="n">heat_geodesics_solve</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">gamma</span><span class="p">,</span><span class="n">D</span><span class="p">);</span>
</code></pre></div>
<p><img alt="The _standard_ FEM Laplacian igl::cotmatrix results in an unstable geodesic
distance approximation that is non-monotonic (left), in the presence of a poor
quality and/or biased mesh (zoom-in center). Switching to the intrinsic Delaunay
triangulation's cotagent Laplacian igl::intrinsic_delaunay_cotmatrix improves
things and ensures monotonicity (right)" src="../images/heat-geodesic-peaks.png" /></p>
<h3 id="fast-winding-number-for-soups-and-clouds">Fast Winding Number For Soups And Clouds<a class="headerlink" href="#fast-winding-number-for-soups-and-clouds" title="Permanent link">&para;</a></h3>
<p>In 2018, Barill et al. <sup id="fnref:barill_2018"><a class="footnote-ref" href="#fn:barill_2018">50</a></sup> demonstrated how to significantly
expediate the computation of the <a href="#generalized-winding-number">generalized winding
numbers</a> mentioned above. The original definition of
generalized winding numbers for triangle meshes is also extended to (oriented) point
clouds.</p>
<h4 id="soups">Soups<a class="headerlink" href="#soups" title="Permanent link">&para;</a></h4>
<p>For triangle soups, the exact divide-and-conquer approach of <sup id="fnref3:jacobson_2013"><a class="footnote-ref" href="#fn:jacobson_2013">40</a></sup>
<em>ideally</em> scales logarithmically <span class="arithmatex"><span class="MathJax_Preview">O(\log{n})</span><script type="math/tex">O(\log{n})</script></span> in the number of triangles.
However, this method has failure modes where the computation becomes linear
<span class="arithmatex"><span class="MathJax_Preview">O(n)</span><script type="math/tex">O(n)</script></span>. This can be dramatically improved with a <a href="https://en.wikipedia.org/wiki/BarnesHut_simulation">tree
method</a> similar to those
used in n-body graviational system simulations or electrostatics problems. The
result is approximate, but much more closely follows a <span class="arithmatex"><span class="MathJax_Preview">O(\log{n})</span><script type="math/tex">O(\log{n})</script></span>  trend and
with much smaller constant factors.</p>
<figure>
<p><img alt="" src="https://github.com/libigl/libigl/tree/main/tutorial/717_FastWindingNumber/main.cpp" />)
  </p>
<figcaption>
    ([Example 717
  </figcaption>
</figure>
<p>loads a mesh, samples 1,000,000 random queries and then discards all those
<em>outside</em> the given model.](images/bunny-fwn-soup.jpg)</p>
<p>Computing <em>fast</em> winding numbers for soups has two steps: building the tree data
structure and then evaluating at query points. In libigl, this is programmed as
follows:</p>
<div class="highlight"><pre><span></span><code><span class="n">igl</span><span class="o">::</span><span class="n">FastWindingNumberBVH</span><span class="w"> </span><span class="n">fwn_bvh</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">fast_winding_number</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">F</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">fwn_bvh</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXf</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">fast_winding_number</span><span class="p">(</span><span class="n">fwn_bvh</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">Q</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">W</span><span class="p">);</span>
</code></pre></div>
<h4 id="clouds">Clouds<a class="headerlink" href="#clouds" title="Permanent link">&para;</a></h4>
<p>For point clouds, the process is similar, but more precomputation may be
necessary. The winding number for point clouds is defined so long as each point
comes with an outward-facing normal and an area value. Areas can be estimated by
using a libigl function that computes a tangents space Voronoi diagram for each
point <code>igl::copyleft::cgal::point_areas</code>. This function in turn relies on first
computing k nearest neighbors <code>igl::knn</code>. And that function and the eventual
winding number computation uses libigl&rsquo;s <code>igl::octree</code> as a bounding volume
hierarchy. To estimate areas use for a point cloud <code>P</code> with normals <code>N</code> use:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Build octree</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">O_PI</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">O_CH</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">O_CN</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">O_W</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">octree</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">O_PI</span><span class="p">,</span><span class="n">O_CH</span><span class="p">,</span><span class="n">O_CN</span><span class="p">,</span><span class="n">O_W</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXi</span><span class="w"> </span><span class="n">I</span><span class="p">;</span>
<span class="w">  </span><span class="n">igl</span><span class="o">::</span><span class="n">knn</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="n">O_PI</span><span class="p">,</span><span class="n">O_CH</span><span class="p">,</span><span class="n">O_CN</span><span class="p">,</span><span class="n">O_W</span><span class="p">,</span><span class="n">I</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// CGAL is only used to help get point areas</span>
<span class="w">  </span><span class="n">igl</span><span class="o">::</span><span class="n">copyleft</span><span class="o">::</span><span class="n">cgal</span><span class="o">::</span><span class="n">point_areas</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">I</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Then it is possible to compute fast winding numbers for a list of queries <code>Q</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">O_CM</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">O_R</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">O_EC</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">fast_winding_number</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">O_PI</span><span class="p">,</span><span class="n">O_CH</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">O_CM</span><span class="p">,</span><span class="n">O_R</span><span class="p">,</span><span class="n">O_EC</span><span class="p">);</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">W</span><span class="p">;</span>
<span class="n">igl</span><span class="o">::</span><span class="n">fast_winding_number</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">O_PI</span><span class="p">,</span><span class="n">O_CH</span><span class="p">,</span><span class="n">O_CM</span><span class="p">,</span><span class="n">O_R</span><span class="p">,</span><span class="n">O_EC</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">W</span><span class="p">);</span>
</code></pre></div>
<h3 id="iterative-closest-point">Iterative Closest Point<a class="headerlink" href="#iterative-closest-point" title="Permanent link">&para;</a></h3>
<div class="admonition todo">
<p class="admonition-title">718_IterativeClosestPoint</p>
<p><em>Entry Missing</em></p>
</div>
<h3 id="exploded-view">Exploded View<a class="headerlink" href="#exploded-view" title="Permanent link">&para;</a></h3>
<div class="admonition todo">
<p class="admonition-title">719_ExplodedView</p>
<p><em>Entry Missing</em></p>
</div>
<h3 id="blue-noise-surface-sampling">Blue Noise Surface Sampling<a class="headerlink" href="#blue-noise-surface-sampling" title="Permanent link">&para;</a></h3>
<div class="admonition todo">
<p class="admonition-title">720_BlueNoise</p>
<p><em>Entry Missing</em></p>
</div>
<h3 id="vector-field-smoothing">Vector Field Smoothing<a class="headerlink" href="#vector-field-smoothing" title="Permanent link">&para;</a></h3>
<div class="admonition todo">
<p class="admonition-title">721_VectorFieldSmoothing</p>
<p><em>Entry Missing</em></p>
</div>
<h3 id="vector-parallel-transport">Vector Parallel Transport<a class="headerlink" href="#vector-parallel-transport" title="Permanent link">&para;</a></h3>
<div class="admonition todo">
<p class="admonition-title">722_VectorParallelTransport</p>
<p><em>Entry Missing</em></p>
</div>
<h2 id="outlook-for-continuing-development">Outlook For Continuing Development<a class="headerlink" href="#outlook-for-continuing-development" title="Permanent link">&para;</a></h2>
<p>Libigl is in active development, and we plan to focus on the following features
in the next months:</p>
<ul>
<li>
<p>A better and more consistent <strong>documentation</strong>, plus extending this tutorial
  to cover more libigl features.</p>
</li>
<li>
<p>Implement a <strong>mixed-integer solver</strong> which only uses Eigen to remove the
  dependency on CoMiSo.</p>
</li>
<li>
<p>Improve the robustness and performance of the active set QP solver. In
  particular, handle linearly dependent constraints.</p>
</li>
<li>
<p>Implement more mesh analysis functions, including structural analysis for
  masonry and <em>3D-printability</em> analysis.</p>
</li>
<li>
<p>Increase support for point clouds and general polygonal meshes.</p>
</li>
<li>
<p>Wrangle/unify the many bounding volume hierarchies that now exist within libigl.</p>
</li>
<li>
<p>What would you like to see in libigl? <a href="mailto:alecjacobson@gmail.com">Contact
  us!</a> or post a <a href="https://github.com/libigl/libigl/issues/new">feature
  request</a>.</p>
</li>
</ul>
<p>We encourage you to contribute to the library and to report problems and bugs.
The best way to contribute new feature or bug fixes is to fork the libigl
repository and to open a <a href="https://help.github.com/articles/using-pull-requests">pull
request</a> on <a href="https://github.com/libigl/libigl">our github
repository</a>.</p>
<h2 id="past-libigl-courses-at-conferences">Past Libigl Courses At Conferences<a class="headerlink" href="#past-libigl-courses-at-conferences" title="Permanent link">&para;</a></h2>
<p>This tutorial was originally presented by Daniele Panozzo and Alec Jacobson at SGP Graduate School 2014. It has also been presented at SGP 2017 (<a href="https://www.google.com/search?q=libigl+sgp&amp;oq=libigl+sgp&amp;aqs=chrome..69i57j69i59l2j69i60l5.2123j0j7&amp;sourceid=chrome&amp;ie=UTF-8">video</a>), ACM SIGGRAPH Asia 2017, Eurographics 2019, and SGP 2020.</p>
<h2 id="references">References<a class="headerlink" href="#references" title="Permanent link">&para;</a></h2>
<!-- Chapter 2 -->

<!-- Chapter 3 -->

<!-- Chapter 4 -->

<!-- Chapter 5 -->

<!-- Chapter 6 -->

<!-- Chapter 7 -->

<div class="footnote">
<hr />
<ol>
<li id="fn:jacobson_thesis_2013">
<p>Alec Jacobson, <a href="https://www.google.com/search?q=Algorithms+and+Interfaces+for+Real-Time+Deformation+of+2D+and+3D+Shapes"><em>Algorithms and Interfaces for Real-Time Deformation of 2D and 3D Shapes</em></a>, 2013.&#160;<a class="footnote-backref" href="#fnref:jacobson_thesis_2013" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:kazhdan_2012">
<p>Michael Kazhdan, Jake Solomon, Mirela Ben-Chen, <a href="https://www.google.com/search?q=Can+Mean-Curvature+Flow+Be+Made+Non-Singular">Can Mean-Curvature Flow Be Made Non-Singular</a>, 2012.&#160;<a class="footnote-backref" href="#fnref:kazhdan_2012" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:meyer_2003">
<p>Mark Meyer, Mathieu Desbrun, Peter Schrder and Alan H.  Barr, <a href="https://www.google.com/search?q=Discrete+Differential-Geometry+Operators+for+Triangulated+2-Manifolds">Discrete Differential-Geometry Operators for Triangulated 2-Manifolds</a>, 2003.&#160;<a class="footnote-backref" href="#fnref:meyer_2003" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:meyer_2003" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:meyer_2003" title="Jump back to footnote 3 in the text">&#8617;</a><a class="footnote-backref" href="#fnref4:meyer_2003" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:mitchell_1987">
<p>Joseph S. B. Mitchell, David M. Mount, Christos H. Papadimitriou. <a href="https://www.google.com/search?q=The+Discrete+Geodesic+Problem">The Discrete Geodesic Problem</a>, 1987&#160;<a class="footnote-backref" href="#fnref:mitchell_1987" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:panozzo_2010">
<p>Daniele Panozzo, Enrico Puppo, Luigi Rocca, <a href="https://www.google.com/search?q=Efficient+Multi-scale+Curvature+and+Crease+Estimation">Efficient Multi-scale Curvature and Crease Estimation</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:panozzo_2010" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:sharf_2007">
<p>Andrei Sharf, Thomas Lewiner, Gil Shklarski, Sivan Toledo, and Daniel Cohen-Or. <a href="https://www.google.com/search?q=Interactive+topology-aware+surface+reconstruction">Interactive topology-aware surface reconstruction</a>, 2007.&#160;<a class="footnote-backref" href="#fnref:sharf_2007" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:barbic_2005">
<p>Jernej Barbic and Doug James. <a href="https://www.google.com/search?q=Real-Time+Subspace+Integration+for+St.Venant-Kirchhoff+Deformable+Models">Real-Time Subspace Integration for St.Venant-Kirchhoff Deformable Models</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:barbic_2005" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:hildebrandt_2011">
<p>Klaus Hildebrandt, Christian Schulz, Christoph von Tycowicz, and Konrad Polthier. <a href="https://www.google.com/search?q=Interactive+Surface+Modeling+using+Modal+Analysis">Interactive Surface Modeling using Modal Analysis</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:hildebrandt_2011" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
<li id="fn:rustamov_2011">
<p>Raid M. Rustamov, <a href="https://www.google.com/search?q=Multiscale+Biharmonic+Kernels">Multiscale Biharmonic Kernels</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:rustamov_2011" title="Jump back to footnote 9 in the text">&#8617;</a></p>
</li>
<li id="fn:vallet_2008">
<p>Bruno Vallet and Bruno Lvy. <a href="https://www.google.com/search?q=Spectral+Geometry+Processing+with+Manifold+Harmonics">Spectral Geometry Processing with Manifold Harmonics</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:vallet_2008" title="Jump back to footnote 10 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:vallet_2008" title="Jump back to footnote 10 in the text">&#8617;</a></p>
</li>
<li id="fn:botsch_2004">
<p>Mario Botsch and Leif Kobbelt. <a href="https://www.google.com/search?q=An+Intuitive+Framework+for+Real-Time+Freeform+Modeling">An Intuitive Framework for Real-Time Freeform Modeling</a>, 2004.&#160;<a class="footnote-backref" href="#fnref:botsch_2004" title="Jump back to footnote 11 in the text">&#8617;</a></p>
</li>
<li id="fn:chao_2010">
<p>Isaac Chao, Ulrich Pinkall, Patrick Sanan, Peter Schrder. <a href="https://www.google.com/search?q=A+Simple+Geometric+Model+for+Elastic+Deformations">A Simple Geometric Model for Elastic Deformations</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:chao_2010" title="Jump back to footnote 12 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_2011">
<p>Alec Jacobson, Ilya Baran, Jovan Popovi, and Olga Sorkine. <a href="https://www.google.com/search?q=Bounded+biharmonic+weights+for+real-time+deformation">Bounded Biharmonic Weights for Real-Time Deformation</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:jacobson_2011" title="Jump back to footnote 13 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:jacobson_2011" title="Jump back to footnote 13 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_2012">
<p>Alec Jacobson, Ilya Baran, Ladislav Kavan, Jovan Popovi, and Olga Sorkine. <a href="https://www.google.com/search?q=Fast+Automatic+Skinning+Transformations">Fast Automatic Skinning Transformations</a>, 2012.&#160;<a class="footnote-backref" href="#fnref:jacobson_2012" title="Jump back to footnote 14 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_mixed_2010">
<p>Alec Jacobson, Elif Tosun, Olga Sorkine, and Denis Zorin. <a href="https://www.google.com/search?q=Mixed+Finite+Elements+for+Variational+Surface+Modeling">Mixed Finite Elements for Variational Surface Modeling</a>, 2010.&#160;<a class="footnote-backref" href="#fnref:jacobson_mixed_2010" title="Jump back to footnote 15 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_skinning_course_2014">
<p>Alec Jacobson, Zhigang Deng, Ladislav Kavan, J.P. Lewis. <a href="https://www.google.com/search?q=Skinning+Real-Time+Shape+Deformation"><em>Skinning: Real-Time Shape Deformation</em></a>, 2014.&#160;<a class="footnote-backref" href="#fnref:jacobson_skinning_course_2014" title="Jump back to footnote 16 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:jacobson_skinning_course_2014" title="Jump back to footnote 16 in the text">&#8617;</a></p>
</li>
<li id="fn:kavan_2008">
<p>Ladislav Kavan, Steven Collins, Jiri Zara, and Carol O&rsquo;Sullivan. <a href="https://www.google.com/search?q=Geometric+Skinning+with+Approximate+Dual+Quaternion+Blending">Geometric Skinning with Approximate Dual Quaternion Blending</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:kavan_2008" title="Jump back to footnote 17 in the text">&#8617;</a></p>
</li>
<li id="fn:le_2019">
<p>Binh Huy Le, J.P. Lewis. <a href="https://www.google.com/search?q=Direct+delta+mush+skinning+and+variants">Direct delta mush skinning and variants</a>, 2019.&#160;<a class="footnote-backref" href="#fnref:le_2019" title="Jump back to footnote 18 in the text">&#8617;</a></p>
</li>
<li id="fn:mancewicz_2014">
<p>Joe Mancewicz, Matt L. Derksen, Hans Rijpkema, and Cyrus A. Wilson. <a href="https://www.google.com/search?q=Delta+Mush%3A+smoothing+deformations+while+preserving+detail">Delta Mush: smoothing deformations while preserving detail</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:mancewicz_2014" title="Jump back to footnote 19 in the text">&#8617;</a></p>
</li>
<li id="fn:mcadams_2011">
<p>Alexa McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis. <a href="https://www.google.com/search?q=Computing+the+Singular+Value+Decomposition+of+3x3+matrices+with+minimal+branching+and+elementary+floating+point+operations">Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations</a>, 2011.&#160;<a class="footnote-backref" href="#fnref:mcadams_2011" title="Jump back to footnote 20 in the text">&#8617;</a></p>
</li>
<li id="fn:sorkine_2004">
<p>Olga Sorkine, Yaron Lipman, Daniel Cohen-Or, Marc Alexa, Christian Rssl and Hans-Peter Seidel. <a href="https://www.google.com/search?q=Laplacian+Surface+Editing">Laplacian Surface Editing</a>, 2004.&#160;<a class="footnote-backref" href="#fnref:sorkine_2004" title="Jump back to footnote 21 in the text">&#8617;</a></p>
</li>
<li id="fn:sorkine_2007">
<p>Olga Sorkine and Marc Alexa. <a href="https://www.google.com/search?q=As-rigid-as-possible+Surface+Modeling">As-rigid-as-possible Surface Modeling</a>, 2007.&#160;<a class="footnote-backref" href="#fnref:sorkine_2007" title="Jump back to footnote 22 in the text">&#8617;</a></p>
</li>
<li id="fn:wang_bc_2015">
<p>Yu Wang, Alec Jacobson, Jernej Barbic, Ladislav Kavan. <a href="https://www.google.com/search?q=Linear+Subspace+Design+for+Real-Time+Shape+Deformation">Linear Subspace Design for Real-Time Shape Deformation</a>, 2015&#160;<a class="footnote-backref" href="#fnref:wang_bc_2015" title="Jump back to footnote 23 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:wang_bc_2015" title="Jump back to footnote 23 in the text">&#8617;</a></p>
</li>
<li id="fn:pixar_2017">
<p>Fernando de Goes, Doug L. James. <a href="https://graphics.pixar.com/library/Kelvinlets/">Regularized Kelvinlets: Sculpting Brushes based on Fundamental Solutions of Elasticity</a>, 2017&#160;<a class="footnote-backref" href="#fnref:pixar_2017" title="Jump back to footnote 24 in the text">&#8617;</a></p>
</li>
<li id="fn:slaughter_2002">
<p>W. S. Slaughter. <a href="https://www.google.com/search?q=the+linearized+theory+of+elasticity+slaughter">The Linearized Theory of Elasticity</a>, 2002&#160;<a class="footnote-backref" href="#fnref:slaughter_2002" title="Jump back to footnote 25 in the text">&#8617;</a></p>
</li>
<li id="fn:bommes_2009">
<p>David Bommes, Henrik Zimmer, Leif Kobbelt. <a href="http://www-sop.inria.fr/members/David.Bommes/publications/miq.pdf">Mixed-integer quadrangulation</a>, 2009.&#160;<a class="footnote-backref" href="#fnref:bommes_2009" title="Jump back to footnote 26 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:bommes_2009" title="Jump back to footnote 26 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:bommes_2009" title="Jump back to footnote 26 in the text">&#8617;</a></p>
</li>
<li id="fn:bouaziz_2012">
<p>Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly <a href="http://lgg.epfl.ch/publications/2012/shapeup.pdf">Shape-Up: Shaping Discrete Geometry with Projections</a>, 2012&#160;<a class="footnote-backref" href="#fnref:bouaziz_2012" title="Jump back to footnote 27 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:bouaziz_2012" title="Jump back to footnote 27 in the text">&#8617;</a></p>
</li>
<li id="fn:eck_2005">
<p>Matthias Eck, Tony DeRose, Tom Duchamp, Hugues Hoppe, Michael Lounsbery, Werner Stuetzle.  <a href="http://research.microsoft.com/en-us/um/people/hoppe/mra.pdf">Multiresolution Analysis of Arbitrary Meshes</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:eck_2005" title="Jump back to footnote 28 in the text">&#8617;</a></p>
</li>
<li id="fn:levy_2002">
<p>Bruno Lvy, Sylvain Petitjean, Nicolas Ray, Jrome Maillot. <a href="http://www.cs.jhu.edu/~misha/Fall09/Levy02.pdf">Least Squares Conformal Maps, for Automatic Texture Atlas Generation</a>, 2002.&#160;<a class="footnote-backref" href="#fnref:levy_2002" title="Jump back to footnote 29 in the text">&#8617;</a></p>
</li>
<li id="fn:levy_2008">
<p>Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno Lvy. <a href="http://alice.loria.fr/publications/papers/2008/DGF/NSDFD-TOG.pdf">N-Symmetry Direction Field Design</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:levy_2008" title="Jump back to footnote 30 in the text">&#8617;</a></p>
</li>
<li id="fn:liu_2008">
<p>Ligang Liu, Lei Zhang, Yin Xu, Craig Gotsman, Steven J. Gortler. <a href="http://cs.harvard.edu/~sjg/papers/arap.pdf">A Local/Global Approach to Mesh Parameterization</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:liu_2008" title="Jump back to footnote 31 in the text">&#8617;</a></p>
</li>
<li id="fn:mullen_2008">
<p>Patrick Mullen, Yiying Tong, Pierre Alliez, Mathieu Desbrun. <a href="http://www.geometry.caltech.edu/pubs/MTAD08.pdf">Spectral Conformal Parameterization</a>, 2008.&#160;<a class="footnote-backref" href="#fnref:mullen_2008" title="Jump back to footnote 32 in the text">&#8617;</a></p>
</li>
<li id="fn:panozzo_2014">
<p>Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung.  <a href="http://cs.nyu.edu/~panozzo/papers/frame-fields-2014.pdf">Frame Fields: Anisotropic and Non-Orthogonal Cross Fields</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:panozzo_2014" title="Jump back to footnote 33 in the text">&#8617;</a></p>
</li>
<li id="fn:vaxman_2016">
<p>Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen. <a href="https://www.google.com/search?q=Directional+Field+Synthesis+Design+and+Processing">Directional Field Synthesis, Design, and Processing</a>, 2016&#160;<a class="footnote-backref" href="#fnref:vaxman_2016" title="Jump back to footnote 34 in the text">&#8617;</a></p>
</li>
<li id="fn:schuller_2013">
<p>Christian Schller, Ladislav Kavan, Daniele Panozzo, Olga Sorkine-Hornung.  <a href="http://igl.ethz.ch/projects/LIM/">Locally Injective Mappings</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:schuller_2013" title="Jump back to footnote 35 in the text">&#8617;</a></p>
</li>
<li id="fn:zhou_2016">
<p>Qingnan Zhou, Eitan Grinspun, Denis Zorin. <a href="https://www.google.com/search?q=Mesh+Arrangements+for+Solid+Geometry">Mesh Arrangements for Solid Geometry</a>, 2016&#160;<a class="footnote-backref" href="#fnref:zhou_2016" title="Jump back to footnote 36 in the text">&#8617;</a></p>
</li>
<li id="fn:baerentzen_2005">
<p>J Andreas Baerentzen and Henrik Aanaes. <a href="https://www.google.com/search?q=Signed+distance+computation+using+the+angle+weighted+pseudonormal">Signed distance computation using the angle weighted pseudonormal</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:baerentzen_2005" title="Jump back to footnote 37 in the text">&#8617;</a></p>
</li>
<li id="fn:garg_2016">
<p>Akash Garg, Alec Jacobson, Eitan Grinspun. <a href="https://www.google.com/search?q=Computational+Design+of+Reconfigurables">Computational Design of Reconfigurables</a>, 2016&#160;<a class="footnote-backref" href="#fnref:garg_2016" title="Jump back to footnote 38 in the text">&#8617;</a></p>
</li>
<li id="fn:hoppe_1996">
<p>Hugues Hoppe. <a href="https://www.google.com/search?q=Progressive+meshes">Progressive Meshes</a>, 1996&#160;<a class="footnote-backref" href="#fnref:hoppe_1996" title="Jump back to footnote 39 in the text">&#8617;</a></p>
</li>
<li id="fn:jacobson_2013">
<p>Alec Jacobson, Ladislav Kavan, and Olga Sorkine. <a href="https://www.google.com/search?q=Robust+Inside-Outside+Segmentation+using+Generalized+Winding+Numbers">Robust Inside-Outside Segmentation using Generalized Winding Numbers</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:jacobson_2013" title="Jump back to footnote 40 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:jacobson_2013" title="Jump back to footnote 40 in the text">&#8617;</a><a class="footnote-backref" href="#fnref3:jacobson_2013" title="Jump back to footnote 40 in the text">&#8617;</a></p>
</li>
<li id="fn:loop_1987">
<p>Charles Loop. <a href="https://www.google.com/search?q=smooth+subdivision+surfaces+based+on+triangles">Smooth Subdivision Surfaces Based on Triangles</a>, 1987.&#160;<a class="footnote-backref" href="#fnref:loop_1987" title="Jump back to footnote 41 in the text">&#8617;</a></p>
</li>
<li id="fn:lorensen_1987">
<p>W.E. Lorensen and Harvey E. Cline. <a href="https://www.google.com/search?q=Marching+cubes:+A+high+resolution+3d+surface+construction+algorithm">Marching cubes: A high resolution 3d surface construction algorithm</a>, 1987.&#160;<a class="footnote-backref" href="#fnref:lorensen_1987" title="Jump back to footnote 42 in the text">&#8617;</a><a class="footnote-backref" href="#fnref2:lorensen_1987" title="Jump back to footnote 42 in the text">&#8617;</a></p>
</li>
<li id="fn:rabinovich_2016">
<p>Michael Rabinovich, Roi Poranne, Daniele Panozzo, Olga Sorkine-Hornung. <a href="http://cs.nyu.edu/~panozzo/papers/SLIM-2016.pdf">Scalable Locally Injective Mappings</a>, 2016.&#160;<a class="footnote-backref" href="#fnref:rabinovich_2016" title="Jump back to footnote 43 in the text">&#8617;</a></p>
</li>
<li id="fn:schroeder_1994">
<p>William J. Schroeder, William E. Lorensen, and Steve Linthicum. <a href="https://www.google.com/search?q=implicit+modeling+of+swept+surfaces+and+volumes">Implicit Modeling of Swept Surfaces and Volumes</a>, 1994.&#160;<a class="footnote-backref" href="#fnref:schroeder_1994" title="Jump back to footnote 44 in the text">&#8617;</a></p>
</li>
<li id="fn:takayama14">
<p>Kenshi Takayama, Alec Jacobson, Ladislav Kavan, Olga Sorkine-Hornung. <a href="https://www.google.com/search?q=A+Simple+Method+for+Correcting+Facet+Orientations+in+Polygon+Meshes+Based+on+Ray+Casting">A Simple Method for Correcting Facet Orientations in Polygon Meshes Based on Ray Casting</a>, 2014.&#160;<a class="footnote-backref" href="#fnref:takayama14" title="Jump back to footnote 45 in the text">&#8617;</a></p>
</li>
<li id="fn:treece_1999">
<p>G.M. Treece, R.W. Prager, and A.H.Gee <a href="https://www.sciencedirect.com/science/article/pii/S009784939900076X">Regularised marching tetrahedra: improved iso-surface extraction</a>, 1999.&#160;<a class="footnote-backref" href="#fnref:treece_1999" title="Jump back to footnote 46 in the text">&#8617;</a></p>
</li>
<li id="fn:crane_2013">
<p>Keenan Crane, Clarisse Weischedel, and Max Wardetzky. <a href="https://www.google.com/search?q=geodesics+in+heat+a+new+approach+to+computing+distance+based+on+heat+flow">Geodesics in Heat: A New Approach to Computing Distance Based on Heat Flow</a>, 2013.&#160;<a class="footnote-backref" href="#fnref:crane_2013" title="Jump back to footnote 47 in the text">&#8617;</a></p>
</li>
<li id="fn:bobenko_2005">
<p>Alexander I. Bobenko and Boris A. Springborn. <a href="https://www.google.com/search?q=a+discrete+laplace-beltrami+operator+for+simplicial+surfaces">A discrete Laplace-Beltrami operator for simplicial surfaces</a>, 2005.&#160;<a class="footnote-backref" href="#fnref:bobenko_2005" title="Jump back to footnote 48 in the text">&#8617;</a></p>
</li>
<li id="fn:jiang_2017">
<p>Zhongshi Jiang, Scott Schaefer, Daniele Panozzo. <a href="https://doi.org/10.1145/3130800.3130895">SCAF: Simplicial Complex Augmentation Framework for Bijective Maps</a>, 2017&#160;<a class="footnote-backref" href="#fnref:jiang_2017" title="Jump back to footnote 49 in the text">&#8617;</a></p>
</li>
<li id="fn:barill_2018">
<p>Gavin Barill, Neil G. Dickson, Ryan Schmidt, David I.W. Levin, Alec Jacobson. <a href="http://www.dgp.toronto.edu/projects/fast-winding-numbers/">Fast Winding Numbers for Soups and Clouds</a>, 2018.&#160;<a class="footnote-backref" href="#fnref:barill_2018" title="Jump back to footnote 50 in the text">&#8617;</a></p>
</li>
<li id="fn:stein_2018">
<p>Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson. <a href="http://www.cs.columbia.edu/cg/hessians/">Natural Boundary Conditions for Smoothing in Geometry Processing</a>, 2018.&#160;<a class="footnote-backref" href="#fnref:stein_2018" title="Jump back to footnote 51 in the text">&#8617;</a></p>
</li>
</ol>
</div>





                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        <div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/libigl" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.dfff1995.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.78eede0e.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>