{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"libigl - A simple C++ geometry processing library","text":"<p>libigl is a simple C++ geometry processing library. We have a wide functionality including construction of sparse discrete differential geometry operators and finite-elements matrices such as the cotangent Laplacian and diagonalized mass matrix, simple facet and edge-based topology data structures, mesh-viewing utilities for OpenGL and GLSL, and many core functions for matrix manipulation which make Eigen feel a lot more like MATLAB.</p> <p>It is a header-only library. You do not need to compile anything to use, just include igl headers (e.g. <code>#include &lt;igl/cotmatrix.h&gt;</code>) and run.  Each header file contains a single function (e.g. <code>igl/cotmatrix.h</code> contains <code>igl::cotmatrix()</code>). Most are tailored to operate on a generic triangle mesh stored in an n-by-3 matrix of vertex positions <code>V</code> and an m-by-3 matrix of triangle indices <code>F</code>.</p> <p>Optionally the library may also be pre-compiled into a statically linked library, for faster compile times with your projects. This only effects compile time (run-time performance and behavior is identical). If in doubt, use the header-only default mode: (i.e. just include the headers you want to use).</p> <p>We use the Eigen library heavily in our code. Our group prototypes a lot in MATLAB, and we have a useful MATLAB to libigl+Eigen conversion table.</p> <p>We regularly test compiling our library on Mac OS X with clang, Linux with gcc and Windows with Visual Studio 2015 Community Edition.</p>"},{"location":"#short-video-introduction","title":"Short Video Introduction","text":""},{"location":"#tutorial","title":"Tutorial","text":"<p>As of version 1.0, libigl includes an introductory tutorial that covers many functionalities.</p>"},{"location":"#libigl-example-project","title":"libigl Example Project","text":"<p>We provide a blank project example showing how to use libigl and cmake. Feel free and encouraged to copy or fork this project as a way of starting a new personal project using libigl.</p>"},{"location":"#coding-guidelines-and-tips","title":"Coding Guidelines and Tips","text":"<p>libigl follows strict coding guidelines, please take a look here before submitting your pull requests. We also have a set of general coding tips on how to code a geometry processing research project.</p>"},{"location":"#installation","title":"Installation","text":"<p>Libigl is a header-only library. You do not need to build anything to install. Simply add <code>libigl/include</code> to your include path and include relevant headers. Here is a small \u201cHello, World\u201d program:</p> <pre><code>#include &lt;igl/cotmatrix.h&gt;\n#include &lt;Eigen/Dense&gt;\n#include &lt;Eigen/Sparse&gt;\n#include &lt;iostream&gt;\nint main()\n{\nEigen::MatrixXd V(4,2);\nV&lt;&lt;0,0,\n1,0,\n1,1,\n0,1;\nEigen::MatrixXi F(2,3);\nF&lt;&lt;0,1,2,\n0,2,3;\nEigen::SparseMatrix&lt;double&gt; L;\nigl::cotmatrix(V,F,L);\nstd::cout&lt;&lt;\"Hello, mesh: \"&lt;&lt;std::endl&lt;&lt;L*V&lt;&lt;std::endl;\nreturn 0;\n}\n</code></pre> <p>If you save this in <code>hello.cpp</code>, then you could compile this with (assuming Eigen is installed in <code>/usr/local/include/eigen3</code>):</p> <pre><code>g++ -std=c++11 -lpthread -I/usr/local/include/eigen3 -I./libigl/include/ hello.cpp -o hello\n</code></pre> <p>Running <code>./hello</code> would then produce</p> <pre><code>Hello, mesh:\n 0.5  0.5\n-0.5  0.5\n-0.5 -0.5\n 0.5 -0.5\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>Dependencies are on a per-include basis and the majority of the functions in libigl depends only on the Eigen library.</p> <p>For more information see our tutorial.</p>"},{"location":"#optional-dependencies","title":"Optional Dependencies","text":"<p>Libigl compartmentalizes its optional dependences via its directory organization in the <code>include/</code> folder. All header files located directly in the <code>include/igl/</code> folder have only stl and Eigen as dependencies. For example, all of the headers that depend on CGAL are located in <code>include/igl/copyleft/cgal</code>. For a full list of optional dependencies check <code>cmake/libigl.cmake</code>.</p> <p>CGAL and Boost</p> <p>By default, the CMake script for libigl will not build the CGAL dependency, since Boost is required to compile CGAL. If you enable the CMake option <code>LIBIGL_WITH_CGAL</code>, you will need to have Boost installed on your machine. On Windows, it is advised to install Boost using <code>conda</code>. On Linux and macOS, you will need to install Boost, GMP and MPFR using your favorite package manager (CGAL itself will be downloaded by libigl).</p>"},{"location":"#downloading-dependencies","title":"Downloading Dependencies","text":"<p>Libigl uses CMake\u2019s ExternalProject_Add to manage external dependencies. External libraries are build statically with libigl using CMake. In order to be included in the CMake script via <code>add_subdirectory</code>, the third-party content is fetched at CMake time using the DownloadProject.cmake script (which has been introduced in CMake itself with the command FetchContent in CMake 3.11).</p> <p>There is not much to know about this, other than the content will be fetched the first time you run CMake, and placed into the <code>external/</code> folder. If something goes wrong with your dependencies, simply erase your <code>external/</code> folder and run CMake again. The exact version of each external dependencies used by libigl are recorded in the file <code>cmake/LibiglDownloadExternal.cmake</code>.</p>"},{"location":"#gcc-and-the-optional-cgal-dependency","title":"GCC and the Optional CGAL Dependency","text":"<p>The <code>include/igl/copyleft/cgal/*.h</code> headers depend on CGAL. It has come to our attention that CGAL does not work properly with GCC 4.8. To the best of our knowledge, GCC 4.7 and clang will work correctly. Please the FAQ for more details.</p>"},{"location":"#openmp-and-windows","title":"OpenMP and Windows","text":"<p>Some of our functions will take advantage of OpenMP if available. However, it has come to our attention that Visual Studio + Eigen + OpenMP does not work properly. Since we use OpenMP only to improve performance, we recommend avoiding OpenMP on Windows or proceeding with caution.</p>"},{"location":"#download","title":"Download","text":"<p>You can keep up to date by cloning a read-only copy of our GitHub repository.</p>"},{"location":"#known-issues","title":"Known Issues","text":"<p>We rely heavily on Eigen. Nearly all inputs and outputs are Eigen matrices of some kind. However, we currently only officially support Eigen\u2019s default column-major ordering. That means, we do not expect our code to work for matrices using the <code>Eigen::RowMajor</code> flag. If you can, change definitions like:</p> <pre><code>Eigen::Matrix&lt;double, Eigen::Dynamic, 3, Eigen::RowMajor&gt; A;\n</code></pre> <p>to</p> <pre><code>Eigen::Matrix&lt;double, Eigen::Dynamic, 3, Eigen::ColMajor&gt; A;\n// or simply\nEigen::Matrix&lt;double, Eigen::Dynamic, 3&gt; A;\n</code></pre> <p>We hope to fix this, or at least identify which functions are safe (many of them probably work just fine). This requires setting up unit testing, which is a major todo for our development.</p>"},{"location":"#unit-testing","title":"Unit Testing","text":"<p>As of v2.0.0, unit tests have been moved into the main libigl repository, under the <code>tests/</code> folder. Unit test data is downloaded at CMake time if the option <code>LIBIGL_BUILD_TESTS=ON</code> is given. Please read this page for more information about unit testing in libigl.</p>"},{"location":"#how-to-contribute","title":"How to Contribute","text":"<p>If you are interested in joining development, please fork the repository and submit a pull request with your changes. libigl follows strict coding guidelines, please take a look at our  style guidelines before submitting your pull requests.</p>"},{"location":"#license","title":"License","text":"<p>libigl is primarily MPL2 licensed (FAQ). Some files contain third-party code under other licenses. We\u2019re currently in the processes of identifying these and marking appropriately.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use libigl in your academic projects, please cite the papers we implement as appropriate. To cite the library in general, you could use this BibTeX entry:</p> <pre><code>@misc{libigl,\ntitle = { {libigl}: A simple {C++} geometry processing library},\nauthor = {Alec Jacobson and Daniele Panozzo and others},\nnote = {https://libigl.github.io/},\nyear = {2018},\n}\n</code></pre>"},{"location":"#projectsuniversities-using-libigl","title":"Projects/Universities using libigl","text":"<p>Libigl is used by many research groups around the world. In 2015, it won the Eurographics/ACM Symposium on Geometry Processing software award. Here are a few labs/companies/institutions using libigl:</p> <ul> <li>Activision</li> <li>Adobe Research</li> <li>Electronic Arts, Inc</li> <li>Epic Games</li> <li>Google Research</li> <li>Industrial Light and Magic</li> <li>Mesh consultants, Canada</li> <li>Microsoft Research</li> <li>Pixar</li> <li>Spine by Esoteric Software is an animation tool dedicated to 2D characters.</li> <li>vvvv toolkit a multipurpose tookit</li> <li>Columbia University, Columbia Computer Graphics Group, USA</li> <li>Cornell University, USA</li> <li>Czech Technical University in Prague, Czech</li> <li>EPF Lausanne, Computer Graphics and Geometry Laboratory, Switzerland</li> <li>ETH Zurich, Interactive Geometry Lab and Advanced Technologies Lab, Swizterland</li> <li>George Mason University, CraGL, USA</li> <li>Hong Kong University of Science and Technology, Hong Kong</li> <li>Inria, Universit\u00e9 Grenoble Alpes, France</li> <li>Jiangnan university, China</li> <li>National Institute of Informatics, Japan</li> <li>New York University, Media Research Lab, USA</li> <li>NYUPoly, Game Innovation Lab, USA</li> <li>TU Berlin, Germany</li> <li>TU Delft, Netherlands</li> <li>TU Wien, Austria</li> <li>Telecom ParisTech, Paris, France</li> <li>UBISOFT, USA</li> <li>Utrecht University, The Netherlands</li> <li>Universidade Federal de Santa Catarina, Brazil</li> <li>University College London, England</li> <li>University of California Berkeley, USA</li> <li>University of Cambridge, England</li> <li>University of Pennsylvania, USA</li> <li>University of Texas at Austin, USA</li> <li>University of Toronto, Canada</li> <li>University of Victoria, Canada</li> <li>University of Wisconsin-Eau Claire, USA</li> <li>Universit\u00e0 della Svizzera Italiana, Switzerland</li> <li>Universit\u00e9 Toulouse III Paul Sabatier, France</li> <li>Zhejiang University, China</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>Libigl is a group endeavor led by Alec Jacobson and Daniele Panozzo. Please contact us if you have questions or comments. For troubleshooting, please post an issue on github.</p> <p>If you\u2019re using libigl in your projects, quickly drop us a note. Tell us who you are and what you\u2019re using it for. This helps us apply for funding and justify spending time maintaining this.</p> <p>If you find bugs or have problems please use our github issue tracking page.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>2019 Alec Jacobson, Daniele Panozzo, Christian Sch\u00fcller, Olga Diamanti, Qingnan Zhou, Sebastian Koch, Jeremie Dumas, Amir Vaxman, Nico Pietroni, Stefan Brugger, Kenshi Takayama, Wenzel Jakob, Nikolas De Giorgis, Luigi Rocca, Leonardo Sacht, Kevin Walliman, Olga Sorkine-Hornung, Teseo Schneider, and others.</p> <p>Please see individual files for appropriate copyright notices.</p>"},{"location":"before-submitting-pull-request/","title":"Before Submitting A Pull Request","text":"<p>There are a variety of things you can do before submitting a pull request that will reduce the effort on the libigl team to merge your code and increase the likelihood that the merge ever happens.</p> <ol> <li>Make sure you are up-to-date with the master branch to create your pull request.</li> <li>Test your code and submit a unit test as part of the pull request;</li> <li>Verify that your code matches the libigl style guidelines;</li> </ol> <p>Tip</p> <p>When opening a pull-request to fix a known bug, you can link to and existing github issue or pull-request by mentioning their number in your message. See for example #954.</p>"},{"location":"before-submitting-pull-request/#compilation-using-static-library","title":"Compilation Using Static Library","text":"<p>If you are using libigl in header-only mode, please ensure that your code also compiles when enabling the CMake flag <code>LIBIGL_USE_STATIC_LIBRARY</code>:</p> <pre><code>mkdir build-use-static\ncd build-use-static\ncmake -DCMAKE_BUILD_TYPE=Release -DLIBIGL_USE_STATIC_LIBRARY=ON ..\nmake\nmake test\n</code></pre>"},{"location":"before-submitting-pull-request/#troubleshooting","title":"Troubleshooting","text":"<p>A typical issue is a missing template instantiation (symbol not found):</p> <pre><code>\"void igl::cgal::points_inside_component&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;(Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;&amp;)\", referenced from:\n    void igl::cgal::outer_hull&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;long, -1, 1, 0, -1, 1&gt;, Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;(Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt;&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;long, -1, 1, 0, -1, 1&gt; &gt;&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;&amp;) in libiglboolean.a(mesh_boolean.cpp.o)\n    void igl::cgal::outer_hull&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;long, -1, 1, 0, -1, 1&gt;, Eigen::Matrix&lt;bool, -1, 1, 0, -1, 1&gt; &gt;(Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt;&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;long, -1, 1, 0, -1, 1&gt; &gt;&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;bool, -1, 1, 0, -1, 1&gt; &gt;&amp;) in libiglboolean.a(mesh_boolean.cpp.o)\n</code></pre> <p>This looks like a mess, but the solution is very simple. Copy the chunk inside of the quotes, in this case:</p> <pre><code>\"void igl::cgal::points_inside_component&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;(Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;double, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;&amp;)\"\n</code></pre> <p>and paste it at the bottom of the relevant .cpp file with the word template in front of it and a semicolon at then. In this case, in include/igl/cgal/points_inside_component.cpp:</p> <pre><code>#ifdef IGL_STATIC_LIBRARY\n// Explicit template instantiation\ntemplate void igl::cgal::points_inside_component&lt;Eigen::Matrix&lt;CGAL::Lazy_exact_nt&lt;CGAL::Gmpq&gt;, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;CGAL::Lazy_exact_nt&lt;CGAL::Gmpq&gt;, -1, 3, 0, -1, 3&gt;, Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;(Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;CGAL::Lazy_exact_nt&lt;CGAL::Gmpq&gt;, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;CGAL::Lazy_exact_nt&lt;CGAL::Gmpq&gt;, -1, 3, 0, -1, 3&gt; &gt; const&amp;, Eigen::PlainObjectBase&lt;Eigen::Matrix&lt;int, -1, 1, 0, -1, 1&gt; &gt;&amp;);\n#endif\n</code></pre> <p>Then \u201crinse and repeat\u201d.</p>"},{"location":"bug-report/","title":"Bug Report","text":"<p>Before opening an issue on creating a pull request, please check the following:</p> <p>Tip</p> <ul> <li> <p>Make sure you read the   FAQ before asking a new   question, search existing   issues   for a problem similar to yours.</p> </li> <li> <p>Make sure you read the information contained in the libigl   homepage as well as the   tutorial.</p> </li> </ul>"},{"location":"bug-report/#general-issues","title":"General Issues","text":"<ul> <li> <p>Make sure you are up-to-date with the main branch, and verify that   your issue has not been fixed already before opening an issue on github.</p> </li> <li> <p>To report a problem about the website (out-of-date content, erroneous   instructions or errors in the tutorial), please open your issue in the   designated repository   for the website.</p> </li> </ul>"},{"location":"bug-report/#compilation-issues","title":"Compilation Issues","text":"<ul> <li> <p>If you are on Windows, did you select the x64 version of the Visual   Studio compiler?</p> </li> <li> <p>If you have a CMake issue, make sure you follow the same approach as the   libigl-example-project   to build libigl with your project, and make sure that you can compile the   example project. Please also make sure to delete your CMakeCache.txt,   or delete your build/ folder and try again.</p> </li> <li> <p>If you have an issue with a submodule, then you are using an old version   of libigl. Please read this page about the transition   to v2.0.0.</p> </li> <li> <p>If you have an issue with downloading an external dependency using the   CMake build, delete the <code>external/</code> folder and try again.</p> </li> <li> <p>If you have an issue with a missing template, check that your code   compiles with the header-only option of libigl activated. Turn <code>OFF</code>   the CMake option <code>LIBIGL_USE_STATIC_LIBRARY</code>: either modify your   <code>CMakeCache.txt</code> via CMake GUI or ccmake, or delete your <code>CMakeCache.txt</code>   and re-run <code>cmake -DLIBIGL_USE_STATIC_LIBRARY=OFF ..</code> in your build folder.</p> </li> <li> <p>If none of these solve your problem, then please report your issue in the   bug tracker!</p> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#version-summary-table","title":"Version Summary Table","text":"Click to unroll. Version Short description main \u2026 2.4.0 Bug fixes, CMake tidying, imgui widgets, broad M1 mac support, dependency bumps 2.3.0 Dual Contouring, DDM skinning, B\u00e9zier, PLY reader, 3D text rendering, matcap 2.2.0 New python bindings, fast winding number for soups, ICP algorithm 2.1.0 Various improvements and bug fixes, updated dependencies 2.0.0 Lighter, simpler CMake build, rewritten history 1.3.3 Switched the build system from submodules to CMake external projects 1.3.2 After merging PRs in the 2018 hackaton 1.3.1 Before merging PRs in the 2018 hackaton 1.3.0 Modernized cmake build, multi-mesh viewer, replace nanogui with imgui 1.2.1 Reorganization opengl-dependent functions: opengl and opengl2 extras 1.2.0 Reorganization of \u201cextras\u201d, rm deprecated funcs, absorb boost &amp; svd3x3 1.1.7 Switch build for static library to cmake. 1.1.6 Major boolean robustness fix, drop CGAL dependency for AABB/distances 1.1.5 Bug fix in booleans 1.1.4 Edge collapsing and linear program solving 1.1.3 Bug fixes in active set and boundary_conditions 1.1.1 PLY file format support 1.1.0 Mesh boolean operations using CGAL and cork, implementing [Attene 14] 1.0.3 Bone heat method 1.0.2 Bug fix in winding number code 1.0.1 Bug fixes and more CGAL support 1.0.0 Major beta release: many renames, tutorial, triangle, org. build 0.4.6 Generalized Winding Numbers 0.4.5 CGAL extra: mesh selfintersection 0.4.4 STL file format support 0.4.3 ARAP implementation 0.4.1 Migrated much of the FAST code including extra for Sifakis\u2019 3x3 svd 0.4.0 Release under MPL2 license 0.3.7 Embree2.0 support 0.3.6 boost extra, patches, mosek 7 support, libiglbbw (mosek optional) 0.3.5 More examples, naive primitive sorting 0.3.3 Many more examples, ambient occlusion with Embree. 0.3.1 Linearly dependent constraints in min_quad_with_fixed, SparseQR buggy 0.3.0 Better active set method support 0.2.3 More explicits, active set method, opengl/anttweakbar guards 0.2.2 More explicit instantiations, faster sorts and uniques 0.2.1 Bug fixes in barycenter and doublearea found by Martin Bisson 0.2.0 XML serializer more stable and fixed bug in remove_duplicate_vertices 0.1.8 Embree and xml (windows only) extras 0.1.5 Compilation on windows, bug fix for compilation with cygwin 0.1.1 Alpha release with core functions, extras, examples"},{"location":"changelog/#upcoming-version-250-changes","title":"Upcoming Version 2.5.0 Changes","text":"<p>The following changes are represent in the main branch of libigl, but not yet included in a tagged release.</p>"},{"location":"changelog/#bugfixes","title":"Bugfixes","text":"<ul> <li><code>ViewerData::set_data()</code> now accepts #F-long data vectors (1f44d1e)</li> </ul>"},{"location":"changelog/#enhancements","title":"Enhancements","text":"<ul> <li><code>ismember_rows</code> split into its own file (may need to change <code>#include &lt;igl/ismember.h&gt;</code> to <code>#include &lt;igl/ismember_rows.h&gt;</code> (#1989)</li> <li><code>igl::predicates::delaunay_triangulation</code> and <code>igl::predicates::lexicographic_triangulation</code> routines (#1988)</li> <li>properly expose edge-markers in <code>igl::triangle::triangulate</code> (#1983)</li> </ul>"},{"location":"changelog/#compilation","title":"Compilation","text":""},{"location":"changelog/#version-240-changes","title":"Version 2.4.0 Changes","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<p>Libigl v2.4.0 introduced a number of breaking changes regarding its CMake build system. If you follow the upgrade guide below, these breaking changes should be easy to resolve.</p> <p>Tip</p> <p>When starting a new project using libigl, use the libigl-example-project as a starting point.</p>"},{"location":"changelog/#cmake-entry-point","title":"CMake entry point","text":"<p>The main entry point for CMake is now the <code>CMakeLists.txt</code> at the root of the libigl repository. If you were using a <code>FindLibigl.cmake</code>, or were including <code>libigl.cmake</code> directly, please update your project.</p> <p>If you are using the libigl-example-project, you may update the content of <code>cmake/libigl.cmake</code> to the following:</p> <pre><code>if(TARGET igl::core)\nreturn()\nendif()\n\ninclude(FetchContent)\nFetchContent_Declare(\nlibigl\nGIT_REPOSITORY https://github.com/libigl/libigl.git\nGIT_TAG &lt;TARGET_SHA1&gt;\n)\nFetchContent_MakeAvailable(libigl)\n</code></pre>"},{"location":"changelog/#cmake-targets","title":"CMake targets","text":"<p>The CMake targets for many libigl modules have been renamed in v2.4.0. This provides greater visibility into each module category (between regular, copyleft and restricted modules). Here is the table mapping the old names to the new names:</p> Old target name (v2.3.0) New target name (v2.4.0) <code>igl::embree</code> Unchanged <code>igl::opengl_glfw</code> <code>igl::glfw</code> <code>igl::opengl_glfw_imgui</code> <code>igl::imgui</code> <code>igl::opengl</code> Unchanged <code>igl::png</code> Unchanged <code>igl::predicates</code> Unchanged <code>igl::xml</code> Unchanged <code>igl_copyleft::core</code> (New) <code>igl::cgal</code> <code>igl_copyleft::cgal</code> <code>igl::comiso</code> <code>igl_copyleft::comiso</code> <code>igl::cork</code> Removed <code>igl::tetgen</code> <code>igl_copyleft::tetgen</code> <code>igl::matlab</code> <code>igl_restricted::matlab</code> <code>igl::mosek</code> <code>igl_restricted::mosek</code> <code>igl::triangle</code> <code>igl_restricted::triangle</code> <p>Important</p> <p>The libigl cork wrapper was removed from this release. A standalone repository with a libigl-style wrapper around cork is available here.</p>"},{"location":"changelog/#cmake-options","title":"CMake options","text":"<p>Many libigl CMake options have changed in v2.4.0. Here is a mapping from the old name to the new names:</p> Old option (v2.3.0) New option (v2.4.0) LIBIGL_COPYLEFT_CORE (New) LIBIGL_BUILD_TESTS Unchanged LIBIGL_BUILD_TUTORIALS Unchanged LIBIGL_EXPORT_TARGETS LIBIGL_INSTALL LIBIGL_USE_STATIC_LIBRARY Unchanged LIBIGL_WITH_CGAL LIBIGL_COPYLEFT_CGAL LIBIGL_WITH_COMISO LIBIGL_COPYLEFT_COMISO LIBIGL_WITH_CORK Removed LIBIGL_WITH_EMBREE LIBIGL_EMBREE LIBIGL_WITH_MATLAB LIBIGL_RESTRICTED_MATLAB LIBIGL_WITH_MOSEK LIBIGL_RESTRICTED_MOSEK LIBIGL_WITH_OPENGL LIBIGL_OPENGL LIBIGL_WITH_OPENGL_GLFW LIBIGL_GLFW LIBIGL_WITH_OPENGL_GLFW_IMGUI LIBIGL_IMGUI LIBIGL_WITH_PNG LIBIGL_PNG LIBIGL_WITH_PREDICATES LIBIGL_PREDICATES LIBIGL_WITH_PYTHON Removed LIBIGL_WITH_TETGEN LIBIGL_COPYLEFT_TETGEN LIBIGL_WITH_TRIANGLE LIBIGL_RESTRICTED_TRIANGLE LIBIGL_WITH_XML Unchanged <p>Tip</p> <p>There is a now a sample file <code>LibiglOption.cmake.sample</code> at the root of the libigl repository. Simply remove the <code>.sample</code> extension and edit this file to modify libigl compilation options. If you are using libigl as a subdirectory (e.g. in a parent project), then please set your options in the parent project instead.</p>"},{"location":"changelog/#imgui-headers","title":"ImGui headers","text":"<p>We are also updating our ImGui dependency to use the base repository as include folder, rather than forcing headers to be copied into a <code>imgui/</code> subfolder. This helps be consistent with other projects that might be using ImGui. This requires users changing their include headers as follows:</p> <ul> <li><code>#include &lt;imgui/imgui.h&gt;</code> \u2192 <code>#include &lt;imgui.h&gt;</code></li> <li><code>#include &lt;imgui/imgui_internal.h&gt;</code> \u2192 <code>#include &lt;imgui_internal.h&gt;</code></li> <li><code>#include &lt;imgui_impl_glfw.h&gt;</code> \u2192 <code>#include &lt;backends/imgui_impl_glfw.h&gt;</code></li> <li><code>#include &lt;imgui_impl_opengl3.h&gt;</code> \u2192 <code>#include &lt;backends/imgui_impl_opengl3.h&gt;</code></li> </ul>"},{"location":"changelog/#imguimenuimguizmopluginselectionplugin-imguiwidgets","title":"ImGuiMenu,ImGuizmoPlugin,SelectionPlugin \u2192 ImGuiWidgets","text":"<p>We\u2019ve introduced a new \u201cparent\u201d <code>ImGuiPlugin</code> which handles ImGui IO functions and converted the old <code>ImGuiMenu</code>, <code>ImGuizmoPlugin</code>, <code>SelectionPlugin</code> plugins to inherit from a new <code>ImGuiWidget</code> class. In this way, a single <code>ImGuiPlugin</code> can be registered to the viewer\u2019s plugins list and one or many widgets are registered to this plugin\u2019s widgets list.</p> <p>For folks just using the menu, this incurs a few extra lines. To add the menu:</p> <pre><code>#include &lt;igl/opengl/glfw/imgui/ImGuiPlugin.h&gt;\n#include &lt;igl/opengl/glfw/imgui/ImGuiMenu.h&gt;\n\u2026\nigl::opengl::glfw::imgui::ImGuiPlugin plugin;\nviewer.plugins.push_back(&amp;plugin);\nigl::opengl::glfw::imgui::ImGuiMenu menu;\nplugin.widgets.push_back(&amp;menu);\n</code></pre> <p>The reward is that now we can use all of these plugins (and any new user created plugins using ImGui subroutines) without conflict.</p>"},{"location":"changelog/#other-changes","title":"Other Changes","text":""},{"location":"changelog/#bugfixes_1","title":"Bugfixes","text":"<ul> <li>Fix #1656 \u201cCan only have one ImGuiMenu plugin at a time\u201d (#1973)</li> <li>Fix #1924 \u201cPLY with no faces throw SIGFPE in ReadPLY\u201d (#1927)</li> <li>LSCM: fix sign for the area term (#1853)</li> <li>Fix bug in igl::read_file_binary (#1821)</li> <li>Fix #1795 \u201cCan\u2019t convert CGAL::Polyhedron_3 to mesh\u201d (#1796)</li> <li>Fix the order of principal curvature (#1767)</li> <li>Fix dirty flag for ViewerData::set_labels (#1761)</li> </ul>"},{"location":"changelog/#enhancements_1","title":"Enhancements","text":"<ul> <li>Modified arap interface to accept Eigen::Map (#1922)</li> <li>Wrapper around CGAL\u2019s 2D constrained delaunay triangulation (#1811) </li> <li>Delete obsolete function <code>igl::point_in_poly</code> (#1810)</li> <li>Instead of calling exit(1), triangle now throws an exception (#1800)</li> <li>Use igl::default_num_threads in cgal module (#1768)</li> <li>Added double_sided flag to embree renderer (#1765)</li> <li>Replace Eigen::PlainObjectBase with Eigen::MatrixBase for input of ambient_occlusion (#1752)</li> <li>10-100x speedup on per corner normals + caching adjacency (#1745)</li> </ul>"},{"location":"changelog/#compilation_1","title":"Compilation","text":"<ul> <li>Update Catch2 to v2.13.8 (#1972)</li> <li>Update Embree to v13.3.3 (#1976)</li> <li>Broad support for M1 macs (#1976, #1975)</li> <li>Update ImGui to v1.85 + use default include folders for ImGui (#1970) </li> <li>CMake refactor (#1805)</li> <li>CGAL and Boost are now built entirely from source via CMake. This means the CGAL module will work out of the box under Windows \u2013 no need for a conda virtual environment. On Linux/macOS, the only dependency to install system-wide are GMP+MPFR.</li> <li>CMake targets and options have been renamed based on the module category: regular/copyleft/restricted. This eliminates long module names (<code>igl::open_glfw_imgui</code>) that didn\u2019t bring much to the table, in favor of three root classes based on available licenses for each module.</li> <li>There is now a <code>LibiglOptions.cmake</code> sample file at the root of the project repository, which should make it easier to document/update available CMake options.</li> <li>There is now a unique entry point for the project, which is the root <code>CMakeLists.txt</code>. This facilitates maintenance, as before either <code>tutorial/CMakeLists.txt</code> and <code>cmake/libigl.cmake</code> could serve as potential entry points.</li> <li>The default behavior for module compilation is:<ul> <li>When compiling libigl on its own, all modules are enabled by default.</li> <li>When compiling libigl as a subproject, all modules are disabled by default.</li> <li>On Linux/macOS, if GMP/MPFR is not installed on the system, shows a warning and disable CGAL by default.</li> <li>If Mosek/Matlab are not installed on the system, shows a warning and disable the Mosek/Matlab libigl wrappers respectively.</li> <li>If the user explicitly enables those modules, but they do not have GMP/MPFR/Mosek/Matlab installed on the system, CMake configuration will fail.</li> </ul> </li> <li>Big cleanup of the tutorial CMake definitions. With the new setup adding a new tutorial is even easier!</li> <li>Cleaned up dependency setup for imgui/stb (among others)</li> <li>Unit tests have been split into different CMake target, based on which module is tested.</li> <li>Add support for Hunter + install() for the <code>igl::core</code> module (should be the same as before).</li> <li>Use a more generic <code>igl_copy_dll()</code> function to copy GMP/MPFR dlls on Windows (should work to copy the CoMiSo dll as well).</li> <li>Cleaned up our .gitignore file.</li> <li>Fix blue noise random shuffle for C++17 (#1949)</li> <li>Bump triangle version (#1813) and tetgen version (#1815)</li> <li>Templates EmbreeRenderer (#1788)</li> <li>Fix Cuda compilation issue on Windows (#1747)</li> <li>Split min_quad_with_fixed implementation into separate cpp (#1746)</li> <li>Silence MSVC warning with std::getenv (#1744)</li> <li>Fix usage of find_package(OpenGL) on Linux (#1733)</li> </ul>"},{"location":"changelog/#version-230-changes","title":"Version 2.3.0 Changes","text":"<p>Warning</p> <p>This is our last stable release before some planned major reorganization (see #1696 for details). The upcoming reorganization is aimed at facilitating maintenance and packaging of various libigl components. The next release will be a new major version of libigl (3.0.0).</p>"},{"location":"changelog/#new-features","title":"New Features","text":"<ul> <li>Dual contouring (#1716)</li> <li>Viewer: Selection Plugin (#1654)</li> <li>Implements \u201cPolygon Laplacian Made Simple\u201d (#1653)</li> <li>Offscreen meshes rendering using Embree (#1652)</li> <li>Signing distances with Fast Winding Number (#1630) </li> <li>Turn ImGuizmo tutorial into a viewer plugin (#1618)</li> <li>Adds MATLAB-like function <code>igl::blkdiag</code> to build a block-diagonal matrix (#1617)</li> <li>Kelvinlet mesh deformation (#1614)</li> <li>Blue noise sampling on triangle meshes + adds <code>igl::barycentric_interpolation</code> (#1597)</li> <li>Direct Delta Mush skinning (#1541)</li> <li>New exploded view tutorial (#1510)</li> <li>B\u00e9zier curve evaluation (<code>igl::bezier</code>) and fitting (<code>igl::fit_cubic_bezier</code>) (#1476)</li> <li>Replace .ply reader/writer with tinyply library (#1422)</li> <li><code>igl::copyleft::cgal::wire_mesh</code> now support per-edge thickness. Adds <code>igl::copyleft::cgal::coplanar</code> test (#1488)</li> <li>New generic function for connected components (<code>igl::connected_components</code>) (#1487)</li> <li>Viewer: matcap support (#1482) + tutorial entry (#1646)</li> <li>Viewer: option for double-sided lighting (#1480)</li> <li>Viewer: new 3D text rendering feature, supporting proper label depth (#1549)</li> </ul>"},{"location":"changelog/#build-system","title":"Build System","text":"<ul> <li>Update ImGui to 1.81 (#1723), fixing rendering issue with newer Visual Studio</li> <li>Fix mosek to work with 9.2; fix mosek dynamic link via CMake (#1675)</li> <li>Reimplement <code>igl::marching_cubes</code> outside of the <code>copyleft/</code> folder (#1666, #1687)</li> <li>Update GLFW to fix an issue on macOS with CMake 3.19.0 (#1657)</li> <li>Update Embree to v3.12.1 (#1648)</li> <li>Use new gitlab remote to clone Eigen (#1631)</li> <li>Update compiler versions in github actions (#1629)</li> <li>Update CoMiSo version (#1608). Note that CoMiSo support for libigl is deprecated and will be removed in version 3.0.</li> <li>Removed <code>_bin</code> suffix from executable files (#1594)</li> <li>Moved SCAF to triangle folder (#1590)</li> <li>Various fixes to github actions (#1649, #1651, #1721)</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Control number of threads in parallel_for with env variable <code>IGL_NUM_THREADS</code> (#1684)</li> <li>Support msh in <code>igl::read_triangle_mesh</code> (#1645)</li> <li>Change boundary weight from length to length squared in <code>igl::per_vertex_point_to_plane_quadrics</code> (#1644)</li> <li>Update STL read to work on problematic thingi10K meshes (#1628)</li> <li>Use an enum to specify file encoding when writing files (#1619)</li> <li>Removed some functions marked as deprecated (#1610) </li> <li>Fix bug with epsilon parameter in <code>igl::remove_duplicate_vertices</code> (#1603)</li> <li>Removed unused function <code>igl::barycentric_to_global</code> (#1596)</li> <li>Fix align_camera_center in Viewer::init() for multiple cores (#1349)</li> <li>Add floating point exceptions in unit tests (#1001)</li> <li>Extended serialization functionality to Eigen::Array (#1113)</li> <li>SCAF: Expose linear system to be solved by user code (#1553)</li> <li>Fix issue with <code>igl::heat_geodesic</code> (#1497)</li> <li>Refactored <code>igl::is_edge_manifold</code> (#1509)</li> <li>Various bugfixes, compile fixes, template fixes (#1335, #1361, #1400, #1402, #1430, #1438, #1441, #1471, #1475, #1484, #1494, #1495, #1497, #1525, #1538, #1544, #1546, #1581, #1582, #1625, #1627, #1638, #1640, #1642, #1658, #1673, #1674, #1679, #1694, #1704, #1709)</li> </ul>"},{"location":"changelog/#version-220-changes","title":"Version 2.2.0 Changes","text":""},{"location":"changelog/#python-bindings","title":"Python Bindings","text":"<p>The python bindings have been moved to a separate repository. These are now available as an conda package.</p>"},{"location":"changelog/#new-features_1","title":"New Features","text":"<ul> <li>Fast winding number for triangle soups (#1218)</li> <li>Iterative closest point algorithm + tutorial (#1347)</li> <li>Ear clipping triangulation (#1169)</li> <li>Added <code>igl::path_to_edges</code> function (#1259)</li> <li><code>igl::dijkstra</code> can now use mesh edge length (#1170)</li> <li>Keep reference to multiple material when reading obj (#1280)</li> <li>Added <code>igl::sharp_edges</code> for sharp edges extraction (#1364)</li> <li>Added <code>igl::unproject_on_line</code>, <code>igl::unproject_on_plane</code> and <code>igl::projection_constraint</code> to compute cursor (un)-projections (#1368)</li> <li>Added <code>igl::quad_grid</code> and <code>igl::triangulated_grid</code> to create meshes from regular grids (#1369)</li> <li>Added <code>igl::isolines_map</code>, <code>ViewerData::set_data</code> and <code>ViewerData::set_colormap</code> to improve scalar field visualization in the Viewer, and updated tutorials accordingly (#1371)</li> <li>Added new <code>COLOR_MAP_TYPE_TURBO</code> colormap, based on Turbo. Jet is now an alias for Turbo, and switched to Viridis as default colormap in the viewer (#1372)</li> <li>Added <code>igl::slice_sorted</code> and removed deprecated <code>Eigen::DynamicSparsematrix</code> from <code>igl::slice</code> (#1370)</li> </ul>"},{"location":"changelog/#build-system_1","title":"Build System","text":"<ul> <li>Overhauled function signatures in preparation of new python bindings (#1162, #1228, #1271, #1274)</li> <li>Added a conda environment <code>cmake/libigl-cgal.yml</code> to provide boost for Windows users (#1239)</li> <li>Added experimental support for Hunter (#1242)</li> <li>Now <code>libigl.cmake</code> will define a CMake target <code>Eigen3::Eigen</code> if not provided by the user (#1299)</li> <li>Added <code>igl_set_folders()</code> to sort CMake targets into folders in IDEs such as Visual Studio or Xcode (#1383)</li> <li>Minor fixes to our CMake build system (#1363)</li> <li>Github actions for CI replacing appveyor and travis (#1389)</li> </ul>"},{"location":"changelog/#misc_1","title":"Misc","text":"<ul> <li>Fix underflow issue when computing normalization in <code>igl::heat_geodesics</code> (#1344) </li> <li>Update nrosy to match the MIQ paper (#1303)</li> <li>Delete <code>Embree_convenience.h</code> (#1314)</li> <li>Refactored <code>igl::cut_mesh</code> (#1332)</li> <li>Various improvements to the viewer (#1196, #1251, #1366)</li> <li>Unit tests: cleand up <code>test_common.h</code> (#1365)</li> <li>Made call to <code>igl::predicates::exactinit()</code> thread-safe + marked internal functions in <code>predicates.c</code> as <code>static</code> to prevent name collisions (#1377)</li> <li>Doc cleanup (#1376)</li> <li>Allows <code>igl::hsv_to_rgb</code> to work on negative hues (#1399)</li> <li>Explicitly marked the following functions as deprecated (#1380):<ul> <li><code>igl::all_edges</code></li> <li><code>igl::internal_angles_using_edge_lengths</code> (only a specific overload is affected)</li> <li><code>igl::is_border_vertex</code> (only a specific overload is affected)</li> <li><code>igl::remove_duplicates</code></li> </ul> </li> <li>Various bugfixes, code cleanup and explicit template instantiations (#1197, #1210, #1216, #1231, #1247, #1258, #1288, #1309, #1320, #1337, #1345, #1379, #1396, #1327)</li> </ul>"},{"location":"changelog/#version-210-changes","title":"Version 2.1.0 Changes","text":"<ul> <li>Various code cleanup, compilation fixes, and explicit template instantiations</li> <li>Added wrapper around Shewchuk\u2019s predicates (#1163)</li> <li>libigl now also compiles with Eigen 3.3 (#1110).</li> <li>Extended <code>igl::cat</code> functionalities (#1108)</li> <li>Extended <code>boundary_facets</code> with outputs revealing which element facet comes from (#1067)</li> <li>Use <code>std::shuffle</code> instead of <code>std::random_shuffle</code> in <code>igl/randperm</code> (#1062)</li> <li>Fixed an Eigen alignment issue in the viewer (#1029)</li> <li>Removed LIM tutorial (#1012, #1014)</li> <li>Fixed current python bindings (#1008)</li> <li>Intrinsic Delaunay triangulation (#988)</li> <li>New Heat Geodesics feature (#988, #1140). See also tutorial 716.</li> <li>Switched from Google Test to Catch2 (#961), and added various unit tests</li> <li>Fixed an issue with transparent window on macOS that was introduced in v2.0.0 (#953)</li> <li>Updated dependencies: Embree 3 (#947), GLFW (#977, #1153), ImGui (#1039), std-image (#1072)</li> <li>Added sparse voxel grids (#937, #942) and tutorial 715 for meshing implicit functions.</li> <li>Added tutorial 714 for marching tets (#716)</li> </ul>"},{"location":"changelog/#version-200-changes","title":"Version 2.0.0 Changes","text":"<p>This release is a result of the 2018 libigl hackathon at NYU. The major changes are:</p> <ul> <li>a simplified cmake set up that can build a static library, tutorials, tests, and python bindings;</li> <li>cmake now uses <code>ExternalProject_Add</code> to download necessary/requested dependency source code and tutorial/test data</li> <li>as a result, <code>git clone --recursive ...</code> is no longer required </li> <li>unit tests are now part of main repo and included in continuous integration (libigl/libigl-unit-tests is obsolete);</li> <li>tutorial data has been moved to libigl/libigl-tutorial-data;</li> <li>unit test data has been moved to libigl/libigl-tests-data;</li> <li>all dependencies previously in <code>libigl/external</code> have been removed or moved to repos (and added via <code>ExternalProject_Add</code>);</li> <li>documentation and the tutorial webpage has been moved to libigl/libigl.github.io;</li> <li>.git history of these files has been purged using bfg</li> <li>unfortunately this means that SHA hashes have changed and any external projects using libigl as a submodule will need to be refreshed to the new hashes.</li> <li>More information and instructions for troubleshooting at https://libigl.github.io/rewritten-history/.</li> <li>A legacy version with SHA hashes matching old repo is hosted at libigl/libigl-legacy.</li> </ul> <p>The major upshot is that the old <code>git clone --recursive</code> that resulted in a 1.8GB <code>libigl/</code> directory is now a <code>git clone</code> that results in 16.5MB, more than a 100x reduction in size. </p> <p>Name changes:</p> Old New <code>igl::components</code> <code>igl::vertex_components</code> <code>igl::slice_tets</code> <code>igl::marching_tets</code>"},{"location":"changelog/#version-132-changes","title":"Version 1.3.2 Changes","text":"<ul> <li>First version after all pull requests were merged during the libigl hackaton, and before switching from submodules to CMake external projects.</li> </ul>"},{"location":"changelog/#version-131-changes","title":"Version 1.3.1 Changes","text":"<ul> <li>Last version before pull requests were merged during the libigl hackaton.</li> <li><code>igl::components</code> has been renamed to <code>igl::vertex_components</code>.</li> <li><code>viewer.core.model</code> matrix is gone (#700).</li> </ul>"},{"location":"changelog/#version-130-changes","title":"Version 1.3.0 Changes","text":"<p>List of changes related to this version:</p> <ul> <li> <p>The CMake build system has been rewritten to be more modular and modern.   libigl modules are now available as CMake target, e.g. <code>igl::triangle</code> or   <code>igl::opengl</code>. See the libigl-example-project for an example of typical   usage.</p> </li> <li> <p><code>igl/antweakbar</code> and <code>igl/opengl2</code> support has been removed from the CMake.   The files are still available, but their use is discouraged.</p> </li> <li> <p>The viewer has been refactored and now supports multiple meshes. See related   tutorial entry for more information. The viewer files are now split   according to their dependencies. E.g. <code>igl::viewer::Viewer</code> has been renamed   <code>igl::opengl::glfw::Viewer</code>.</p> </li> <li> <p>NanoGui has been replaced by ImGui, and is now available as a viewer plugin   instead of <code>#define</code></p> </li> <li> <p>Polyvector code has been moved to   libdirectional (#630).</p> </li> </ul>"},{"location":"changelog/#version-12-changes","title":"Version 1.2 Changes","text":"<p>This change introduces better organization of dependencies and removes some deprecated/repeated functions. The 3x3 svd code and dependent functions (including ARAP) were absorbed into the main library. Similarly, the boost dependency extra was absorbed.</p>"},{"location":"changelog/#external-libraries-as-git-subrepos","title":"External libraries as git subrepos","text":"<p>The core functionality of libigl (still) just depends on stl, c++11 and Eigen. There are additional optional dependencies (e.g. CGAL, embree, glfw, tetgen, triangle). Libigl functions using these are located (still) in sub-folders of the include directory (e.g.  <code>include/igl/cgal/</code>, <code>include/igl/embree/</code>). Prior to version 1.2 we included copies of the code for some of these dependencies in the <code>external/</code> directory. As of version 1.2, these have been replaced with git sub-repos. If you have cloned libigl before version 1.2 then you should issue </p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"changelog/#deprecatedrepeated-functions","title":"Deprecated/repeated functions","text":"Old New <code>igl::angles</code> <code>igl::internal_angles</code> <code>igl::get_modifiers</code> [deleted] <code>igl::nchoosek(offset,K,N,std::vector)</code> <code>igl::nchoosek(Eigen,K,Eigen)</code> <code>#include &lt;igl/boost/components.h&gt;</code> <code>#include &lt;igl/components.h&gt;</code> <code>#include &lt;igl/boost/bfs_orient.h&gt;</code> <code>#include &lt;igl/bfs_orient.h&gt;</code> <code>#include &lt;igl/boost/orientable_patches.h&gt;</code> <code>#include &lt;igl/orientable_patches.h&gt;</code> <code>#include &lt;igl/svd3x3/arap.h&gt;</code> <code>#include &lt;igl/arap.h&gt;</code> <code>#include &lt;igl/svd3x3/arap_dof.h&gt;</code> <code>#include &lt;igl/arap_dof.h&gt;</code> <code>#include &lt;igl/svd3x3/fit_rotations.h&gt;</code> <code>#include &lt;igl/fit_rotations.h&gt;</code> <code>#include &lt;igl/svd3x3/polar_svd3x3.h&gt;</code> <code>#include &lt;igl/polar_svd3x3.h&gt;</code> <code>#include &lt;igl/svd3x3/svd3x3.h&gt;</code> <code>#include &lt;igl/svd3x3.h&gt;</code> <code>#include &lt;igl/svd3x3/svd3x3_avx.h&gt;</code> <code>#include &lt;igl/svd3x3_avx.h&gt;</code> <code>#include &lt;igl/svd3x3/svd3x3_sse.h&gt;</code> <code>#include &lt;igl/svd3x3_sse.h&gt;</code>"},{"location":"changelog/#version-10-changes","title":"Version 1.0 Changes","text":"<p>Our beta release marks our confidence that this library can be used outside of casual experimenting. To maintain order, we have made a few changes which current users should read and adapt their code accordingly.</p>"},{"location":"changelog/#renamed-functions","title":"Renamed functions","text":"<p>The following table lists functions which have changed name as of version 1.0.0:</p> Old New <code>igl::add_barycenter</code> <code>igl::false_barycentric_subdivision</code> <code>igl::areamatrix</code> <code>igl::vector_area_matrix</code> <code>igl::barycentric2global</code> <code>igl::barycentric_to_global</code> <code>igl::boundary_faces</code> <code>igl::boundary_facets</code> <code>igl::boundary_vertices_sorted</code> <code>igl::boundary_loop</code> <code>igl::cotangent</code> <code>igl::cotmatrix_entries</code> <code>igl::edgetopology</code> <code>igl::edge_topology</code> <code>igl::gradMat</code> <code>igl::grad</code> <code>igl::is_manifold</code> <code>igl::is_edge_manifold</code> <code>igl::mexStream</code> <code>igl::MexStream</code> <code>igl::moveFV</code> <code>igl::average_onto_vertices</code> <code>igl::moveVF</code> <code>igl::average_onto_faces</code> <code>igl::plot_vector</code> <code>igl::print_vector</code> <code>igl::pos</code> <code>igl::HalfEdgeIterator</code> <code>igl::plane_project</code> <code>igl::project_isometrically_to_plane</code> <code>igl::project_points_mesh</code> <code>igl::line_mesh_intersection</code> <code>igl::read</code> <code>igl::read_triangle_mesh</code> <code>igl::removeDuplicates.cpp</code> <code>igl::remove_duplicates</code> <code>igl::removeUnreferenced</code> <code>igl::remove_unreferenced</code> <code>igl::tt</code> <code>igl::triangle_triangle_adjacency</code> <code>igl::vf</code> <code>igl::vertex_triangle_adjacency</code> <code>igl::write</code> <code>igl::write_triangle_mesh</code> <code>igl::manifold_patches</code> <code>igl::orientable_patches</code> <code>igl::selfintersect</code> <code>igl::remesh_self_intersections</code> <code>igl::project_mesh</code> <code>igl::line_mesh_intersection</code> <code>igl::triangulate</code> <code>igl::polygon_mesh_to_triangle_mesh</code> <code>igl::is_manifold</code> <code>igl::is_edge_manifold</code> <code>igl::triangle_wrapper</code> <code>igl::triangulate</code>"},{"location":"changelog/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>To match interfaces provided by (all) other quadratic optimization    libraries, <code>igl::min_quad_with_fixed</code> and <code>igl::active_set</code> now expect as    input twice the quadratic coefficients matrix, i.e. the Hessian. For    example, <code>igl::min_quad_with_fixed(H,B,...)</code> minimizes \\frac{1}{2}x^T H    x+x^T B.</li> <li>We have inverted the <code>IGL_HEADER_ONLY</code> macro to <code>IGL_STATIC_LIBRARY</code>. To    compile using libigl as a header-only library, simply include headers and    libigl in the header search path. To link to libigl, you must define the    <code>IGL_STATIC_LIBRARY</code> macro at compile time and link to the <code>libigl*.a</code>    libraries.</li> <li>Building libigl as a static library is now more organized. There is a    <code>build/</code> directory with Makefiles for the main library (<code>Makefile</code>) and each    dependency (e.g. <code>Makefile_mosek</code> for <code>libiglmosek.a</code>)</li> <li><code>igl::polar_svd</code> now always returns a rotation in <code>R</code>, never a reflection.    This mirrors the behavior of <code>igl::polar_svd3x3</code>.  Consequently the <code>T</code>    part may have negative skews.</li> <li>We have organized the static library build</li> <li>The previous <code>igl::grad</code> function, which computed the per-triangle gradient    of a per-vertex scalar function has been replaced. Now <code>igl::grad</code> computes    the linear operator (previous computed using <code>igl::gradMat</code>). The gradient    values can still be recovered by multiplying the operator against the scalar    field as a vector and reshaping to have gradients per row.</li> <li><code>MASSMATRIX_*</code> has become <code>MASSMATRIX_TYPE_*</code></li> <li>The function <code>igl::project_normals</code>, which cast a line for each vertex of    mesh A in the normal direction and found the closest intersection along    these lines with mesh B, has been removed.</li> </ul>"},{"location":"coding-guidelines/","title":"Libigl Coding Tips (aka \u201cHow to code a SIGGRAPH project\u201d)","text":"<p>This is a short list of coding tips that will greatly reduce your pain and suffering before (and after) the SIGGRAPH deadline.</p>"},{"location":"coding-guidelines/#1-serialize-it-all","title":"1. Serialize it all","text":"<p>The entire state of your application should be serializable, i.e. It should be possible to save it into a binary file and reload it at any point. This drastically simplifies debugging, since you can serialize just before a crash happens and debug from that point without running your complete algorithm again. Serializing all results shown in the paper\u2019s figures enables quicker editing iterations before (and after) the deadline. It also allows you to share your results with others that wish to compare with your method. An additional tip is to serialize the state of the application on the window close event and automatically reload it when you launch it again.</p>"},{"location":"coding-guidelines/#2-always-assert","title":"2. Always assert","text":"<p>Even if you know what you are doing, always assert, you will be surprised. Assertion is a powerful but underused feature available in all programming languages. It is essential for writing research code since often you will have to implement algorithms that turns out to not be doing what you expect: in these cases it is important to know if the algorithm is flawed or if there is a bug in your implementation. Discarding a good idea  because of a coding bug is frustrating and unfortunately common. Assertion is an ideal way to reduce the chances of introducing bugs in your code and, differently from unit testing, requires a very minor programming effort. You should use them extensively.</p>"},{"location":"coding-guidelines/#3-plot-everything","title":"3. Plot everything","text":"<p>If you can visually plot the results or some intermediate steps of your algorithm, do it, even if you think your implementation is correct! It is a lot easier to find bugs or to get an intuition on an algorithm by looking at a plot than by looking at the code.</p>"},{"location":"coding-guidelines/#4-if-the-compilation-time-after-a-code-change-is-more-than-five-seconds-you-are-doing-it-wrong","title":"4. If the compilation time after a code change is more than five seconds, you are doing it wrong","text":"<p>You will change your code hundreds of times every day for months. Let\u2019s say that you will change it a hundred times a day (which is a  very conservative estimate): if the compilation takes one minute, you will waste almost two hours every day, just waiting! What is even worse, is that since it is only 1-2 minutes at a time, it will not even be sufficient to prepare a coffee. Spend the hour or two that is needed to get your code to compile in a few seconds, you will benefit from it in the same day already, and the time saved over an entire project will be gigantic.</p>"},{"location":"coding-guidelines/#5-commit-often-and-with-a-meaningful-description","title":"5. Commit often (and with a meaningful description)","text":"<p>Use a distributed version control system (git,hg), and keep the repository on a remote host. Commit often and put meaningful comments. This will serve you as an emergency backup and it will always allow you to have a running version of your code whenever your advisor is passing by and asking to see some results. She will be impressed and you will not have to quickly fix your build with your boss breathing down your neck.</p>"},{"location":"coding-guidelines/#6-dependencies-are-evil-avoid-them","title":"6. Dependencies are evil, avoid them","text":"<p>Keep your code simple and with minimal external dependencies. Spending a day or two to code something from scratch while avoiding to use third party code is usually an investment that pays off. The more code you have in your algorithm that is not written by you, the harder debugging becomes. In particular, refrain from building your entire project on code that you do not understand to avoid bad surprises just before the deadline. If you must use code written by others, spend the time that is needed to fully understand what it does, and link it statically so that it will be easy to place breakpoints inside it.</p>"},{"location":"coding-guidelines/#7-global-variables-are-not-evil-use-them","title":"7. Global variables are not evil, use them","text":"<p>Global variables are often extremely useful \u2014 if you think you need one, use it. They are indeed dangerous for large projects, but you are not coding one of those, you are coding a prototype to test a research idea. I suggest to keep one single copy of your entire application state in a global variable (or a singleton class) that can be serialized (see tip 1). This variable should include everything rendered on screen and all the temporary data produced by your algorithm. This will allow you to easily access all the data in your project for plotting or debugging purposes.</p>"},{"location":"coding-guidelines/#8-prototype-first","title":"8. Prototype first","text":"<p>Don\u2019t preemptively optimize and try to quickly write code that is clean and correct. It is common to try multiple different approaches to solve a new problem before finding the right one. This means that the majority of the code that you will write will not be used at the end of the project. While you should still write high-quality and bug-free code to make sure that your results is correct, you definitely do not want to spend time optimizing it before you are sure that is the right approach. In particular, it is helpful to learn a good prototyping language (Python, matlab) and use it for the early stages of the project and switch to (or mix it with) c++ only after finding a promising direction.</p>"},{"location":"coding-guidelines/#9-avoid-explicit-pointers","title":"9. Avoid explicit pointers","text":"<p>Do yourself a favor, do not use explicit pointers. If you use a language that supports explicit pointers, use them only if you really have to. And even in that case, keep them isolated in a single file and be very careful with them. Writing data inside another variable by accident might not trigger a crash, and simply produce strange artifacts that might convince you that a promising research direction does not work, while the problem lies in a nasty bug in your code. There is no reason to take that risk during prototyping, just avoid them and leave them for the end of the project in case they become necessary to optimize your code.</p>"},{"location":"coding-guidelines/#10-if-your-program-crashes-fix-it-now","title":"10. If your program crashes, fix it now!","text":"<p>If your program crashes, don\u2019t close your eyes and move on. Try to make it happen again, debug it and fix it immediately. These bugs are a nightmare to find, and the more code you add on top of a bug will just make it harder to find. If you don\u2019t fix it, due to Murphy\u2019s law, it will start to be problematic only a few days before the deadline and you will have no time to fix it at that point.</p> <p>Daniele Panozzo</p>"},{"location":"example-project/","title":"libigl example project","text":"<p>A blank project example showing how to use libigl and cmake can be found here. Feel free and encouraged to copy or fork this project as a way of starting a new personal project using libigl.</p>"},{"location":"example-project/#see-the-tutorial-first","title":"See the tutorial first","text":"<p>Then build, run and understand the libigl tutorial.</p>"},{"location":"example-project/#dependencies","title":"Dependencies","text":"<p>The only dependencies are the STL, libigl, Eigen3 (included in libigl) and the dependencies of the <code>igl::opengl::glfw::Viewer</code>.</p> <p>libigl can be installed by cloning the git repository on your computer: <pre><code>git clone https://github.com/libigl/libigl.git\n</code></pre> In the next section we discuss how to find an existing copy of libigl when compiling the example project.</p> <p>For ease of use, it can be a good idea to place your example project right next to the libigl folder. For example, if libigl is installed in <code>~/foo/libigl</code>, then you can create a copy of the example project right next to it: <pre><code>git clone https://github.com/libigl/libigl-example-project.git ~/foo/libigl-example-project\n</code></pre></p>"},{"location":"example-project/#compilation","title":"Compilation","text":"<p>Compile this project using the standard CMake routine:</p> <pre><code>mkdir build\ncd build\ncmake ../\nmake\n</code></pre> <p>Just make sure that CMake is able to find libigl. To do so CMake checks a few directories and environment variables, see FindLIBIGL.cmake. If your libigl version is located elsewhere, you can set the environment variable <code>LIBIGL_DIR</code> to the root directory of libigl, or pass this variable when invoking CMake from the command line: <pre><code>cmake -DLIBIGL_DIR=&lt;path-to-libigl&gt; ..\n</code></pre></p> <p>This should find and build the dependencies and create a <code>example_bin</code> binary.</p>"},{"location":"example-project/#run","title":"Run","text":"<p>From within the <code>build</code> directory just issue:</p> <pre><code>./example_bin\n</code></pre> <p>A glfw app should launch displaying a 3D cube.</p> <p> </p>      Libigl example project: libigl/libigl-example-project"},{"location":"example-project/#enabling-optional-modules-via-cmake","title":"Enabling optional modules via cmake","text":"<p>The example project already requires the <code>glfw</code> module. This shows up in the <code>CMakeLists.txt</code> in two places:</p> <pre><code>igl_include(glfw)\n\u2026\ntarget_link_libraries(${PROJECT_NAME} PUBLIC igl::glfw)\n</code></pre> <p>Suppose you\u2019d like to add another module, for example, so that you can include <code>#include &lt;igl/copyleft/tetgen/tetrahedralize.h&gt;</code> then you\u2019d change these to:</p> <pre><code>igl_include(copyleft tetgen)\n\u2026\ntarget_link_libraries(${PROJECT_NAME} PUBLIC igl::glfw igl_copyleft::tetgen)\n</code></pre>"},{"location":"faq/","title":"FAQ","text":"I\u2019d like to merge two 3D meshes into one. How to do it with igl? <p>It sounds like you\u2019re trying to compute a union. Are your two meshes closed, watertight manifolds? Then you could call <code>igl/boolean/mesh_boolean</code> with the union option. If not, then there\u2019s still hope with something else. [Alec]</p> In other apps I have seen the the user is asked to specify singularities , and the then the rosy field is generated. But in libigl it seems like you have to specify faces and direction vectors to design a field. Is it possible to specify singularities? <p>It is not possible to specify singularities right now. To specify the directions, the vectors should be in global coordinates (the vectors are 3D vectors, the libigl function takes care of projecting them onto the corresponding face), you can take a look here for a basic example that fixes only one face: Example 505 [Daniele]</p> Does Libigl use the same 2D Triangle code (my search in the Libigl source code indicates NO, but a confirmation would be reassuring)? <p>No, it uses CGAL for triangulation. [Alec]</p> Libigl\u2019s Boolean depends on some GPL-licensed header files from CGAL. Is it possible to remove this dependency? <p>No, the dependency on CGAL would require severely rewriting a core function. It is possible to do, but I will not do it. [Alec]</p> Do you have a ready to run command line program so that I can run a test with a few of my sample data sets? <p>No, but it would be very easy to alter the boolean tutorial example to do that. Basically drop the viewer and change the hardcoded paths to command line arguments and write out the result to an obj. [Alec]</p> I see that it can generate N-rosy fields, but is it possible to remesh based on the rosy field? <p>Here is an example that uses libigl to produce a seamless parametrization: Example 505</p> <p>If you want a mesh, you can pass this parametrization to libQEX (hcebke/libQEx) to extract it. We do not have it built in in the tutorial due to a more restrictive licence used by libQEx. [Daniele]</p> I am having issues with parameterization (igl::miq). Even at 100 iterations, there are still distortions. What is the cause? <p>This is unfortunately the expected behaviour, the MIQ parametrization tends to concentrate the distortion around singularities. [Daniele]</p> I am receiving compilation errors along the lines of \u201cISO C++ forbids declaration of \u2026 with no type\u201d when compiling under Windows using gcc. <p>We never tried to compile libigl on Windows with gcc, but we did test our library on:</p> <ul> <li>windows using visual studio</li> <li>linux with gcc</li> <li>macosx with clang</li> </ul> <p>You might have a version of gcc that doesn\u2019t support (enough of) c++11. Try using Cygwin and g++ 4.9.2. [Alec, Daniele]</p> What\u2019s the deal with CGAL and GCC 4.8? <p>It has come to our attention that CGAL does not work properly with GCC 4.8. Please read see #650, and in particular this thread, for more detailed information. [J\u00e9r\u00e9mie]</p> Why do a get a compilation error when writing <code>contexpr a = 1.0 / 2.0;</code>? <p>You are likely facing this issue because you are using CGAL 4.12+ with gcc. Starting from 4.12, CGAL now properly supports CMake. In particular, it will propagates flags such as <code>-frounding-math</code>, which will cause gcc to produce a compilation error on the code above. You can read more about this issue in the CGAL bug tracker, and how it may impact your code. Our current recommendation is to keep the CGAL parts self-contained as much as possible, and avoid such constructs in the parts of the code that use CGAL. [J\u00e9r\u00e9mie]</p> Should I use <code>Eigen::MatrixBase</code> or <code>Eigen::PlainObjectBase</code> as an argument for my templated functions? <ul> <li>Use <code>Eigen::MatrixBase</code> for inputs (so you can pass plain matrices, maps and matrix expressions);</li> <li>Use <code>Eigen::PlainObjectBase</code> for outputs (so the memory can be allocated by the libigl function).</li> </ul> I get an <code>error: Server does not allow request for unadvertised object</code> when cloning a repository using libigl as a submodule. <p>You are probably getting this error because the libigl history rewriting that happened on XXX. Read more about this breaking change [here].</p> I have some old GUI code that uses NanoGUI. How can I update it to the latest version of libigl? <p>In 2017, libigl switched from NanoGUI to ImGui for its viewer\u2019s user interface. The main reason was to remove nested dependencies in common with libigl, thus providing an overall lighter experience. ImGui also has other advantages, such as more dynamic menus (where you can add/remove elements on the fly), inject UI debugging code in user-code (with <code>ImGuiOnceUponAFrame</code>), etc.</p> <p>Porting UI code to ImGui should be relatively straightforward. Have a look at tutorial 106, or read issue #719 for more discussion. If you would like to keep NanoGUI as your interface library for whatever reason, you are welcome to write a ViewerPlugin reusing the old binding code, and we would be happy to advertise it somewhere.</p> How to write custom shader code in the viewer? <p>See #657.</p> How to draw text in the viewer? <p>See #876.</p> Issues with multi-threading and cgal::CSGTree <p>There is a known race condition that can occur in rare occasions when doing CSG operations with duplicated nodes in the CSG tree, e.g., <pre><code>igl::copyleft::cgal::CSGTree inter(tree, tree, \"i\");\n</code></pre> See an detailed explanation of the problem here, and please use this thread to discuss the bug if it affects you. So far the problem has only been observed on macOS.</p> Commenting out viewer.launch() causes linker errors with imgui/glad (no imgui/glad functions called) <p>This issue only happens on macOS with the Xcode project generator, when libigl is compiled in header-only mode. Possible solutions:</p> <ul> <li>Add an unused function in your project calling <code>viewer.launch()</code>.</li> <li>Compile libigl as a static library.</li> <li>Compile your project using another project generator (Makefile or Ninja).</li> </ul> <p>For a more detailed explanation of the problem, see this answer.</p>"},{"location":"license/","title":"License","text":"<p>Libigl is primarily licensed under MPL2:</p> <ul> <li>http://www.mozilla.org/MPL/2.0/</li> <li>http://www.mozilla.org/MPL/2.0/FAQ.html</li> </ul> <p>All <code>.h</code> and <code>.cpp</code> files directly in <code>include/igl</code> (but not necessarily in sub-directories) are subject only to the terms of the MPL2; they should not include any code that is covered by other/less-permissive licenses.</p> <p>The <code>.h</code> and <code>.cpp</code> files in sub-directories of <code>include/igl</code> allow libigl to integrate with external third-party libraries (e.g., those in <code>external/</code>) and are subject to the MPL2, and also the terms of licenses of the corresponding external library.  The licenses used by these libraries fall under three categories:</p> <ul> <li>common \u201cfree, non-copyleft licenses\u201d (such as zlib, BSD, MIT, and public   domain)</li> <li><code>include/igl/anttweakbar</code></li> <li><code>include/igl/embree</code></li> <li><code>include/igl/opengl</code></li> <li><code>include/igl/opengl/glfw</code></li> <li><code>include/igl/opengl2</code></li> <li><code>include/igl/png</code></li> <li><code>include/igl/viewer</code></li> <li><code>include/igl/xml</code></li> <li>common \u201ccopyleft\u201d licences (such as GPL, LGPL, and AGPL)</li> <li><code>include/igl/copyleft</code></li> <li><code>include/igl/copyleft/cgal</code></li> <li><code>include/igl/copyleft/comiso</code></li> <li><code>include/igl/copyleft/cork</code></li> <li><code>include/igl/copyleft/tetgen</code></li> <li>other \u201cuncommon\u201d licenses or commercial software</li> <li><code>include/igl/lim</code></li> <li><code>include/igl/matlab</code></li> <li><code>include/igl/mosek</code></li> <li><code>include/igl/triangle</code></li> </ul> <p>The Libigl code that interfaces with \u201ccopyleft\u201d libraries is in <code>include/igl/copyleft</code>.  Only include these headers if you are accept the licensing terms of the corresponding external library.  For example, using <code>include/igl/copyleft/tetgen</code> requires that you accept the terms of the AGPLv3.</p>"},{"location":"matlab-to-eigen/","title":"Matlab-libigl Cheatsheet","text":""},{"location":"python-bindings/","title":"Python Bindings","text":""},{"location":"rewritten-history/","title":"Rewritten History","text":"<p>Danger</p> <p>On October 15, 2018, a lighter version of the libigl repository has been pushed to the master branch. This new version has its history rewritten, which does invalidate all commit SHA1 numbers pointing to previous versions of libigl. See the full list of changes in the changelog.</p>"},{"location":"rewritten-history/#why-are-we-doing-this","title":"Why Are We Doing This?","text":"<p>libigl was always intended as lightweight library. Over the year, the size of the git repository grew significantly for various reasons: large binary assets being committed to the main repository, optional submodules growing in size, etc. To remedy this, we have changed the way external dependencies are handled. But to truly reduce the size of the repository to something manageable, it was necessary to prune large binary files from the git history. This means introducing breaking changes and invalidating existing commit SHA1 numbers.</p>"},{"location":"rewritten-history/#how-to-upgrade","title":"How To Upgrade?","text":"<p>If you are using libigl as a submodule, I suggest you simply remove the submodule and add it again. To remove a submodule you can write (replacing <code>external/libigl</code> with the relative path to libigl in your repo): <pre><code>git submodule deinit external/libigl\ngit rm -rf external/libigl\n</code></pre></p> <p>And to add it again: <pre><code>git submodule add https://github.com/libigl/libigl.git external/libigl\n</code></pre></p> <p>Before commmit your changes, here is what the output of <code>git status</code> should look like: <pre><code>On branch master\nYour branch is up to date with 'origin/master'.\n\nChanges to be committed:\n  (use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n  modified:   .gitmodules\n  modified:   external/libigl\n\nSubmodule changes to be committed:\n\n* external/libigl 7371494...ed363da:\n  Warn: external/libigl doesn't contain commit 737149498ad3d25ea1a56dc4234a66d2876764ef\n</code></pre></p> <p>The warning is normal: this is because submodule was referencing an old commit (<code>7371494</code>) that no longer exists in the new history, but the new commit (<code>ed363da</code>) does.</p> <p>If you have an existing fork of libigl, we strongly suggest that you delete it and fork the project anew. You will not be able to create a PR with a fork that has the old history. If you have existing changes (e.g. from a pending PR), then simply apply the same changes on the newly forked project, and submit your PR again.</p> <p>If you are new to libigl, there is nothing to do: use the new repository normally, and enjoy the new lightness!</p>"},{"location":"rewritten-history/#what-about-my-old-code","title":"What About My Old Code?","text":"<p>We maintain a copy of libigl with the old history in the repository libigl-legacy. If you have an old code the depends on a specific version of libigl, simply update the url (e.g. by editing the <code>.gitmodules</code> file), and it will pick up the matching commit with the SHA1 number from the old history.</p>"},{"location":"rewritten-history/#troubleshooting","title":"Troubleshooting","text":""},{"location":"rewritten-history/#problem-1","title":"Problem 1","text":"<p>I have an old project with a submodule using libigl, but it is pointing to an invalid commit number:</p> <pre><code>Submodule 'libigl' (git@github.com:libigl/libigl.git) registered for path 'external/libigl'\nCloning into '/home/user/foo/libigl-example-project/external/libigl'...\nerror: Server does not allow request for unadvertised object 03536c4aa44a399ed7134b68f04cf3773edebc73\nFetched in submodule path 'external/libigl', but it did not contain 03536c4aa44a399ed7134b68f04cf3773edebc73. Direct fetching of that commit failed.\n</code></pre> How to fix"},{"location":"rewritten-history/#steps-to-reproduce-the-problem","title":"Steps to reproduce the problem:","text":"<ol> <li>Suppose we have a parent project with libigl submodule in <code>external/libigl/</code>.</li> <li>Clone the parent repository     <pre><code>git clone git@github.com:gabuzome/libigl-example-project.git\n</code></pre></li> <li>Try to initialize the submodules with the command     <pre><code>git submodule update --init --recursive\n</code></pre>    this should produces the error you see above.</li> </ol>"},{"location":"rewritten-history/#steps-to-fix-the-problem-execute-in-that-order","title":"Steps to fix the problem (execute in that order):","text":"<ol> <li>Delete the local folder that contained the submodule    <pre><code>rm -rf external/libigl/\n</code></pre></li> <li>Delete the corrupted copy in the <code>.git/</code> folder    <pre><code>rm -rf .git/modules/external/libigl/\n</code></pre></li> <li>Change the <code>libigl/libigl.git</code> to <code>libigl/libigl-legacy.git</code> in the <code>.gitmodules</code> file.  <p>Or issue, on Linux    <pre><code>sed -i 's|libigl/libigl.git|libigl/libigl-legacy.git|' .gitmodules\n</code></pre> Or issue, on Mac OS X    <pre><code>sed -i '' 's|libigl/libigl.git|libigl/libigl-legacy.git|' .gitmodules\n</code></pre> </p> </li> <li>Update local configuration of your submodule repos with the new URL     <pre><code>git submodule sync\n</code></pre></li> <li>Clone the submodule with the new address     <pre><code>git submodule update --init --recursive\n</code></pre></li> </ol>"},{"location":"rewritten-history/#problem-2","title":"Problem 2","text":"<p>I have a problem with my current project that I want to update to the latest version, but I messed up my submodule and somehow get this error message:</p> <pre><code>A git directory for 'external/libigl' is found locally with remote(s):\n  origin  https://github.com/libigl/libigl.git\nIf you want to reuse this local git directory instead of cloning again from\n  https://github.com/libigl/libigl.git\nuse the '--force' option. If the local git directory is not the correct repo\nor you are unsure what this means choose another name with the '--name' option.\n</code></pre> How to fix"},{"location":"rewritten-history/#steps-to-fix-the-problem-execute-in-that-order_1","title":"Steps to fix the problem (execute in that order):","text":"<ol> <li>Delete the local folder that contained the submodule    <pre><code>rm -rf external/libigl/\n</code></pre></li> <li>Delete the corrupted copy in the <code>.git/</code> folder    <pre><code>rm -rf .git/modules/external/libigl/\n</code></pre></li> <li>Update local configuration of your submodule repos with the new URL     <pre><code>git submodule sync\n</code></pre></li> <li>Clone the submodule to the current tip of the repository     <pre><code>git submodule update --init --recursive\n</code></pre></li> </ol>"},{"location":"rewritten-history/#problem-3","title":"Problem 3","text":"<p>I have updated my submodule to the latest version of libigl, but the CMake script is complaining about missing targets.</p> How to fix <p>The files in the libigl repository have been restructured a little bit. The CMake build script are now located under <code>cmake/</code> instead of <code>shared/cmake/</code>. Please check out the latest version of the FindLIBIGL.cmake from the <code>libigl-example-project</code>.</p>"},{"location":"rewritten-history/#problem-4","title":"Problem 4","text":"<p>I have an existing fork with some changes, how do I update it to the latest version of libigl?</p> How to fix <p>For now we advise that you keep a copy of your legacy fork (you can rename/archive your existing fork, etc.), and create a new fork from the current libigl repository. If you have existing changes that you would like to merge, you can also try to <code>cherry-pick</code> the individual commits, but the simplest solution might to recreate new commits with the desired changes.</p>"},{"location":"rewritten-history/#other-problems","title":"Other Problems","text":"<p>Please check out the changelog page for the list of changes that have been merged into the main branch.</p>"},{"location":"static-library/","title":"Static Library","text":""},{"location":"static-library/#compiling-libigl-as-a-static-library","title":"Compiling libigl As A Static Library","text":"<p>Warning</p> <p>Compiling libigl as a static library is considerably more difficult than using it as a header-only library (see installation instruction instead). Do it only if you are experienced with C++, cmake and make, and you want to improve your compilation times.</p> <p>Libigl is developed most often on Mac OS X, though has current users in Linux and Windows.</p>"},{"location":"static-library/#linuxmac-os-xcygwin","title":"Linux/Mac OS X/Cygwin","text":"<p>Libigl may also be compiled to a static library. This is advantageous when building a project with libigl, since when used as an header-only library can slow down compile times.</p> <p>To build the entire libigl library producing at least <code>lib/libigl.a</code> and possible other (automatically detected) extras, e.g. <code>lib/libiglcgal.a</code> issue:</p> <p><pre><code>cmake ../ -DCMAKE_BUILD_TYPE=Release\\\n-DLIBIGL_USE_STATIC_LIBRARY=ON\\\n-DCMAKE_INSTALL_PREFIX=/path/to/custom/installation\n</code></pre> <pre><code>make\nmake install\n</code></pre> This will install libigl into the directory specified by <code>CMAKE_INSTALL_PREFIX</code>, which is set to <code>/usr/local</code> by deafault on macOS and Linux. The installation process does not only create <code>${CMAKE_INSTALL_PREFIX}/lib/libigl.a</code>, it copies the libigl headers into <code>${CMAKE_INSTALL_PREFIX}/include/igl/</code> too.</p> <p>Or if you base your project on the libigl-example-project you can add</p> <pre><code>option(LIBIGL_USE_STATIC_LIBRARY     \"Use libIGL as static librarie\" ON)\n</code></pre> <p>before the following line</p> <pre><code>find_package(LIBIGL REQUIRED QUIET)\n</code></pre> <p>in the <code>CMakeLists.txt</code> to always build libigl as static library for your project. See example-project aswell.</p> <p>Tip</p> <p>If you have changed the value for <code>LIBIGL_USE_STATIC_LIBRARY</code> in your CMakeLists.txt make sure to remove or update the CMakeCache.txt in your build directory.</p> <p>Warning</p> <p>You should expect to see a few linker warnings of the form:</p> <pre><code>/opt/local/bin/ranlib: file: libigl.a(*.cpp.o) has no symbols\n</code></pre> <p>These are (admittedly unpopular) functions that have never been used by us statically so we haven\u2019t explicit instantiations (yet).</p>"},{"location":"static-library/#development","title":"Development","text":"<p>Further documentation for developers is listed in style-guidelines.</p>"},{"location":"static-library/#license","title":"License","text":"<p>See <code>LICENSE.txt</code></p>"},{"location":"static-library/#zipping","title":"Zipping","text":"<p>Zip this directory without .git litter and binaries using:</p> <pre><code>git archive -prefix=libigl/ -o libigl.zip master\n</code></pre>"},{"location":"static-library/#explicit-instantiations-of-templated-functions","title":"Explicit Instantiations Of Templated Functions","text":"<p>Special care must be taken by the developers of each function and class in the libigl library that uses C++ templates. If this function is intended to be compiled into the statically linked libigl library then function is only compiled for each explicitly instantiated declaration. These should be added at the bottom of the corresponding .cpp file surrounded by a</p> <pre><code>#ifdef IGL_STATIC_LIBRARY\n</code></pre> <p>Of course, a developer may not know ahead of time which instantiations should be explicitly included in the igl static lib. One way to find out is to add one explicit instantiation for each call in one\u2019s own project. This only ever needs to be done once for each template.</p> <p>The process is somewhat mechanical using a linker with reasonable error output.</p> <p>Supposed for example we have compiled the igl static lib, including the cat.h and cat.cpp functions, without any explicit instantiation. Say using the makefile in the <code>libigl</code> directory:</p> <pre><code>cd $LIBIGL\nmake\n</code></pre> <p>Now if we try to compile a project and link against it we may get an error like:</p> <pre><code>Undefined symbols for architecture x86_64:\n\"Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; igl::cat&lt;Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; &gt;(int, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;)\", referenced from:\nuniform_sample(Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt; const&amp;, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;, int, double, Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt;&amp;)in Skinning.o\n\"Eigen::SparseMatrix&lt;double, 0, int&gt; igl::cat&lt;Eigen::SparseMatrix&lt;double, 0, int&gt; &gt;(int, Eigen::SparseMatrix&lt;double, 0, int&gt; const&amp;, Eigen::SparseMatrix&lt;double, 0, int&gt; const&amp;)\", referenced from:\ncovariance_scatter_matrix(Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt; const&amp;, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;, ArapEnergy, Eigen::SparseMatrix&lt;double, 0, int&gt;&amp;)in arap_dof.o\narap_rhs(Eigen::Matrix&lt;double, -1, -1, 0, -1, -1&gt; const&amp;, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;, ArapEnergy, Eigen::SparseMatrix&lt;double, 0, int&gt;&amp;)in arap_dof.o\n</code></pre> <p>This looks like a mess, but luckily we don\u2019t really need to read it all. Just copy the first part in quotes</p> <pre><code>Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; igl::cat&lt;Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; &gt;(int, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;)\n</code></pre> <p>, then append it to the list of explicit template instantiations at the end of <code>cat.cpp</code> after the word template and followed by a semi-colon. Like this:</p> <pre><code>#ifdef IGL_STATIC_LIBRARY\n// Explicit template instantiation\ntemplate Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; igl::cat&lt;Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; &gt;(int, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;, Eigen::Matrix&lt;int, -1, -1, 0, -1, -1&gt; const&amp;);\n#endif\n</code></pre> <p>Then you must recompile the IGL static library.</p> <pre><code>cd $LIBIGL\nmake\n</code></pre> <p>And try to compile your project again, potentially repeating this process until no more symbols are undefined.</p> <p>Note</p> <p>It may be useful to check that you code compiles with no errors first using the headers-only version to be sure that all errors are from missing template instantiations.</p> <p>If you\u2019re using make then the following command will reveal each missing symbol on its own line:</p> <pre><code>make 2&gt;&amp;1 | grep \"referenced from\" | sed -e \"s/, referenced from.*//\"\n</code></pre>"},{"location":"static-library/#benefits-of-static-library","title":"Benefits Of Static Library","text":"<ul> <li> <p>Faster compile time: Because the libigl library     is already compiled, only the new code in ones project must be     compiled and then linked to IGL. This means compile times are     generally faster.</p> </li> <li> <p>Debug or optimized: The IGL static     library may be compiled in debug mode or optimized release mode     regardless of whether one\u2019s project is being optimized or     debugged.</p> </li> </ul>"},{"location":"static-library/#drawbacks-of-static-library","title":"Drawbacks Of Static Library","text":"<ul> <li>Hard to use templates: Special care (by the developers of the library) needs to be taken when exposing templated functions.</li> </ul>"},{"location":"style-guidelines/","title":"Style Guidelines","text":""},{"location":"style-guidelines/#libigl-style-guidelines","title":"Libigl Style Guidelines","text":"<p>Libigl is used and developed by many people. This document highlights some style guidelines for developers of the library, but also acts as best-practices for users.</p>"},{"location":"style-guidelines/#one-function-one-hcpp-pair","title":"One function, one .h/.cpp pair","text":"<p>The structure of libigl is very flat and function-based. For every function/sub-routine, create a single .h and .cpp file. For example, if you have a function that determines connected components from a face list <code>F</code> you would create the header <code>connected_components.h</code> and <code>connected_components.cpp</code> and the only function defined should be <code>void connected_components(const ... F, ... C)</code>. If the implementation of <code>connected_components</code> requires a subroutine to compute an adjacency matrix then create another pair <code>adjacency_matrix.h</code> and <code>adjacency_matrix.cpp</code> with a single function <code>void adjacency_matrix(const ... F, ... A)</code>.</p>"},{"location":"style-guidelines/#example","title":"Example","text":"<p>Here is an example function that would be defined in <code>include/igl/example_fun.h</code> and implemented in <code>include/igl/example_fun.cpp</code>.</p>"},{"location":"style-guidelines/#example_funh","title":"<code>example_fun.h</code>","text":"<pre><code>// This file is part of libigl, a simple c++ geometry processing library.\n// \n// Copyright (C) 2015 [Your Name] [your email address]\n// \n// This Source Code Form is subject to the terms of the Mozilla Public License \n// v. 2.0. If a copy of the MPL was not distributed with this file, You can \n// obtain one at http://mozilla.org/MPL/2.0/\n#ifndef IGL_EXAMPLE_FUN_H\n#define IGL_EXAMPLE_FUN_H\n\n#include \"igl_inline.h\"\n\nnamespace igl\n{\n// This is an example of a function, it takes a templated parameter and\n// shovels it into cout\n//\n// Input:\n//   input  some input of a Printable type\n// Returns true for the sake of returning something\ntemplate &lt;typename Printable&gt;\nIGL_INLINE bool example_fun(const Printable &amp; input);\n}\n\n#ifndef IGL_STATIC_LIBRARY\n#  include \"example_fun.cpp\"\n#endif\n\n#endif\n</code></pre>"},{"location":"style-guidelines/#example_funcpp","title":"<code>example_fun.cpp</code>","text":"<pre><code>// This file is part of libigl, a simple c++ geometry processing library.\n// \n// Copyright (C) 2015 [Your Name] [your email address]\n// \n// This Source Code Form is subject to the terms of the Mozilla Public License \n// v. 2.0. If a copy of the MPL was not distributed with this file, You can \n// obtain one at http://mozilla.org/MPL/2.0/\n#include \"igl/example_fun.h\"\n#include &lt;iostream&gt;\n\ntemplate &lt;typename Printable&gt;\nIGL_INLINE bool igl::example_fun(const Printable &amp; input)\n{\nusing namespace std;\ncout&lt;&lt;\"example_fun: \"&lt;&lt;input&lt;&lt;endl;\nreturn true;\n}\n\n#ifdef IGL_STATIC_LIBRARY\ntemplate bool igl::example_fun&lt;double&gt;(const double&amp; input);\ntemplate bool igl::example_fun&lt;int&gt;(const int&amp; input);\n#endif\n</code></pre>"},{"location":"style-guidelines/#avoid-static-helper-functions","title":"Avoid static \u201chelper\u201d functions","text":"<p>Strive to encapsulate sub-functions that could possibly be useful outside of the implementation of your current function. This might mean abstracting the interface a bit. If it doesn\u2019t dramatically effect performance then create a new pair of .h/.cpp files with this sub-function.</p>"},{"location":"style-guidelines/#lambda-functions","title":"Lambda functions","text":"<p>If encapsulation in a separate file is not possible or does not make sense, then avoid crowding the namespace by creating lambda functions within the function implementation.</p> <p>These lambda functions must still be documented with clear input and output arguments. Avoid using full capturing of all automatic variables: do not use <code>[&amp;]</code> or <code>[=]</code>. Rather specify each captured variable individually.</p>"},{"location":"style-guidelines/#avoid-helper-classes","title":"Avoid \u201chelper\u201d classes","text":"<p>Libigl is built around the high-performance paradigm of \u201cstruct of arrays\u201d rather than \u201carray of structs\u201d. The way we achieve this is to avoid classes and pass \u201cbasic types\u201d directly. The price we pay is long function interfaces, but this increases code reuse dramatically. A \u201cbasic type\u201d in our context is a Eigen type, stl type, or basic C type.</p>"},{"location":"style-guidelines/#header-documentation","title":"Header Documentation","text":"<p>Each function prototype should be well documented in its corresponding .h header file. A typical documentation consists of four parts:</p> <pre><code>// [A human readable description of what the function does.]\n//\n// Inputs:\n//   [variable name of first (const) input]   [dimensions and description of\n//     this input variable]\n//   [variable name of second (const) input]   [dimensions and description of\n//     this input variable]\n//   ...\n// Outputs:\n//   [variable name of first output ]   [dimensions and description of this\n//     output variable]\n//   [variable name of second output ]   [dimensions and description of this\n//     output variable]\n//   ...\n// Returns [description of return value]\n</code></pre>"},{"location":"style-guidelines/#example_1","title":"Example","text":"<p>For example the header <code>barycenter.h</code></p> <pre><code>// Computes the barycenter of every simplex\n//\n// Inputs:\n//   V  #V by dim matrix of vertex coordinates\n//   F  #F by simplex_size  matrix of indices of simplex corners into V\n// Output:\n//   BC  #F by dim matrix of 3d vertices\n//\n</code></pre>"},{"location":"style-guidelines/#const-inputs","title":"Const inputs","text":"<p>All input parameters should be demarcated <code>const</code>. If an input is also an output than consider exposing two parameters (one <code>const</code>) or be sure to list the variable under both <code>// Inputs:</code> and <code>// Outputs:</code> in the header comments.</p>"},{"location":"style-guidelines/#reference-parameters","title":"Reference parameters","text":"<p>All but simple types should be passed by reference (e.g. <code>Matrix &amp; mat</code>) rather than pointers (e.g. <code>Matrix * mat</code>) or value (e.g. <code>Matrix mat</code>).</p>"},{"location":"style-guidelines/#returns-vs-output-parameters","title":"Returns vs output parameters","text":"<p>All functions should be implemented with at least one overload that has a <code>void</code> or simple return type (e.g. <code>bool</code> on success/failure). With this implementation its then possible to write an overload that returns a single output. Please see Templating with Eigen.</p> <p>For example:</p> <pre><code>template &lt;typename Atype&gt;\nvoid adjacency_matrix(const ... &amp; F, Eigen::SparseMatrix&lt;AType&gt; &amp; A);\n\ntemplate &lt;typename Atype&gt;\nEigen::SparseMatrix&lt;Atype&gt; adjacency_matrix(const ... &amp; F);\n</code></pre>"},{"location":"style-guidelines/#templating-with-eigen","title":"Templating with Eigen","text":"<p>Functions taking Eigen dense matrices/arrays as inputs and outputs (but not return arguments), should template on top of <code>Eigen::MatrixBase</code>. Each parameter should be derived using its own template.</p> <p>For example,</p> <pre><code>template &lt;typename DerivedV, typename DerivedF, typename DerivedBC&gt;\nvoid barycenter(\nconst Eigen::MatrixBase&lt;DerivedV&gt; &amp; V,\nconst Eigen::MatrixBase&lt;DerivedF&gt; &amp; F,\nconst Eigen::MatrixBase&lt;DerivedBC&gt; &amp; BC);\n</code></pre> <p>The <code>Derived*</code> template encodes the scalar type (e.g. <code>double</code>, <code>int</code>), the number of rows and cols at compile time, and the data storage (Row-major vs. column-major). </p> <p>Returning Eigen types is discouraged. In cases where the size and scalar type are a fixed and matching function of an input <code>Derived*</code> template, then return that <code>Derived*</code> type. Do not return <code>Eigen::PlainObjectBase&lt;...&gt;</code> types. For example, this function scales fits a given set of points to the unit cube. The return is a new set of vertex positions so its type should match that of the input points:</p> <pre><code>template &lt;typename DerivedV&gt;\nvoid DerivedV fit_to_unit_cube(const Eigen::PlainObjectBase&lt;DerivedV&gt; &amp; V);\n</code></pre> <p>To implement this function, it is required to implement a more generic output-argument version and call that. So a full implementation looks like:</p> <p>In <code>igl/fit_in_unit_cube.h</code>:</p> <pre><code>template &lt;typename DerivedV, typename DerivedW&gt;\nvoid fit_to_unit_cube(\nconst Eigen::MatrixBase&lt;DerivedV&gt; &amp; V,\nEigen::PlainObjectBase&lt;DerivedW&gt; &amp; W);\ntemplate &lt;typename DerivedV&gt;\nvoid DerivedV fit_to_unit_cube(const Eigen::PlainObjectBase&lt;DerivedV&gt; &amp; V);\n</code></pre> <p>In <code>igl/fit_in_unit_cube.cpp</code>:</p> <pre><code>template &lt;typename DerivedV, typename DerivedW&gt;\nvoid fit_to_unit_cube(\nconst Eigen::MatrixBase&lt;DerivedV&gt; &amp; V,\nEigen::PlainObjectBase&lt;DerivedW&gt; &amp; W)\n{\nW = (V.rowwise()-V.colwise().minCoeff()).array() /\n(V.maxCoeff()-V.minCoeff());\n}\n\ntemplate &lt;typename DerivedV&gt;\nvoid DerivedV fit_to_unit_cube(const Eigen::MatrixBase&lt;DerivedV&gt; &amp; V)\n{\nDerivedV W;\nfit_to_unit_cube(V,W);\nreturn W;\n}\n</code></pre> <p>Notice that <code>W</code> is declared as a <code>DerivedV</code> type and not <code>Eigen::PlainObjectBase&lt;DerivedV&gt;</code> type.</p> <p>Note: Not all functions are suitable for returning Eigen types. For example <code>igl::barycenter</code> above outputs a #F by dim list of barycenters. Returning a <code>DerivedV</code> type would be inappropriate since the number of rows in <code>DerivedV</code> will be #V and may not match the number of rows in <code>DerivedF</code> (#F).</p>"},{"location":"style-guidelines/#function-naming-conventions","title":"Function naming conventions","text":"<p>Functions (and thus also files) should have simple, descriptive names using lowercase letters and underscores between words. Avoid unnecessary prefaces. For example, instead of <code>compute_adjacency_matrix</code>, <code>construct_adjacency_matrix</code>, <code>extract_adjacency_matrix</code>, <code>get_adjacency_matrix</code>, or <code>set_adjacency_matrix</code> just call the function <code>adjacency_matrix</code>.</p>"},{"location":"style-guidelines/#variable-naming-conventions","title":"Variable naming conventions","text":"<p>Libigl prefers short (even single character) variable names with heavy documentation in the comments in the header file or above the declaration of the function. When possible use <code>V</code> to mean a list of vertex positions and <code>F</code> to mean a list of faces/triangles.</p>"},{"location":"style-guidelines/#class-naming-conventions","title":"Class naming conventions","text":"<p>Classes should be avoided. When naming a class use CamelCase (e.g. SortableRow.h).</p>"},{"location":"style-guidelines/#enum-naming-conversion","title":"Enum naming conversion","text":"<p>Enums types should be placed in the appropriate <code>igl::</code> namespace and should be named in CamelCase (e.g. <code>igl::SolverStatus</code>) and instances should be named in ALL_CAPS with underscores between words and prefaced with the name of the enum. For example:</p> <pre><code>namespace igl\n{\nenum SolverStatus\n{\n// Good\nSOLVER_STATUS_CONVERGED = 0,\n// OK\nSOLVER_STATUS_MAX_ITER = 1,\n// Bad\nSOLVER_STATUS_ERROR = 2,\nNUM_SOLVER_STATUSES = 3,\n};\n};\n</code></pre>"},{"location":"style-guidelines/#exception-for-file-io","title":"Exception for file IO","text":"<p>For legacy reasons, file reading and writing functions use a different naming convention. A functions reading a <code>.xyz</code> file should be named <code>readXYZ</code> and a function writing <code>.xyz</code> files should be names <code>writeXYZ</code>.</p>"},{"location":"style-guidelines/#using-namespace-in-global-scope","title":"<code>using namespace ...</code> in global scope","text":"<p>Writing <code>using namespace std;</code>, <code>using namespace Eigen;</code> etc. outside of a global scope is strictly forbidden. Place these lines at the top of each function instead.</p>"},{"location":"style-guidelines/#namespaces-and-external-dependencies","title":"Namespaces and external dependencies","text":"<p>Functions in the main library (directly in <code>include/igl</code>) should only depend on Eigen and stl. These functions should have the <code>igl::</code> namespace.</p> <p>Functions with other dependencies should be placed into appropriate sub-directories (e.g. if <code>myfunction</code> depends on tetgen then create <code>igl/copyleft/tetgen/myfunction.h</code> and <code>igl/copyleft/tetgen/myfunction.cpp</code> and give the function the namespace <code>igl::copyleft::tetgen::myfunction</code>.</p>"},{"location":"style-guidelines/#copyleft-subdirectorynamespace","title":"copyleft subdirectory/namespace","text":"<p>Dependencies that require users of libigl to release their projects open source (e.g. GPL) are considered aggressively \u201ccopyleft\u201d and should be placed in the <code>include/igl/copyleft/</code> sub-directory and <code>igl::copyleft::</code> namespace.</p>"},{"location":"style-guidelines/#assertions","title":"Assertions","text":"<p>Be generous with assertions and always identify the assertion with strings:</p> <pre><code>assert(m &lt; n &amp;&amp; \"m must be less than n\");\n</code></pre>"},{"location":"style-guidelines/#ifndef-include-guard","title":"ifndef include guard","text":"<p>Every header file should be wrapped in an <code>#ifndef</code> compiler directive. The name of the guard should be in direct correspondence with the path of the .h file. For example, <code>include/igl/copyleft/tetgen/tetrahedralize.h</code> should be</p> <pre><code>#ifndef IGL_COPYLEFT_TETGEN_TETRAHEDRALIZE_H\n#define IGL_COPYLEFT_TETGEN_TETRAHEDRALIZE_H\n...\n#endif\n</code></pre>"},{"location":"style-guidelines/#spaces-vs-tabs-indentation","title":"Spaces vs. tabs indentation","text":"<p>Do not use tabs. Use 2 spaces for each indentation level.</p>"},{"location":"style-guidelines/#max-line-length","title":"Max line length","text":"<p>Limit lines to 80 characters. Break up long lines into many operations (this also helps performance).</p>"},{"location":"style-guidelines/#include-order","title":"Include order","text":"<p><code>#include</code> directives at the top of a .h or .cpp file should be sorted according to a simple principle: place headers of files most likely to be edited by you first. This means for <code>include/igl/copyleft/tetgen/tetrahedralize.cpp</code> you might see</p> <pre><code>// [Includes of headers in this directory]\n#include \"tetrahedralize.h\"\n#include \"mesh_to_tetgenio.h\"\n#include \"tetgenio_to_tetmesh.h\"\n// [Includes of headers in this project]\n#include \"../../matrix_to_list.h\"\n#include \"../../list_to_matrix.h\"\n#include \"../../boundary_facets.h\"\n// [Includes of headers of related projects]\n#include &lt;Eigen/Core&gt;\n// [Includes of headers of standard libraries]\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n</code></pre>"},{"location":"style-guidelines/#placement-of-includes","title":"Placement of includes","text":"<p>Whenever possible <code>#include</code> directives should be placed in the <code>.cpp</code> implementation file rather than the <code>.h</code> header file.</p>"},{"location":"style-guidelines/#warnings","title":"Warnings","text":"<p>Code should compile without firing any warnings.</p>"},{"location":"style-guidelines/#an-exception","title":"An Exception","text":"<p>The only exception is for the use of the deprecated <code>Eigen::DynamicSparseMatrix</code> in core sub-routines (e.g. <code>igl::cat</code>). This class is still supported and faster than the standard, non-deprecated Eigen implementation so we\u2019re keeping it as long as possible and profitable.</p>"},{"location":"third-party/","title":"External Dependencies","text":"<p>The <code>external/</code> directory contains external libraries which are either difficult to obtain, difficult to compile or patched for libigl.</p>"},{"location":"third-party/#embree","title":"Embree","text":"<p>Install <code>ispc</code>  and <code>tbb</code> for example (<code>brew install ispc tbb</code>), then</p> <pre><code>mkdir build\ncd build\ncmake -DCMAKE_C_COMPILER=/usr/bin/gcc -DCMAKE_CXX_COMPILER=/usr/bin/g++ -DCMAKE_BUILD_TYPE=Release ..\nmake\n</code></pre>"},{"location":"third-party/#tinyxml2","title":"TinyXML2","text":"<p>double precision bug fixes:</p> <p>tinyxml2.h line 1286 add function:</p> <pre><code>void SetAttribute( const char* name, float value ) {\nXMLAttribute* a = FindOrCreateAttribute( name );\na-&gt;SetAttribute( value );\n}\n</code></pre> <p>tinyxml2.cpp line 434 replace with:</p> <pre><code>TIXML_SNPRINTF( buffer, bufferSize, \"%.15e\", v );\n</code></pre>"},{"location":"third-party/#cgal","title":"CGAL","text":"<p>CGAL can be built as a CMake external project thanks to the <code>CMakeLists.txt</code> provided in this folder. While this is mainly intended as a convenience for Windows users, and CI builds on AppVeyor, this should work on Linux/macOS as well. To build CGAL and Boost with the provided CMake script, build this folder as you would compile any CMake project (use CMake GUI and MSVC on Windows):</p> <pre><code>mkdir build\ncd build\ncmake ..\nmake -j4\n</code></pre> <p>Once this is done, just build the libigl tutorials, and it should properly detect CGAL and Boost.</p>"},{"location":"third-party/#bbw","title":"bbw","text":"<p>This library extra contains functions for computing Bounded Biharmonic Weights, can be used with and without the mosek extra via the <code>IGL_NO_MOSEK</code> macro.</p>"},{"location":"third-party/#boolean","title":"boolean","text":"<p>This library extra contains functions for computing mesh-mesh booleans, depending on CGAL and optionally Cork.</p>"},{"location":"third-party/#embree_1","title":"embree","text":"<p>This library extra utilizes embree\u2019s efficient ray tracing queries.</p>"},{"location":"third-party/#matlab","title":"matlab","text":"<p>This library extra provides support for reading and writing <code>.mat</code> workspace files, interfacing with Matlab at run time and compiling mex functions.</p>"},{"location":"third-party/#mosek","title":"mosek","text":"<p>This library extra utilizes mosek\u2019s efficient interior-point solver for quadratic programs.</p>"},{"location":"third-party/#png","title":"png","text":"<p>This library extra uses <code>libpng</code> and <code>YImage</code> to read and write <code>.png</code> files.</p>"},{"location":"third-party/#tetgen","title":"tetgen","text":"<p>This library extra provides a simplified wrapper to the tetgen 3d tetrahedral meshing library.</p>"},{"location":"third-party/#triangle","title":"Triangle","text":"<p>This library extra provides a simplified wrapper to the triangle 2d triangle meshing library.</p>"},{"location":"third-party/#xml","title":"xml","text":"<p>This library extra utilizes tinyxml2 to read and write serialized classes containing Eigen matrices and other standard simple data-structures.</p>"},{"location":"third-party/#optional","title":"Optional","text":"<ul> <li>OpenGL (disable with <code>LIBIGL_WITH_OPENGL</code> set to <code>OFF</code>)<ul> <li>OpenGL &gt;= 4 (enable with <code>IGL_OPENGL_4</code>)</li> </ul> </li> <li>GLEW  Windows and Linux</li> <li>OpenMP</li> <li>libpng  libiglpng extra only</li> <li>Mosek  libiglmosek extra only</li> <li>Matlab  libiglmatlab extra only</li> <li>boost  libiglboost, libiglcgal extra only</li> <li>SSE/AVX  libiglsvd3x3 extra only</li> <li>CGAL  libiglcgal extra only<ul> <li>boost</li> <li>gmp</li> <li>mpfr</li> </ul> </li> <li>CoMiSo libcomiso extra only</li> </ul>"},{"location":"third-party/#optional-included-in-external","title":"Optional (included in external/)","text":"<ul> <li>TetGen  libigltetgen extra only</li> <li>Embree  libiglembree extra only</li> <li>tinyxml2  libiglxml extra only</li> <li>glfw libviewer extra only</li> <li>LIM  liblim extra only</li> </ul>"},{"location":"tutorial/","title":"Tutorial","text":"libigl tutorial <p>Libigl is an open source C++ library for geometry processing research and development.  Dropping the heavy data structures of tradition geometry libraries, libigl is a simple header-only library of encapsulated functions. This combines the rapid prototyping familiar to Matlab or Python programmers with the performance and versatility of C++.  The tutorial is a self-contained, hands-on introduction to libigl.  Via interactive, step-by-step examples, we demonstrate how to accomplish common geometry processing tasks such as computation of differential quantities and operators, real-time deformation, parametrization, numerical optimization and remeshing. Each section of the lecture notes links to a cross-platform example application.</p>"},{"location":"tutorial/#chapter-1","title":"Chapter 1","text":"<p>We introduce libigl with a series of self-contained examples. The purpose of each example is to showcase a feature of libigl while applying to a practical problem in geometry processing. In this chapter, we will present the basic concepts of libigl and introduce a simple mesh viewer that allows to visualize a surface mesh and its attributes. All the tutorial examples are cross-platform and can be compiled on MacOSX, Linux and Windows.</p>"},{"location":"tutorial/#libigl-design-principles","title":"Libigl Design Principles","text":"<p>Before getting into the examples, we summarize the main design principles in libigl:</p> <ol> <li> <p>No complex data types. We mostly use matrices and vectors. This greatly   favors code reusability and forces the function authors to expose all the   parameters used by the algorithm.  </p> </li> <li> <p>Minimal dependencies. We use external libraries only when necessary and   we wrap them in a small set of functions.</p> </li> <li> <p>Header-only. It is straight forward to use our library since it is only   one additional include directory in your project. (if you are worried about   compilation speed, it is also possible to build the library as a static library)</p> </li> <li> <p>Function encapsulation. Every function (including its full   implementation) is contained in a pair of .h/.cpp files with the same name of   the function.</p> </li> </ol>"},{"location":"tutorial/#downloading-libigl","title":"Downloading Libigl","text":"<p>libigl can be downloaded from our github repository or cloned with git:</p> <pre><code>git clone https://github.com/libigl/libigl.git\n</code></pre> <p>The core libigl functionality only depends on the C++ Standard Library and Eigen. Optional dependencies will be downloaded upon issuing <code>cmake</code>, below.</p> <p>To build all the examples in the tutorial (and tests), you can use the CMakeLists.txt in the root folder:</p> <pre><code>cd libigl/\nmkdir build\ncd build\ncmake ../\nmake\n</code></pre> <p>Note about CGAL</p> <p>The optional dependency CGAL has been notoriously difficult to setup (as it also depends on boost/gmp/mpfr). By default, it will only be enabled on Linux/macOS if GMP and MPFR are installed system-wide. On Windows, all its dependencies will be downloaded by CMake, thus requiring no setup on your part.</p> <p>The examples can also be built independently using the CMakeLists.txt inside each example folder.</p> <p>Note for linux users</p> <p>Many linux distributions do not include gcc and the basic development tools in their default installation. On Ubuntu, you need to install the following packages:</p> <pre><code>sudo apt-get install \\\ngit \\\nbuild-essential \\\ncmake \\\nlibx11-dev \\\nmesa-common-dev libgl1-mesa-dev libglu1-mesa-dev \\\nlibxrandr-dev \\\nlibxi-dev \\\nlibxmu-dev \\\nlibblas-dev \\\nlibxinerama-dev \\\nlibxcursor-dev\n</code></pre> <p>Note for Windows users</p> <p>libigl only supports the Microsoft Visual Studio 2015 compiler and later, in 64bit mode. It will not work with a 32bit build and it will not work with older versions of visual studio.</p> <p>A few examples in Chapter 5 requires the CoMiSo solver. We provide a mirror of CoMISo that works out of the box with libigl. A copy will be downloaded automatically by CMake the first time you build the libigl root project. You can build the tutorials as usual and libigl will automatically find and compile CoMISo.</p> <p>Note 1: CoMISo is distributed under the GPL3 license, it does impose restrictions on commercial usage.</p> <p>Note 2: CoMISo requires a blas implementation. We use the built-in blas in macosx and linux, and we bundle a precompiled binary for VS2015 64 bit. Do NOT compile the tutorials in 32 bit on windows.</p> <p>Libigl Example Project</p> <p>We provide a blank project example showing how to use libigl and CMake. This is the recommended way of using libigl in your project. Feel free and encouraged to use this repository as a template to start a new personal project using libigl.</p>"},{"location":"tutorial/#mesh-representation","title":"Mesh Representation","text":"<p>libigl uses the Eigen library to encode vector and matrices. We suggest that you keep the dense and sparse quick reference guides at hand while you read the examples in this tutorial.</p> <p>A triangular mesh is encoded as a pair of matrices:</p> <pre><code>Eigen::MatrixXd V;\nEigen::MatrixXi F;\n</code></pre> <p><code>V</code> is a #N by 3 matrix which stores the coordinates of the vertices. Each row stores the coordinate of a vertex, with its x,y and z coordinates in the first, second and third column, respectively. The matrix <code>F</code> stores the triangle connectivity: each line of <code>F</code> denotes a triangle whose 3 vertices are represented as indices pointing to rows of <code>V</code>.</p> <p> </p>      A simple mesh made of 2 triangles and 4 vertices.    <p>Note that the order of the vertex indices in <code>F</code> determines the orientation of the triangles and it should thus be consistent for the entire surface. This simple representation has many advantages:</p> <ol> <li>it is memory efficient and cache friendly</li> <li>the use of indices instead of pointers greatly simplifies debugging</li> <li>the data can be trivially copied and serialized</li> </ol> <p>libigl provides input [output] functions to read [write] many common mesh formats. The IO functions are contained in the files read*.h and write*.h. As a general rule each libigl function is contained in a pair of .h/.cpp files with the same name. By default, the .h files include the corresponding cpp files, making the library header-only.</p> <p>Reading a mesh from a file requires a single libigl function call:</p> <pre><code>igl::readOFF(TUTORIAL_SHARED_PATH \"/cube.off\", V, F);\n</code></pre> <p>The function reads the mesh cube.off and it fills the provided <code>V</code> and <code>F</code> matrices. Similarly, a mesh can be written in an OBJ file using:</p> <pre><code>igl::writeOBJ(\"cube.obj\",V,F);\n</code></pre> <p>Example 101 contains a simple mesh converter from OFF to OBJ format.</p>"},{"location":"tutorial/#visualizing-surfaces","title":"Visualizing Surfaces","text":"<p>Libigl provides an glfw-based OpenGL 3.2 viewer to visualize surfaces, their properties and additional debugging information.</p> <p>The following code (Example 102) is a basic skeleton for all the examples that will be used in the tutorial. It is a standalone application that loads a mesh and uses the viewer to render it.</p> <pre><code>#include &lt;igl/readOFF.h&gt;\n#include &lt;igl/opengl/glfw/Viewer.h&gt;\n\nEigen::MatrixXd V;\nEigen::MatrixXi F;\n\nint main(int argc, char *argv[])\n{\n// Load a mesh in OFF format\nigl::readOFF(TUTORIAL_SHARED_PATH \"/bunny.off\", V, F);\n\n// Plot the mesh\nigl::opengl::glfw::Viewer viewer;\nviewer.data().set_mesh(V, F);\nviewer.launch();\n}\n</code></pre> <p>The function <code>set_mesh</code> copies the mesh into the viewer. <code>Viewer.launch()</code>  creates a window, an OpenGL context and it starts the draw loop. The default camera motion mode is 2-axis (<code>ROTATION_TYPE_TWO_AXIS_VALUATOR_FIXED_UP</code>),  which can be changed to 3-axis trackball style by adding this line: <pre><code>  viewer.core().set_rotation_type(igl::opengl::ViewerCore::ROTATION_TYPE_TRACKBALL);\n</code></pre> Additional properties can be plotted on the mesh (as we will see later), and it is possible to extend the viewer with standard OpenGL code. Please see the documentation in Viewer.h for more details.</p> <p> </p>      (Example 102) loads and draws a mesh."},{"location":"tutorial/#interaction-with-keyboard-and-mouse","title":"Interaction With Keyboard And Mouse","text":"<p>Keyboard and mouse events triggers callbacks that can be registered in the viewer. The viewer supports the following callbacks:</p> <pre><code>bool (*callback_pre_draw)(Viewer&amp; viewer);\nbool (*callback_post_draw)(Viewer&amp; viewer);\nbool (*callback_mouse_down)(Viewer&amp; viewer, int button, int modifier);\nbool (*callback_mouse_up)(Viewer&amp; viewer, int button, int modifier);\nbool (*callback_mouse_move)(Viewer&amp; viewer, int mouse_x, int mouse_y);\nbool (*callback_mouse_scroll)(Viewer&amp; viewer, float delta_y);\nbool (*callback_key_down)(Viewer&amp; viewer, unsigned char key, int modifiers);\nbool (*callback_key_up)(Viewer&amp; viewer, unsigned char key, int modifiers);\n</code></pre> <p>A keyboard callback can be used to visualize multiple meshes or different stages of an algorithm, as demonstrated in Example 103, where the keyboard callback changes the visualized mesh depending on the key pressed:</p> <pre><code>bool key_down(igl::opengl::glfw::Viewer&amp; viewer, unsigned char key, int modifier)\n{\nif (key == '1')\n{\nviewer.data().clear();\nviewer.data().set_mesh(V1, F1);\nviewer.core.align_camera_center(V1,F1);\n}\nelse if (key == '2')\n{\nviewer.data().clear();\nviewer.data().set_mesh(V2, F2);\nviewer.core.align_camera_center(V2,F2);\n}\nreturn false;\n}\n</code></pre> <p>The callback is registered in the viewer as follows:</p> <pre><code>viewer.callback_key_down = &amp;key_down;\n</code></pre> <p>Note that the mesh is cleared before using set_mesh. This has to be called every time the number of vertices or faces of the plotted mesh changes. Every callback returns a boolean value that tells the viewer if the event has been handled by the plugin, or if the viewer should process it normally. This is useful, for example, to disable the default mouse event handling if you want to control the camera directly in your code.</p> <p>The viewer can be extended using plugins, which are classes that implements all the viewer\u2019s callbacks. See the Viewer_plugin for more details.</p>"},{"location":"tutorial/#scalar-field-visualization","title":"Scalar Field Visualization","text":"<p>Colors can be associated to faces or vertices using the <code>set_colors</code> function:</p> <pre><code>viewer.data().set_colors(C);\n</code></pre> <p><code>C</code> is a #C by 3 matrix with one RGB color per row. <code>C</code> must have as many rows as the number of faces or the number of vertices of the mesh.  Depending on the size of <code>C</code>, the viewer applies the color to the faces or to the vertices. In Example 104, the colors of mesh vertices are set according to their Cartesian coordinates.</p> <p> </p>      (Example 104) Set the colors of a mesh.     <p>Per-Vertex scalar fields can be directly visualized using <code>set_data</code> function:</p> <pre><code>viewer.data().set_data(D);\n</code></pre> <p><code>D</code> is a #V by 1 vector with one value corresponding to each vertex. <code>set_data</code> will color according to linearly interpolating the data within a triangle (in the fragment shader) and use this interpolated data to look up a color in a colormap (stored as a texture). The colormap defaults to <code>igl::COLOR_MAP_TYPE_VIRIDIS</code> with 21 discrete intervals. A custom colormap may be set with <code>set_colormap</code>.</p>"},{"location":"tutorial/#overlays","title":"Overlays","text":"<p>In addition to plotting the surface, the viewer supports the visualization of points, lines and text labels: these overlays can be very helpful while developing geometric processing algorithms to plot debug information.</p> <pre><code>viewer.data().add_points(P,Eigen::RowVector3d(r,g,b));\n</code></pre> <p>Draws a point of color r,g,b for each row of P. The point is placed at the coordinates specified in each row of P, which is a #P by 3 matrix. Size of the points (in pixels) can be changed globally by setting <code>viewer.data().point_size</code>.</p> <pre><code>viewer.data().add_edges(P1,P2,Eigen::RowVector3d(r,g,b));\n</code></pre> <p>Draws a line of color r,g,b for each row of P1 and P2, which connects the 3D point in to the point in P2. Both P1 and P2 are of size #P by 3.</p> <pre><code>viewer.data().add_label(p,str);\n</code></pre> <p>Draws a label containing the string str at the position p, which is a vector of length 3.</p> <p>These functions are demonstrate in Example 105 where the bounding box of a mesh is plotted using lines and points. Using matrices to encode the mesh and its attributes allows to write short and efficient code for many operations, avoiding to write for loops. For example, the bounding box of a mesh can be found by taking the colwise maximum and minimum of <code>V</code>:</p> <pre><code>Eigen::Vector3d m = V.colwise().minCoeff();\nEigen::Vector3d M = V.colwise().maxCoeff();\n</code></pre> <p> </p>      (Example 105) The bounding box of a mesh is shown using overlays."},{"location":"tutorial/#viewer-menu","title":"Viewer Menu","text":"<p>As of latest version, the viewer uses a new menu and completely replaces AntTweakBar and nanogui with Dear ImGui. To extend the default menu of the viewer and to expose more user defined variables you have to implement a custom interface, as in Example 106: <pre><code>// Add content to the default menu window\nmenu.callback_draw_viewer_menu = [&amp;]()\n{\n// Draw parent menu content\nmenu.draw_viewer_menu();\n\n// Add new group\nif (ImGui::CollapsingHeader(\"New Group\", ImGuiTreeNodeFlags_DefaultOpen))\n{\n// Expose variable directly ...\nImGui::InputFloat(\"float\", &amp;floatVariable, 0, 0, 3);\n\n// ... or using a custom callback\nstatic bool boolVariable = true;\nif (ImGui::Checkbox(\"bool\", &amp;boolVariable))\n{\n// do something\nstd::cout &lt;&lt; \"boolVariable: \" &lt;&lt; std::boolalpha &lt;&lt; boolVariable &lt;&lt; std::endl;\n}\n\n// Expose an enumeration type\nenum Orientation { Up=0, Down, Left, Right };\nstatic Orientation dir = Up;\nImGui::Combo(\"Direction\", (int *)(&amp;dir), \"Up\\0Down\\0Left\\0Right\\0\\0\");\n\n// We can also use a std::vector&lt;std::string&gt; defined dynamically\nstatic int num_choices = 3;\nstatic std::vector&lt;std::string&gt; choices;\nstatic int idx_choice = 0;\nif (ImGui::InputInt(\"Num letters\", &amp;num_choices))\n{\nnum_choices = std::max(1, std::min(26, num_choices));\n}\nif (num_choices != (int) choices.size())\n{\nchoices.resize(num_choices);\nfor (int i = 0; i &lt; num_choices; ++i)\nchoices[i] = std::string(1, 'A' + i);\nif (idx_choice &gt;= num_choices)\nidx_choice = num_choices - 1;\n}\nImGui::Combo(\"Letter\", &amp;idx_choice, choices);\n\n// Add a button\nif (ImGui::Button(\"Print Hello\", ImVec2(-1,0)))\n{\nstd::cout &lt;&lt; \"Hello\\n\";\n}\n}\n};\n</code></pre></p> <p>If you need a separate new menu window implement:</p> <pre><code>// Draw additional windows\nmenu.callback_draw_custom_window = [&amp;]()\n{\n// Define next window position + size\nImGui::SetNextWindowPos(ImVec2(180.f * menu.menu_scaling(), 10), ImGuiSetCond_FirstUseEver);\nImGui::SetNextWindowSize(ImVec2(200, 160), ImGuiSetCond_FirstUseEver);\nImGui::Begin(\n\"New Window\", nullptr,\nImGuiWindowFlags_NoSavedSettings\n);\n\n// Expose the same variable directly ...\nImGui::PushItemWidth(-80);\nImGui::DragFloat(\"float\", &amp;floatVariable, 0.0, 0.0, 3.0);\nImGui::PopItemWidth();\n\nstatic std::string str = \"bunny\";\nImGui::InputText(\"Name\", str);\n\nImGui::End();\n};\n</code></pre> <p> </p>      (Example 106) The UI of the viewer can be easily customized."},{"location":"tutorial/#multiple-meshes","title":"Multiple Meshes","text":"<p>Libigl\u2019s <code>igl::opengl::glfw::Viewer</code> provides basic support for rendering multiple meshes.</p> <p>Which mesh is selected is controlled via the <code>viewer.selected_data_index</code> field. By default the index is set to <code>0</code>, so in the typical case of a single mesh <code>viewer.data()</code> returns the <code>igl::ViewerData</code> corresponding to the one and only mesh.</p> <p> </p>      (Example 107) The <code>igl::opengl::glfw::Viewer</code> can render multiple meshes, each with its own attributes like colors."},{"location":"tutorial/#multiple-views","title":"Multiple Views","text":"<p>Libigl\u2019s <code>igl::opengl::glfw::Viewer</code> provides basic support for rendering meshes with multiple views.</p> <p>A new view core can be added to the viewer using the <code>Viewer::append_core()</code> method. There can be a maximum of 31 cores created through the life of any viewer. Each core is assigned an <code>unsigned int</code> id that is guaranteed to be unique. A core can be accessed by its id calling the <code>Viewer::core(id)</code> method.</p> <p>When there are more than one view core, the user is responsible for specifying each viewport\u2019s size and position by setting their <code>viewport</code> attribute. The user must also indicates how to resize each viewport when the size of the window changes. For example:</p> <pre><code>viewer.callback_post_resize = [&amp;](igl::opengl::glfw::Viewer &amp;v, int w, int h) {\nv.core( left_view).viewport = Eigen::Vector4f(0, 0, w / 2, h);\nv.core(right_view).viewport = Eigen::Vector4f(w / 2, 0, w - (w / 2), h);\nreturn true;\n};\n</code></pre> <p>Note that the viewport currently hovered by the mouse can be selected using the <code>Viewer::selected_core_index()</code> method, and the selected view core can then be accessed by calling <code>viewer.core_list[viewer.selected_core_index]</code>.</p> <p>Finally, the visibility of a mesh on a given view core is controlled by a bitmask flag per mesh. This property can be easily controlled by calling the method</p> <pre><code>viewer.data(mesh_id).set_visible(false, view_id);\n</code></pre> <p>When appending a new mesh or a new view core, an optional argument controls the visibility of the existing objects with respect to the new mesh/view. Please refer to the documentation of <code>Viewer::append_mesh()</code> and <code>Viewer::append_core()</code> for more details.</p> <p> </p>      (Example 108) The <code>igl::opengl::glfw::Viewer</code> can render the same scene using multiple views, each with its own attributes like colors, and individual mesh visibility."},{"location":"tutorial/#viewer-guizmos","title":"Viewer Guizmos","text":"<p>Bug</p> <p>It is currently not possible to have more than one ImGui-related viewer plugin active at the same time (that includes <code>ImGuiMenu</code>, <code>ImGuizmoPlugin</code> and <code>SelectionPlugin</code>). Please follow #1656 for more information.</p> <p>The viewer integrates with ImGuizmo to provide  widgets for manipulating a mesh. Mesh manipulations consist of translations, rotations,  and scaling, where <code>W,w</code>, <code>E,e</code>, and <code>R,r</code> can be used to toggle between them, respectively. </p> <p>First, register the <code>ImGuizmoPlugin</code> plugin with the Viewer: <pre><code>#include &lt;igl/opengl/glfw/imgui/ImGuizmoPlugin.h&gt;\n\n// ImGuizmoPlugin replaces the ImGuiMenu plugin entirely\nigl::opengl::glfw::imgui::ImGuizmoPlugin plugin;\nvr.plugins.push_back(&amp;plugin);\n</code></pre></p> <p>On initialization, ImGuizmo must be provided with the mesh centroid, as shown in Example 109:</p> <p><pre><code>// Initialize ImGuizmo at mesh centroid\nplugin.T.block(0,3,3,1) = 0.5*(V.colwise().maxCoeff() + V.colwise().minCoeff()).transpose().cast&lt;float&gt;();\n</code></pre> To apply the mesh manipulations invoked by the guizmos, the resulting transformation matrix  is computed and applied to the input geometric data explicitly through the viewer\u2019s API: </p> <pre><code>// Update can be applied relative to this remembered initial transform\nconst Eigen::Matrix4f T0 = plugin.T;\n// Attach callback to apply imguizmo's transform to mesh\nplugin.callback = [&amp;](const Eigen::Matrix4f &amp; T)\n{\nconst Eigen::Matrix4d TT = (T*T0.inverse()).cast&lt;double&gt;().transpose();\nvr.data().set_vertices(\n(V.rowwise().homogeneous()*TT).rowwise().hnormalized());\nvr.data().compute_normals();\n};\n</code></pre> <p>      ([Example 109](https://github.com/libigl/libigl/tree/main/tutorial/109_ImGuizmo/main.cpp)) The Libigl Viewer integrates with ImGuizmo to provide transformation widgets.    <p> </p>"},{"location":"tutorial/#msh-viewer","title":"Msh Viewer","text":"<p>Libigl can read mixed meshes stored in Gmsh <code>.msh</code> version 2 file format. These files can contain mixture of different meshes, as well as additional scalar and vector fields defined on element level and vertex level.</p> <pre><code>Eigen::MatrixXd X; // Vertex coorinates (Xx3)\nEigen::MatrixXi Tri; // Triangular elements (Yx3)\nEigen::MatrixXi Tet; // Tetrahedral elements (Zx4)\nEigen::VectorXi TriTag; // Integer tags defining triangular submeshes\nEigen::VectorXi TetTag; // Integer tags defining tetrahedral submeshes\n\nstd::vector&lt;std::string&gt; XFields; // headers (names) of fields defined on vertex level\nstd::vector&lt;std::string&gt; EFields; // headers (names) of fields defined on element level\n\nstd::vector&lt;Eigen::MatrixXd&gt; XF;   // fields defined on vertex \nstd::vector&lt;Eigen::MatrixXd&gt; TriF; // fields defined on triangular elements\nstd::vector&lt;Eigen::MatrixXd&gt; TetF; // fields defined on tetrahedral elements\n\n// loading mixed mesh from Gmsh file\nigl::readMSH(\"hand.msh\", X, Tri, Tet, TriTag, TetTag, XFields, XF, EFields, TriF, TetF);\n</code></pre> <p>The interactive viewer is unable to directly draw tetrahedra though. So for visualization purposes each tetrahedron can be converted to four triangles.</p> <p> </p>      (Example 110) Shows a slice of tetrahedral mesh with scalar field defined on element level"},{"location":"tutorial/#matcaps","title":"MatCaps","text":"<p>MatCaps (material captures), also known as environment maps, are a simple image-based rendering technique to achieve complex lighting without a complex shader program.</p> <p>Using offline rendering or even a painting program, an image of a rendered unit sphere is created, such as this image of a sphere with a jade material viewed under studio lighting:</p> <p></p> <p>The position \\mathbf{p} of each point on the sphere is also its unit normal vector \\hat{\\mathbf{n}} = \\mathbf{p}. The idea of matcaps is to use this image of the sphere as a lookup table keyed on an input normal value and outputting the rgb color: I(\\hat{\\mathbf{n}}) \\rightarrow (r,g,b).</p> <p>When rendering a non-spherical shape, in the fragment shader we compute the normal vector \\hat{\\mathbf{n}} and then use its x- and y- components as texture coordinates to look up the corresponding point in the matcap image. In this way, there is no lighting model or lighting computation done in the fragment shader, it is simply a texture lookup, but rather than requiring a UV-mapping (parameterization) of the model, we use the per-fragment normals. By using the normal relative to the camera\u2019s coordinate system we get view dependent complex lighting \u201cfor free\u201d:</p> <p> </p> Example 111 demonstrates using a jade matcap to add complex lighting to the libigl viewer.    <p>In libigl, if the rgba data for a matcap image is stored in <code>R</code>,<code>G</code>,<code>B</code>, and <code>A</code> (as output, e.g., by <code>igl::png::readPNG</code>) then this can be attached to the  <code>igl::opengl::ViewerData</code> by setting it as the texture data and then turning on matcap rendering:</p> <pre><code>viewer.data().set_texture(R,G,B,A);\nviewer.data().use_matcap = true;\n</code></pre>"},{"location":"tutorial/#chapter-2-discrete-geometric-quantities-and-operators","title":"Chapter 2: Discrete Geometric Quantities And Operators","text":"<p>This chapter illustrates a few discrete quantities that libigl can compute on a mesh and the libigl functions that construct popular discrete differential geometry operators. It also provides an introduction to basic drawing and coloring routines of our viewer.</p>"},{"location":"tutorial/#normals","title":"Normals","text":"<p>Surface normals are a basic quantity necessary for rendering a surface. There are a variety of ways to compute and store normals on a triangle mesh. Example 201 demonstrates how to compute and visualize normals with libigl.</p>"},{"location":"tutorial/#per-face","title":"Per-face","text":"<p>Normals are well defined on each triangle of a mesh as the vector orthogonal to triangle\u2019s plane. These piecewise-constant normals produce piecewise-flat renderings: the surface appears non-smooth and reveals its underlying discretization.</p>"},{"location":"tutorial/#per-vertex","title":"Per-vertex","text":"<p>Normals can be computed and stored on vertices, and interpolated in the interior of the triangles to produce smooth renderings (Phong shading). Most techniques for computing per-vertex normals take an average of incident face normals. The main difference between these techniques is their weighting scheme: Uniform weighting is heavily biased by the discretization choice, whereas area-based or angle-based weighting is more forgiving.</p> <p>The typical half-edge style computation of area-based weights has this structure:</p> <pre><code>N.setZero(V.rows(),3);\nfor(int i : vertices)\n{\nfor(face : incident_faces(i))\n{\nN.row(i) += face.area * face.normal;\n}\n}\nN.rowwise().normalize();\n</code></pre> <p>At first glance, it might seem inefficient to loop over incident faces\u2014and thus constructing the per-vertex normals\u2014 without using an half-edge data structure. However, per-vertex normals may be throwing each face normal to running sums on its corner vertices:</p> <pre><code>N.setZero(V.rows(),3);\nfor(int f = 0; f &lt; F.rows();f++)\n{\nfor(int c = 0; c &lt; 3;c++)\n{\nN.row(F(f,c)) += area(f) * face_normal.row(f);\n}\n}\nN.rowwise().normalize();\n</code></pre>"},{"location":"tutorial/#per-corner","title":"Per-corner","text":"<p>Storing normals per-corner is an efficient and convenient way of supporting both smooth and sharp (e.g. creases and corners) rendering. This format is common to OpenGL and the .obj mesh file format. Often such normals are tuned by the mesh designer, but creases and corners can also be computed automatically. Libigl implements a simple scheme which computes corner normals as averages of normals of faces incident on the corresponding vertex which do not deviate by more than a specified dihedral angle (e.g. 20\u00b0).</p> <p> </p>      The <code>Normals</code> example computes per-face (left), per-vertex (middle) and per-corner (right) normals"},{"location":"tutorial/#gaussian-curvature","title":"Gaussian Curvature","text":"<p>Gaussian curvature on a continuous surface is defined as the product of the principal curvatures:</p> <p>k_G = k_1 k_2.</p> <p>As an intrinsic measure, it depends on the metric and not the surface\u2019s embedding.</p> <p>Intuitively, Gaussian curvature tells how locally spherical or elliptic the surface is ( k_G&gt;0 ), how locally saddle-shaped or hyperbolic the surface is ( k_G&lt;0 ), or how locally cylindrical or parabolic ( k_G=0 ) the surface is.</p> <p>In the discrete setting, one definition for a \u201cdiscrete Gaussian curvature\u201d on a triangle mesh is via a vertex\u2019s angular deficit:</p> <p>k_G(v_i) = 2\u03c0 - \\sum\\limits_{j\\in N(i)}\u03b8_{ij},</p> <p>where N(i) are the triangles incident on vertex i and \u03b8_{ij} is the angle at vertex i in triangle j <sup>3</sup>.</p> <p>Just like the continuous analog, our discrete Gaussian curvature reveals elliptic, hyperbolic and parabolic vertices on the domain, as demonstrated in Example 202.</p> <p> </p>      The <code>GaussianCurvature</code> example computes discrete Gaussian curvature and visualizes it in pseudocolor."},{"location":"tutorial/#curvature-directions","title":"Curvature Directions","text":"<p>The two principal curvatures (k_1,k_2) at a point on a surface measure how much the surface bends in different directions. The directions of maximum and minimum (signed) bending are called principal directions and are always orthogonal.</p> <p>Mean curvature is defined as the average of principal curvatures:</p> <p>H = \\frac{1}{2}(k_1 + k_2).</p> <p>One way to extract mean curvature is by examining the Laplace-Beltrami operator applied to the surface positions. The result is a so-called mean-curvature normal:</p> <p>-\\Delta \\mathbf{x} = H \\mathbf{n}.</p> <p>It is easy to compute this on a discrete triangle mesh in libigl using the cotangent Laplace-Beltrami operator <sup>3</sup>.</p> <pre><code>#include &lt;igl/cotmatrix.h&gt;\n#include &lt;igl/massmatrix.h&gt;\n#include &lt;igl/invert_diag.h&gt;\n...\nMatrixXd HN;\nSparseMatrix&lt;double&gt; L,M,Minv;\nigl::cotmatrix(V,F,L);\nigl::massmatrix(V,F,igl::MASSMATRIX_TYPE_VORONOI,M);\nigl::invert_diag(M,Minv);\nHN = -Minv*(L*V);\nH = HN.rowwise().norm(); //up to sign\n</code></pre> <p>Combined with the angle defect definition of discrete Gaussian curvature, one can define principal curvatures and use least squares fitting to find directions <sup>3</sup>.</p> <p>Alternatively, a robust method for determining principal curvatures is via quadric fitting <sup>5</sup>. In the neighborhood around every vertex, a best-fit quadric is found and principal curvature values and directions are analytically computed on this quadric (Example 203).</p> <p> </p>      The <code>CurvatureDirections</code> example computes principal curvatures via quadric fitting and visualizes mean curvature in pseudocolor and principal directions with a cross field."},{"location":"tutorial/#gradient","title":"Gradient","text":"<p>Scalar functions on a surface can be discretized as a piecewise linear function with values defined at each mesh vertex:</p> <p>f(\\mathbf{x}) \\approx \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i,</p> <p>where \\phi_i is a piecewise linear hat function defined by the mesh so that for each triangle \\phi_i is the linear function which is one only at vertex i and zero at the other corners.</p> <p> </p>      Hat function \\phi_i is one at vertex i, zero at all other vertices, and linear on incident triangles.    <p>Thus gradients of such piecewise linear functions are simply sums of gradients of the hat functions:</p> <p>\\nabla f(\\mathbf{x}) \\approx  \\nabla \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i =  \\sum\\limits_{i=1}^n \\nabla \\phi_i(\\mathbf{x})\\, f_i.</p> <p>This reveals that the gradient is a linear function of the vector of f_i values. Because the \\phi_i are linear in each triangle, their gradients are constant in each triangle. Thus our discrete gradient operator can be written as a matrix multiplication taking vertex values to triangle values:</p> <p>\\nabla f \\approx \\mathbf{G}\\,\\mathbf{f},</p> <p>where \\mathbf{f} is n\\times 1 and \\mathbf{G} is an md\\times n sparse matrix. This matrix \\mathbf{G} can be derived geometrically, e.g. ch. 2<sup>1</sup>. Libigl\u2019s <code>grad</code> function computes \\mathbf{G} for triangle and tetrahedral meshes (Example 204):</p> <p> </p>      The <code>Gradient</code> example computes gradients of an input function on a mesh and visualizes the vector field."},{"location":"tutorial/#laplacian","title":"Laplacian","text":"<p>The discrete Laplacian is an essential geometry processing tool. Many interpretations and flavors of the Laplace and Laplace-Beltrami operator exist.</p> <p>In open Euclidean space, the Laplace operator is the usual divergence of gradient (or equivalently the Laplacian of a function is the trace of its Hessian):</p> <p>\\Delta f =  \\frac{\\partial^2 f}{\\partial x^2} +  \\frac{\\partial^2 f}{\\partial y^2} +  \\frac{\\partial^2 f}{\\partial z^2}.</p> <p>The Laplace-Beltrami operator generalizes this to surfaces.</p> <p>When considering piecewise-linear functions on a triangle mesh, a discrete Laplacian may be derived in a variety of ways. The most popular in geometry processing is the so-called ``cotangent Laplacian\u2019\u2019 \\mathbf{L}, arising simultaneously from FEM, DEC and applying divergence theorem to vertex one-rings. As a linear operator taking vertex values to vertex values, the Laplacian \\mathbf{L} is a n\\times n matrix with elements:</p> <p>L_{ij} = \\begin{cases}j \\in N(i) &amp;\\cot \\alpha_{ij} + \\cot \\beta_{ij},\\\\ j \\notin N(i) &amp; 0,\\\\ i = j &amp; -\\sum\\limits_{k\\neq i} L_{ik}, \\end{cases}</p> <p>where N(i) are the vertices adjacent to (neighboring) vertex i, and \\alpha_{ij},\\beta_{ij} are the angles opposite to edge {ij}. This formula leads to a typical half-edge style implementation for constructing \\mathbf{L}:</p> <pre><code>for(int i : vertices)\n{\nfor(int j : one_ring(i))\n{\nfor(int k : triangle_on_edge(i,j))\n{\nL(i,j) += cot(angle(i,j,k));\nL(i,i) -= cot(angle(i,j,k));\n}\n}\n}\n</code></pre> <p>Similarly as before, it may seem to loop over one-rings without having an half-edge data structure. However, this is not the case, since the Laplacian may be built by summing together contributions for each triangle, much in spirit with its FEM discretization of the Dirichlet energy (sum of squared gradients):</p> <pre><code>for(triangle t : triangles)\n{\nfor(edge i,j : t)\n{\nL(i,j) += cot(angle(i,j,k));\nL(j,i) += cot(angle(i,j,k));\nL(i,i) -= cot(angle(i,j,k));\nL(j,j) -= cot(angle(i,j,k));\n}\n}\n</code></pre> <p>Libigl implements discrete \u201ccotangent\u201d Laplacians for triangles meshes and tetrahedral meshes, building both with fast geometric rules rather than \u201cby the book\u201d FEM construction which involves many (small) matrix inversions, cf. <sup>6</sup>.</p> <p>The operator applied to mesh vertex positions amounts to smoothing by flowing the surface along the mean curvature normal direction (Example 205). Note that this is equivalent to minimizing surface area.</p> <p> </p>      The <code>Laplacian</code> example computes conformalized mean curvature flow using the cotangent Laplacian <sup>2</sup>."},{"location":"tutorial/#mass-matrix","title":"Mass Matrix","text":"<p>The mass matrix \\mathbf{M} is another n \\times n matrix which takes vertex values to vertex values. From an FEM point of view, it is a discretization of the inner-product: it accounts for the area around each vertex. Consequently, \\mathbf{M} is often a diagonal matrix, such that M_{ii} is the barycentric or voronoi area around vertex i in the mesh <sup>3</sup>. The inverse of this matrix is also very useful as it transforms integrated quantities into point-wise quantities, e.g.:</p> <p>\\Delta f \\approx \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f}.</p> <p>In general, when encountering squared quantities integrated over the surface, the mass matrix will be used as the discretization of the inner product when sampling function values at vertices:</p> <p>\\int_S x\\, y\\ dA \\approx \\mathbf{x}^T\\mathbf{M}\\,\\mathbf{y}.</p> <p>An alternative mass matrix \\mathbf{T} is a md \\times md matrix which takes triangle vector values to triangle vector values. This matrix represents an inner-product accounting for the area associated with each triangle (i.e. the triangles true area).</p>"},{"location":"tutorial/#alternative-construction-of-laplacian","title":"Alternative Construction Of Laplacian","text":"<p>An alternative construction of the discrete cotangent Laplacian is by \u201csquaring\u201d the discrete gradient operator. This may be derived by applying Green\u2019s identity (ignoring boundary conditions for the moment):</p> <p>\\int_S \\|\\nabla f\\|^2 dA = \\int_S f \\Delta f dA</p> <p>Or in matrix form which is immediately translatable to code:</p> <p>\\mathbf{f}^T \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{f} =   \\mathbf{f}^T \\mathbf{M} \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f} =   \\mathbf{f}^T \\mathbf{L} \\mathbf{f}.</p> <p>So we have that \\mathbf{L} = \\mathbf{G}^T \\mathbf{T} \\mathbf{G}. This also hints that we may consider \\mathbf{G}^T as a discrete divergence operator, since the Laplacian is the divergence of the gradient. Naturally, \\mathbf{G}^T is a n \\times md sparse matrix which takes vector values stored at triangle faces to scalar divergence values at vertices.</p>"},{"location":"tutorial/#exact-discrete-geodesic-distances","title":"Exact Discrete Geodesic Distances","text":"<p>The discrete geodesic distance between two points is the length of the shortest path between then restricted to the surface. For triangle meshes, such a path is made of a set of segments which can be either edges of the mesh or crossing a triangle.</p> <p>Libigl includes a wrapper for the exact geodesic algorithm <sup>4</sup> developed by Danil Kirsanov (https://code.google.com/archive/p/geodesic/), exposing it through an Eigen-based API. The function  <pre><code>igl::exact_geodesic(V,F,VS,FS,VT,FT,d);\n</code></pre> computes the closest geodesic distances of each vertex in VT or face in FT, from the source vertices VS or faces FS of the input mesh V,F. The output is written in the vector d, which lists first the distances for the vertices in VT, and then for the faces in FT. For example, if you want to compute the distance from the vertex with id <code>vid</code>, to all vertices of F you can use: <pre><code>Eigen::VectorXi VS,FS,VT,FT;\n// The selected vertex is the source\nVS.resize(1);\nVS &lt;&lt; vid;\n// All vertices are the targets\nVT.setLinSpaced(V.rows(),0,V.rows()-1);\nEigen::VectorXd d;\nigl::exact_geodesic(V,F,VS,FS,VT,FT,d);\n</code></pre></p> <p> </p>      [Example 206    <p>allows to interactively pick the source vertex and displays the distance using a periodic color pattern.](images/geodesicdistance.jpg)</p>"},{"location":"tutorial/#chapter-3-matrices-and-linear-algebra","title":"Chapter 3: Matrices And Linear Algebra","text":"<p>Libigl relies heavily on the Eigen library for dense and sparse linear algebra routines. Besides geometry processing routines, libigl has linear algebra routines which bootstrap Eigen and make it feel even more similar to a high-level algebra library such as Matlab.</p>"},{"location":"tutorial/#slice","title":"Slice","text":"<p>A very familiar and powerful routine in Matlab is array slicing. This allows reading from or writing to a possibly non-contiguous sub-matrix. Let\u2019s consider the Matlab code:</p> <pre><code>B = A(R,C);\n</code></pre> <p>If <code>A</code> is a m \\times n matrix and <code>R</code> is a j-long list of row-indices (between 1 and m) and <code>C</code> is a k-long list of column-indices, then as a result <code>B</code> will be a j \\times k matrix drawing elements from <code>A</code> according to <code>R</code> and <code>C</code>. In libigl, the same functionality is provided by the <code>slice</code> function (Example 301):</p> <pre><code>VectorXi R,C;\nMatrixXd A,B;\n...\nigl::slice(A,R,C,B);\n</code></pre> <p>Note that <code>A</code> and <code>B</code> could also be sparse matrices.</p> <p>Similarly, consider the Matlab code:</p> <pre><code>A(R,C) = B;\n</code></pre> <p>Now, the selection is on the left-hand side so the j \\times k matrix  <code>B</code> is being written into the submatrix of <code>A</code> determined by <code>R</code> and <code>C</code>. This functionality is provided in libigl using <code>slice_into</code>:</p> <pre><code>igl::slice_into(B,R,C,A);\n</code></pre> <p> </p>      The example <code>Slice</code> shows how to use <code>igl::slice</code> to change the colors for triangles on a mesh."},{"location":"tutorial/#sort","title":"Sort","text":"<p>Matlab and other higher-level languages make it very easy to extract indices of sorting and comparison routines. For example in Matlab, one can write:</p> <pre><code>[Y,I] = sort(X,1,'ascend');\n</code></pre> <p>so if <code>X</code> is a m \\times n matrix then <code>Y</code> will also be an m \\times n matrix with entries sorted along dimension <code>1</code> in <code>'ascend'</code>ing order. The second output <code>I</code> is a m \\times n matrix of indices such that <code>Y(i,j) = X(I(i,j),j);</code>. That is, <code>I</code> reveals how <code>X</code> is sorted into <code>Y</code>.</p> <p>This same functionality is supported in libigl:</p> <pre><code>igl::sort(X,1,true,Y,I);\n</code></pre> <p>Similarly, sorting entire rows can be accomplished in Matlab using:</p> <pre><code>[Y,I] = sortrows(X,'ascend');\n</code></pre> <p>where now <code>I</code> is a m vector of indices such that <code>Y = X(I,:)</code>.</p> <p>In libigl, this is supported with</p> <p><pre><code>igl::sortrows(X,true,Y,I);\n</code></pre> where again <code>I</code> reveals the index of sort so that it can be reproduced with <code>igl::slice(X,I,1,Y)</code>.</p> <p>Analogous functions are available in libigl for: <code>max</code>, <code>min</code>, and <code>unique</code>.</p> <p> </p>      The example <code>Sort</code> shows how to use <code>igl::sortrows</code> to pseudocolor triangles according to their barycenters\u2019 sorted order (Example 302)."},{"location":"tutorial/#other-matlab-style-functions","title":"Other Matlab-style Functions","text":"<p>Libigl implements a variety of other routines with the same api and functionality as common Matlab functions.</p> Name Description <code>igl::all</code> Whether all elements are non-zero (true) <code>igl::any</code> Whether any elements are non-zero (true) <code>igl::cat</code> Concatenate two matrices (especially useful for dealing with Eigen sparse matrices) <code>igl::ceil</code> Round entries up to nearest integer <code>igl::cumsum</code> Cumulative sum of matrix elements <code>igl::colon</code> Act like Matlab\u2019s <code>:</code>, similar to Eigen\u2019s <code>LinSpaced</code> <code>igl::components</code> Connected components of graph (cf. Matlab\u2019s <code>graphconncomp</code>) <code>igl::count</code> Count non-zeros in rows or columns <code>igl::cross</code> Cross product per-row <code>igl::cumsum</code> Cumulative summation <code>igl::dot</code> dot product per-row <code>igl::eigs</code> Solve sparse eigen value problem <code>igl::find</code> Find subscripts of non-zero entries <code>igl::floor</code> Round entries down to nearest integer <code>igl::histc</code> Counting occurrences for building a histogram <code>igl::hsv_to_rgb</code> Convert HSV colors to RGB (cf. Matlab\u2019s <code>hsv2rgb</code>) <code>igl::intersect</code> Set intersection of matrix elements. <code>igl::isdiag</code> Determine whether matrix is diagonal <code>igl::ismember</code> Determine whether elements in A occur in B <code>igl::jet</code> Quantized colors along the rainbow. <code>igl::max</code> Compute maximum entry per row or column <code>igl::median</code> Compute the median per column <code>igl::min</code> Compute minimum entry per row or column <code>igl::mod</code> Compute per element modulo <code>igl::mode</code> Compute the mode per column <code>igl::null</code> Compute the null space basis of a matrix <code>igl::nchoosek</code> Compute all k-size combinations of n-long vector <code>igl::orth</code> Orthogonalization of a basis <code>igl::parula</code> Generate a quantized colormap from blue to yellow <code>igl::pinv</code> Compute Moore-Penrose pseudoinverse <code>igl::randperm</code> Generate a random permutation of [0,\u2026,n-1] <code>igl::rgb_to_hsv</code> Convert RGB colors to HSV (cf. Matlab\u2019s <code>rgb2hsv</code>) <code>igl::repmat</code> Repeat a matrix along columns and rows <code>igl::round</code> Per-element round to whole number <code>igl::setdiff</code> Set difference of matrix elements <code>igl::setunion</code> Set union of matrix elements <code>igl::setxor</code> Set exclusive \u201cor\u201d of matrix elements <code>igl::slice</code> Slice parts of matrix using index lists: (cf. Matlab\u2019s <code>B = A(I,J)</code>) <code>igl::slice_mask</code> Slice parts of matrix using boolean masks: (cf. Matlab\u2019s <code>B = A(M,N)</code>) <code>igl::slice_into</code> Slice left-hand side of matrix assignment using index lists (cf. Matlab\u2019s <code>B(I,J) = A</code>) <code>igl::sort</code> Sort elements or rows of matrix <code>igl::speye</code> Identity as sparse matrix <code>igl::sum</code> Sum along columns or rows (of sparse matrix) <code>igl::unique</code> Extract unique elements or rows of matrix"},{"location":"tutorial/#laplace-equation","title":"Laplace Equation","text":"<p>A common linear system in geometry processing is the Laplace equation:</p> <p>\u2206z = 0</p> <p>subject to some boundary conditions, for example Dirichlet boundary conditions (fixed value):</p> <p>\\left.z\\right|_{\\partial{S}} = z_{bc}</p> <p>In the discrete setting, the linear system can be written as:</p> <p>\\mathbf{L} \\mathbf{z} = \\mathbf{0}</p> <p>where \\mathbf{L} is the n \\times n discrete Laplacian and \\mathbf{z} is a vector of per-vertex values. Most of \\mathbf{z} correspond to interior vertices and are unknown, but some of \\mathbf{z} represent values at boundary vertices. Their values are known so we may move their corresponding terms to the right-hand side.</p> <p>Conceptually, this is very easy if we have sorted \\mathbf{z} so that interior vertices come first and then boundary vertices:</p>   \\left(\\begin{array}{cc}  \\mathbf{L}_{in,in} &amp; \\mathbf{L}_{in,b}\\\\  \\mathbf{L}_{b,in} &amp; \\mathbf{L}_{b,b}\\end{array}\\right)  \\left(\\begin{array}{c}  \\mathbf{z}_{in}\\\\  \\mathbf{z}_{b}\\end{array}\\right) =  \\left(\\begin{array}{c}  \\mathbf{0}_{in}\\\\  \\mathbf{z}_{bc}\\end{array}\\right)  <p>The bottom block of equations is no longer meaningful so we\u2019ll only consider the top block:</p>   \\left(\\begin{array}{cc}  \\mathbf{L}_{in,in} &amp; \\mathbf{L}_{in,b}\\end{array}\\right)  \\left(\\begin{array}{c}  \\mathbf{z}_{in}\\\\  \\mathbf{z}_{b}\\end{array}\\right) =  \\mathbf{0}_{in}  <p>We can move the known values to the right-hand side:</p>   \\mathbf{L}_{in,in}  \\mathbf{z}_{in} = -  \\mathbf{L}_{in,b}  \\mathbf{z}_{b}  <p>Finally we can solve this equation for the unknown values at interior vertices \\mathbf{z}_{in}.</p> <p>However, our vertices will often not be sorted in this way. One option would be to sort <code>V</code>, then proceed as above and then unsort the solution <code>Z</code> to match <code>V</code>. However, this solution is not very general.</p> <p>With array slicing no explicit sort is needed. Instead we can slice-out submatrix blocks (\\mathbf{L}_{in,in}, \\mathbf{L}_{in,b}, etc.) and follow the linear algebra above directly. Then we can slice the solution into the rows of <code>Z</code> corresponding to the interior vertices (Example 303).</p> <p> </p>      The <code>LaplaceEquation</code> example solves a Laplace equation with Dirichlet boundary conditions."},{"location":"tutorial/#quadratic-energy-minimization","title":"Quadratic Energy Minimization","text":"<p>The same Laplace equation may be equivalently derived by minimizing Dirichlet energy subject to the same boundary conditions:</p> <p>\\mathop{\\text{minimize }}_z \\frac{1}{2}\\int\\limits_S \\|\\nabla z\\|^2 dA</p> <p>On our discrete mesh, recall that this becomes</p> <p>\\mathop{\\text{minimize }}_\\mathbf{z}  \\frac{1}{2}\\mathbf{z}^T \\mathbf{G}^T \\mathbf{D}  \\mathbf{G} \\mathbf{z} \\rightarrow \\mathop{\\text{minimize }}_\\mathbf{z} \\mathbf{z}^T \\mathbf{L} \\mathbf{z}</p> <p>The general problem of minimizing some energy over a mesh subject to fixed value boundary conditions is so wide spread that libigl has a dedicated api for solving such systems.</p> <p>Let us consider a general quadratic minimization problem subject to different common constraints:</p>   \\mathop{\\text{minimize }}_\\mathbf{z}  \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} +  \\mathbf{z}^T \\mathbf{B} + \\text{constant},  <p>subject to</p>   \\mathbf{z}_b = \\mathbf{z}_{bc} \\text{ and } \\mathbf{A}_{eq} \\mathbf{z} =  \\mathbf{B}_{eq},  <p>where</p> <ul> <li>\\mathbf{Q} is a (usually sparse) n \\times n positive semi-definite     matrix of quadratic coefficients (Hessian),</li> <li>\\mathbf{B} is a n \\times 1 vector of linear coefficients,</li> <li>\\mathbf{z}_b is a |b| \\times 1 portion of \\mathbf{z} corresponding to boundary or fixed vertices,</li> <li>\\mathbf{z}_{bc} is a |b| \\times 1 vector of known values corresponding to     \\mathbf{z}_b,</li> <li>\\mathbf{A}_{eq} is a (usually sparse) m \\times n matrix of linear     equality constraint coefficients (one row per constraint), and</li> <li>\\mathbf{B}_{eq} is a m \\times 1 vector of linear equality constraint     right-hand side values.</li> </ul> <p>This specification is overly general as we could write \\mathbf{z}_b = \\mathbf{z}_{bc} as rows of \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq}, but these fixed value constraints appear so often that they merit a dedicated place in the API.</p> <p>In libigl, solving such quadratic optimization problems is split into two routines: precomputation and solve. Precomputation only depends on the quadratic coefficients, known value indices and linear constraint coefficients:</p> <pre><code>igl::min_quad_with_fixed_data mqwf;\nigl::min_quad_with_fixed_precompute(Q,b,Aeq,true,mqwf);\n</code></pre> <p>The output is a struct <code>mqwf</code> which contains the system matrix factorization and is used during solving with arbitrary linear terms, known values, and constraint in the right-hand sides:</p> <pre><code>igl::min_quad_with_fixed_solve(mqwf,B,bc,Beq,Z);\n</code></pre> <p>The output <code>Z</code> is a n \\times 1 vector of solutions with fixed values correctly placed to match the mesh vertices <code>V</code>.</p>"},{"location":"tutorial/#linear-equality-constraints","title":"Linear Equality Constraints","text":"<p>We saw above that <code>min_quad_with_fixed_*</code> in libigl provides a compact way to solve general quadratic programs. Let\u2019s consider another example, this time with active linear equality constraints. Specifically let\u2019s solve the <code>bi-Laplace equation</code> or equivalently minimize the Laplace energy:</p>   \\Delta^2 z = 0 \\leftrightarrow \\mathop{\\text{minimize }}\\limits_z \\frac{1}{2}  \\int\\limits_S (\\Delta z)^2 dA  <p>subject to fixed value constraints and a linear equality constraint:</p> <p>z_{a} = 1, z_{b} = -1 and z_{c} = z_{d}.</p> <p>Notice that we can rewrite the last constraint in the familiar form from above:</p> <p>z_{c} - z_{d} = 0.</p> <p>Now we can assembly <code>Aeq</code> as a 1 \\times n sparse matrix with a coefficient 1 in the column corresponding to vertex c and a -1 at d. The right-hand side <code>Beq</code> is simply zero.</p> <p>Internally, <code>min_quad_with_fixed_*</code> solves using the Lagrange Multiplier method. This method adds additional variables for each linear constraint (in general a m \\times 1 vector of variables \\lambda) and then solves the saddle problem:</p>    \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} +   \\mathbf{z}^T \\mathbf{B} + \\text{constant} + \\lambda^T\\left(\\mathbf{A}_{eq}  \\mathbf{z} - \\mathbf{B}_{eq}\\right)  <p>This can be rewritten in a more familiar form by stacking \\mathbf{z} and \\lambda into one (m+n) \\times 1 vector of unknowns:</p>   \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\,  \\frac{1}{2}  \\left(   \\mathbf{z}^T   \\lambda^T  \\right)  \\left(   \\begin{array}{cc}   \\mathbf{Q}      &amp; \\mathbf{A}_{eq}^T\\\\   \\mathbf{A}_{eq} &amp; 0   \\end{array}  \\right)  \\left(   \\begin{array}{c}   \\mathbf{z}\\\\   \\lambda   \\end{array}  \\right) +  \\left(   \\mathbf{z}^T   \\lambda^T  \\right)  \\left(   \\begin{array}{c}   \\mathbf{B}\\\\   -\\mathbf{B}_{eq}   \\end{array}   \\right)   + \\text{constant}  <p>Differentiating with respect to \\left( \\mathbf{z}^T \\lambda^T \\right) reveals a linear system and we can solve for \\mathbf{z} and \\lambda. The only difference from the straight quadratic minimization system, is that this saddle problem system will not be positive definite. Thus, we must use a different factorization technique (LDLT rather than LLT): libigl\u2019s <code>min_quad_with_fixed_precompute</code> automatically chooses the correct solver in the presence of linear equality constraints (Example 304).</p> <p> </p>      The example <code>LinearEqualityConstraints</code> first solves with just fixed value constraints (left: 1 and -1 on the left hand and foot respectively), then solves with an additional linear equality constraint (right: points on right hand and foot constrained to be equal)."},{"location":"tutorial/#quadratic-programming","title":"Quadratic Programming","text":"<p>We can generalize the quadratic optimization in the previous section even more by allowing inequality constraints. Specifically box constraints (lower and upper bounds):</p> <p>\\mathbf{l} \\le \\mathbf{z} \\le \\mathbf{u},</p> <p>where \\mathbf{l},\\mathbf{u} are n \\times 1 vectors of lower and upper bounds and general linear inequality constraints:</p> <p>\\mathbf{A}_{ieq} \\mathbf{z} \\le \\mathbf{B}_{ieq},</p> <p>where \\mathbf{A}_{ieq} is a k \\times n matrix of linear coefficients and \\mathbf{B}_{ieq} is a k \\times 1 matrix of constraint right-hand sides.</p> <p>Again, we are overly general as the box constraints could be written as rows of the linear inequality constraints, but bounds appear frequently enough to merit a dedicated api.</p> <p>Libigl implements its own active set routine for solving quadratric programs (QPs). This algorithm works by iteratively \u201cactivating\u201d violated inequality constraints by enforcing them as equalities and \u201cdeactivating\u201d constraints which are no longer needed.</p> <p>After deciding which constraints are active at each iteration, the problem reduces to a quadratic minimization subject to linear equality constraints, and the method from the previous section is invoked. This is repeated until convergence.</p> <p>Currently the implementation is efficient for box constraints and sparse non-overlapping linear inequality constraints.</p> <p>Unlike alternative interior-point methods, the active set method benefits from a warm-start (initial guess for the solution vector \\mathbf{z}).</p> <pre><code>igl::active_set_params as;\n// Z is optional initial guess and output\nigl::active_set(Q,B,b,bc,Aeq,Beq,Aieq,Bieq,lx,ux,as,Z);\n</code></pre> <p> </p> Example 305 uses an active set solver to optimize discrete biharmonic kernels <sup>9</sup> at multiple scales ."},{"location":"tutorial/#eigen-decomposition","title":"Eigen Decomposition","text":"<p>Libigl has rudimentary support for extracting eigen pairs of a generalized eigen value problem:</p> <p>Ax = \\lambda B x</p> <p>where A is a sparse symmetric matrix and B is a sparse positive definite matrix. Most commonly in geometry processing, we let A=L the cotangent Laplacian and B=M the per-vertex mass matrix (e.g. <sup>10</sup>). Typically applications will make use of the low frequency eigen modes. Analogous to the Fourier decomposition, a function f on a surface can be represented via its spectral decomposition of the eigen modes of the Laplace-Beltrami:</p> <p>f = \\sum\\limits_{i=1}^\\infty a_i \\phi_i</p> <p>where each \\phi_i is an eigen function satisfying: \\Delta \\phi_i = \\lambda_i \\phi_i and a_i are scalar coefficients. For a discrete triangle mesh, a completely analogous decomposition exists, albeit with finite sum:</p> <p>\\mathbf{f} = \\sum\\limits_{i=1}^n a_i \\phi_i</p> <p>where now a column vector of values at vertices \\mathbf{f} \\in \\mathcal{R}^n specifies a piecewise linear function and \\phi_i \\in \\mathcal{R}^n is an eigen vector satisfying:</p> <p>\\mathbf{L} \\phi_i = \\lambda_i \\mathbf{M} \\phi_i.</p> <p>Note that Vallet &amp; Levy <sup>10</sup> propose solving a symmetrized standard eigen problem \\mathbf{M}^{-1/2}\\mathbf{L}\\mathbf{M}^{-1/2} \\phi_i = \\lambda_i \\phi_i. Libigl implements a generalized eigen problem solver so this unnecessary symmetrization can be avoided.</p> <p>Often the sum above is truncated to the first k eigen vectors. If the low frequency modes are chosen, i.e. those corresponding to small \\lambda_i values, then this truncation effectively regularizes \\mathbf{f} to smooth, slowly changing functions over the mesh (e.g. <sup>8</sup>). Modal analysis and model subspaces have been used frequently in real-time deformation (e.g. <sup>7</sup>).</p> <p>In Example 306), the first 5 eigen vectors of the discrete Laplace-Beltrami operator are computed and displayed in pseudo-color atop the beetle. Eigen vectors are computed using <code>igl::eigs</code> (mirroring MATLAB\u2019s <code>eigs</code>). The 5 eigen vectors are placed into the columns of <code>U</code> and the eigen values are placed into the entries of <code>S</code>:</p> <pre><code>SparseMatrix&lt;double&gt; L,M;\nigl::cotmatrix(V,F,L);\nigl::massmatrix(V,F,igl::MASSMATRIX_TYPE_DEFAULT,M);\nEigen::MatrixXd U;\nEigen::VectorXd S;\nigl::eigs(L,M,5,igl::EIGS_TYPE_SM,U,S);\n</code></pre> <p> </p>      (Example 306) Low frequency eigen vectors of the discrete Laplace-Beltrami operator vary smoothly and slowly over the Beetle."},{"location":"tutorial/#chapter-4-shape-deformation","title":"Chapter 4: Shape Deformation","text":"<p>Modern mesh-based shape deformation methods satisfy user deformation constraints at handles (selected vertices or regions on the mesh) and propagate these handle deformations to the rest of shape smoothly and without removing or distorting details. Libigl provides implementations of a variety of state-of-the-art deformation techniques, ranging from quadratic mesh-based energy minimizers, to skinning methods, to non-linear elasticity-inspired techniques.</p>"},{"location":"tutorial/#biharmonic-deformation","title":"Biharmonic Deformation","text":"<p>The period of research between 2000 and 2010 produced a collection of techniques that cast the problem of handle-based shape deformation as a quadratic energy minimization problem or equivalently the solution to a linear partial differential equation.</p> <p>There are many flavors of these techniques, but a prototypical subset are those that consider solutions to the bi-Laplace equation, that is a biharmonic function <sup>11</sup>. This fourth-order PDE provides sufficient flexibility in boundary conditions to ensure C^1 continuity at handle constraints (in the limit under refinement) <sup>15</sup>.</p>"},{"location":"tutorial/#biharmonic-surfaces","title":"Biharmonic Surfaces","text":"<p>Let us first begin our discussion of biharmonic deformation, by considering biharmonic surfaces. We will casually define biharmonic surfaces as surface whose position functions are biharmonic with respect to some initial parameterization:</p> <p>\\Delta^2 \\mathbf{x}' = 0</p> <p>and subject to some handle constraints, conceptualized as \u201cboundary conditions\u201d:</p> <p>\\mathbf{x}'_{b} = \\mathbf{x}_{bc}.</p> <p>where \\mathbf{x}' is the unknown 3D position of a point on the surface. So we are asking that the bi-Laplacian of each of spatial coordinate function to be zero.</p> <p>In libigl, one can solve a biharmonic problem with <code>igl::harmonic</code> and setting k=2 (bi-harmonic):</p> <pre><code>// U_bc contains deformation of boundary vertices b\nigl::harmonic(V,F,b,U_bc,2,U);\n</code></pre> <p>This produces a smooth surface that interpolates the handle constraints, but all original details on the surface will be smoothed away. Most obviously, if the original surface is not already biharmonic, then giving all handles the identity deformation (keeping them at their rest positions) will not reproduce the original surface. Rather, the result will be the biharmonic surface that does interpolate those handle positions.</p> <p>Thus, we may conclude that this is not an intuitive technique for shape deformation.</p>"},{"location":"tutorial/#biharmonic-deformation-fields","title":"Biharmonic Deformation Fields","text":"<p>Now we know that one useful property for a deformation technique is \u201crest pose reproduction\u201d: applying no deformation to the handles should apply no deformation to the shape.</p> <p>To guarantee this by construction we can work with deformation fields (ie. displacements) \\mathbf{d} rather than directly with positions \\mathbf{x}. Then the deformed positions can be recovered as</p> <p>\\mathbf{x}' = \\mathbf{x}+\\mathbf{d}.</p> <p>A smooth deformation field \\mathbf{d} which interpolates the deformation fields of the handle constraints will impose a smooth deformed shape \\mathbf{x}'. Naturally, we consider biharmonic deformation fields:</p> <p>\\Delta^2 \\mathbf{d} = 0</p> <p>subject to the same handle constraints, but rewritten in terms of their implied deformation field at the boundary (handles):</p> <p>\\mathbf{d}_b = \\mathbf{x}_{bc} - \\mathbf{x}_b.</p> <p>Again we can use <code>igl::harmonic</code> with k=2, but this time solve for the deformation field and then recover the deformed positions:</p> <pre><code>// U_bc contains deformation of boundary vertices b\nD_bc = U_bc - igl::slice(V,b,1);\nigl::harmonic(V,F,b,D_bc,2,D);\nU = V+D;\n</code></pre> <p> </p>      The BiharmonicDeformation example deforms a statue\u2019s head as a biharmonic surface (top) and using a biharmonic displacements (bottom)."},{"location":"tutorial/#relationship-to-differential-coordinates-and-laplacian-surface-editing","title":"Relationship To \u201cdifferential Coordinates\u201d And Laplacian Surface Editing","text":"<p>Biharmonic functions (whether positions or displacements) are solutions to the bi-Laplace equation, but also minimizers of the \u201cLaplacian energy\u201d. For example, for displacements \\mathbf{d}, the energy reads</p> <p>\\int\\limits_S \\|\\Delta \\mathbf{d}\\|^2 dA,</p> <p>where we define \\Delta \\mathbf{d} to simply apply the Laplacian coordinate-wise.</p> <p>By linearity of the Laplace(-Beltrami) operator we can reexpress this energy in terms of the original positions \\mathbf{x} and the unknown positions \\mathbf{x}' = \\mathbf{x} - \\mathbf{d}:</p> <p>\\int\\limits_S \\|\\Delta (\\mathbf{x}' - \\mathbf{x})\\|^2 dA = \\int\\limits_S  \\|\\Delta \\mathbf{x}' - \\Delta \\mathbf{x})\\|^2 dA.</p> <p>In the early work of Sorkine et al., the quantities \\Delta \\mathbf{x}' and \\Delta \\mathbf{x} were dubbed \u201cdifferential coordinates\u201d <sup>21</sup>. Their deformations (without linearized rotations) is thus equivalent to biharmonic deformation fields.</p>"},{"location":"tutorial/#polyharmonic-deformation","title":"Polyharmonic Deformation","text":"<p>We can generalize biharmonic deformation by considering different powers of the Laplacian, resulting in a series of PDEs of the form:</p> <p>\\Delta^k \\mathbf{d} = 0.</p> <p>with k\\in{1,2,3,\\dots}. The choice of k determines the level of continuity at the handles. In particular, k=1 implies C^0 at the boundary, k=2 implies C^1, k=3 implies C^2 and in general k implies C^{k-1}.</p> <pre><code>int k = 2;// or 1,3,4,...\nigl::harmonic(V,F,b,bc,k,Z);\n</code></pre> <p> </p>      The PolyharmonicDeformation example deforms a flat domain (left) into a bump as a solution to various k-harmonic PDEs."},{"location":"tutorial/#bounded-biharmonic-weights","title":"Bounded Biharmonic Weights","text":"<p>In computer animation, shape deformation is often referred to as \u201cskinning\u201d. Constraints are posed as relative rotations of internal rigid \u201cbones\u201d inside a character. The deformation method, or skinning method, determines how the surface of the character (i.e. its skin) should move as a function of the bone rotations.</p> <p>The most popular technique is linear blend skinning. Each point on the shape computes its new location as a linear combination of bone transformations:</p> <p>\\mathbf{x}' = \\sum\\limits_{i = 1}^m w_i(\\mathbf{x}) \\mathbf{T}_i  \\left(\\begin{array}{c}\\mathbf{x}_i\\\\1\\end{array}\\right),</p> <p>where w_i(\\mathbf{x}) is the scalar weight function of the ith bone evaluated at \\mathbf{x} and \\mathbf{T}_i is the bone transformation as a 4 \\times 3 matrix.</p> <p>This formula is embarassingly parallel (computation at one point does not depend on shared data need by computation at another point). It is often implemented as a vertex shader. The weights and rest positions for each vertex are sent as vertex shader attributes and bone transformations are sent as uniforms. Then vertices are transformed within the vertex shader, just in time for rendering.</p> <p>As the skinning formula is linear (hence its name), we can write it as matrix multiplication:</p> <p>\\mathbf{X}' = \\mathbf{M} \\mathbf{T},</p> <p>where \\mathbf{X}' is n \\times 3 stack of deformed positions as row vectors, \\mathbf{M} is a n \\times m\\cdot dim matrix containing weights and rest positions and \\mathbf{T} is a m\\cdot (dim+1) \\times dim stack of transposed bone transformations.</p> <p>Traditionally, the weight functions w_j are painted manually by skilled rigging professionals. Modern techniques now exist to compute weight functions automatically given the shape and a description of the skeleton (or in general any handle structure such as a cage, collection of points, selected regions, etc.).</p> <p>Bounded biharmonic weights are one such technique that casts weight computation as a constrained optimization problem <sup>13</sup>. The weights enforce smoothness by minimizing the familiar Laplacian energy:</p> <p>\\sum\\limits_{i = 1}^m \\int_S (\\Delta w_i)^2 dA</p> <p>subject to constraints which enforce interpolation of handle constraints:</p> <p>w_i(\\mathbf{x}) = \\begin{cases} 1 &amp; \\text{ if } \\mathbf{x} \\in H_i\\\\ 0 &amp;  \\text{ otherwise } \\end{cases},</p> <p>where H_i is the ith handle, and constraints which enforce non-negativity, parition of unity and encourage sparsity:</p> <p>0\\le w_i \\le 1 and \\sum\\limits_{i=1}^m w_i = 1.</p> <p>This is a quadratic programming problem and libigl solves it using its active set solver or by calling out to Mosek.</p> <p> </p>      The example BoundedBiharmonicWeights computes weights for a tetrahedral mesh given a skeleton (top) and then animates a linear blend skinning deformation (bottom)."},{"location":"tutorial/#dual-quaternion-skinning","title":"Dual Quaternion Skinning","text":"<p>Even with high quality weights, linear blend skinning is limited. In particular, it suffers from known artifacts stemming from blending rotations as matrices: a weight combination of rotation matrices is not necessarily a rotation. Consider an equal blend between rotating by -\\pi/2 and by \\pi/2 about the z-axis. Intuitively one might expect to get the identity matrix, but instead the blend is a degenerate matrix scaling the x and y coordinates by zero:</p> <p>0.5\\left(\\begin{array}{ccc}0&amp;-1&amp;0\\\\1&amp;0&amp;0\\\\0&amp;0&amp;1\\end{array}\\right)+  0.5\\left(\\begin{array}{ccc}0&amp;1&amp;0\\\\-1&amp;0&amp;0\\\\0&amp;0&amp;1\\end{array}\\right)=  \\left(\\begin{array}{ccc}0&amp;0&amp;0\\\\0&amp;0&amp;0\\\\0&amp;0&amp;1\\end{array}\\right)</p> <p>In practice, this means the shape shrinks and collapses in regions where bone weights overlap: near joints.</p> <p>Dual quaternion skinning presents a solution <sup>17</sup>. This method represents rigid transformations as a pair of unit quaternions, \\hat{\\mathbf{q}}. The linear blend skinning formula is replaced with a linear blend of dual quaternions:</p> <p>\\mathbf{x}' =  \\cfrac{\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}}  {\\left\\|\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}\\right\\|}  \\mathbf{x},</p> <p>where \\hat{\\mathbf{q}_i} is the dual quaternion representation of the rigid transformation of bone i. The normalization forces the result of the linear blending to again be a unit dual quaternion and thus also a rigid transformation.</p> <p>Like linear blend skinning, dual quaternion skinning is best performed in the vertex shader. The only difference being that bone transformations are sent as dual quaternions rather than affine transformation matrices.  Libigl supports CPU-side dual quaternion skinning with the <code>igl::dqs</code> function, which takes a more traditional representation of rigid transformations as input and internally converts to the dual quaternion representation before blending:</p> <pre><code>// vQ is a list of rotations as quaternions\n// vT is a list of translations\nigl::dqs(V,W,vQ,vT,U);\n</code></pre> <p> </p>      The example DualQuaternionSkinning compares linear blend skinning (top) to dual quaternion skinning (bottom), highlighting LBS\u2019s candy wrapper effect (middle) and joint collapse (right)."},{"location":"tutorial/#as-rigid-as-possible","title":"As-rigid-as-possible","text":"<p>Skinning and other linear methods for deformation are inherently limited. Difficult arises especially when large rotations are imposed by the handle constraints.</p> <p>In the context of energy-minimization approaches, the problem stems from comparing positions (our displacements) in the coordinate frame of the undeformed shape. These quadratic energies are at best invariant to global rotations of the entire shape, but not smoothly varying local rotations. Thus linear techniques will not produce non-trivial bending and twisting.</p> <p>Furthermore, when considering solid shapes (e.g. discretized with tetrahedral meshes) linear methods struggle to maintain local volume, and they often suffer from shrinking and bulging artifacts.</p> <p>Non-linear deformation techniques present a solution to these problems. They work by comparing the deformation of a mesh vertex to its rest position rotated to a new coordinate frame which best matches the deformation. The non-linearity stems from the mutual dependence of the deformation and the best-fit rotation. These techniques are often labeled \u201cas-rigid-as-possible\u201d as they penalize the sum of all local deformations\u2019 deviations from rotations.</p> <p>To arrive at such an energy, let\u2019s consider a simple per-triangle energy:</p> <p>E_\\text{linear}(\\mathbf{X}') = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\}  \\in t} w_{ij} \\left\\|  \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) -  \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2</p> <p>where \\mathbf{X}' are the mesh\u2019s unknown deformed vertex positions, t is a triangle in a list of triangles T, a_t is the area of triangle t and \\{i,j\\} is an edge in triangle t. Thus, this energy measures the norm of change between an edge vector in the original mesh \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right) and the unknown mesh \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right).</p> <p>This energy is not rotation invariant. If we rotate the mesh by 90 degrees the change in edge vectors not aligned with the axis of rotation will be large, despite the overall deformation being perfectly rigid.</p> <p>So, the \u201cas-rigid-as-possible\u201d solution is to append auxiliary variables \\mathbf{R}_t for each triangle t which are constrained to be rotations. Then the energy is rewritten, this time comparing deformed edge vectors to their rotated rest counterparts:</p> <p>E_\\text{arap}(\\mathbf{X}',\\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\}) = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\}  \\in t} w_{ij} \\left\\|  \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right)-  \\mathbf{R}_t\\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2.</p> <p>The separation into the primary vertex position variables \\mathbf{X}' and the rotations \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} lead to strategy for optimization, too. If the rotations \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} are held fixed then the energy is quadratic in the remaining variables \\mathbf{X}' and can be optimized by solving a (sparse) global linear system. Alternatively, if \\mathbf{X}' are held fixed then each rotation is the solution to a localized Procrustes problem (found via 3 \\times 3 SVD or polar decompostion). These two steps\u2014local and global\u2014each weakly decrease the energy, thus we may safely iterate them until convergence.</p> <p>The different flavors of \u201cas-rigid-as-possible\u201d depend on the dimension and codimension of the domain and the edge-sets T. The proposed surface manipulation technique by Sorkine and Alexa <sup>22</sup>, considers T to be the set of sets of edges emanating from each vertex (spokes). Later, Chao et al.  derived the relationship between \u201cas-rigid-as-possible\u201d mesh energies and co-rotational elasticity considering 0-codimension elements as edge-sets: triangles in 2D and tetrahedra in 3D <sup>12</sup>. They also showed how Sorkine and Alexa\u2019s edge-sets are not a discretization of a continuous energy, proposing instead edge-sets for surfaces containing all edges of elements incident on a vertex (spokes and rims). They show that this amounts to measuring bending, albeit in a discretization-dependent way.</p> <p>Libigl, supports these common flavors. Selecting one is a matter of setting the energy type before the precompuation phase:</p> <pre><code>igl::ARAPData arap_data;\narap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES;\n//arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS;\n//arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS; //triangles or tets\nigl::arap_precomputation(V,F,dim,b,arap_data);\n</code></pre> <p>Just like <code>igl::min_quad_with_fixed_*</code>, this precomputation phase only depends on the mesh, fixed vertex indices <code>b</code> and the energy parameters. To solve with certain constraints on the positions of vertices in <code>b</code>, we may call:</p> <pre><code>igl::arap_solve(bc,arap_data,U);\n</code></pre> <p>which uses <code>U</code> as an initial guess and then computes the solution into it.</p> <p>Libigl\u2019s implementation of as-rigid-as-possible deformation takes advantage of the highly optimized singular value decomposition code from McAdams et al. <sup>20</sup> which leverages SSE intrinsics.</p> <p> </p>      The example AsRigidAsPossible deforms a surface as if it were made of an elastic material    <p>The concept of local rigidity will be revisited shortly in the context of surface parameterization.</p>"},{"location":"tutorial/#fast-automatic-skinning-transformations","title":"Fast Automatic Skinning Transformations","text":"<p>Non-linear optimization is, unsurprisingly, slower than its linear cousins. In the case of the as-rigid-as-possible optimization, the bottleneck is typically the large number of polar decompositions necessary to recover best fit rotations for each edge-set (i.e. for each triangle, tetrahedron, or vertex cell). Even if this code is optimized, the number of primary degrees of freedom is tied to the discretization level, despite the deformations\u2019 low frequency behavior.</p> <p>This invites two routes toward fast non-linear optimization. First, is it necessary (or even advantageous) to find so many best-fit rotations? Second, can we reduce the degrees of freedom to better reflect the frequency of the desired deformations.</p> <p>Taken in turn, these optimizations culminate in a method which optimizes over the space of linear blend skinning deformations spanned by high-quality weights (i.e. manually painted ones or bounded biharmonic weights). This space is a low-dimensional subspace of all possible mesh deformations, captured by writing linear blend skinning in matrix form:</p> <p>\\mathbf{X}' = \\mathbf{M}\\mathbf{T}</p> <p>where the mesh vertex positions in the n \\times 3 matrix \\mathbf{X}' are replaced by a linear combination of a small number of degrees of freedom in the (3+1)m \\times 3 stack of transposed \u201chandle\u201d transformations. Swapping in \\mathbf{M}\\mathbf{T} for \\mathbf{X}' in the ARAP energies above immediately sees performance gains during the global solve step as m &lt;&lt; n.</p> <p>The complexity of the local step\u2014fitting rotations\u2014is still bound to the original mesh discretization. However, if the skinning is well behaved, we can make the assumption that places on the shape with similar skinning weights will deform similarly and thus imply similar best-fit rotations. Therefore, we cluster edge-sets according to their representation in weight-space: where a vertex \\mathbf{x} takes the coordinates [w_1(\\mathbf{x}),w_2(\\mathbf{x}),\\dots,w_m(\\mathbf{x})]. The number of clustered edge-sets show diminishing returns on the deformation quality so we may choose a small number of clusters, proportional to the number of skinning weight functions (rather than the number of discrete mesh vertices).</p> <p>This proposed deformation model <sup>14</sup>, can simultaneously be seen as a fast, subspace optimization for ARAP and as an automatic method for finding the best skinning transformation degrees of freedom.</p> <p>A variety of user interfaces are supported via linear equality constraints on the skinning transformations associated with handles. To fix a transformation entirely we simply add the constraint:</p> <p>\\left(\\begin{array}{cccc}  1 &amp; 0 &amp; 0 &amp; 0\\\\  0 &amp; 1 &amp; 0 &amp; 0\\\\  0 &amp; 0 &amp; 1 &amp; 0\\\\  0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right)  \\mathbf{T}_i^T = \\hat{\\mathbf{T}}_i^T,</p> <p>where \\hat{\\mathbf{T}}_i^T is the (3+1) \\times 3 transposed fixed transformation for handle i.</p> <p>To fix only the origin of a handle, we add a constraint requiring the transformation to interpolate a point in space (typically the centroid of all points with w_i = 1:</p> <p>\\mathbf{c}'^T\\mathbf{T}_i^T = \\mathbf{c}^T,</p> <p>where \\mathbf{c}^T is the 1 \\times (3+1) position of the point at rest in transposed homogeneous coordinates, and \\mathbf{c}'^T the point given by the user.</p> <p>We can similarly fix just the linear part of the transformation at a handle, freeing the translation component (producing a \u201cchickenhead\u201d effect):</p> <p>\\left(\\begin{array}{cccc}  1&amp;0&amp;0&amp;0\\\\  0&amp;1&amp;0&amp;0\\\\  0&amp;0&amp;1&amp;0\\end{array}\\right)  \\mathbf{T}_i^T = \\hat{\\mathbf{L}}_i^T,</p> <p>where \\hat{\\mathbf{L}}_i^T is the fixed 3 \\times 3 linear part of the transformation at handle i.</p> <p>And lastly we can allow the user to entirely free the transformation\u2019s degrees of freedom, delegating the optimization to find the best possible values for all elements. To do this, we simply abstain from adding a corresponding constraint.</p>"},{"location":"tutorial/#arap-with-grouped-edge-sets","title":"Arap With Grouped Edge-sets","text":"<p>Being a subspace method, an immediate disadvantage is the reduced degrees of freedom. This brings performance, but in some situations limits behavior too much. In such cases one can use the skinning subspace to build an effective clustering of rotation edge-sets for a traditional ARAP optimization: forgoing the subspace substitution. This has a two-fold effect. The cost of the rotation fitting, local step drastically reduces, and the deformations are \u201cregularized\u201d according the clusters. From a high level point of view, if the clusters are derived from skinning weights, then they will discourage bending, especially along isolines of the weight functions. If handles are not known in advance, one could also cluster according to a \u201cgeodesic embedding\u201d like the biharmonic distance embedding.</p> <p>In this light, we can think of the \u201cspokes+rims\u201d style surface ARAP as a (slight and redundant) clustering of the per-triangle edge-sets.</p> <p> </p>      The example FastAutomaticSkinningTransformations compares a full (slow) ARAP deformation on a detailed shape (left of middle), to ARAP with grouped rotation edge sets (right of middle), to the very fast subpsace method (right)."},{"location":"tutorial/#biharmonic-coordinates","title":"Biharmonic Coordinates","text":"<p>Linear blend skinning (as above) deforms a mesh by propagating full affine transformations at handles (bones, points, regions, etc.) to the rest of the shape via weights. Another deformation framework, called \u201cgeneralized barycentric coordinates\u201d, is a special case of linear blend skinning <sup>16</sup>: transformations are restricted to pure translations and weights are required to retain affine precision. This latter requirement means that we can write the rest-position of any vertex in the mesh as the weighted combination of the control handle locations:</p> <p>\\mathbf{x} = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i,</p> <p>where \\mathbf{c}_i is the rest position of the ith control point. This simplifies the deformation formula at run-time. We can simply take the new position of each point of the shape to be the weighted combination of the translated control point positions:</p> <p>\\mathbf{x}' = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i'.</p> <p>There are many different flavors of \u201cgeneralized barycentric coordinates\u201d (see table in \u201cAutomatic Methods\u201d section, <sup>16</sup>). The vague goal of \u201cgeneralized barycentric coordinates\u201d is to capture as many properties of simplicial barycentric coordinates (e.g. for triangles in 2D and tetrahedral in 3D) for larger sets of points or polyhedra. Some generalized barycentric coordinates can be computed in closed form; others require optimization-based precomputation. Nearly all flavors require connectivity information describing how the control points form a external polyhedron around the input shape: a cage. However, a recent techinique does not require a cage <sup>23</sup>. This method ensures affine precision during optimization over weights of a smoothness energy with affine functions in its kernel:</p> <p>\\mathop{\\text{min}}_\\mathbf{W}\\,\\, \\text{trace}(\\frac{1}{2}\\mathbf{W}^T \\mathbf{A}  \\mathbf{W}), \\text{subject to: } \\mathbf{C} = \\mathbf{W}\\mathbf{C}</p> <p>subject to interpolation constraints at selected vertices. If \\mathbf{A} has affine functions in its kernel\u2014that is, if \\mathbf{A}\\mathbf{V} = 0\u2014then the weights \\mathbf{W} will retain affine precision and we\u2019ll have that:</p> <p>\\mathbf{V} = \\mathbf{W}\\mathbf{C}</p> <p>the matrix form of the equality above. The proposed way to define \\mathbf{A} is to construct a matrix \\mathbf{K} that measures the Laplacian at all interior vertices and at all boundary vertices. The usual definition of the discrete Laplacian (e.g. what libigl returns from <code>igl::cotmatrix</code>), measures the Laplacian of a function for interior vertices, but measures the Laplacian of a function minus the normal derivative of a function for boundary vertices. Thus, we can let:</p> <p>\\mathbf{K} = \\mathbf{L} + \\mathbf{N}</p> <p>where \\mathbf{L} is the usual Laplacian and \\mathbf{N} is matrix that computes normal derivatives of a piecewise-linear function at boundary vertices of a mesh. Then \\mathbf{A} is taken as quadratic form computing the square of the integral-average of \\mathbf{K} applied to a function and integrated over the mesh:</p> <p>\\mathbf{A} = (\\mathbf{M}^{-1}\\mathbf{K})^2_\\mathbf{M} = \\mathbf{K}^T \\mathbf{M}^{-1}  \\mathbf{K}.</p> <p>Since the Laplacian \\mathbf{K} is a second-order derivative it measures zero on affine functions, thus \\mathbf{A} has affine functions in its null space. A short derivation proves that this implies \\mathbf{W} will be affine precise (see <sup>23</sup>).</p> <p>Minimizers of this \u201csquared Laplacian\u201d energy are in some sense discrete biharmonic functions. Thus they\u2019re dubbed \u201cbiharmonic coordinates\u201d (not the same as bounded biharmonic weights, which are not generalized barycentric coordinates).</p> <p>In libigl, one can compute biharmonic coordinates given a mesh <code>(V,F)</code> and a list <code>S</code> of selected control points or control regions (which act like skinning handles):</p> <pre><code>igl::biharmonic_coordinates(V,F,S,W);\n</code></pre> <p> </p>      (Example 407) shows a physics simulation on a coarse orange mesh. The vertices of this mesh become control points for a biharmonic coordinates deformation of the blue high-resolution mesh."},{"location":"tutorial/#direct-delta-mush","title":"Direct Delta Mush","text":"<p>To produce a smooth deformation, linear blend skinning requires smooth skinning weights. These could be painted manually or computed automatically (e.g., using Bounded Biharmonic Weights <sup>13</sup>). Even still, linear blend skinning suffers from shrinkage and collapse artifacts due to its inherent linearity (see earlier). \u201cDirect Delta Mush\u201d <sup>18</sup> skinning attempts to solve both of these issues by providing a direct skinning method that takes as input a rig with piecewise-constant weight functions (weights are either =0 or =1 everywhere). Direct delta mush is an adaptation of a less performant method called simply \u201cDelta Mush\u201d <sup>19</sup>. The computation of Delta Mush separates into \u201cbind pose\u201d precomputation and runtime evaluation. </p> <p>At bind time, Laplacian smoothing is conducted on the bind pose, moving each vertex from its rest position \\mathbf{v}_i to a new position \\tilde{\\mathbf{v}}_i. The \u201cdelta\u201d describing undoing this smoothing procedure, is computed and stored in a local coordinate frame associated with the vertex:</p> <p>\\delta_i = \\mathbf{T}_i^{-1} (\\mathbf{v}_i - \\tilde{\\mathbf{v}}_i).</p> <p>At run time, the mesh is deformed using linear blend skinning and piecewise-constant weights. Near bones, the deformation is perfectly rigid, while near joints where bones meet, the mesh tears apart with a sudden change to the next rigid transformation. The same amount of Laplacian smoothing is applied at run time to this posed mesh. Moving each vertex to a location \\tilde{\\mathbf{u}}_i. A local frame \\mathbf{S}_i is computed at this location and the cached deltas are adding in this resolved frame to restore the shape\u2019s original details:</p> <p>\\mathbf{u}_i = \\tilde{\\mathbf{u}}_i + \\mathbf{S}_i \\delta_i.</p> <p>The key insight of \u201cDelta Mush\u201d is that Laplacian smoothing acts similarly on the rest and posed models.</p> <p>The key insight of \u201cDirect Delta Mush\u201d is that this process of Laplacian smoothing at runtime is nearly linear and local frames can be computed in a embarrassingly parallel fashion using SVD (cf. ARAP).</p> <p>Direct delta mush moves the smoothing step into precomputation, resulting in \u201cvector-valued\u201d skinning weights per-vertex per-bone, stored in a matrix \\Omega. In libigl, for a mesh <code>(V,F)</code> and (e.g., piecewise-constant) weights <code>W</code> this precomputation is computed using:</p> <pre><code>igl::direct_delta_mush_precomputation(V, F,Wsparse, p, lambda, kappa, alpha, Omega);\n</code></pre> <p>the parameters <code>p, lambda, kappa, alpha</code> control the smoothness and compactness of the resulting deformation. The precomputation\u2019s output is the matrix <code>Omega</code>.</p> <p>At runtime, \\Omega is used to deform the mesh to its final locations. In libigl, this is computed using:</p> <pre><code>igl::direct_delta_mush(V, T_list, Omega, U);\n</code></pre> <p>where <code>T_list</code> is the input pose (affine) transformations associated with each bone and the final locations are stored in <code>U</code>.</p> <p> </p>      (Example 408) Direct Delta Mush. (left) input piecewise-rigid skinning, (middle) skeleton animation, (right) smooth Direct Delta Mush skinning"},{"location":"tutorial/#mesh-deformation-with-kelvinlet","title":"Mesh Deformation with Kelvinlet","text":"<p>Kelvinlets<sup>24</sup> is a technique for real-time physically based volume sculpting of virtual elastic materials. The technique treats meshes as fluids made of compressible materials and deforms them by advecting points along a displacement field. It relies on analytical solutions to the equations of elasticity.</p>"},{"location":"tutorial/#a-quick-primer-on-linear-elastostatics-25","title":"A quick primer on linear elastostatics <sup>25</sup>","text":"<p>The equilibrium state of linear elasticity is determined by a displacement field \\mathbf{u} : R^3 \\rightarrow  R^3 that minimizes the elastic potential energy </p> <p>E(\\mathbf{u}) = \\frac{\\mu}{2}\\left\\|\\nabla\\mathbf{u}\\right\\|^2  +  \\frac{\\mu}{2(1-2\\nu)}\\left\\|\\nabla \\cdot \\mathbf{u}\\right\\|^2 - \\langle\\mathbf{b},  \\mathbf{u}\\rangle</p> <p>where \\mu is the elastic shear modulus,  \\nu is the Poisson ratio, and \\mathbf{b} represents the external body forces.</p> <p>The first term controls the smoothness of the displacement field, the second term penalizes infinitesimal volume change, and the last term indicates the external body forces to be counteracted.</p> <p>One can associate the optimal displacement field with the solution to the critical point of the above equation, also known as the Navier-Cauchy equation:</p> <p>\\mu\\Delta\\mathbf{u} + \\frac{\\mu}{(1 - 2\\nu)}\\nabla(\\nabla \\cdot \\mathbf{u}) + \\mathbf{b} = 0</p> <p>The Kelvinlet is the solution to the Navier-Cauchy equation in the case of a concentrated body load due to a force vector \\mathbf{f} at a point \\mathbf{x}_{0}, i.e., where \\mathbf{b}(\\mathbf{x}) = \\mathbf{f} \\delta(\\mathbf{x} \u2212 \\mathbf{x}_{0}) and can be written as:</p> <p>\\mathbf{u}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r}I + \\frac{\\mathbf{b}}{\\mathit{r}^3}\\mathbf{r}\\mathbf{r}^{t}\\right] \\mathbf{f} \\equiv \\mathbf{K}(\\mathbf{r})\\mathbf{f}</p> <p>where \\mathbf{K} is the Kelvinlet function, \\mathbf{r} = \\mathbf{x} \u2212 \\mathbf{x}_{0} is the relative position vector from the load location \\mathbf{x}_{0} to an observation point \\mathbf{x}, \\mathit{r} is the norm of \\mathbf{r}, a = \\frac{1}{4\\pi\\mu} and b = \\frac{a}{(1-\\nu)}</p> <p>The displacement field \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) deforms a point \\mathbf{x} in a linear elastic material to \\mathbf{x} + \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}). The associated deformation gradient is then defined by a 3\u00d73 matrix of the form \\mathbf{G}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) = \\mathbf{I} + \\nabla\\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}).</p> <p>This gradient \\mathbf{G}(\\mathbf{r}) determines the different properties of the displacement field \\mathbf{u(\\mathbf{r})}. For instance, the skew-symmetric part of \\nabla\\mathbf{u}(\\mathbf{r}) indicates the rotation induced by \\mathbf{u(\\mathbf{r})}, while its symmetric part corresponds to the elastic strain and determines the stretching. The strain tensor can also be decomposed into a trace term that represents the scaling of the volume of the elastic medium, and a traceless term that represents the pinching deformation.</p> <p>This forms the fundamentals of the Kelvinlet brushes. </p>"},{"location":"tutorial/#regularized-kelvinlets","title":"Regularized kelvinlets","text":"<p>The concentrated body load at a single point \\mathbf{x}_{0} introduces a singularity to the Kelvinlet solution at \\mathbf{x}_{0}. For this reason, the kelvinlet equation is modified to:</p> <p>\\mathbf{u_{\\epsilon}}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r_{\\epsilon}}I + \\frac{\\mathbf{b}}{\\mathit{r_{\\epsilon}}^3}\\mathbf{r_{\\epsilon}}\\mathbf{r_{\\epsilon}}^{t} + \\frac{a}{2}\\frac{\\epsilon^2}{r_{\\epsilon}^3}I\\right] \\equiv \\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{f}</p> <p>where \\mathbf{r}_{\\epsilon} = \\sqrt{r^2 + \\epsilon^2} is the regularized distance, \\epsilon &gt; 0 is the radius of the sculpting brush.</p> <p>Thus, given a force vector \\mathbf{f}, the displacement for any point in R^3 can be calculated, thus defining the physically based space deformation. In practice, the force vector is parameterized in terms of the brush tip displacement \\mathbf{\\bar{u}}. To this end, we can expand the regularized kelvinlet equation with the constraint \\mathbf{u}_{\\epsilon}(0) = \\mathbf{\\bar{u}}  to end up with \\mathbf{u_{\\epsilon}} = c\\epsilon\\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{\\bar{u}}  where c = 2/(3a - 2b)</p> <p>Kelvinlets of different radial scales can be linearly combined to construct brushes with arbitrarily fast decays:</p> <p>\\mathbf{u}_{\\epsilon_{1},..\\epsilon_{n}}(\\mathbf{r}) = c \\left( \\sum_{i}  \\frac{w_{i}}{\\epsilon_{i}}\\right)^{-1} \\left[\\sum_{i}  w_{i}\\mathbf{K_{\\epsilon_{i}}}(\\mathbf{r})  \\right] \\mathbf{\\bar{u}}</p> <p>where w_{i} are weights and \\epsilon_{i} &lt; \\epsilon_{i+1}.  Due to the superposition principle, these compound brushes still satisfy the Navier-Cauchy equation.</p> <p>Regularized kelvinlets can further be extended by replacing the vector-based load distribution with a matrix-based distribution to achieve non-affine transformations like twist, pinch, and scale as described earlier.</p> <p>In libigl, this is computed using:</p> <p><pre><code>igl::KelvinletParams&lt;double&gt; brushParams{brushRadius, scale, brushType};\nigl::kelvinlets(V, origin, forceVec, forceMatrix, brushParams, result);\n</code></pre> where <code>brushRadius, scale, brushType</code> correspond to \\epsilon, the falloff, and operation(grab, pinch, scale, twist).</p> <p> </p>      (Example 409) pinch, twist, grab and scale in action"},{"location":"tutorial/#chapter-5-parametrization","title":"Chapter 5: Parametrization","text":"<p>In computer graphics, we denote as surface parametrization a map from the surface to \\(\\mathbf{R}^2\\). It is usually encoded by a new set of 2D coordinates for each vertex of the mesh (and possibly also by a new set of faces in one to one correspondence with the faces of the original surface). Note that this definition is the inverse of the classical differential geometry definition.</p> <p>A parametrization has many applications, ranging from texture mapping to surface remeshing. Many algorithms have been proposed, and they can be broadly divided in four families:</p> <ol> <li> <p>Single patch, fixed boundary: these algorithm can parametrize a disk-like part of the surface given fixed 2D positions for its boundary. These algorithms are efficient and simple, but they usually produce high-distortion maps due to the fixed boundary.</p> </li> <li> <p>Single patch, free boundary: these algorithms let the boundary deform freely, greatly reducing the map distortion. Care should be taken to prevent the border from self-intersecting.</p> </li> <li> <p>Global parametrization: these algorithms work on meshes with arbitrary genus. They initially cut the mesh in multiple patches that can be separately parametrized. The generated maps are discontinuous on the cuts (often referred as seams).</p> </li> <li> <p>Global seamless parametrization: these are global parametrization algorithm that hides the seams, making the parametrization \u201ccontinuous\u201d, under specific assumptions that we will discuss later.</p> </li> </ol>"},{"location":"tutorial/#harmonic-parametrization","title":"Harmonic Parametrization","text":"<p>Harmonic parametrization <sup>28</sup> is a single patch, fixed boundary parametrization algorithm that computes the 2D coordinates of the flattened mesh as two harmonic functions.</p> <p>The algorithm is divided in 3 steps:</p> <ol> <li>Detect of the boundary vertices</li> <li>Map the boundary vertices to a circle</li> <li>Compute two harmonic functions (one for u and one for the v coordinate). The harmonic functions use the fixed vertices on the circle as boundary constraints.</li> </ol> <p>The algorithm can be coded using libigl as follows:</p> <pre><code>Eigen::VectorXi bnd;\nigl::boundary_loop(V,F,bnd);\n\nEigen::MatrixXd bnd_uv;\nigl::map_vertices_to_circle(V,bnd,bnd_uv);\n\nigl::harmonic(V,F,bnd,bnd_uv,1,V_uv);\n</code></pre> <p>where <code>bnd</code> contains the indices of the boundary vertices, bnd_uv their position on the UV plane, and \u201c1\u201d denotes that we want to compute an harmonic function (2 will be for biharmonic, 3 for triharmonic, etc.). Note that each of the three functions is designed to be reusable in other parametrization algorithms.</p> <p>A UV parametrization can be visualized in the viewer with:</p> <pre><code>viewer.data().set_uv(V_uv);\n</code></pre> <p>The UV coordinates are then used to apply a procedural checkerboard texture to the mesh (Example 501).</p> <p> </p>      (Example 501) Harmonic parametrization. (left) mesh with texture, (right) UV parametrization with texture"},{"location":"tutorial/#least-squares-conformal-maps","title":"Least Squares Conformal Maps","text":"<p>Least squares conformal maps parametrization <sup>29</sup> minimizes the conformal (angular) distortion of the parametrization. Differently from harmonic parametrization, it does not need to have a fixed boundary.</p> <p>LSCM minimizes the following energy:</p> <p>\\[ E_{LSCM}(\\mathbf{u},\\mathbf{v}) = \\int_X \\frac{1}{2}| \\nabla \\mathbf{u}^{\\perp} - \\nabla \\mathbf{v} |^2 dA \\]</p> <p>which can be rewritten in matrix form as <sup>32</sup>:</p> <p>\\[ E_{LSCM}(\\mathbf{u},\\mathbf{v}) = \\frac{1}{2} [\\mathbf{u},\\mathbf{v}]^t (L_c - 2A) [\\mathbf{u},\\mathbf{v}] \\]</p> <p>where L_c is the cotangent Laplacian matrix and A is a matrix such that [\\mathbf{u},\\mathbf{v}]^t A  [\\mathbf{u},\\mathbf{v}] is equal to the vector area of the mesh.</p> <p>Using libigl, this matrix energy can be written in a few lines of code. The cotangent matrix can be computed using <code>igl::cotmatrix</code>:</p> <pre><code>SparseMatrix&lt;double&gt; L;\nigl::cotmatrix(V,F,L);\n</code></pre> <p>Note that we want to apply the Laplacian matrix to the u and v coordinates at the same time, thus we need to extend it taking the left Kronecker product with a 2x2 identity matrix:</p> <pre><code>SparseMatrix&lt;double&gt; L_flat;\nigl::repdiag(L,2,L_flat);\n</code></pre> <p>The area matrix is computed with <code>igl::vector_area_matrix</code>:</p> <pre><code>SparseMatrix&lt;double&gt; A;\nigl::vector_area_matrix(F,A);\n</code></pre> <p>The final energy matrix is L_{flat} - 2A. Note that in this case we do not need to fix the boundary. To remove the null space of the energy and make the minimum unique, it is sufficient to fix two arbitrary vertices to two arbitrary positions. The full source code is provided in Example 502.</p> <p> </p>      (Example 502) LSCM parametrization. (left) mesh with texture, (right) UV parametrization"},{"location":"tutorial/#as-rigid-as-possible-parametrization","title":"As-rigid-as-possible Parametrization","text":"<p>As-rigid-as-possible parametrization <sup>31</sup> is a powerful single-patch, non-linear algorithm to compute a parametrization that strives to preserve distances (and thus angles). The idea is very similar to ARAP surface deformation: each triangle is mapped to the plane trying to preserve its original shape, up to a rigid rotation.</p> <p>The algorithm can be implemented reusing the functions discussed in the deformation chapter: <code>igl::arap_precomputation</code> and <code>igl::arap_solve</code>. The only difference is that the optimization has to be done in 2D instead of 3D and that we need to compute a starting point. While for 3D deformation the optimization is bootstrapped with the original mesh, this is not the case for ARAP parametrization since the starting point must be a 2D mesh. In Example 503, we initialize the optimization with harmonic parametrization. Similarly to LSCM, the boundary is free to deform to minimize the distortion.</p> <p> </p>      (Example 503) As-Rigid-As-Possible parametrization. (left) mesh with texture, (right) UV parametrization with texture"},{"location":"tutorial/#n-rotationally-symmetric-tangent-fields","title":"N-rotationally Symmetric Tangent Fields","text":"<p>The design of tangent fields is a basic tool used to design guidance fields for uniform quadrilateral and hexahedral remeshing. Libigl contains an implementation of all the state-of-the-art algorithms to design N-RoSy fields and their generalizations.</p> <p>In libigl, tangent unit-length vector fields are piece-wise constant on the faces of a triangle mesh, and they are described by one or more vectors per-face. The function</p> <pre><code>igl::nrosy(V,F,b,bc,b_soft,b_soft_weight,bc_soft,N,0.5,\noutput_field,output_singularities);\n</code></pre> <p>creates a smooth unit-length vector field (N=1) starting from a sparse set of constrained faces, whose indices are listed in b and their constrained value is specified in bc. The functions supports soft_constraints (b_soft, b_soft_weight, bc_soft), and returns the interpolated field for each face of the triangle mesh (output_field), plus the singularities of the field (output_singularities).</p> <p> </p>      Design of a unit-length vector field    <p>The singularities are vertices where the field vanishes (highlighted in red in the figure above). <code>igl::nrosy</code> can also generate N-RoSy fields <sup>30</sup>, which are a generalization of vector fields where in every face the vector is defined up to a constant rotation of 2\\pi / N. As can be observed in the following figure, the singularities of the fields generated with different N are of different types and they appear in different positions.</p> <p> </p>      Design of a 2-,4- and 9-RoSy field    <p>We demonstrate how to call and plot N-RoSy fields in Example 504, where the degree of the field can be change pressing the number keys. <code>igl::nrosy</code> implements the algorithm proposed in <sup>26</sup>. N-RoSy fields can also be interpolated with many other algorithms, see the library libdirectional for a reference implementation of the most popular ones. For a complete categorization of fields used in various applications see Vaxman et al. 2016 <sup>34</sup>.</p>"},{"location":"tutorial/#global-seamless-integer-grid-parametrization","title":"Global, Seamless Integer-grid Parametrization","text":"<p>The previous parametrization methods were focusing on creating parametrizations of surface patches aimed at texture mapping or baking of other surface properties such as normals and high-frequency details. Global, seamless parametrization aims at parametrizing complex shapes with a parametrization that is aligned with a given set of directions for the purpose of surface remeshing. In libigl, we provide a reference  implementation of the pipeline proposed in the mixed integer quadrangulation paper <sup>26</sup>.</p> <p>The first step involves the design of a 4-RoSy field (sometimes called cross field) that describes the alignment of the edges of the desired quadrilateral remeshing. The field constraints are usually manually specified or extracted from the principal curvature directions. In Example 506, we simply fix one face in a random direction.</p> <p> </p>      Initial cross field prescribing the edge alignment."},{"location":"tutorial/#combing-and-cutting","title":"Combing And Cutting","text":"<p>Given the cross field, we now want to cut the surface so that it becomes homeomorphic to a disk. While this could be done directly on the cross-field, we opt to perform this operation on its bisector field (a copy of the field rotated by 45 degrees) since it is more stable and generic. Working on the bisectors allow us to take as input generalized, non-orthogonal and non-unit length cross fields.</p> <p>We thus rotate the field,</p> <p> </p>      Bisector field.    <p>and we remove the rotation ambiguity by assigning to each face a u and a v direction. The assignment is done with a breadth-first search starting from a random face.</p> <p> </p>      Combed bisector field.    <p>You can imagine this process as combing a hairy surface: you will be able to comb part of it, but at some point you will not be able to consistently comb the entire surface (Hairy ball theorem). The discontinuities in the combing define the cut graph:</p> <p> </p>      Cut graph.    <p>Finally, we rotate the combed field by 45 degrees to undo the initial degrees rotation:</p> <p> </p>      Combed cross field.    <p>The combed cross field can be seen as the ideal Jacobian of the parametrization that will be computed in the next section.</p>"},{"location":"tutorial/#poisson-parametrization","title":"Poisson Parametrization","text":"<p>The mesh is cut along the seams and a parametrization is computed trying to find two scalar functions whose gradient matches the combed cross field directions. This is a classical Poisson problem, that is solved minimizing the following quadratic energy:</p> <p>\\[ E(\\mathbf{u},\\mathbf{v}) = |\\nabla \\mathbf{u} - X_u|^2 + |\\nabla \\mathbf{v} - X_v|^2 \\]</p> <p>where X_u and X_u denotes the combed cross field. Solving this problem generates a parametrization whose u and v isolines are aligned with the input cross field.</p> <p> </p>      Poisson parametrization.    <p>We hide the seams by adding integer constraints to the Poisson problem that align the isolines on both sides of each seam <sup>26</sup>.</p> <p> </p>      Seamless Poisson parametrization.    <p>Note that this parametrization can only be used for remeshing purposes, since it contains many overlaps.</p> <p> </p>      Seamless Poisson parametrization (in 2D).    <p>A quad mesh can be extracted from this parametrization using libQEx (not included in libigl). The full pipeline is implemented in Example 505.</p>"},{"location":"tutorial/#anisotropic-remeshing","title":"Anisotropic Remeshing","text":"<p>Anisotropic and non-uniform quad remeshing is important to concentrate the elements in the regions with more details. It is possible to extend the MIQ quad meshing framework to generate anisotropic quad meshes using a mesh deformation approach <sup>33</sup>.</p> <p>The input of the anisotropic remeshing algorithm is a sparse set of constraints that define the shape and scale of the desired quads. This can be encoded as a frame field, which is a pair of non-orthogonal and non-unit length vectors. The frame field can be interpolated by decomposing it in a 4-RoSy field and a unique affine transformation. The two parts can then be interpolated separately, using <code>igl::nrosy</code> for the cross field, and an harmonic interpolant for the affine part.</p> <p> </p>      Interpolation of a frame field. Colors on the vectors denote the desired scale. The red faces contains the frame field constraints.    <p>After the interpolation, the surface is warped to transform each frame into an orthogonal and unit length cross (i.e. removing the scaling and skewness from the frame). This deformation defines a new embedding (and a new metric) for the surface.</p> <p> </p>      The surface is deformed to transform the frame field in a cross field.    <p>The deformed surface can the be isotropically remeshed using the MIQ algorithm that has been presented in the previous section.</p> <p> </p>      The deformed surface is isotropically remeshed.    <p>The UV coordinates of the deformed surface can then be used to transport the parametrization to the original surface, where the isolines will trace a quad mesh whose elements are similar to the shape prescribed in the input frame field.</p> <p> </p>      The global parametrization is lifted to the original surface to create the anisotropic quad meshing.    <p>Our implementation (Example 506) uses MIQ to generate the UV parametrization, but other algorithms could be applied: the only desiderata is that the generated quad mesh should be as isotropic as possible.</p>"},{"location":"tutorial/#planarization","title":"Planarization","text":"<p>A quad mesh can be transformed in a planar quad mesh with Shape-Up <sup>27</sup>, a local/global approach that uses the global step to enforce surface continuity and the local step to enforce planarity.</p> <p>Example 507 planarizes a quad mesh until it satisfies a user-given planarity threshold.</p> <p> </p>      A non-planar quad mesh (left) is planarized using the libigl function igl::planarize (right). The colors represent the planarity of the quads."},{"location":"tutorial/#chapter-6-external-libraries","title":"Chapter 6: External Libraries","text":"<p>An additional positive side effect of using matrices as basic types is that it is easy to exchange data between libigl and other software and libraries.</p>"},{"location":"tutorial/#state-serialization","title":"State Serialization","text":"<p>Geometry processing applications often require a considerable amount of computational time and/or manual input. Serializing the state of the application is a simple strategy to greatly increase the development efficiency. It allows to quickly start debugging just before the crash happens, avoiding to wait for the precomputation to take place every time and it also makes your experiments reproducible, allowing to quickly test algorithms variants on the same input data.</p> <p>Serialization is often not considered in geometry processing due to the extreme difficulty in serializing pointer-based data structures, such as an half-edge data structure (OpenMesh, CGAL), or a pointer based indexed structure (VCG).</p> <p>In libigl, serialization is much simpler, since the majority of the functions use basic types, and pointers are used in very rare cases (usually to interface with external libraries). Libigl bundles a simple and self-contained binary and XML serialization framework, that drastically reduces the overhead required to add serialization to your applications.</p> <p>To de-/serialize a set of variables use the following method:</p> <pre><code>#include \"igl/serialize.h\"\n\nbool b = true;\nunsigned int num = 10;\nstd::vector&lt;float&gt; vec = {0.1,0.002,5.3};\n\n// use overwrite = true for the first serialization to create or overwrite an\n// existing file\nigl::serialize(b,\"B\",\"filename\",true);\n// append following serialization to existing file\nigl::serialize(num,\"Number\",\"filename\");\nigl::serialize(vec,\"VectorName\",\"filename\");\n\n// deserialize back to variables\nigl::deserialize(b,\"B\",\"filename\");\nigl::deserialize(num,\"Number\",\"filename\");\nigl::deserialize(vec,\"VectorName\",\"filename\");\n</code></pre> <p>Currently all fundamental data types (bool, int, float, double, \u2026) are supported, as well as std::string, basic <code>STL</code> containers, dense and sparse Eigen matrices and nestings of those.  Some limitations apply to pointers. Currently, loops or many to one type of link structures are not handled correctly. Each pointer is assumed to point to a different independent object. Uninitialized pointers must be set to <code>nullptr</code> before de-/serialization to avoid memory leaks. Cross-platform issues like little-, big-endianess is currently not supported.  To make user defined types serializable, just derive from <code>igl::Serializable</code> and trivially implementing the <code>InitSerialization</code> method.</p> <p>Assume that the state of your application is a mesh and a set of integer ids:</p> <pre><code>#include \"igl/serialize.h\"\n\nstruct State : public igl::Serializable\n{\nEigen::MatrixXd V;\nEigen::MatrixXi F;\nstd::vector&lt;int&gt; ids;\n\nvoid InitSerialization()\n{\nthis-&gt;Add(V  , \"V\");\nthis-&gt;Add(F  , \"F\");\nthis-&gt;Add(ids, \"ids\");\n}\n};\n</code></pre> <p>If you need more control over the serialization of your types, you can override the following functions or directly inherit from the interface <code>igl::SerializableBase</code>.</p> <pre><code>bool Serializable::PreSerialization() const;\nvoid Serializable::PostSerialization() const;\nbool Serializable::PreDeserialization();\nvoid Serializable::PostDeserialization();\n</code></pre> <p>Alternatively, if you want a non-intrusive way of serializing your state you can overload the following functions:</p> <pre><code>namespace igl\n{\nnamespace serialization\n{\ntemplate &lt;&gt; inline void serialize(const State&amp; obj,std::vector&lt;char&gt;&amp; buffer)\n{\n::igl::serialize(obj.V,std::string(\"V\"),buffer);\n::igl::serialize(obj.F,std::string(\"F\"),buffer);\n::igl::serialize(obj.ids,std::string(\"ids\"),buffer);\n}\ntemplate &lt;&gt; inline void deserialize(State&amp; obj,const std::vector&lt;char&gt;&amp; buffer)\n{\n::igl::deserialize(obj.V,std::string(\"V\"),buffer);\n::igl::deserialize(obj.F,std::string(\"F\"),buffer);\n::igl::deserialize(obj.ids,std::string(\"ids\"),buffer);\n}\n}\n}\n</code></pre> <p>Equivalently, you can use the following macros:</p> <pre><code>SERIALIZE_TYPE(State,\nSERIALIZE_MEMBER(V)\nSERIALIZE_MEMBER(F)\nSERIALIZE_MEMBER_NAME(ids,\"ids\")\n)\n</code></pre> <p>All the former code is for binary serialization which is especially useful if you have to handle larger data where the loading and saving times become more important.  For cases where you want to read and edit the serialized data by hand we provide a serialization to XML files which is based on the library tinyxml2.  There you also have the option to create a partial binary serialization of your data by using the binary parameter, exposed in the function <code>serialize_xml()</code>:</p> <pre><code>#include \"igl/xml/serialize_xml.h\"\n\nint number;\n\n// binary = false, overwrite = true\nigl::serialize_xml(vec,\"VectorXML\",xmlFile,false,true);\n// binary = true, overwrite = true\nigl::serialize_xml(vec,\"VectorBin\",xmlFile,true,true);\nigl::deserialize_xml(vec,\"VectorXML\",xmlFile);\nigl::deserialize_xml(vec,\"VectorBin\",xmlFile);\n</code></pre> <p>For user defined types derive from <code>XMLSerializable</code>.</p> <p>The code snippets above are extracted from Example 601. We strongly suggest that you make the entire state of your application always serializable since it will save you a lot of troubles when you will be preparing figures for a scientific report. It is very common to have to do small changes to figures, and being able to serialize the entire state just before you take screenshots will save you many painful hours before a submission deadline.</p>"},{"location":"tutorial/#mixing-matlab-code","title":"Mixing Matlab Code","text":"<p>Libigl can be interfaced with Matlab to offload numerically heavy computation to a Matlab script. The major advantage of this approach is that you will be able to develop efficient and complex user-interfaces in C++, while exploring the syntax and fast protototyping features of matlab. In particular, the use of an external Matlab script in a libigl application allows to change the Matlab code while the C++ application is running, greatly increasing coding efficiency.</p> <p>We demonstrate how to integrate Matlab in a libigl application in Example 602. The example uses Matlab to compute the Eigenfunctions of the discrete Laplacian operator, relying on libigl for mesh IO, visualization and for computing the Laplacian operator.</p> <p>Libigl can connect to an existing instance of Matlab (or launching a new one on Linux/MacOSX) using:</p> <pre><code>igl::mlinit(&amp;engine);\n</code></pre> <p>The cotangent Laplacian is computed using igl::cotmatrix and uploaded to the Matlab workspace:</p> <pre><code>igl::cotmatrix(V,F,L);\nigl::mlsetmatrix(&amp;engine,\"L\",L);\n</code></pre> <p>It is now possible to use any Matlab function on the data. For example, we can see the sparsity pattern of L using spy:</p> <pre><code>igl::mleval(&amp;engine,\"spy(L)\");\n</code></pre> <p> </p>      The Matlab spy function is called from a libigl-based application.    <p>The results of Matlab computations can be returned back to the C++ application</p> <pre><code>igl::mleval(&amp;engine,\"[EV,~] = eigs(-L,10,'sm')\");\nigl::mlgetmatrix(&amp;engine,\"EV\",EV);\n</code></pre> <p>and plotted using the libigl viewer.</p> <p> </p>      Eigenfunctions of the Laplacian computed in Matlab, plotted in the libigl viewer."},{"location":"tutorial/#saving-a-matlab-workspace","title":"Saving A Matlab Workspace","text":"<p>To aid debugging, libigl also supplies functions to write Matlab <code>.mat</code> \u201cWorkspaces\u201d. This C++ snippet saves a mesh and it\u2019s sparse Laplacian matrix to a file:</p> <pre><code>igl::readOFF(TUTORIAL_SHARED_PATH \"/fertility.off\", V, F);\nigl::cotmatrix(V,F,L);\nigl::MatlabWorkspace mw;\nmw.save(V,\"V\");\nmw.save_index(F,\"F\");\nmw.save(L,\"L\");\nmw.write(\"fertility.mat\");\n</code></pre> <p>Then this workspace can be loaded into a Matlab IDE:</p> <pre><code>load fertility.mat\n</code></pre> <p>The <code>igl::MatlabWorkspace</code> depends on Matlab libraries to compile and run, but\u2014in contrast to the engine routines above\u2014will avoid launching a Matlab instance upon execution.</p>"},{"location":"tutorial/#dumping-eigen-matrices-to-copy-and-paste-into-matlab","title":"Dumping Eigen Matrices To Copy And Paste Into Matlab","text":"<p>Eigen supplies a sophisticated API for printing its matrix types to the screen. Libigl has wrapped up a particularly useful formatting which makes it simple to copy standard output from a C++ program into a Matlab IDE. The code:</p> <pre><code>igl::readOFF(TUTORIAL_SHARED_PATH \"/2triangles.off\", V, F);\nigl::cotmatrix(V,F,L);\nstd::cout&lt;&lt;igl::matlab_format(V,\"V\")&lt;&lt;std::endl;\nstd::cout&lt;&lt;igl::matlab_format((F.array()+1).eval(),\"F\")&lt;&lt;std::endl;\nstd::cout&lt;&lt;igl::matlab_format(L,\"L\")&lt;&lt;std::endl;\n</code></pre> <p>produces the output:</p> <pre><code>V = [\n0 0 0\n1 0 0\n1 1 1\n2 1 0\n];\nF = [\n1 2 3\n2 4 3\n];\nLIJV = [\n1  1    -0.7071067811865476\n2  1     0.7071067811865475\n3  1  1.570092458683775e-16\n1  2     0.7071067811865475\n2  2     -1.638010440969447\n3  2     0.6422285251880865\n4  2     0.2886751345948129\n1  3  1.570092458683775e-16\n2  3     0.6422285251880865\n3  3    -0.9309036597828995\n4  3     0.2886751345948129\n2  4     0.2886751345948129\n3  4     0.2886751345948129\n4  4    -0.5773502691896258\n];\nL = sparse(LIJV(:,1),LIJV(:,2),LIJV(:,3));\n</code></pre> <p>which is easily copied and pasted into Matlab for debugging, etc.</p>"},{"location":"tutorial/#calling-libigl-functions-from-matlab","title":"Calling Libigl Functions From Matlab","text":"<p>It is also possible to call libigl functions from matlab, compiling them as MEX functions. This can be used to offload to C++ code the computationally intensive parts of a Matlab application.</p> <p>We provide a wrapper for <code>igl::readOBJ</code> in Example 603. We plan to provide wrappers for all our functions in the future, if you are interested in this feature (or if you want to help implementing it) please let us know.</p>"},{"location":"tutorial/#triangulation-of-closed-polygons","title":"Triangulation Of Closed Polygons","text":"<p>The generation of high-quality triangle and tetrahedral meshes is a very common task in geometry processing. We provide wrappers in libigl to triangle and Tetgen.</p> <p>A triangle mesh with a given boundary can be created with:</p> <pre><code>igl::triangulate(V,E,H,V2,F2,\"a0.005q\");\n</code></pre> <p>where <code>E</code> is a set of boundary edges (#E by 2), <code>H</code> is a set of 2D positions of points contained in holes of the triangulation (#H by 2) and (<code>V2</code>,<code>F2</code>) is the generated triangulation. Additional parameters can be passed to <code>triangle</code>, to control the quality: <code>\"a0.005q\"</code> enforces a bound on the maximal area of the triangles and a minimal angle of 20 degrees. In Example 604, the interior of a square (excluded a smaller square in its interior) is triangulated.</p> <p> </p>      Triangulation of the interior of a polygon."},{"location":"tutorial/#tetrahedralization-of-closed-surfaces","title":"Tetrahedralization Of Closed Surfaces","text":"<p>Similarly, the interior of a closed manifold surface can be tetrahedralized using the function <code>igl::tetrahedralize</code> which wraps the Tetgen library (Example 605):</p> <pre><code>igl::tetrahedralize(V,F,\"pq1.414\", TV,TT,TF);\n</code></pre> <p> </p>      Tetrahedralization of the interior of a surface mesh."},{"location":"tutorial/#baking-ambient-occlusion","title":"Baking Ambient Occlusion","text":"<p>Ambient occlusion is a rendering technique used to calculate the exposure of each point in a surface to ambient lighting. It is usually encoded as a scalar (normalized between 0 and 1) associated with the vertice of a mesh.</p> <p>Formally, ambient occlusion is defined as:</p> <p>\\[ A_p = \\frac{1}{\\pi} \\int_\\omega V_{p,\\omega}(n \\cdot \\omega) d\\omega \\]</p> <p>where V_{p,\\omega} is the visibility function at  p, defined to be zero if p is occluded in the direction \\omega and one otherwise, and d\\omega is the infinitesimal solid angle step of the integration variable \\omega.</p> <p>The integral is usually approximated by casting rays in random directions around each vertex. This approximation can be computed using the function:</p> <pre><code>igl::ambient_occlusion(V,F,V_samples,N_samples,500,AO);\n</code></pre> <p>that given a scene described in <code>V</code> and <code>F</code>, computes the ambient occlusion of the points in <code>V_samples</code> whose associated normals are <code>N_samples</code>. The number of casted rays can be controlled (usually at least 300-500 rays are required to get a smooth result) and the result is returned in <code>AO</code>, as a single scalar for each sample.</p> <p>Ambient occlusion can be used to darken the surface colors, as shown in Example 606</p> <p> </p>      A mesh rendered without (left) and with (right) ambient occlusion."},{"location":"tutorial/#screen-capture","title":"Screen Capture","text":"<p>Libigl supports read and writing to .png files via the stb image code.</p> <p>With the viewer used in this tutorial, it is possible to render the scene in a memory buffer using the function, <code>igl::opengl::ViewerCore::draw_buffer</code>:</p> <pre><code>// Allocate temporary buffers for 1280x800 image\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; R(1280,800);\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; G(1280,800);\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; B(1280,800);\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; A(1280,800);\n\n// Draw the scene in the buffers\nviewer.core.draw_buffer(viewer.data(),false,R,G,B,A);\n\n// Save it to a PNG\nigl::png::writePNG(R,G,B,A,\"out.png\");\n</code></pre> <p>In Example 607 a scene is rendered in a temporary png and used to texture a quadrilateral.</p>"},{"location":"tutorial/#off-screen-rendering-using-ray-tracing-with-embree","title":"Off-screen rendering using ray tracing with Embree","text":"<p>If libigl is compiled without OpenGL support, or when the interactive viewer is not practical, it is still possible to render view in memory using Embree library. Currently only triangular meshes are supported. The usage is very similar to the Screen Capture tutorial.</p> <pre><code>// Create embree renderer object\nigl::embree::EmbreeRenderer er;\n// Specify mesh, tell embree to optimize for static scene\ner.set_mesh(V,F,true);\n\n// Specify scalar data, use JET color map to convert to colors\ner.set_data(K,igl::COLOR_MAP_TYPE_JET);\n\n// Since the render is not interactive, need to specify scene parameters\n// the default view is identical to the interactive viewer\nEigen::Matrix3d rot_matrix;\n\n// Specify rotation matrix:\n//     10 degrees around X axis\n//      5 degrees around Y axis\n//      4 degrees around Z axis\nrot_matrix =  Eigen::AngleAxisd( 10*igl::PI/180.0, Eigen::Vector3d::UnitX())\n* Eigen::AngleAxisd(  5*igl::PI/180.0, Eigen::Vector3d::UnitY())\n* Eigen::AngleAxisd(  4*igl::PI/180.0, Eigen::Vector3d::UnitZ());\ner.set_rot(rot_matrix);\n\n// Specify relative zoom factor\ner.set_zoom(1.5);\n// Request orthographic projection\ner.set_orthographic(false);\n\n// Allocate temporary buffers for 1280x800 image\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; R(1280,800);\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; G(1280,800);\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; B(1280,800);\nEigen::Matrix&lt;unsigned char,Eigen::Dynamic,Eigen::Dynamic&gt; A(1280,800);\n\n// Render view\ner.render_buffer(R,G,B,A);\n\n// Save it to a PNG\nigl::png::writePNG(R,G,B,A,png_file);\n</code></pre> <p> </p>      Fertility statue showing curvature as scalar field, rendered with embree    <p>In Example 608 a scene is rendered in a memory buffer and saved as png file.</p>"},{"location":"tutorial/#boolean-operations-on-meshes","title":"Boolean Operations On Meshes","text":"<p>Constructive solid geometry (CSG) is a technique to define a complex surface as the result of a number of set operations on solid regions of space: union, intersection, set difference, symmetric difference, complement. Typically, CSG libraries represent the inputs and outputs to these operations implicitly: the solid A is defined as the open set of points \\mathbf{x} for which some function a(\\mathbf{x}) \u201creturns true\u201d. The surface of this shape is the closure of all points x in A.</p> <p>With this sort of representation, boolean operations are straightforward. For example, the union of solids A and B is simply</p> <p>A \\cup B = \\{\\mathbf{x} \\left.\\right|   a(\\mathbf{x}) \\text{ or } b(\\mathbf{x})\\},</p> <p>the intersection is</p> <p>A \\cap B = \\{\\mathbf{x} \\left.\\right|   a(\\mathbf{x}) \\text{ and } b(\\mathbf{x})\\},</p> <p>the difference A minus B is</p> <p>A \\setminus B = \\{\\mathbf{x} \\left.\\right|   a(\\mathbf{x}) \\text{ and _not_ } b(\\mathbf{x})\\},</p> <p>and the symmetric difference (XOR) is</p> <p>A \\triangle B = \\{\\mathbf{x} \\left.\\right|   \\text{either } a(\\mathbf{x}) \\text{ or } b(\\mathbf{x}) \\text{ but not both }\\}.</p> <p>Stringing together many of these operations, one can design quite complex shapes. A typical CSG library might only keep explicit base-case representations of canonical shapes: half-spaces, quadrics, etc.</p> <p>In libigl, we currently do not have an implicit surface representation. Instead we expect our users to be working with explicit triangle mesh boundary representations of solid shapes. CSG operations are much hard to compute robustly with boundary representations, but are nonetheless useful.</p> <p>To compute a boolean operation on a triangle mesh with vertices <code>VA</code> and triangles <code>FA</code> and another mesh <code>VB</code> and <code>FB</code>, libigl first computes a unified \u201cmesh arrangement\u201d (see <sup>36</sup>[]) with vertices <code>V</code> and triangles <code>F</code> where all triangle-triangle intersections have been \u201cresolved\u201d. That is, edges and vertices are added exactly at the intersection lines, so the resulting non-manifold mesh <code>(V,F)</code> has no self-intersections.</p> <p>Then libigl labels each \u201ccell\u201d bounded by surfaces of the arrangement according to its winding number vector: winding number with respect to each input mesh (w_A,w_B). Finally, according to the desired operation (e.g. union, intersection) the boundary of the corresponding cells are extracted.</p> <p>Calling libigl\u2019s boolean operations is simple. To compute the union of <code>(VA,FA)</code> and <code>(VB,FB)</code> into a new mesh <code>(VC,FC)</code>, use:</p> <pre><code>igl::copyleft::cgal::mesh_boolean(VA,FA,VB,FB,MESH_BOOLEAN_TYPE_UNION,VC,FC);\n</code></pre> <p>The following figure shows each boolean operation on two meshes.</p> <p> </p>      The example Boolean conducts boolean operations on the Cheburashka (red) and Knight (green). From left to right: union, intersection, set minus, symmetric difference (XOR), \u201cresolve\u201d. Bottom row reveals inner surfaces, darker color indicates back-facing triangles.    <p>The union, symmetric difference and \u201cresolve\u201d have the same outward appearance, but differ in their treatment of internal structures. The union has no internal surfaces: the triangles are not included in the output. The symmetric difference is the same set of triangles as the \u201cresolve\u201d, but internal surfaces have been reversed in orientation, indicating that the solid result of the operation. The \u201cresolve\u201d operation is not really a boolean operation, it is simply the result of resolving all intersections and gluing together coincident vertices, maintaining original triangle orientations.</p> <p>Libigl also provides a wrapper <code>igl::copyleft::cork::mesh_boolean</code> to the cork, which is typically faster, but is not always robust.</p>"},{"location":"tutorial/#csg-tree","title":"Csg Tree","text":"<p>The previous section discusses using <code>igl::copyleft::cgal::mesh_boolean</code> to compute the result of a single boolean operation on two input triangle meshes. When employing constructive solid geometry (CSG) as a modeling paradigm, shapes are represented as the result of many such binary operations. The sequence is stored in a binary tree.</p> <p>Libigl uses exact arithmetic internally to construct the intermediary boolean results robustly. \u201cRounding\u201d this result to floating point (even double precision) would cause problems if re-injected into a further boolean operation. To facilitate CSG tree operations and encourage callers not to call <code>igl::copyleft::cgal::mesh_boolean</code> multiple times explicitly, libigl implements a class <code>igl::copyleft::cgal::CSGTree</code>. Leaf nodes of this class are simply \u201csolid\u201d meshes (otherwise good input to <code>igl::copyleft::cgal::mesh_boolean</code>). Interior nodes of the tree combine two children with a boolean operation. Using the intializer list constructor it is easy to hard-code specific tree constructions. Here\u2019s an example taking the intersection of a cube A and sphere B minus the union of three cylinders:</p> <pre><code>// Compute result of (A \u2229 B) \\ ((C \u222a D) \u222a E)\nigl::copyleft::cgal::CSGTree&lt;MatrixXi&gt; CSGTree =\n{ { {VA,FA},{VB,FB},\"i\"},{ { {VC,FC},{VD,FD},\"u\"}, {VE,FE},\"u\"},\"m\"};\n</code></pre> <p> </p>      A CSG Tree represents a shape as a combination of binary boolean operations    <p>Example 610 computes each intermediary CSG result and then the final composite.</p> <p> </p>      Example 610 computes  complex CSG Tree operation on 5 input meshes."},{"location":"tutorial/#chapter-7-miscellaneous","title":"Chapter 7: Miscellaneous","text":"<p>Libigl contains a wide variety of geometry processing tools and functions for dealing with meshes and the linear algebra related to them: far too many to discuss in this introductory tutorial. We\u2019ve pulled out a couple of the interesting functions in this chapter to highlight.</p>"},{"location":"tutorial/#mesh-statistics","title":"Mesh Statistics","text":"<p>Libigl contains various mesh statistics, including face angles, face areas and the detection of singular vertices, which are vertices with more or less than 6 neighbours in triangulations or 4 in quadrangulations.</p> <p>The example Statistics computes these quantities and does a basic statistic analysis that allows to estimate the isometry and regularity of a mesh:</p> <pre><code>Irregular vertices:\n136/2400 (5.67%)\nAreas (Min/Max)/Avg_Area Sigma:\n0.01/5.33 (0.87)\nAngles in degrees (Min/Max) Sigma:\n17.21/171.79 (15.36)\n</code></pre> <p>The first row contains the number and percentage of irregular vertices, which is particularly important for quadrilateral meshes when they are used to define subdivision surfaces: every singular point will result in a point of the surface that is only C^1.</p> <p>The second row reports the area of the minimal element, maximal element and the standard deviation.  These numbers are normalized by the mean area, so in the example above 5.33 max area means that the biggest face is 5 times larger than the average face. An ideal isotropic mesh would have both min and max area close to 1.</p> <p>The third row measures the face angles, which should be close to 60 degrees (90 for quads) in a perfectly regular triangulation. For FEM purposes, the closer the angles are to 60 degrees the more stable will the optimization be. In this case, it is clear that the mesh is of bad quality and it will probably result in artifacts if used for solving PDEs.</p>"},{"location":"tutorial/#generalized-winding-number","title":"Generalized Winding Number","text":"<p>The problem of tetrahedralizing the interior of closed watertight surface mesh is a difficult, but well-posed problem (see our Tetgen wrappers).  But black-box tet-meshers like TetGen will refuse input triangle meshes with self-intersections, open boundaries, non-manifold edges from multiple connected components. The problem is two-fold: self-intersections present contradictory facet constraints and self-intersections/open-boundaries/non-manifold edges make the problem of determining inside from outside ill-posed without further assumptions.</p> <p>The first problem is easily solved by \u201cresolving\u201d all self-intersections. That is, meshing intersecting triangles so that intersects occur exactly at edges and vertices. This is accomplished using <code>igl::selfintersect</code>.</p> <p>TetGen can usually tetrahedralize the convex hull of this \u201cresolved\u201d mesh, and then the problem becomes determining which of these tets are inside the input mesh and which are outside. That is, which should be kept and which should be removed.</p> <p>The \u201cGeneralized Winding Number\u201d is a robust method for determined inside and outside for troublesome meshes <sup>40</sup>.  The generalized winding number with respect to <code>(V,F)</code> at some point \\mathbf{p} \\in \\mathcal{R}^3 is defined as scalar function:</p>   w(\\mathbf{p}) = \\sum\\limits_{f_i\\in F} \\frac{1}{4\\pi}\\Omega_{f_i}(\\mathbf{p})  <p>where \\Omega_{f_i} is the solid angle subtended by f_i (the ith face in <code>F</code>) at the point \\mathbf{p}. This solid angle contribution is a simple, closed-form expression involving <code>atan2</code> and some dot-products.</p> <p>If <code>(V,F)</code> does form a closed watertight surface, then w(\\mathbf{p})=1 if \\mathbf{p} lies inside <code>(V,F)</code> and w(\\mathbf{p})=0 if outside <code>(V,F)</code>.  If <code>(V,F)</code> is closed but overlaps itself then w(\\mathbf{p}) is an integer value counting how many (signed) times <code>(V,F)</code> wraps around \\mathbf{p}.  Finally, if <code>(V,F)</code> is not closed or not even manifold (but at least consistently oriented), then w(\\mathbf{p}) tends smoothly toward 1 as \\mathbf{p} is more inside <code>(V,F)</code>, and toward 0 as \\mathbf{p} is more outside.</p> <p> </p>      Example 702 computes the generalized winding number function for a tetrahedral mesh inside a cat with holes and self intersections (gold). The silver mesh is surface of the extracted interior tets, and slices show the winding number function on all tets in the convex hull: blue (~0), green (~1), yellow (~2)."},{"location":"tutorial/#mesh-decimation","title":"Mesh Decimation","text":"<p>The study of mesh simplification or decimation is nearly as old as meshes themselves. Given a high resolution mesh with too many triangles, find a \u201cwell approximating\u201d low resolution mesh with far fewer triangles. By now there are a variety of different paradigms for solving this problem and state-of-the-art methods are fairly advanced.</p> <p>One family of mesh decimation methods operates by successively remove elements from the mesh. In particular, Hoppe advocates for successively remove or rather collapsing edges <sup>39</sup>[]. The generic form of this technique is to construct a sequence of n meshes from the initial high-resolution mesh M_0 to the lowest resolution mesh M_n by collapsing a single edge:</p> <p>M_0 \\mathop{\\longrightarrow}_\\text{edge collapse}   M_1 \\mathop{\\longrightarrow}_\\text{edge collapse}   \\dots \\mathop{\\longrightarrow}_\\text{edge collapse}   M_{n-1} \\mathop{\\longrightarrow}_\\text{edge collapse} M_n.</p> <p>Hoppe\u2019s original method and subsequent follow-up works propose various ways to choose the next edge to collapse in this sequence. Using a cost-based paradigm, one can maintain a priority queue of edges based on their \u201ccost\u201d (how much \u201cworse\u201d will my approximation be if I remove this edge?). The cheapest edge is collapsed and costs of neighboring edges are updated.</p> <p>In order to maintain the topology (e.g. if the mesh is combinatorially as sphere or a torus etc.), one should assign infinite cost to edges whose collapse would alter the mesh topology. Indeed this happens if and only if the number of mutual neighbors of the endpoints of the collapsing edge is not exactly two!</p> <p>If there exists a third shared vertex, then another face will be removed, but 2 edges will be removed. This can result in unwanted holes or non-manifold \u201cflaps\u201d.</p> <p> </p>      A valid edge collapse and an invalid edge collapse.    <p>There is also a one-off condition that no edges of a tetrahedron should be collapsed.</p> <p>Because libigl (purposefully) does not center its implementations around a dynamic mesh data structure (e.g. half-edge datastructure), support for topology changes are limited. Nonetheless, libigl has support for isolated edge collapses, sequences of edge-collapses (each in O(log) time) and priority queue based decimation.</p> <p>The simplest is <code>igl::decimation</code>. By calling</p> <pre><code>igl::decimate(V,F,1000,U,G);\n</code></pre> <p>the mesh <code>(V,F)</code> will be decimated to a new mesh <code>(U,G)</code> so that <code>G</code> has at most <code>1000</code> faces. This uses default (naive) criteria for determining the cost of an edge collapse and the placement of the merged vertex. Shortest edges are collapsed first, and merged vertices are placed at edge midpoints.</p> <p>One can also provide function handles (<code>c++</code> lambda functions are convenient here) <code>cost_and_placement</code> and <code>stopping_condition</code> for determining the cost/placement of an edge collapse and the stopping condition respectively. For example, the default version above is implemented as:</p> <pre><code>igl::decimate(V,F,shortest_edge_and_midpoint,max_m,U,G);\n</code></pre> <p>where <code>shortest_edge_and_midpoint</code> assign the edge\u2019s length as cost and its midpoint as the merged vertex placement and <code>max_m</code> counts the current number of faces (valid collapses decrease count by 2) and returns <code>true</code> if the count drops below <code>m=1000</code>.</p> <p>One can also scratch deeper inside the decimation loop and call <code>igl::collapse_edge</code> directly. In order to operate efficiently, this routine needs more than the usual <code>(V,F)</code> mesh representation. We need <code>E</code> a list of edge indices, where <code>E.row(i) --&gt; [s,d]</code>; we need <code>EMAP</code> which maps the \u201chalf\u201d-edges of each triangle in <code>F</code> to its corresponding edge in <code>E</code> so that <code>E.row(EMAP(f+i*F.rows)) --&gt; [s,d]</code> if the edge across from the ith corner of the fth face is <code>[s,d]</code> (up to orientation); we need <code>EF</code> and <code>EI</code> which keep track of the faces incident on each edge and across from which corner of those faces the edges appears, so that <code>EF(e,o) = f</code> and <code>EI(e,o) = i</code> means that the edge <code>E.row(e) --&gt; [s,d]</code> appears in the fth face across from its ith corner (for <code>o=0</code> the edge orientations should match, for <code>o=1</code> the orientations are opposite).</p> <p>When a collapse occurs, the sizes of the <code>F</code>,<code>E</code>, etc. matrices do not change. Rather rows corresponding to \u201cremoved\u201d faces and edges are set to a special constant value <code>IGL_COLLAPSE_EDGE_NULL</code>. Doing this ensures that we\u2019re able to remove edges in truly constant time O(1).</p> <p>Conveniently <code>IGL_COLLAPSE_EDGE_NULL==0</code>. This means most OPENGL style renderings of <code>F</code> will simply draw a bunch of 0-area triangles at the first vertex.</p> <p>The following will collapse the first edge and place its merged vertex at the origin:</p> <p><pre><code>igl::collapse_edge(0,RowVector3d(0,0,0),V,F,E,EMAP,EF,EI);\n</code></pre> If valid, then <code>V</code>,<code>F</code>,<code>E</code>,<code>EF</code>,<code>EI</code> are adjusted accordingly.</p> <p>This is powerful, but low level. To build a decimator around this you\u2019d need to keep track which edges are left to collapse and which to collapse next. Fortunately, libigl also exposes a priority queue based edge collapse with function handles to adjust costs and placements.</p> <p>The priority queue is implemented as a (ordered) set <code>Q</code> or (cost,edge index) pairs and a list of iterators <code>Qit</code> so that <code>Qit[e]</code> reveals the iterator in <code>Q</code> corresponding to the eth edge. Placements are stored in a #E list of positions <code>C</code>. When the following is called:</p> <pre><code>igl::collapse_edge(cost_and_placement,V,F,E,EMAP,EF,EI,Q,Qit,C);\n</code></pre> <p>the lowest cost edge collapse according to <code>Q</code> is attempted. If valid, then <code>V</code>,<code>F</code>,etc. are adjusted accordingly and that edge is \u201cpopped\u201d from <code>Q</code>. Using <code>Qit</code> its neighboring edges are also popped from <code>Q</code> and re-inserted after updating their costs according to <code>cost_and_placement</code>, new placements are remembered in <code>C</code>. If not valid, then the edge is \u201cpopped\u201d from <code>Q</code> and reinserted with infinite cost.</p> <p> </p>      Example 703 conducts edge collapses on the fertility model.    <p>The Example 703 demonstrates using this priority queue based approach with the simple shortest-edge-midpoint cost/placement strategy discussed above.</p>"},{"location":"tutorial/#signed-distances","title":"Signed Distances","text":"<p>In the Generalized Winding Number section, we examined a robust method for determining whether points lie inside or outside of a given triangle soup mesh. Libigl complements this algorithm with accelerated signed and unsigned distance queries and \u201cin element\u201d queries for planar triangle meshes and 3D tetrahedral meshes. These routines make use of libigl\u2019s general purpose axis-aligned bounding box hierarchy (<code>igl/AABB.h</code>). This class is lightweight and\u2014by design\u2014does not store a copy of the mesh (taking it as inputs to its member functions instead).</p>"},{"location":"tutorial/#point-location","title":"Point Location","text":"<p>For tetrahedral meshes, this is useful for \u201cin element\u201d or \u201cpoint location\u201d queries: given a point \\mathbf{q}\\in\\mathcal{R}^3 and a tetrahedral mesh (V,T) determine in which tetrahedron \\mathbf{q} lies. This is accomplished in libigl for a tet mesh <code>V,T</code> and a list of query points in the rows of <code>Q</code> via the <code>igl::in_element()</code>:</p> <pre><code>// Initialize AABB tree\nigl::AABB&lt;MatrixXd,3&gt; tree;\ntree.init(V,T);\nVectorXi I;\nigl::in_element(V,T,Q,tree,I);\n</code></pre> <p>the resulting vector <code>I</code> is a list of indices into <code>T</code> revealing the first tetrahedron found to contain the corresponding point in <code>Q</code>.</p> <p>For overlapping meshes, a point \\mathbf{q} may belong to more than one tetrahedron. In those cases, one can find them all (not just the first) by using the <code>igl::in_element</code> overload with a <code>SparseMatrix</code> as the output:</p> <pre><code>SparseMatrix&lt;int&gt; I;\nigl::in_element(V,T,Q,tree,I);\n</code></pre> <p>now each row of <code>I</code> reveals whether each tet contains the corresponding row in <code>Q</code>: <code>I(q,e)!=0</code> means that point <code>q</code> is in element <code>e</code>.</p>"},{"location":"tutorial/#closest-points","title":"Closest Points","text":"<p>For Triangle meshes, we use the AABB tree to accelerate point-mesh closest point queries: given a mesh (V,F) and a query point \\mathbf{q}\\in\\mathcal{R}^3 find the closest point \\mathbf{c} \\in (V,F) (where \\mathbf{c} is not necessarily a vertex of (V,F)). This is accomplished for a triangle mesh <code>V,F</code> and a list of points in the rows of <code>P</code> via <code>igl::point_mesh_squared_distance</code>:</p> <pre><code>VectorXd sqrD;\nVectorXi I;\nMatrixXd C;\nigl::point_mesh_squared_distance(P,V,F,sqrD,I,C);\n</code></pre> <p>the output <code>sqrD</code> contains the (unsigned) squared distance from each point in <code>P</code> to its closest point given in <code>C</code> which lies on the element in <code>F</code> given by <code>I</code> (e.g. from which one could recover barycentric coordinates, using <code>igl::barycentric_coordinates</code>).</p> <p>If the mesh <code>V,F</code> is static, but the point set <code>P</code> is changing dynamically then it\u2019s best to reuse the AABB hierarchy that\u2019s being built during <code>igl::point_mesh_squared_distance</code>:</p> <pre><code>igl::AABB tree;\ntree.init(V,F);\ntree.squared_distance(V,F,P,sqrD,I,C);\n... // P changes, but (V,F) does not\ntree.squared_distance(V,F,P,sqrD,I,C);\n</code></pre>"},{"location":"tutorial/#signed-distance","title":"Signed Distance","text":"<p>Finally, from the closest point or the winding number it\u2019s possible to sign this distance. In <code>igl::signed_distance</code> we provide two methods for signing: the so-called \u201cpseudo-normal test\u201d <sup>37</sup>[] and the generalized winding number <sup>40</sup>[].</p> <p>The pseudo-normal test (see also <code>igl::pseudonormal_test</code>) assumes the input mesh is a watertight (closed, non-self-intersecting, manifold) mesh. Then given a query point \\mathbf{q} and its closest point \\mathbf{c} \\in (V,F), it carefully chooses an outward normal \\mathbf{n} at \\mathbf{c} so that \\text{sign}(\\mathbf{q}-\\mathbf{c})\\cdot \\mathbf{n} reveals whether \\mathbf{q} is inside (V,F): -1, or outside: +1. This is a fast O(1) test once \\mathbf{c} is located, but may fail if <code>V,F</code> is not watertight.</p> <p>An alternative is to use the generalized winding number to determine the sign. This is very robust to unclean meshes <code>V,F</code> but slower: something like O(\\sqrt{n}) once \\mathbf{c} is located.</p> <p>In either case, the interface via <code>igl::signed_distance</code> is:</p> <pre><code>// Choose type of signing to use\nigl::SignedDistanceType type = SIGNED_DISTANCE_TYPE_PSEUDONORMAL;\nigl::signed_distance(P,V,F,sign_type,S,I,C,N);\n</code></pre> <p>the outputs are as above for <code>igl::point_mesh_squared_distance</code> but now <code>S</code> contains signed (unsquared) distances and the extra output <code>N</code> (only set when <code>type == SIGNED_DISTANCE_TYPE_PSEUDON</code>) contains the normals used for signing with the pseudo-normal test.</p> <p> </p>      Example 704 computes signed distance on slices through the bunny."},{"location":"tutorial/#marching-cubes","title":"Marching Cubes","text":"<p>Often 3D data is captured as scalar field defined over space f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R}. Lurking within this field, iso-surfaces of the scalar field are often salient geometric objects. The iso-surface at value v is composed of all points \\mathbf{x} in \\mathcal{R}^3 such that f(\\mathbf{x}) = v. A core problem in geometry processing is to extract an iso-surface as a triangle mesh for further mesh-based processing or visualization. This is referred to as iso-contouring.</p> <p>\u201cMarching Cubes\u201d <sup>42</sup> is a famous method for iso-contouring tri-linear functions f on a regular lattice (aka grid). The core idea of this method is to contour the iso-surface passing through each cell  (if it does at all) with a predefined topology (aka connectivity) chosen from a look up table depending on the function values at each vertex of the cell. The method iterates (\u201cmarches\u201d) over all cells (\u201ccubes\u201d) in the grid and stitches together the final, watertight mesh.</p> <p>In libigl, <code>igl::marching_cubes</code> constructs a triangle mesh <code>(V,F)</code> from an input scalar field <code>S</code> sampled at vertex locations <code>GV</code> of a <code>nx</code> by <code>ny</code> by <code>nz</code> regular grid:</p> <pre><code>igl::marching_cubes(S,GV,nx,ny,nz,V,F);\n</code></pre> <p> </p>      (Example 705) samples signed distance to the input mesh (left) and then reconstructs the surface using marching cubes to contour the 0-level set (center). For comparison, clamping this signed distance field to an indicator function and contouring reveals serious aliasing artifacts."},{"location":"tutorial/#facet-orientation","title":"Facet Orientation","text":"<p>Models from the web occasionally arrive unorientated in the sense that the orderings of each triangles vertices do not consistently agree. Determining a consistent facet orientation for a mesh is essential for two-sided lighting (e.g., a cloth with red velvet on one side and gold silk on the other side) and for inside-outside determination(e.g., using generalized winding numbers).</p> <p>For (open) surfaces representing two-sided sheets, libigl provides a routine to force consistent orientations within each orientable patch (<code>igl::orientable_patches</code>) of a mesh:</p> <pre><code>igl::bfs_orient(F,FF,C);\n</code></pre> <p>This simple routine will use breadth-first search on each patch of the mesh to enforce a consistent facet orientation in the output faces <code>FF</code>.</p> <p>For (closed or nearly closed) surfaces representing the boundary of a solid object, libigl provides a routine to reorient faces so that the vertex ordering corresponds to a counter-clockwise ordering of the vertices with a right-hand-rule normal pointing outward. This method <sup>45</sup>[] assumes that most of the universe is empty. That is, most points in space are outside of the solid object than inside. Points are sampled over surface patches. For each sample point, rays are shot into both hemispheres to compute average of the (distance weighted) ambient occlusion on each side. A patch is oriented so that the outward side is less occluded (lighter, i.e., facing more void space).</p> <pre><code>igl::embree::reorient_facets_raycast(V,F,FF,I);\n</code></pre> <p>The boolean vector <code>I</code> reveals which rows of <code>F</code> have been flipped in <code>FF</code>.</p> <p> </p>      (Example 706) loads a truck model with inconsistent orientations (back facing triangles shown darker). Orientable patches are uniquely colored and then oriented to face outward (middle left). Alternatively, each individual triangle is considered a \u201cpatch\u201d (middle right) and oriented outward independently."},{"location":"tutorial/#swept-volume","title":"Swept Volume","text":"<p>The swept volume S of a moving solid object A can be defined as any point in space such that at one moment in time the point lies inside the solid. In other words, it is the union of the solid object transformed by the rigid motion f(t) over time:</p> <p>S = \\bigcup \\limits_{t\\in [0,1]} f(t) A.</p> <p>The surface of the swept volume of a solid bounded by a triangle mesh undergoing a rigid motion with non-trivial rotation is not a surface exactly representably by triangle mesh: it will be a piecewise-ruled surface.</p> <p>To see this, consider the surface swept by a single edge\u2019s line segment as it performs a screw motion.</p> <p>This means that if we\u2019d like to the surface of the swept volume of a triangle mesh undergoing a rigid motion and we\u2019d like the output to be another triangle mesh, then we\u2019re going to have to be happy with some amount of approximation error.</p> <p>With this in mind, the simplest method for computing an approximate swept volume is by exploiting an alternative definition of the swept volume based on signed distances:</p> <p>S = \\left\\{ \\mathbf{p}\\ \\middle| \\ d(\\mathbf{p},\\partial S) &lt; 0 \\right\\} = \\left\\{ \\mathbf{p}\\ \\middle|\\ \\min\\limits_{t \\in [0,1]} d(\\mathbf{p},f(t)\\ \\partial A) &lt; 0 \\right\\}</p> <p>If \\partial A is a triangle mesh, then we can approximate this by 1) discretizing time at a finite step of steps [0,\\Delta t,2\\Delta t, \\dots, 1] and by 2) discretizing space with a regular grid and representing the distance field using trilinear interpolation of grid values. Finally the output mesh, \\partial S is approximated by contouring using Marching Cubes <sup>42</sup>.</p> <p>This method is similar to one described by Schroeder et al. in 1994 <sup>44</sup>, and the one used in conjunction with boolean operations by Garg et al. 2016 <sup>38</sup>.</p> <p>In libigl, if your input solid\u2019s surface is represented by <code>(V,F)</code> then the output surface mesh will be <code>(SV,SF)</code> after calling:</p> <pre><code>igl::copyleft::swept_volume(V,F,num_time_steps,grid_size,isolevel,SV,SF);\n</code></pre> <p>The <code>isolevel</code> parameter can be set to zero to approximate the exact swept volume, greater than zero to approximate a positive offset of the swept volume or less than zero to approximate a negative offset.</p> <p> </p>      (Example 707) computes the surface of the swept volume (silver) of the bunny model undergoing a rigid motion (gold)."},{"location":"tutorial/#picking","title":"Picking","text":"<p>Picking vertices and faces using the mouse is very common in geometry processing applications. While this might seem a simple operation, its implementation is not straightforward. Libigl contains a function that solves this problem using the Embree raycaster. Its usage is demonstrated in Example 708:</p> <pre><code>bool hit = igl::unproject_onto_mesh(\nVector2f(x,y),\nF,\nviewer.core.view * viewer.core.model,\nviewer.core.proj,\nviewer.core.viewport,\n*ei,\nfid,\nbc);\n</code></pre> <p>This function casts a ray from the view plane in the view direction. Variables <code>x</code> and <code>y</code> are the mouse screen coordinates; <code>view</code>, <code>model</code>, <code>proj</code> are the view, model and projection matrix respectively; <code>viewport</code> is the viewport in OpenGL format; <code>ei</code> contains a Bounding Volume Hierarchy constructed by Embree, and <code>fid</code> and <code>bc</code> are the picked face and barycentric coordinate of the picked position, respectively.</p> <p> </p>      (Example 708) Picking via ray casting. The selected faces are colored in red."},{"location":"tutorial/#scalable-locally-injective-maps","title":"Scalable Locally Injective Maps","text":"<p>The Scalable Locally Injective Maps <sup>43</sup> algorithm allows to compute locally injective maps on massive datasets. The algorithm shares many similarities with ARAP, but uses a reweighting scheme to minimize arbitrary distortion energies, including those that prevent the introduction of flips.</p> <p>Example 709 contains three demos: (1) an example of large scale 2D parametrization, (2) an example of 2D deformation with soft constraints, and (3) an example of 3D deformation with soft constraints. The implementation in libigl is self-contained and relies on Eigen for the solution of the linear system used in the global step. An optimized version that relies on Pardiso is available here.</p> <p> </p>      A locally injective parametrization of a mesh with 50k faces is computed using the SLIM algorithm in 10 iterations."},{"location":"tutorial/#simplicial-complex-augmentation-framework-for-bijective-maps","title":"Simplicial Complex Augmentation Framework For Bijective Maps","text":"<p>The Simplicial Complex Augmentation Framework  <sup>49</sup> algorithm allows to compute bijective maps efficiently and robustly. The algorithm constructed a scaffold structure to take advantage of efficient locally injective mapping algorithms like SLIM, guarantees a overlapping free map with low distortion while being efficient and scalable.</p> <p>Example 710 contains a demo of bijective parameterizing a camel mesh.</p> <p></p>"},{"location":"tutorial/#subdivision-surfaces","title":"Subdivision Surfaces","text":"<p>Given a coarse mesh (aka cage) with vertices <code>V</code> and faces <code>F</code>, one can create a higher-resolution mesh with more vertices and faces by subdividing every face. That is, each coarse triangle in the input is replaced by many smaller triangles. Libigl has three different methods for subdividing a triangle mesh.</p> <p>An \u201cin plane\u201d subdivision method will not change the point set or carrier surface of the mesh. New vertices are added on the planes of existing triangles and vertices surviving from the original mesh are not moved.</p> <p>By adding new faces, a subdivision algorithm changes the combinatorics of the mesh. The change in combinatorics and the formula for positioning the high-resolution vertices is called the \u201csubdivision rule\u201d.</p> <p>For example, in the in plane subdivision method of <code>igl::upsample</code>, vertices are added at the midpoint of every edge: v_{ab} = \\frac{1}{2}(v_a + v_b) and each triangle (i_a,i_b,i_c) is replaced with four triangles: (i_a,i_{ab},i_{ca}), (i_b,i_{bc},i_{ab}), (i_{ab},i_{bc},i_{ca}), and (i_{bc},i_{c},i_{ca}). This process may be applied recursively, resulting in a finer and finer mesh.</p> <p>The subdivision method of <code>igl::loop</code> is not in plane. The vertices of the refined mesh are moved to weight combinations of their neighbors: the mesh is smoothed as it is refined <sup>41</sup>. This and other smooth subdivision methods can be understood as generalizations of spline curves to surfaces. In particular the Loop subdivision method will converge to a C^1 surface as we consider the limit of recursive applications of subdivision. Away from \u201cirregular\u201d or \u201cextraordinary\u201d vertices (vertices of the original cage with valence not equal to 6), the surface is C^2. The combinatorics (connectivity and number of faces) of <code>igl::loop</code> and <code>igl::upsample</code> are identical: the only difference is that the vertices have been smoothed in <code>igl::loop</code>.</p> <p>Finally, libigl also implements a form of in plane \u201cfalse barycentric subdivision\u201d in <code>igl::false_barycentric_subdivision</code>. This method simply adds the barycenter of every triangle as a new vertex v_{abc} and replaces each triangle with three triangles (i_a,i_b,i_{abc}), (i_b,i_c,i_{abc}), and (i_c,i_a,i_{abc}). In contrast to <code>igl::upsample</code>, this method will create triangles with smaller and smaller internal angles and new vertices will sample the carrier surfaces with extreme bias.</p> <p> </p>      The original coarse mesh and three different subdivision methods: <code>igl::upsample</code>, <code>igl::loop</code> and <code>igl::false_barycentric_subdivision</code>."},{"location":"tutorial/#data-smoothing","title":"Data Smoothing","text":"<p>A noisy function f defined on a surface \\Omega can be smoothed using an energy minimization that balances a smoothing term E_S with a quadratic fitting term:</p> <p>u = \\operatorname{argmin}_u \\alpha E_S(u) + (1-\\alpha)\\int_\\Omega ||u-f||^2 dx</p> <p>The parameter \\alpha determines how aggressively the function is smoothed.</p> <p>A classical choice for the smoothness energy is the Laplacian energy of the function with zero Neumann boundary conditions, which is a form of the biharmonic energy. It is constructed using the cotangent Laplacian <code>L</code> and the mass matrix <code>M</code>: <code>QL = L'*(M\\L)</code>. Because of the implicit zero Neumann boundary conditions however, the function behavior is significantly warped at the boundary if f does not have zero normal gradient at the boundary.</p> <p>In <sup>51</sup> it is suggested to use the Biharmonic energy with natural Hessian boundary conditions instead, which corresponds to the Hessian energy with the matrix <code>QH = H'*(M2\\H)</code>, where <code>H</code> is a finite element Hessian and <code>M2</code> is a stacked mass matrix. The matrices <code>H</code> and <code>QH</code> are implemented in libigl as <code>igl::hessian</code> and <code>igl::hessian_energy</code> respectively. An example of how to use the function is given in Example 712.</p> <p>In the following image the differences between the Laplacian energy with zero Neumann boundary conditions and the Hessian energy can be clearly seen: whereas the zero Neumann boundary condition in the third image bias the isolines of the function to be perpendicular to the boundary, the Hessian energy gives an unbiased result.</p> <p> </p>      (Example 712) From left to right: a function on the beetle mesh, the function with added noise, the result of smoothing with the Laplacian energy and zero Neumann boundary conditions, and the result of smoothing with the Hessian energy."},{"location":"tutorial/#shapeup-projections","title":"Shapeup Projections","text":"<p>Our input is a set of points P_0 (not necessarily part of any mesh), and a set of constraints S=\\left\\{S_1,S_2,...S_m\\right\\}, where each constraint is defined on a different, and sparse, subset of P_0. We wish to create a new set of points P that are close to the original set P_0 (each point with corresponding indices), while adhering to the constraints. Other objectives, such as smoothness, can be employed. The constraints can be nonlinear, which makes the problem nonconvex, difficult, and without a guaranteed global optimum. A very popular lightweight approach to such problems is a local-global iterative algorithm, comprising these two steps:</p> <p>For iteration k: 1. Local step: compute the projections of the set P_{k-1} onto S, individually per constraint; that would mean fragmenting each point that appears in multiple constraints. That can be a nonlinear operation, but if the constraints are sparse, it is a a set of many small systems. 2. Global step: integrate the set P_k to be as close as possible to the projected fragmented set, with auxiliary objective functions possible. That results in a global, but quadratic objective function. Moreover, the resulting linear system has a constant matrix, and therefore can be pre-factored.</p> <p>The version we implement in libigl is the general version described by <sup>27</sup>, and is in two files: <code>&lt;igl/shapeup.h&gt;</code> and <code>&lt;igl/shapeup_local_projections.h&gt;</code>. A demo implementing regularity constraints (creating a mesh in which each face is as regular as possible) is in Example 713. </p> <p>The local step is instantiated by a function of type <code>igl::shapeup_projection_function</code>. The global step is done by two functions: <code>igl::shapeup_precomputation()</code>, which precomputes the matrices required for the global step, and <code>igl::shapeup_solve()</code>, which solves the problem, according to the initial solution P_0 and the input local projection function. The data struct <code>igl::ShapeUpData</code> contains the information necessary to run the algorithm, and can be configured; for instance, the self-explanatory variable <code>Maxiterations</code>.</p> <p>The global step minimizes the following energy:</p>    E_{total}=\\lambda_{shape}E_{shape}+\\lambda_{close}E_{close}+\\lambda_{smooth}E_{smooth},  <p>where the \\lambda coefficients are encoded in <code>igl::ShapeUpData</code>, and can be updated prior to calling <code>igl::shapeup_precomputation()</code>. The E_{shape} component is the integration energy (fitting P_k to the local projections). The E_{close} component is adherence to positional constraints, given by <code>b</code> and <code>bc</code> parameters. The E_{smooth} component is an optional objective function, to minimize differences (in the Dirichlet sense) between points, encodes by \u201cedges\u201d in parameter <code>E</code>. Both E_{close} and E_{shape} are also weighted by <code>wClose</code> and <code>wShape</code> function parameters, respectively.</p> <p> </p>      (Example 713) The half-tunnel mesh (left) has been optimized to be almost perfectly regular (right). The color scale is between \\lbrack 0,0.05 \\rbrack, measuring the average normalized deviation of the angles of each face from 90^{\\circ}."},{"location":"tutorial/#marching-tetrahedra","title":"Marching Tetrahedra","text":"<p>Often 3D data is captured as scalar field defined over space f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R}. Lurking within this field, iso-surfaces of the scalar field are often salient geometric objects. The iso-surface at value v is composed of all points \\mathbf{x} in \\mathcal{R}^3 such that f(\\mathbf{x}) = v. A core problem in geometry processing is to extract an iso-surface as a triangle mesh for further mesh-based processing or visualization. This is referred to as iso-contouring.</p> <p>\u201cMarching Tetrahedra\u201d <sup>46</sup> is a famous method for iso-contouring tri-linear functions f on a 3D simplicial complex (aka a tet mesh). The core idea of this method is to contour the iso-surface passing through each cell  (if it does at all) with a predefined topology (aka connectivity) chosen from a look up table depending on the function values at each vertex of the cell. The method iterates (\u201cmarches\u201d) over all cells (\u201ctetrahedra\u201d) in the complex and stitches together the final mesh.</p> <p>In libigl, <code>igl::marching_tets</code> constructs a triangle mesh <code>(V,F)</code> approximating the iso-level set for the value <code>isovalue</code> from an input scalar field <code>S</code> sampled at the vertices of a tet mesh locations <code>(TV, TT)</code>:</p> <pre><code>igl::marching_tets(TV,TT,S, isovalue ,V,F);\n</code></pre>"},{"location":"tutorial/#implicit-function-meshing","title":"Implicit Function Meshing","text":"<p>715_MeshImplicitFunction</p> <p>Entry Missing</p>"},{"location":"tutorial/#heat-method-for-fast-geodesic-distance-approximation","title":"Heat Method For Fast Geodesic Distance Approximation","text":"<p>In the Exact Discrete Geodesic Distances example above, geodesic distances are computed exactly. This is an expensive operation: O(n\u00b2 log(n)) for a mesh with n edges. In 2013, Crane et al. <sup>47</sup> proposed a method to compute approximate geodesic distances much faster by solving heat equation on the surface, filtering the result and then reconstructing a smooth solution by solving a Poisson equation. The method begins with the observation of Varadhan that the geodesic distance d(\\mathbf{x},\\mathbf{y}) between two points \\mathbf{x} and \\mathbf{y} is equal to the square root of the logarithm of the heat diffused from \\mathbf{x} to \\mathbf{y} after a time t:</p> <p>\\[ d(\\mathbf{x},\\mathbf{y}) = \\lim_{t\u21920} \\sqrt{ -4 t \\log k_{t,\\mathbf{x}} (\\mathbf{y}) }, \\] where k_{t,\\mathbf{x}} is the heat kernel. We can think of this heat diffusion problem as placing a hot needle on \\mathbf{x} and then after t seconds, measuring the temperature at point \\mathbf{y}.</p> <p>On triangle meshes we know how to solve the heat equation for any finite time t:</p> <p>\\[ (-\\mathbf{L}+\\frac{1}{t}\\mathbf{M}) \\mathbf{u} = \u03b4_{x}, \\]</p> <p>where \\mathbf{L} \u2208 \\mathbb{R}^{n\u00d7n} is the discrete Laplacian matrix, \\mathbf{M} \u2208 \\mathbb{R}^{n\u00d7n} is the discrete mass matrix, \\mathbf{u} \u2208 \\mathbb{R}^n are the resulting temperatures at each vertex, and \u03b4_x \u2208 \\mathbb{R}^n is a vector of all zeros except a one at the vertex at the source \\mathbf{x}.</p> <p>If we had sufficient numerical accuracy and precision, we could simply evaluate \\sqrt{-4 t \\log u} for a small time parameter t. The problem observed by Crane et al. is that our numerical accuracy of the value of \\mathbf{u} is far from sufficient. However, the direction of the gradient \u2207 \\mathbf{u} is surprisingly accurate. Hence, their idea is to acquire the gradient of \\mathbf{u}, normalize these vectors to get a gradient direction (unit vector). And then solve a Poisson equation to integrate these directions into actual distance values.</p> <p>This method involves inverting n\u00d7n sparse matrices (a O(n^{1.\\cdots}) operation), but if Cholesky factorizations are used then the factorization is precomputation that can be reused even if the source of the geodesic distances is changed. For a new source, only back-substitution needs to be performed.</p> <p>In libigl, you can compute approximate geodesic distances for a mesh (<code>V</code>,<code>F</code>) from a list of source vertex indices <code>gamma</code> into a vector <code>D</code> using this method via two steps:</p> <pre><code>igl::HeatGeodesicsData&lt;double&gt; data;\nigl::heat_geodesics_precompute(V,F,data);\n...\nigl::heat_geodesics_solve(data,gamma,D);\n</code></pre> <p>)   </p>      ([Example 716    <p>loads a mesh and computes approximate geodesics distances from wherever the user clicks.](images/heat-geodesic-beetle.gif)</p>"},{"location":"tutorial/#intrinsic-delaunay-triangulation","title":"Intrinsic Delaunay Triangulation","text":"<p>The original heat method for geodesic distances works well on regular, unbiased meshes: i.e., where the finite-element cotangent and mass matrices are well-behaved. For poor quality meshes, however, this method may show arbitrarily poor results. Increasing the time parameter t can reduce this instability but but simultaneously smoothes the resulting approximate distances.</p> <p>Instead, one avenue of improvement is to employ the so-called intrinsic Delaunay triangulation discrete Laplace operator <sup>48</sup>.</p> <p>Since the cotangent Laplacian only depends on the edge-lengths of a triangle mesh, this new operator will be constructed by intrinsically flipping edges and recording changes to edge-lengths. Edges are flipped until every edge is locally Delaunay (i.e., its corresponding cotangent weights are positive).</p> <p>You can compute the intrinsic Delaunay triangulation of mesh (<code>V</code>,<code>F</code>) in libigl using:</p> <pre><code>Eigen::MatrixXd l;\nigl::edge_lengths(V,F,l);\nEigen::MatrixXd l_intrinsic;\nEigen::MatrixXi F_intrinsic;\nigl::intrinsic_delaunay_triangulation(l,F,l_intrinsic,F_intrinsic);\n</code></pre> <p>Notice that the mesh vertex positions <code>V</code> are not used, since this is a purely intrinsic operation. The method inputs and outputs edge-lengths and triangle indices.</p> <p>You may construct the intrinsic Delaunay cotangent Laplacian matrix directly using:</p> <pre><code>Eigen::SparseMatrix&lt;double&gt; L;\nigl::intrinsic_delaunay_cotmatrix(V,F,L);\n</code></pre> <p>And finally you can compute heat geodesics using this matrix via:</p> <pre><code>igl::HeatGeodesicsData&lt;double&gt; data;\ndata.use_intrinsic_delaunay = true;\nigl::heat_geodesics_precompute(V,F,data);\n...\nigl::heat_geodesics_solve(data,gamma,D);\n</code></pre> <p></p>"},{"location":"tutorial/#fast-winding-number-for-soups-and-clouds","title":"Fast Winding Number For Soups And Clouds","text":"<p>In 2018, Barill et al. <sup>50</sup> demonstrated how to significantly expediate the computation of the generalized winding numbers mentioned above. The original definition of generalized winding numbers for triangle meshes is also extended to (oriented) point clouds.</p>"},{"location":"tutorial/#soups","title":"Soups","text":"<p>For triangle soups, the exact divide-and-conquer approach of <sup>40</sup> ideally scales logarithmically O(\\log{n}) in the number of triangles. However, this method has failure modes where the computation becomes linear O(n). This can be dramatically improved with a tree method similar to those used in n-body graviational system simulations or electrostatics problems. The result is approximate, but much more closely follows a O(\\log{n})  trend and with much smaller constant factors.</p> <p>)   </p>      ([Example 717    <p>loads a mesh, samples 1,000,000 random queries and then discards all those outside the given model.](images/bunny-fwn-soup.jpg)</p> <p>Computing fast winding numbers for soups has two steps: building the tree data structure and then evaluating at query points. In libigl, this is programmed as follows:</p> <pre><code>igl::FastWindingNumberBVH fwn_bvh;\nigl::fast_winding_number(V.cast&lt;float&gt;(),F,2,fwn_bvh);\nEigen::VectorXf W;\nigl::fast_winding_number(fwn_bvh,2,Q.cast&lt;float&gt;(),W);\n</code></pre>"},{"location":"tutorial/#clouds","title":"Clouds","text":"<p>For point clouds, the process is similar, but more precomputation may be necessary. The winding number for point clouds is defined so long as each point comes with an outward-facing normal and an area value. Areas can be estimated by using a libigl function that computes a tangents space Voronoi diagram for each point <code>igl::copyleft::cgal::point_areas</code>. This function in turn relies on first computing k nearest neighbors <code>igl::knn</code>. And that function and the eventual winding number computation uses libigl\u2019s <code>igl::octree</code> as a bounding volume hierarchy. To estimate areas use for a point cloud <code>P</code> with normals <code>N</code> use:</p> <pre><code>// Build octree\nstd::vector&lt;std::vector&lt;int &gt; &gt; O_PI;\nEigen::MatrixXi O_CH;\nEigen::MatrixXd O_CN;\nEigen::VectorXd O_W;\nigl::octree(P,O_PI,O_CH,O_CN,O_W);\nEigen::VectorXd A;\n{\nEigen::MatrixXi I;\nigl::knn(P,20,O_PI,O_CH,O_CN,O_W,I);\n// CGAL is only used to help get point areas\nigl::copyleft::cgal::point_areas(P,I,N,A);\n}\n</code></pre> <p>Then it is possible to compute fast winding numbers for a list of queries <code>Q</code>:</p> <pre><code>Eigen::MatrixXd O_CM;\nEigen::VectorXd O_R;\nEigen::MatrixXd O_EC;\nigl::fast_winding_number(P,N,A,O_PI,O_CH,2,O_CM,O_R,O_EC);\nEigen::VectorXd W;\nigl::fast_winding_number(P,N,A,O_PI,O_CH,O_CM,O_R,O_EC,Q,2,W);\n</code></pre>"},{"location":"tutorial/#iterative-closest-point","title":"Iterative Closest Point","text":"<p>718_IterativeClosestPoint</p> <p>Entry Missing</p>"},{"location":"tutorial/#exploded-view","title":"Exploded View","text":"<p>719_ExplodedView</p> <p>Entry Missing</p>"},{"location":"tutorial/#blue-noise-surface-sampling","title":"Blue Noise Surface Sampling","text":"<p>720_BlueNoise</p> <p>Entry Missing</p>"},{"location":"tutorial/#vector-field-smoothing","title":"Vector Field Smoothing","text":"<p>721_VectorFieldSmoothing</p> <p>Entry Missing</p>"},{"location":"tutorial/#vector-parallel-transport","title":"Vector Parallel Transport","text":"<p>722_VectorParallelTransport</p> <p>Entry Missing</p>"},{"location":"tutorial/#outlook-for-continuing-development","title":"Outlook For Continuing Development","text":"<p>Libigl is in active development, and we plan to focus on the following features in the next months:</p> <ul> <li> <p>A better and more consistent documentation, plus extending this tutorial   to cover more libigl features.</p> </li> <li> <p>Implement a mixed-integer solver which only uses Eigen to remove the   dependency on CoMiSo.</p> </li> <li> <p>Improve the robustness and performance of the active set QP solver. In   particular, handle linearly dependent constraints.</p> </li> <li> <p>Implement more mesh analysis functions, including structural analysis for   masonry and 3D-printability analysis.</p> </li> <li> <p>Increase support for point clouds and general polygonal meshes.</p> </li> <li> <p>Wrangle/unify the many bounding volume hierarchies that now exist within libigl.</p> </li> <li> <p>What would you like to see in libigl? Contact   us! or post a feature   request.</p> </li> </ul> <p>We encourage you to contribute to the library and to report problems and bugs. The best way to contribute new feature or bug fixes is to fork the libigl repository and to open a pull request on our github repository.</p>"},{"location":"tutorial/#past-libigl-courses-at-conferences","title":"Past Libigl Courses At Conferences","text":"<p>This tutorial was originally presented by Daniele Panozzo and Alec Jacobson at SGP Graduate School 2014. It has also been presented at SGP 2017 (video), ACM SIGGRAPH Asia 2017, Eurographics 2019, and SGP 2020.</p>"},{"location":"tutorial/#references","title":"References","text":"<ol> <li> <p>Alec Jacobson, Algorithms and Interfaces for Real-Time Deformation of 2D and 3D Shapes, 2013.\u00a0\u21a9</p> </li> <li> <p>Michael Kazhdan, Jake Solomon, Mirela Ben-Chen, Can Mean-Curvature Flow Be Made Non-Singular, 2012.\u00a0\u21a9</p> </li> <li> <p>Mark Meyer, Mathieu Desbrun, Peter Schr\u00f6der and Alan H.  Barr, Discrete Differential-Geometry Operators for Triangulated 2-Manifolds, 2003.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Joseph S. B. Mitchell, David M. Mount, Christos H. Papadimitriou. The Discrete Geodesic Problem, 1987\u00a0\u21a9</p> </li> <li> <p>Daniele Panozzo, Enrico Puppo, Luigi Rocca, Efficient Multi-scale Curvature and Crease Estimation, 2010.\u00a0\u21a9</p> </li> <li> <p>Andrei Sharf, Thomas Lewiner, Gil Shklarski, Sivan Toledo, and Daniel Cohen-Or. Interactive topology-aware surface reconstruction, 2007.\u00a0\u21a9</p> </li> <li> <p>Jernej Barbic and Doug James. Real-Time Subspace Integration for St.Venant-Kirchhoff Deformable Models, 2005.\u00a0\u21a9</p> </li> <li> <p>Klaus Hildebrandt, Christian Schulz, Christoph von Tycowicz, and Konrad Polthier. Interactive Surface Modeling using Modal Analysis, 2011.\u00a0\u21a9</p> </li> <li> <p>Raid M. Rustamov, Multiscale Biharmonic Kernels, 2011.\u00a0\u21a9</p> </li> <li> <p>Bruno Vallet and Bruno L\u00e9vy. Spectral Geometry Processing with Manifold Harmonics, 2008.\u00a0\u21a9\u21a9</p> </li> <li> <p>Mario Botsch and Leif Kobbelt. An Intuitive Framework for Real-Time Freeform Modeling, 2004.\u00a0\u21a9</p> </li> <li> <p>Isaac Chao, Ulrich Pinkall, Patrick Sanan, Peter Schr\u00f6der. A Simple Geometric Model for Elastic Deformations, 2010.\u00a0\u21a9</p> </li> <li> <p>Alec Jacobson, Ilya Baran, Jovan Popovi\u0107, and Olga Sorkine. Bounded Biharmonic Weights for Real-Time Deformation, 2011.\u00a0\u21a9\u21a9</p> </li> <li> <p>Alec Jacobson, Ilya Baran, Ladislav Kavan, Jovan Popovi\u0107, and Olga Sorkine. Fast Automatic Skinning Transformations, 2012.\u00a0\u21a9</p> </li> <li> <p>Alec Jacobson, Elif Tosun, Olga Sorkine, and Denis Zorin. Mixed Finite Elements for Variational Surface Modeling, 2010.\u00a0\u21a9</p> </li> <li> <p>Alec Jacobson, Zhigang Deng, Ladislav Kavan, J.P. Lewis. Skinning: Real-Time Shape Deformation, 2014.\u00a0\u21a9\u21a9</p> </li> <li> <p>Ladislav Kavan, Steven Collins, Jiri Zara, and Carol O\u2019Sullivan. Geometric Skinning with Approximate Dual Quaternion Blending, 2008.\u00a0\u21a9</p> </li> <li> <p>Binh Huy Le, J.P. Lewis. Direct delta mush skinning and variants, 2019.\u00a0\u21a9</p> </li> <li> <p>Joe Mancewicz, Matt L. Derksen, Hans Rijpkema, and Cyrus A. Wilson. Delta Mush: smoothing deformations while preserving detail, 2014.\u00a0\u21a9</p> </li> <li> <p>Alexa McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis. Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations, 2011.\u00a0\u21a9</p> </li> <li> <p>Olga Sorkine, Yaron Lipman, Daniel Cohen-Or, Marc Alexa, Christian R\u00f6ssl and Hans-Peter Seidel. Laplacian Surface Editing, 2004.\u00a0\u21a9</p> </li> <li> <p>Olga Sorkine and Marc Alexa. As-rigid-as-possible Surface Modeling, 2007.\u00a0\u21a9</p> </li> <li> <p>Yu Wang, Alec Jacobson, Jernej Barbic, Ladislav Kavan. Linear Subspace Design for Real-Time Shape Deformation, 2015\u00a0\u21a9\u21a9</p> </li> <li> <p>Fernando de Goes, Doug L. James. Regularized Kelvinlets: Sculpting Brushes based on Fundamental Solutions of Elasticity, 2017\u00a0\u21a9</p> </li> <li> <p>W. S. Slaughter. The Linearized Theory of Elasticity, 2002\u00a0\u21a9</p> </li> <li> <p>David Bommes, Henrik Zimmer, Leif Kobbelt. Mixed-integer quadrangulation, 2009.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly Shape-Up: Shaping Discrete Geometry with Projections, 2012\u00a0\u21a9\u21a9</p> </li> <li> <p>Matthias Eck, Tony DeRose, Tom Duchamp, Hugues Hoppe, Michael Lounsbery, Werner Stuetzle.  Multiresolution Analysis of Arbitrary Meshes, 2005.\u00a0\u21a9</p> </li> <li> <p>Bruno L\u00e9vy, Sylvain Petitjean, Nicolas Ray, J\u00e9rome Maillot. Least Squares Conformal Maps, for Automatic Texture Atlas Generation, 2002.\u00a0\u21a9</p> </li> <li> <p>Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno L\u00e9vy. N-Symmetry Direction Field Design, 2008.\u00a0\u21a9</p> </li> <li> <p>Ligang Liu, Lei Zhang, Yin Xu, Craig Gotsman, Steven J. Gortler. A Local/Global Approach to Mesh Parameterization, 2008.\u00a0\u21a9</p> </li> <li> <p>Patrick Mullen, Yiying Tong, Pierre Alliez, Mathieu Desbrun. Spectral Conformal Parameterization, 2008.\u00a0\u21a9</p> </li> <li> <p>Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung.  Frame Fields: Anisotropic and Non-Orthogonal Cross Fields, 2014.\u00a0\u21a9</p> </li> <li> <p>Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen. Directional Field Synthesis, Design, and Processing, 2016\u00a0\u21a9</p> </li> <li> <p>Christian Sch\u00fcller, Ladislav Kavan, Daniele Panozzo, Olga Sorkine-Hornung.  Locally Injective Mappings, 2013.\u00a0\u21a9</p> </li> <li> <p>Qingnan Zhou, Eitan Grinspun, Denis Zorin. Mesh Arrangements for Solid Geometry, 2016\u00a0\u21a9</p> </li> <li> <p>J Andreas Baerentzen and Henrik Aanaes. Signed distance computation using the angle weighted pseudonormal, 2005.\u00a0\u21a9</p> </li> <li> <p>Akash Garg, Alec Jacobson, Eitan Grinspun. Computational Design of Reconfigurables, 2016\u00a0\u21a9</p> </li> <li> <p>Hugues Hoppe. Progressive Meshes, 1996\u00a0\u21a9</p> </li> <li> <p>Alec Jacobson, Ladislav Kavan, and Olga Sorkine. Robust Inside-Outside Segmentation using Generalized Winding Numbers, 2013.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Charles Loop. Smooth Subdivision Surfaces Based on Triangles, 1987.\u00a0\u21a9</p> </li> <li> <p>W.E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3d surface construction algorithm, 1987.\u00a0\u21a9\u21a9</p> </li> <li> <p>Michael Rabinovich, Roi Poranne, Daniele Panozzo, Olga Sorkine-Hornung. Scalable Locally Injective Mappings, 2016.\u00a0\u21a9</p> </li> <li> <p>William J. Schroeder, William E. Lorensen, and Steve Linthicum. Implicit Modeling of Swept Surfaces and Volumes, 1994.\u00a0\u21a9</p> </li> <li> <p>Kenshi Takayama, Alec Jacobson, Ladislav Kavan, Olga Sorkine-Hornung. A Simple Method for Correcting Facet Orientations in Polygon Meshes Based on Ray Casting, 2014.\u00a0\u21a9</p> </li> <li> <p>G.M. Treece, R.W. Prager, and A.H.Gee Regularised marching tetrahedra: improved iso-surface extraction, 1999.\u00a0\u21a9</p> </li> <li> <p>Keenan Crane, Clarisse Weischedel, and Max Wardetzky. Geodesics in Heat: A New Approach to Computing Distance Based on Heat Flow, 2013.\u00a0\u21a9</p> </li> <li> <p>Alexander I. Bobenko and Boris A. Springborn. A discrete Laplace-Beltrami operator for simplicial surfaces, 2005.\u00a0\u21a9</p> </li> <li> <p>Zhongshi Jiang, Scott Schaefer, Daniele Panozzo. SCAF: Simplicial Complex Augmentation Framework for Bijective Maps, 2017\u00a0\u21a9</p> </li> <li> <p>Gavin Barill, Neil G. Dickson, Ryan Schmidt, David I.W. Levin, Alec Jacobson. Fast Winding Numbers for Soups and Clouds, 2018.\u00a0\u21a9</p> </li> <li> <p>Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson. Natural Boundary Conditions for Smoothing in Geometry Processing, 2018.\u00a0\u21a9</p> </li> </ol>"},{"location":"unit-tests/","title":"Unit Tests for libigl","text":"<p>The libigl unit test are included in the main repository inside the <code>tests</code> folder. There is a CMake flag to enable/disable the testings <code>LIBIGL_BUILD_TESTS</code> which is disabled by default when libigl is not a toplevel project, that is when you are using libigl as a library in your own project.</p> <p>Tip</p> <p>Before writing any new unit test, be sure you are up-to-date with the master branch to use the latest version of libigl available.</p>"},{"location":"unit-tests/#dependencies","title":"Dependencies","text":"<ul> <li>Catch2 is an auto-downloaded dependency.</li> </ul>"},{"location":"unit-tests/#build-and-test","title":"Build And Test","text":"<p>Use <code>cmake</code> to generate a <code>Makefile</code> that will build and test upon issuing <code>make</code>:</p> <pre><code>mkdir build\ncd build\ncmake ..\n</code></pre> <p>Then build and test with</p> <pre><code>make\nmake test\n</code></pre> <p>This will first compile the tests and then immediately run the tests. If tests are succeeding you should see output similar to:</p> <pre><code>Test project /usr/local/libigl-unit-tests/build\n    Start 1: run_igl_mosek_tests\n1/4 Test #1: run_igl_mosek_tests ..............***Exception: Other  0.00 sec\n    Start 2: run_igl_boolean_tests\n2/4 Test #2: run_igl_boolean_tests ............   Passed    1.12 sec\n    Start 3: run_igl_cgal_tests\n3/4 Test #3: run_igl_cgal_tests ...............   Passed    2.46 sec\n    Start 4: run_igl_tests\n</code></pre> <p>We refer to the Catch2 manual for additional options.</p>"},{"location":"unit-tests/#generating-new-tests","title":"Generating New Tests","text":"<p>To create a new test, just create a file with the same name of the file you want to test inside the <code>include\\igl</code> in the <code>tests</code> folder. Then just add <pre><code>#include &lt;test_common.h&gt;\n\nTEST_CASE(\"&lt;function_name&gt; &lt;possible description&gt;\", \"[igl]\")\n{\n//test code goes here\n}\n</code></pre></p> <p>You can use functions like <code>test_common::assert_eq</code> to assert equality between two Eigen matrices. The cumsum test is a good simple example of a test case.</p> <p>Many libigl functions act on triangle meshes, you can use <code>igl::read_triangle_mesh(test_common::data_path(\"cube.obj\"), V, F)</code> to load a triangle mesh located in the test data folder.</p> <p>Note</p> <p>The data used for testing is not in the main libigl repository. Instead it is contained in the libigl-tests-data repository. It is automatically downloaded when <code>LIBIGL_BUILD_TESTS</code> is enabled.</p>"},{"location":"unit-tests/#conventions","title":"Conventions","text":"<p>When naming a test for a function <code>igl::extra::function_name</code> use:</p> <pre><code>TEST_CASE(\"function_name: my_description\", \"[igl/extra]\")\n{\n...\n}\n</code></pre> <p>where <code>my_description</code> can be used to identify the type of unit test being run on the function <code>function_name</code>.</p>"},{"location":"unit-tests/#example","title":"Example","text":"<p>The test for <code>igl::copyleft::cgal::order_facets_around_edges</code> in <code>include/igl/copyleft/cgal/order_facets_around_edges.cpp</code> is:</p> <pre><code>TEST_CASE(\"copyleft_cgal_order_facets_around_edges: Simple\", \"[igl/copyleft/cgal]\")\n{\n...\n}\n</code></pre> <p>which tests this function on example data containing a triplet of faces.</p>"},{"location":"unit-tests/#guarantees","title":"Guarantees","text":"<p>None.</p> <p>(Obviously?) The presence of a unit test here for some function (e.g., <code>igl::cotmatrix</code>) is not a guarantee or even an endorsement of the notion that the libigl function <code>igl::cotmatrix</code> is bug free or \u201cfully tested\u201d or \u201cheavily tested\u201d or even \u201cadequately tested\u201d.</p>"},{"location":"unit-tests/#need-work","title":"Need Work?","text":"<p>Some of the most used libigl functions</p> <pre><code>grep -hr \"^#include \\\"\" ../libigl/include/igl | sed -e 's/\\(\\.\\.\\/\\)//g' | sort | uniq -c | sort\n</code></pre> <p>still don\u2019t have unit tests.</p>"},{"location":"website/","title":"Building the Website","text":"<p>For developers who want to contribute to the website/documentation of libigl. The website is now hosted in its own repository separate from the main libigl repository.</p>"},{"location":"website/#simple-workflow","title":"Simple Workflow","text":"<ol> <li> <p>For simple edits to the website, you can directly edit the pages online:   </p> </li> <li> <p>Write your changes to the markdown file on github:   </p> </li> <li> <p>Preview the modified page on github:   </p> </li> <li> <p>Finally, commit the changes to a new branch/fork and let github create a pull request with your changes:   </p> </li> </ol> <p>Feel free\u00a0to make your changes locally, and use something like dynamic previews in VS Code to preview your changes. The files are just markdown so anything should work! For more complicated changes (e.g. to render math equations), you may want to run mkdocs to preview the final website.</p>"},{"location":"website/#final-website-preview","title":"Final Website Preview","text":"<p>For more complicated changes, you may want to preview the website locally on your machine while editing its content. You will need to run mkdocs to do this.  If you want to preview the website locally on your machine, you will need to run mkdocs</p>"},{"location":"website/#prerequisites","title":"Prerequisites","text":"<pre><code>python -m pip install -r requirements.txt\n</code></pre>"},{"location":"website/#render-the-website","title":"Render the Website","text":"<pre><code>mkdocs serve\n</code></pre> <p>Tip</p> <p>Dead links can be checked using the LinkChecker tool. Run the website locally, then run LinkChecker on it: <pre><code>linkchecker http://127.0.0.1:8000\n</code></pre></p>"},{"location":"website/#doxygen","title":"Doxygen","text":"<p>Doxygen documentation is generated from withing libigl source. Run </p> <pre><code>cd libigl\ndoxygen docs/doxygen.conf\n</code></pre>"},{"location":"website/#deployment","title":"Deployment","text":"<p>Deployment has been automated through the use of GitHub Actions. The configuration file is located here.</p>"},{"location":"website/#references","title":"References","text":"<ul> <li>MkDocs</li> <li>Material Theme</li> </ul>"},{"location":"file-formats/","title":"libigl file formats","text":"<ul> <li>.bf ASCII files for representing skeletal bone \u201cforests\u201d</li> <li>.dmat uncompressed ASCII/binary files for dense matrices</li> <li>.ele Element (triangle or tet) list. This format comes in similar flavors: tetgen\u2019s, stellar\u2019s, and triangle\u2019s. The formats of TetGen and stellar are identical upto conventions on index ordering and number of allowed attributes (unverified).</li> <li>.face TetGen\u2019s file format for simplicial facets.</li> <li>.mesh Medit\u2019s triangle surface mesh + tetrahedral volume mesh file format, see page 33, section 7.2.1</li> <li>.msh Gmsh finite element mesh generator legacy version 2 file format. This format is very flexible and supports mixture of various elements, each vertex and each element can also have arbitrary number of scalar or vector fields defined, also elements are assigned integer tags to define sub meshes. Currently only triangular and tetrahedral elements are supported. Both ASCII and binary encodings are supported.</li> <li>.node List of points (vertices). Described identically (upto accepted dimensions, use of attributes and boundary markers) by Triangle, TetGen, and Stellar.</li> <li>.off Geomview\u2019s polyhedral file format</li> <li>.obj Wavefront object file format. Usually unsafe to assume anything more than vertex positions and triangle indices are supported</li> <li>.ply Polygon File Format, supporting ASCII and binary encoding. Each vertex and element can have artitrary number of additional properties.</li> <li>.png Portable Network Graphics image file. libigl supports png image files via the stb image library. Alpha channels and compression are supported.</li> <li>.poly Piecewise-linear complex. This format comes in many similar but importantly different flavors: triangle\u2019s, tetgen\u2019s, pyramid/SVR\u2019s</li> <li>.rbr ASCII files for saving state of ReAntTweakBar</li> <li>.stl 3D Systems\u2019CAD and 3D printing mesh file format. ASCII and binary versions.</li> <li>.tga Truevision TGA or TARGA image file format. IGLLIB supports only very basic reading and writing RGB/RGBA files without colormaps and (unverified) run-length compression.</li> <li>.tgf ASCII files for representing control handle graphs</li> <li>.wrl VRML (Virtual Reality Modeling Language) file format for 3D scenes.</li> <li>.xml XMLSerializer\u2019s file format containing the serialization of object data structures.</li> </ul>"},{"location":"file-formats/#triangle-mesh-file-format-performance","title":"Triangle mesh file format performance","text":"<p>.obj and .off file formats support meshes with arbitrary polygon degrees. However, often we are only working with triangle meshes. Further, .obj files do not have useful headers revealing the number of elements. For triangle meshes, .off and .obj are inferior file formats to the .mesh file format. The current (version 0.1.6) IO functions for these file formats perform as follows for reading and writing a 300,000 triangle mesh:</p> <pre><code>writeOBJ:  1.33742 secs\nwriteOFF:  0.510111 secs\nwriteMESH: 0.218139 secs\n\nreadOBJ:   1.3782 secs\nreadOFF:   0.691496 secs\nreadMESH:  0.242315 secs\n</code></pre> <p>This reveals that .mesh is 6.5x faster than .obj and about 2.5x faster than .off.</p> <p>While .obj files support normals, it is typically much faster to (re)compute normals from the geometry using <code>per_face_normals</code>, <code>per_vertex_normals</code>, <code>per_corner_normals</code> than to read and write them to files.</p> <p>It gets even better if you\u2019re willing to use a nonstandard format. If your triangle mesh is in (<code>V</code>,<code>F</code>) then you can read and write those variables as dense matrices of doubles to .dmat uncompressed binary files. This not only ensures perfect precision but also big speed ups. On that same 300,000 triangle mesh, .dmat achieves:</p> <pre><code>writeDMAT: 0.0384338 secs\n\nreadDMAT:  0.0117921 secs\n</code></pre> <p>This reveals that binary .dmat files are 34x/116x faster at writing and reading than .obj and a hefty 5x/20x over .mesh. In this case it may pay to compute normals once into <code>N</code> and also read and write it to a .dmat file.</p>"},{"location":"file-formats/bf/","title":".bf - bone forests","text":"<p>A .bf file contains a \u201cbone forest\u201d. Normally a skeleton for linear blend skinning is a \u201cbone tree\u201d with a single root. But this format may store multiple trees, hence a forest.</p> <p>Each line contains data about a vertex (joint) of the bone forest:</p> <pre><code>[weight index] [parent index] [x] [y] [z] [undocument optional data]\n</code></pre> <p>Indices begin with 0. The weight index is -1 if the bone does not have an associated weight. The parent index is -1 for root nodes. The x,y,z coordinates are offset vectors from this joint\u2019s parent\u2019s location (for roots, an offset from the origin).</p>"},{"location":"file-formats/dmat/","title":".dmat - dense matrices","text":"<p>A .dmat file contains a dense matrix in column major order. It can contain ASCII or binary data. Note that it is uncompressed so binary only reduces the file size by 50%. But writing and reading binary is usually faster. In MATLAB, binary is almost 100x faster.</p>"},{"location":"file-formats/dmat/#ascii","title":"ASCII","text":"<p>The first line is a header containing:</p> <pre><code>[#cols] [#rows]\n</code></pre> <p>Then the coefficients are printed in column-major order separated by spaces.</p>"},{"location":"file-formats/dmat/#binary","title":"Binary","text":"<p>Binary files will also contain the ascii header, but it should read:</p> <pre><code>0 0\n</code></pre> <p>Then there should be another header containing the size of the binary part:</p> <pre><code>[#cols] [#rows]\n</code></pre> <p>Then coefficients are written in column-major order in Little-endian 8-byte double precision IEEE floating point format.</p> <p>Note: Line endings must be <code>'\\n'</code> aka <code>char(10)</code> aka line feeds.</p>"},{"location":"file-formats/rbr/","title":".rbr - ReAntTweakbar state file","text":"<p>An .rbr file contains the saved values of the ReAntTweakBar class. It is used to load and save variables (and states specified via callbacks) stored in an AntTweakBar GUI.</p> <p>Each line contains the name of the AntTweakBar item, the type of item and the value as a string:</p> <pre><code>[name]: [type] [value]\n</code></pre> <p>As per AntTweakBar\u2019s own advice, names should not contain spaces. Names should also not contain colons (<code>:</code>). An example of a line looks like:</p> <pre><code>my_rotation: TW_TYPE_QUAT4 0.0111272 -0.00101157 0.00648534 -0.999917\n</code></pre> <p>Not all AntTweakBar types are currently supported. See <code>igl/ReAntTweakbar.h</code> for an up-to-date list of supported types.</p>"},{"location":"file-formats/tgf/","title":".tgf - control handle graphs","text":"<p>A .tgf file contains a graph of describing a set of control handles/structures: point controls, bones of a skeleton and cages made of \u201ccage edges\u201d.</p> <p>The first part of the file consists of lines regarding each vertex of the graph. Each line reads:</p> <pre><code>[index] [x] [y] [z] [undocument optional data]\n</code></pre> <p>Indices begin with 1 and should proceed in order. Then there should be a line with a sole:</p> <pre><code>#\n</code></pre> <p>The next section concerns the edges of the graph. Each line corresponds to an edge:</p> <pre><code>[source index] [dest index] [is bone] [is pseudo-edge] [is cage edge] [undocument other data]\n</code></pre> <p>Bone edges trump pseudo and cage edges.</p>"},{"location":"file-formats/xml/","title":".xml - serialization format","text":"<p>A .xml file contains the serialization of an object data structure generated with the XMLSerializer:</p> <p>The top level elements represent the groups in which the object are organised. The object names are unique within these groups.</p> <pre><code>&lt;group1&gt;\n  &lt;object1 val=\"value of object 1\"/&gt;\n  &lt;object2 val=\"value of object 2\"/&gt;\n&lt;/group1&gt;\n\n&lt;group2&gt;\n  &lt;object1 val=\"value of object 1\"/&gt;\n&lt;/group2&gt;\n</code></pre> <p>An object can be of following type:</p> <ul> <li>Basic types: char, char*, std::string, bool, usigned int, int, float, double</li> <li>STL containers: std::array, std::vector, std::pair</li> <li>Eigen types: Eigen::Matrix, Eigen::SparseMatrix</li> <li>User defined types: XMLSerializable*.</li> </ul> <p>There can also be a hierarchical structure like <code>vector&lt;int&gt;</code>, this will result in the following serialization:</p> <pre><code>&lt;group&gt;\n  &lt;vector size=\"3\"&gt;\n    &lt;value0 val=\"1\"/&gt;\n    &lt;value1 val=\"2\"/&gt;\n    &lt;value2 val=\"3\"/&gt;\n  &lt;/vector&gt;\n&lt;/group&gt;\n</code></pre> <p>An example of a serialization of an instance of the class Test</p> <pre><code>class Test{\n  int var1;\n  vector&amp;ltfloat&gt; vec1;  \n};\n</code></pre> <p>is shown here:</p> <pre><code>&lt;group&gt;\n  &lt;Test&gt;\n    &lt;var1 val=\"0\"&gt;\n    &lt;vec1 size=\"2\"&gt;\n      &lt;value0 val=\"1\"/&gt;\n      &lt;value1 val=\"2\"/&gt;\n    &lt;/vector&gt;\n  &lt;/Test&gt;\n&lt;/group&gt;\n</code></pre> <p>In the following we show the serialization of Eigen matrices.</p> <p><code>Eigen::Matrix&lt;int,4,3&gt;</code>:</p> <pre><code>&lt;group&gt;\n  &lt;matrix row=\"4\" col=\"3\" matrix=\"\n1,2,3,\n4,5,6,\n7,8,9,\n10,11,12/&gt;\n&lt;/group&gt;\n</code></pre> <p><code>Eigen::SparseMatrix&lt;int&gt;</code> (3x3 identity saved as triplets of the non-zero entries):</p> <pre><code>&lt;group&gt;\n  &lt;matrix row=\"3\" col=\"3\" matrix=\"\n0,0,1,\n1,1,1,\n2,2,1/&gt;\n&lt;/group&gt;\n</code></pre>"}]}