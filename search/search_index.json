{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"libigl - A simple C++ geometry processing library \u00b6 libigl is a simple C++ geometry processing library. We have a wide functionality including construction of sparse discrete differential geometry operators and finite-elements matrices such as the cotangent Laplacian and diagonalized mass matrix, simple facet and edge-based topology data structures, mesh-viewing utilities for OpenGL and GLSL, and many core functions for matrix manipulation which make Eigen feel a lot more like MATLAB. It is a header-only library . You do not need to compile anything to use, just include igl headers (e.g. #include <igl/cotmatrix.h> ) and run. Each header file contains a single function (e.g. igl/cotmatrix.h contains igl::cotmatrix() ). Most are tailored to operate on a generic triangle mesh stored in an n-by-3 matrix of vertex positions V and an m-by-3 matrix of triangle indices F . Optionally the library may also be pre-compiled into a statically linked library, for faster compile times with your projects. This only effects compile time (run-time performance and behavior is identical). If in doubt, use the header-only default mode: (i.e. just include the headers you want to use). We use the Eigen library heavily in our code. Our group prototypes a lot in MATLAB, and we have a useful MATLAB to libigl+Eigen conversion table . We regularly test compiling our library on Mac OS X with clang, Linux with gcc and Windows with Visual Studio 2015 Community Edition. Short Video Introduction \u00b6 Tutorial \u00b6 As of version 1.0, libigl includes an introductory tutorial that covers many functionalities. libigl Example Project \u00b6 We provide a blank project example showing how to use libigl and cmake. Feel free and encouraged to copy or fork this project as a way of starting a new personal project using libigl. Coding Guidelines and Tips \u00b6 libigl follows strict coding guidelines, please take a look here before submitting your pull requests. We also have a set of general coding tips on how to code a geometry processing research project. Installation \u00b6 Libigl is a header-only library. You do not need to build anything to install. Simply add libigl/include to your include path and include relevant headers. Here is a small \u201cHello, World\u201d program: #include <igl/cotmatrix.h> #include <Eigen/Dense> #include <Eigen/Sparse> #include <iostream> int main () { Eigen :: MatrixXd V ( 4 , 2 ); V << 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ; Eigen :: MatrixXi F ( 2 , 3 ); F << 0 , 1 , 2 , 0 , 2 , 3 ; Eigen :: SparseMatrix < double > L ; igl :: cotmatrix ( V , F , L ); std :: cout << \"Hello, mesh: \" << std :: endl << L * V << std :: endl ; return 0 ; } If you save this in hello.cpp , then you could compile this with (assuming Eigen is installed in /usr/local/include/eigen3 ): g++ -std = c++11 -lpthread -I/usr/local/include/eigen3 -I./libigl/include/ hello.cpp -o hello Running ./hello would then produce Hello, mesh: 0.5 0.5 -0.5 0.5 -0.5 -0.5 0.5 -0.5 Dependencies \u00b6 Dependencies are on a per-include basis and the majority of the functions in libigl depends only on the Eigen library. For more information see our tutorial . Optional Dependencies \u00b6 Libigl compartmentalizes its optional dependences via its directory organization in the include/ folder. All header files located directly in the include/igl/ folder have only stl and Eigen as dependencies. For example, all of the headers that depend on CGAL are located in include/igl/copyleft/cgal . For a full list of optional dependencies check cmake/libigl.cmake . CGAL and Boost By default, the CMake script for libigl will not build the CGAL dependency, since Boost is required to compile CGAL. If you enable the CMake option LIBIGL_WITH_CGAL , you will need to have Boost installed on your machine. On Windows , it is advised to install Boost using conda . On Linux and macOS , you will need to install Boost, GMP and MPFR using your favorite package manager (CGAL itself will be downloaded by libigl). Downloading Dependencies \u00b6 Libigl uses CMake\u2019s ExternalProject_Add to manage external dependencies. External libraries are build statically with libigl using CMake. In order to be included in the CMake script via add_subdirectory , the third-party content is fetched at CMake time using the DownloadProject.cmake script (which has been introduced in CMake itself with the command FetchContent in CMake 3.11). There is not much to know about this, other than the content will be fetched the first time you run CMake, and placed into the external/ folder. If something goes wrong with your dependencies, simply erase your external/ folder and run CMake again. The exact version of each external dependencies used by libigl are recorded in the file cmake/LibiglDownloadExternal.cmake . GCC and the Optional CGAL Dependency \u00b6 The include/igl/copyleft/cgal/*.h headers depend on CGAL. It has come to our attention that CGAL does not work properly with GCC 4.8. To the best of our knowledge, GCC 4.7 and clang will work correctly. Please the FAQ for more details. OpenMP and Windows \u00b6 Some of our functions will take advantage of OpenMP if available. However, it has come to our attention that Visual Studio + Eigen + OpenMP does not work properly. Since we use OpenMP only to improve performance, we recommend avoiding OpenMP on Windows or proceeding with caution. Download \u00b6 You can keep up to date by cloning a read-only copy of our GitHub repository . Known Issues \u00b6 We rely heavily on Eigen. Nearly all inputs and outputs are Eigen matrices of some kind. However, we currently only officially support Eigen\u2019s default column-major ordering. That means, we do not expect our code to work for matrices using the Eigen::RowMajor flag. If you can, change definitions like: Eigen :: Matrix < double , Eigen :: Dynamic , 3 , Eigen :: RowMajor > A ; to Eigen :: Matrix < double , Eigen :: Dynamic , 3 , Eigen :: ColMajor > A ; // or simply Eigen :: Matrix < double , Eigen :: Dynamic , 3 > A ; We hope to fix this, or at least identify which functions are safe (many of them probably work just fine). This requires setting up unit testing, which is a major todo for our development. Unit Testing \u00b6 As of v2.0.0, unit tests have been moved into the main libigl repository, under the tests/ folder. Unit test data is downloaded at CMake time if the option LIBIGL_BUILD_TESTS=ON is given. Please read this page for more information about unit testing in libigl. How to Contribute \u00b6 If you are interested in joining development, please fork the repository and submit a pull request with your changes. libigl follows strict coding guidelines, please take a look at our style guidelines before submitting your pull requests. License \u00b6 libigl is primarily MPL2 licensed ( FAQ ). Some files contain third-party code under other licenses. We\u2019re currently in the processes of identifying these and marking appropriately. Citation \u00b6 If you use libigl in your academic projects, please cite the papers we implement as appropriate. To cite the library in general, you could use this BibTeX entry: @misc { libigl , title = { {libigl}: A simple {C++} geometry processing library} , author = {Alec Jacobson and Daniele Panozzo and others} , note = {https://libigl.github.io/} , year = {2018} , } Projects/Universities using libigl \u00b6 Libigl is used by many research groups around the world. In 2015, it won the Eurographics/ACM Symposium on Geometry Processing software award. Here are a few labs/companies/institutions using libigl: Activision Adobe Research Electronic Arts, Inc Epic Games Google Research Industrial Light and Magic Mesh consultants , Canada Microsoft Research Pixar Spine by Esoteric Software is an animation tool dedicated to 2D characters. vvvv toolkit a multipurpose tookit Columbia University, Columbia Computer Graphics Group , USA Cornell University , USA Czech Technical University in Prague , Czech EPF Lausanne, Computer Graphics and Geometry Laboratory , Switzerland ETH Zurich, Interactive Geometry Lab and Advanced Technologies Lab , Swizterland George Mason University, CraGL , USA Hong Kong University of Science and Technology , Hong Kong Inria, Universit\u00e9 Grenoble Alpes , France Jiangnan university , China National Institute of Informatics , Japan New York University, Media Research Lab , USA NYUPoly, Game Innovation Lab , USA TU Berlin , Germany TU Delft , Netherlands TU Wien , Austria Telecom ParisTech , Paris, France UBISOFT , USA Utrecht University , The Netherlands Universidade Federal de Santa Catarina , Brazil University College London , England University of California Berkeley , USA University of Cambridge , England University of Pennsylvania , USA University of Texas at Austin , USA University of Toronto , Canada University of Victoria , Canada University of Wisconsin-Eau Claire , USA Universit\u00e0 della Svizzera Italiana , Switzerland Universit\u00e9 Toulouse III Paul Sabatier , France Zhejiang University , China Contact \u00b6 Libigl is a group endeavor led by Alec Jacobson and Daniele Panozzo . Please contact us if you have questions or comments. For troubleshooting, please post an issue on github. If you\u2019re using libigl in your projects, quickly drop us a note . Tell us who you are and what you\u2019re using it for. This helps us apply for funding and justify spending time maintaining this. If you find bugs or have problems please use our github issue tracking page . Copyright \u00b6 2019 Alec Jacobson, Daniele Panozzo, Christian Sch\u00fcller, Olga Diamanti, Qingnan Zhou, Sebastian Koch, Jeremie Dumas, Amir Vaxman, Nico Pietroni, Stefan Brugger, Kenshi Takayama, Wenzel Jakob, Nikolas De Giorgis, Luigi Rocca, Leonardo Sacht, Kevin Walliman, Olga Sorkine-Hornung, Teseo Schneider, and others. Please see individual files for appropriate copyright notices.","title":"Home"},{"location":"#libigl-a-simple-c-geometry-processing-library","text":"libigl is a simple C++ geometry processing library. We have a wide functionality including construction of sparse discrete differential geometry operators and finite-elements matrices such as the cotangent Laplacian and diagonalized mass matrix, simple facet and edge-based topology data structures, mesh-viewing utilities for OpenGL and GLSL, and many core functions for matrix manipulation which make Eigen feel a lot more like MATLAB. It is a header-only library . You do not need to compile anything to use, just include igl headers (e.g. #include <igl/cotmatrix.h> ) and run. Each header file contains a single function (e.g. igl/cotmatrix.h contains igl::cotmatrix() ). Most are tailored to operate on a generic triangle mesh stored in an n-by-3 matrix of vertex positions V and an m-by-3 matrix of triangle indices F . Optionally the library may also be pre-compiled into a statically linked library, for faster compile times with your projects. This only effects compile time (run-time performance and behavior is identical). If in doubt, use the header-only default mode: (i.e. just include the headers you want to use). We use the Eigen library heavily in our code. Our group prototypes a lot in MATLAB, and we have a useful MATLAB to libigl+Eigen conversion table . We regularly test compiling our library on Mac OS X with clang, Linux with gcc and Windows with Visual Studio 2015 Community Edition.","title":"libigl - A simple C++ geometry processing library"},{"location":"#short-video-introduction","text":"","title":"Short Video Introduction"},{"location":"#tutorial","text":"As of version 1.0, libigl includes an introductory tutorial that covers many functionalities.","title":"Tutorial"},{"location":"#libigl-example-project","text":"We provide a blank project example showing how to use libigl and cmake. Feel free and encouraged to copy or fork this project as a way of starting a new personal project using libigl.","title":"libigl Example Project"},{"location":"#coding-guidelines-and-tips","text":"libigl follows strict coding guidelines, please take a look here before submitting your pull requests. We also have a set of general coding tips on how to code a geometry processing research project.","title":"Coding Guidelines and Tips"},{"location":"#installation","text":"Libigl is a header-only library. You do not need to build anything to install. Simply add libigl/include to your include path and include relevant headers. Here is a small \u201cHello, World\u201d program: #include <igl/cotmatrix.h> #include <Eigen/Dense> #include <Eigen/Sparse> #include <iostream> int main () { Eigen :: MatrixXd V ( 4 , 2 ); V << 0 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ; Eigen :: MatrixXi F ( 2 , 3 ); F << 0 , 1 , 2 , 0 , 2 , 3 ; Eigen :: SparseMatrix < double > L ; igl :: cotmatrix ( V , F , L ); std :: cout << \"Hello, mesh: \" << std :: endl << L * V << std :: endl ; return 0 ; } If you save this in hello.cpp , then you could compile this with (assuming Eigen is installed in /usr/local/include/eigen3 ): g++ -std = c++11 -lpthread -I/usr/local/include/eigen3 -I./libigl/include/ hello.cpp -o hello Running ./hello would then produce Hello, mesh: 0.5 0.5 -0.5 0.5 -0.5 -0.5 0.5 -0.5","title":"Installation"},{"location":"#dependencies","text":"Dependencies are on a per-include basis and the majority of the functions in libigl depends only on the Eigen library. For more information see our tutorial .","title":"Dependencies"},{"location":"#optional-dependencies","text":"Libigl compartmentalizes its optional dependences via its directory organization in the include/ folder. All header files located directly in the include/igl/ folder have only stl and Eigen as dependencies. For example, all of the headers that depend on CGAL are located in include/igl/copyleft/cgal . For a full list of optional dependencies check cmake/libigl.cmake . CGAL and Boost By default, the CMake script for libigl will not build the CGAL dependency, since Boost is required to compile CGAL. If you enable the CMake option LIBIGL_WITH_CGAL , you will need to have Boost installed on your machine. On Windows , it is advised to install Boost using conda . On Linux and macOS , you will need to install Boost, GMP and MPFR using your favorite package manager (CGAL itself will be downloaded by libigl).","title":"Optional Dependencies"},{"location":"#downloading-dependencies","text":"Libigl uses CMake\u2019s ExternalProject_Add to manage external dependencies. External libraries are build statically with libigl using CMake. In order to be included in the CMake script via add_subdirectory , the third-party content is fetched at CMake time using the DownloadProject.cmake script (which has been introduced in CMake itself with the command FetchContent in CMake 3.11). There is not much to know about this, other than the content will be fetched the first time you run CMake, and placed into the external/ folder. If something goes wrong with your dependencies, simply erase your external/ folder and run CMake again. The exact version of each external dependencies used by libigl are recorded in the file cmake/LibiglDownloadExternal.cmake .","title":"Downloading Dependencies"},{"location":"#gcc-and-the-optional-cgal-dependency","text":"The include/igl/copyleft/cgal/*.h headers depend on CGAL. It has come to our attention that CGAL does not work properly with GCC 4.8. To the best of our knowledge, GCC 4.7 and clang will work correctly. Please the FAQ for more details.","title":"GCC and the Optional CGAL Dependency"},{"location":"#openmp-and-windows","text":"Some of our functions will take advantage of OpenMP if available. However, it has come to our attention that Visual Studio + Eigen + OpenMP does not work properly. Since we use OpenMP only to improve performance, we recommend avoiding OpenMP on Windows or proceeding with caution.","title":"OpenMP and Windows"},{"location":"#download","text":"You can keep up to date by cloning a read-only copy of our GitHub repository .","title":"Download"},{"location":"#known-issues","text":"We rely heavily on Eigen. Nearly all inputs and outputs are Eigen matrices of some kind. However, we currently only officially support Eigen\u2019s default column-major ordering. That means, we do not expect our code to work for matrices using the Eigen::RowMajor flag. If you can, change definitions like: Eigen :: Matrix < double , Eigen :: Dynamic , 3 , Eigen :: RowMajor > A ; to Eigen :: Matrix < double , Eigen :: Dynamic , 3 , Eigen :: ColMajor > A ; // or simply Eigen :: Matrix < double , Eigen :: Dynamic , 3 > A ; We hope to fix this, or at least identify which functions are safe (many of them probably work just fine). This requires setting up unit testing, which is a major todo for our development.","title":"Known Issues"},{"location":"#unit-testing","text":"As of v2.0.0, unit tests have been moved into the main libigl repository, under the tests/ folder. Unit test data is downloaded at CMake time if the option LIBIGL_BUILD_TESTS=ON is given. Please read this page for more information about unit testing in libigl.","title":"Unit Testing"},{"location":"#how-to-contribute","text":"If you are interested in joining development, please fork the repository and submit a pull request with your changes. libigl follows strict coding guidelines, please take a look at our style guidelines before submitting your pull requests.","title":"How to Contribute"},{"location":"#license","text":"libigl is primarily MPL2 licensed ( FAQ ). Some files contain third-party code under other licenses. We\u2019re currently in the processes of identifying these and marking appropriately.","title":"License"},{"location":"#citation","text":"If you use libigl in your academic projects, please cite the papers we implement as appropriate. To cite the library in general, you could use this BibTeX entry: @misc { libigl , title = { {libigl}: A simple {C++} geometry processing library} , author = {Alec Jacobson and Daniele Panozzo and others} , note = {https://libigl.github.io/} , year = {2018} , }","title":"Citation"},{"location":"#projectsuniversities-using-libigl","text":"Libigl is used by many research groups around the world. In 2015, it won the Eurographics/ACM Symposium on Geometry Processing software award. Here are a few labs/companies/institutions using libigl: Activision Adobe Research Electronic Arts, Inc Epic Games Google Research Industrial Light and Magic Mesh consultants , Canada Microsoft Research Pixar Spine by Esoteric Software is an animation tool dedicated to 2D characters. vvvv toolkit a multipurpose tookit Columbia University, Columbia Computer Graphics Group , USA Cornell University , USA Czech Technical University in Prague , Czech EPF Lausanne, Computer Graphics and Geometry Laboratory , Switzerland ETH Zurich, Interactive Geometry Lab and Advanced Technologies Lab , Swizterland George Mason University, CraGL , USA Hong Kong University of Science and Technology , Hong Kong Inria, Universit\u00e9 Grenoble Alpes , France Jiangnan university , China National Institute of Informatics , Japan New York University, Media Research Lab , USA NYUPoly, Game Innovation Lab , USA TU Berlin , Germany TU Delft , Netherlands TU Wien , Austria Telecom ParisTech , Paris, France UBISOFT , USA Utrecht University , The Netherlands Universidade Federal de Santa Catarina , Brazil University College London , England University of California Berkeley , USA University of Cambridge , England University of Pennsylvania , USA University of Texas at Austin , USA University of Toronto , Canada University of Victoria , Canada University of Wisconsin-Eau Claire , USA Universit\u00e0 della Svizzera Italiana , Switzerland Universit\u00e9 Toulouse III Paul Sabatier , France Zhejiang University , China","title":"Projects/Universities using libigl"},{"location":"#contact","text":"Libigl is a group endeavor led by Alec Jacobson and Daniele Panozzo . Please contact us if you have questions or comments. For troubleshooting, please post an issue on github. If you\u2019re using libigl in your projects, quickly drop us a note . Tell us who you are and what you\u2019re using it for. This helps us apply for funding and justify spending time maintaining this. If you find bugs or have problems please use our github issue tracking page .","title":"Contact"},{"location":"#copyright","text":"2019 Alec Jacobson, Daniele Panozzo, Christian Sch\u00fcller, Olga Diamanti, Qingnan Zhou, Sebastian Koch, Jeremie Dumas, Amir Vaxman, Nico Pietroni, Stefan Brugger, Kenshi Takayama, Wenzel Jakob, Nikolas De Giorgis, Luigi Rocca, Leonardo Sacht, Kevin Walliman, Olga Sorkine-Hornung, Teseo Schneider, and others. Please see individual files for appropriate copyright notices.","title":"Copyright"},{"location":"before-submitting-pull-request/","text":"Before Submitting A Pull Request \u00b6 There are a variety of things you can do before submitting a pull request that will reduce the effort on the libigl team to merge your code and increase the likelihood that the merge ever happens. Make sure you are up-to-date with the master branch to create your pull request. Test your code and submit a unit test as part of the pull request; Verify that your code matches the libigl style guidelines ; Tip When opening a pull-request to fix a known bug, you can link to and existing github issue or pull-request by mentioning their number in your message. See for example #954 . Compilation Using Static Library \u00b6 If you are using libigl in header-only mode, please ensure that your code also compiles when enabling the CMake flag LIBIGL_USE_STATIC_LIBRARY : mkdir build-use-static cd build-use-static cmake -DCMAKE_BUILD_TYPE = Release -DLIBIGL_USE_STATIC_LIBRARY = ON .. make make test Troubleshooting \u00b6 A typical issue is a missing template instantiation (symbol not found): \"void igl::cgal::points_inside_component<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&)\", referenced from: void igl::cgal::outer_hull<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<long, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> >&, Eigen::PlainObjectBase<Eigen::Matrix<long, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&) in libiglboolean.a(mesh_boolean.cpp.o) void igl::cgal::outer_hull<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<long, -1, 1, 0, -1, 1>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> >&, Eigen::PlainObjectBase<Eigen::Matrix<long, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<bool, -1, 1, 0, -1, 1> >&) in libiglboolean.a(mesh_boolean.cpp.o) This looks like a mess, but the solution is very simple. Copy the chunk inside of the quotes, in this case: \"void igl::cgal::points_inside_component<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&)\" and paste it at the bottom of the relevant .cpp file with the word template in front of it and a semicolon at then. In this case, in include/igl/cgal/points_inside_component.cpp: #ifdef IGL_STATIC_LIBRARY // Explicit template instantiation template void igl :: cgal :: points_inside_component < Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > , Eigen :: Matrix < int , -1 , 3 , 0 , -1 , 3 > , Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > , Eigen :: Matrix < int , -1 , 1 , 0 , -1 , 1 > > ( Eigen :: PlainObjectBase < Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > > const & , Eigen :: PlainObjectBase < Eigen :: Matrix < int , -1 , 3 , 0 , -1 , 3 > > const & , Eigen :: PlainObjectBase < Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > > const & , Eigen :: PlainObjectBase < Eigen :: Matrix < int , -1 , 1 , 0 , -1 , 1 > >& ); #endif Then \u201crinse and repeat\u201d.","title":"Creating a Pull Request"},{"location":"before-submitting-pull-request/#before-submitting-a-pull-request","text":"There are a variety of things you can do before submitting a pull request that will reduce the effort on the libigl team to merge your code and increase the likelihood that the merge ever happens. Make sure you are up-to-date with the master branch to create your pull request. Test your code and submit a unit test as part of the pull request; Verify that your code matches the libigl style guidelines ; Tip When opening a pull-request to fix a known bug, you can link to and existing github issue or pull-request by mentioning their number in your message. See for example #954 .","title":"Before Submitting A Pull Request"},{"location":"before-submitting-pull-request/#compilation-using-static-library","text":"If you are using libigl in header-only mode, please ensure that your code also compiles when enabling the CMake flag LIBIGL_USE_STATIC_LIBRARY : mkdir build-use-static cd build-use-static cmake -DCMAKE_BUILD_TYPE = Release -DLIBIGL_USE_STATIC_LIBRARY = ON .. make make test","title":"Compilation Using Static Library"},{"location":"before-submitting-pull-request/#troubleshooting","text":"A typical issue is a missing template instantiation (symbol not found): \"void igl::cgal::points_inside_component<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&)\", referenced from: void igl::cgal::outer_hull<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<long, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> >&, Eigen::PlainObjectBase<Eigen::Matrix<long, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&) in libiglboolean.a(mesh_boolean.cpp.o) void igl::cgal::outer_hull<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<long, -1, 1, 0, -1, 1>, Eigen::Matrix<bool, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> >&, Eigen::PlainObjectBase<Eigen::Matrix<long, -1, 1, 0, -1, 1> >&, Eigen::PlainObjectBase<Eigen::Matrix<bool, -1, 1, 0, -1, 1> >&) in libiglboolean.a(mesh_boolean.cpp.o) This looks like a mess, but the solution is very simple. Copy the chunk inside of the quotes, in this case: \"void igl::cgal::points_inside_component<Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 3, 0, -1, 3>, Eigen::Matrix<double, -1, 3, 0, -1, 3>, Eigen::Matrix<int, -1, 1, 0, -1, 1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 0, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1> >&)\" and paste it at the bottom of the relevant .cpp file with the word template in front of it and a semicolon at then. In this case, in include/igl/cgal/points_inside_component.cpp: #ifdef IGL_STATIC_LIBRARY // Explicit template instantiation template void igl :: cgal :: points_inside_component < Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > , Eigen :: Matrix < int , -1 , 3 , 0 , -1 , 3 > , Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > , Eigen :: Matrix < int , -1 , 1 , 0 , -1 , 1 > > ( Eigen :: PlainObjectBase < Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > > const & , Eigen :: PlainObjectBase < Eigen :: Matrix < int , -1 , 3 , 0 , -1 , 3 > > const & , Eigen :: PlainObjectBase < Eigen :: Matrix < CGAL :: Lazy_exact_nt < CGAL :: Gmpq > , -1 , 3 , 0 , -1 , 3 > > const & , Eigen :: PlainObjectBase < Eigen :: Matrix < int , -1 , 1 , 0 , -1 , 1 > >& ); #endif Then \u201crinse and repeat\u201d.","title":"Troubleshooting"},{"location":"bug-report/","text":"Before opening an issue on creating a pull request, please check the following: Tip Make sure you read the FAQ before asking a new question, search existing issues for a problem similar to yours. Make sure you read the information contained in the libigl homepage as well as the tutorial . General Issues \u00b6 Make sure you are up-to-date with the main branch, and verify that your issue has not been fixed already before opening an issue on github. To report a problem about the website (out-of-date content, erroneous instructions or errors in the tutorial), please open your issue in the designated repository for the website. Compilation Issues \u00b6 If you are on Windows, did you select the x64 version of the Visual Studio compiler? If you have a CMake issue , make sure you follow the same approach as the libigl-example-project to build libigl with your project, and make sure that you can compile the example project. Please also make sure to delete your CMakeCache.txt , or delete your build/ folder and try again. If you have an issue with a submodule , then you are using an old version of libigl. Please read this page about the transition to v2.0.0. If you have an issue with downloading an external dependency using the CMake build, delete the external/ folder and try again. If you have an issue with a missing template , check that your code compiles with the header-only option of libigl activated. Turn OFF the CMake option LIBIGL_USE_STATIC_LIBRARY : either modify your CMakeCache.txt via CMake GUI or ccmake, or delete your CMakeCache.txt and re-run cmake -DLIBIGL_USE_STATIC_LIBRARY=OFF .. in your build folder. If none of these solve your problem, then please report your issue in the bug tracker!","title":"Bug Report"},{"location":"bug-report/#general-issues","text":"Make sure you are up-to-date with the main branch, and verify that your issue has not been fixed already before opening an issue on github. To report a problem about the website (out-of-date content, erroneous instructions or errors in the tutorial), please open your issue in the designated repository for the website.","title":"General Issues"},{"location":"bug-report/#compilation-issues","text":"If you are on Windows, did you select the x64 version of the Visual Studio compiler? If you have a CMake issue , make sure you follow the same approach as the libigl-example-project to build libigl with your project, and make sure that you can compile the example project. Please also make sure to delete your CMakeCache.txt , or delete your build/ folder and try again. If you have an issue with a submodule , then you are using an old version of libigl. Please read this page about the transition to v2.0.0. If you have an issue with downloading an external dependency using the CMake build, delete the external/ folder and try again. If you have an issue with a missing template , check that your code compiles with the header-only option of libigl activated. Turn OFF the CMake option LIBIGL_USE_STATIC_LIBRARY : either modify your CMakeCache.txt via CMake GUI or ccmake, or delete your CMakeCache.txt and re-run cmake -DLIBIGL_USE_STATIC_LIBRARY=OFF .. in your build folder. If none of these solve your problem, then please report your issue in the bug tracker!","title":"Compilation Issues"},{"location":"changelog/","text":".md-nav--secondary .md-nav__list .md-nav__list { display: none } Changelog \u00b6 Version Summary Table \u00b6 Click to unroll. Version Short description main \u2026 2.4.0 Bug fixes, CMake tidying, imgui widgets, broad M1 mac support, dependency bumps 2.3.0 Dual Contouring, DDM skinning, B\u00e9zier, PLY reader, 3D text rendering, matcap 2.2.0 New python bindings, fast winding number for soups, ICP algorithm 2.1.0 Various improvements and bug fixes, updated dependencies 2.0.0 Lighter, simpler CMake build, rewritten history 1.3.3 Switched the build system from submodules to CMake external projects 1.3.2 After merging PRs in the 2018 hackaton 1.3.1 Before merging PRs in the 2018 hackaton 1.3.0 Modernized cmake build, multi-mesh viewer, replace nanogui with imgui 1.2.1 Reorganization opengl-dependent functions: opengl and opengl2 extras 1.2.0 Reorganization of \u201cextras\u201d, rm deprecated funcs, absorb boost & svd3x3 1.1.7 Switch build for static library to cmake. 1.1.6 Major boolean robustness fix, drop CGAL dependency for AABB/distances 1.1.5 Bug fix in booleans 1.1.4 Edge collapsing and linear program solving 1.1.3 Bug fixes in active set and boundary_conditions 1.1.1 PLY file format support 1.1.0 Mesh boolean operations using CGAL and cork, implementing [Attene 14] 1.0.3 Bone heat method 1.0.2 Bug fix in winding number code 1.0.1 Bug fixes and more CGAL support 1.0.0 Major beta release: many renames, tutorial, triangle, org. build 0.4.6 Generalized Winding Numbers 0.4.5 CGAL extra: mesh selfintersection 0.4.4 STL file format support 0.4.3 ARAP implementation 0.4.1 Migrated much of the FAST code including extra for Sifakis\u2019 3x3 svd 0.4.0 Release under MPL2 license 0.3.7 Embree2.0 support 0.3.6 boost extra, patches, mosek 7 support, libiglbbw (mosek optional) 0.3.5 More examples, naive primitive sorting 0.3.3 Many more examples, ambient occlusion with Embree. 0.3.1 Linearly dependent constraints in min_quad_with_fixed, SparseQR buggy 0.3.0 Better active set method support 0.2.3 More explicits, active set method, opengl/anttweakbar guards 0.2.2 More explicit instantiations, faster sorts and uniques 0.2.1 Bug fixes in barycenter and doublearea found by Martin Bisson 0.2.0 XML serializer more stable and fixed bug in remove_duplicate_vertices 0.1.8 Embree and xml (windows only) extras 0.1.5 Compilation on windows, bug fix for compilation with cygwin 0.1.1 Alpha release with core functions, extras, examples Upcoming Version 2.5.0 Changes \u00b6 The following changes are represent in the main branch of libigl, but not yet included in a tagged release. Bugfixes \u00b6 ViewerData::set_data() now accepts #F-long data vectors ( 1f44d1e ) Enhancements \u00b6 ismember_rows split into its own file (may need to change #include <igl/ismember.h> to #include <igl/ismember_rows.h> ( #1989 ) igl::predicates::delaunay_triangulation and igl::predicates::lexicographic_triangulation routines ( #1988 ) properly expose edge-markers in igl::triangle::triangulate ( #1983 ) Compilation \u00b6 Version 2.4.0 Changes \u00b6 Breaking Changes \u00b6 Libigl v2.4.0 introduced a number of breaking changes regarding its CMake build system . If you follow the upgrade guide below, these breaking changes should be easy to resolve. Tip When starting a new project using libigl, use the libigl-example-project as a starting point. CMake entry point \u00b6 The main entry point for CMake is now the CMakeLists.txt at the root of the libigl repository. If you were using a FindLibigl.cmake , or were including libigl.cmake directly, please update your project. If you are using the libigl-example-project , you may update the content of cmake/libigl.cmake to the following: if ( TARGET igl::core ) return () endif () include ( FetchContent ) FetchContent_Declare ( libigl GIT_REPOSITORY https://github.com/libigl/libigl.git GIT_TAG <TARGET_SHA1> ) FetchContent_MakeAvailable ( libigl ) CMake targets \u00b6 The CMake targets for many libigl modules have been renamed in v2.4.0. This provides greater visibility into each module category (between regular, copyleft and restricted modules). Here is the table mapping the old names to the new names: Old target name (v2.3.0) New target name (v2.4.0) igl::embree Unchanged igl::opengl_glfw igl::glfw igl::opengl_glfw_imgui igl::imgui igl::opengl Unchanged igl::png Unchanged igl::predicates Unchanged igl::xml Unchanged igl_copyleft::core ( New ) igl::cgal igl_copyleft::cgal igl::comiso igl_copyleft::comiso igl::cork Removed igl::tetgen igl_copyleft::tetgen igl::matlab igl_restricted::matlab igl::mosek igl_restricted::mosek igl::triangle igl_restricted::triangle Important The libigl cork wrapper was removed from this release. A standalone repository with a libigl-style wrapper around cork is available here . CMake options \u00b6 Many libigl CMake options have changed in v2.4.0. Here is a mapping from the old name to the new names: Old option (v2.3.0) New option (v2.4.0) LIBIGL_COPYLEFT_CORE ( New ) LIBIGL_BUILD_TESTS Unchanged LIBIGL_BUILD_TUTORIALS Unchanged LIBIGL_EXPORT_TARGETS LIBIGL_INSTALL LIBIGL_USE_STATIC_LIBRARY Unchanged LIBIGL_WITH_CGAL LIBIGL_COPYLEFT_CGAL LIBIGL_WITH_COMISO LIBIGL_COPYLEFT_COMISO LIBIGL_WITH_CORK Removed LIBIGL_WITH_EMBREE LIBIGL_EMBREE LIBIGL_WITH_MATLAB LIBIGL_RESTRICTED_MATLAB LIBIGL_WITH_MOSEK LIBIGL_RESTRICTED_MOSEK LIBIGL_WITH_OPENGL LIBIGL_OPENGL LIBIGL_WITH_OPENGL_GLFW LIBIGL_GLFW LIBIGL_WITH_OPENGL_GLFW_IMGUI LIBIGL_IMGUI LIBIGL_WITH_PNG LIBIGL_PNG LIBIGL_WITH_PREDICATES LIBIGL_PREDICATES LIBIGL_WITH_PYTHON Removed LIBIGL_WITH_TETGEN LIBIGL_COPYLEFT_TETGEN LIBIGL_WITH_TRIANGLE LIBIGL_RESTRICTED_TRIANGLE LIBIGL_WITH_XML Unchanged Tip There is a now a sample file LibiglOption.cmake.sample at the root of the libigl repository. Simply remove the .sample extension and edit this file to modify libigl compilation options. If you are using libigl as a subdirectory (e.g. in a parent project), then please set your options in the parent project instead. ImGui headers \u00b6 We are also updating our ImGui dependency to use the base repository as include folder, rather than forcing headers to be copied into a imgui/ subfolder. This helps be consistent with other projects that might be using ImGui. This requires users changing their include headers as follows: #include <imgui/imgui.h> \u2192 #include <imgui.h> #include <imgui/imgui_internal.h> \u2192 #include <imgui_internal.h> #include <imgui_impl_glfw.h> \u2192 #include <backends/imgui_impl_glfw.h> #include <imgui_impl_opengl3.h> \u2192 #include <backends/imgui_impl_opengl3.h> ImGuiMenu,ImGuizmoPlugin,SelectionPlugin \u2192 ImGuiWidgets \u00b6 We\u2019ve introduced a new \u201cparent\u201d ImGuiPlugin which handles ImGui IO functions and converted the old ImGuiMenu , ImGuizmoPlugin , SelectionPlugin plugins to inherit from a new ImGuiWidget class. In this way, a single ImGuiPlugin can be registered to the viewer\u2019s plugins list and one or many widgets are registered to this plugin\u2019s widgets list. For folks just using the menu, this incurs a few extra lines. To add the menu: #include <igl/opengl/glfw/imgui/ImGuiPlugin.h> #include <igl/opengl/glfw/imgui/ImGuiMenu.h> \u2026 igl :: opengl :: glfw :: imgui :: ImGuiPlugin plugin ; viewer . plugins . push_back ( & plugin ); igl :: opengl :: glfw :: imgui :: ImGuiMenu menu ; plugin . widgets . push_back ( & menu ); The reward is that now we can use all of these plugins (and any new user created plugins using ImGui subroutines) without conflict. Other Changes \u00b6 Bugfixes \u00b6 Fix #1656 \u201cCan only have one ImGuiMenu plugin at a time\u201d ( #1973 ) Fix #1924 \u201cPLY with no faces throw SIGFPE in ReadPLY\u201d ( #1927 ) LSCM: fix sign for the area term ( #1853 ) Fix bug in igl::read_file_binary ( #1821 ) Fix #1795 \u201cCan\u2019t convert CGAL::Polyhedron_3 to mesh\u201d ( #1796 ) Fix the order of principal curvature ( #1767 ) Fix dirty flag for ViewerData::set_labels ( #1761 ) Enhancements \u00b6 Modified arap interface to accept Eigen::Map ( #1922 ) Wrapper around CGAL\u2019s 2D constrained delaunay triangulation ( #1811 ) Delete obsolete function igl::point_in_poly ( #1810 ) Instead of calling exit(1), triangle now throws an exception ( #1800 ) Use igl::default_num_threads in cgal module ( #1768 ) Added double_sided flag to embree renderer ( #1765 ) Replace Eigen::PlainObjectBase with Eigen::MatrixBase for input of ambient_occlusion ( #1752 ) 10-100x speedup on per corner normals + caching adjacency ( #1745 ) Compilation \u00b6 Update Catch2 to v2.13.8 ( #1972 ) Update Embree to v13.3.3 ( #1976 ) Broad support for M1 macs ( #1976 , #1975 ) Update ImGui to v1.85 + use default include folders for ImGui ( #1970 ) CMake refactor ( #1805 ) CGAL and Boost are now built entirely from source via CMake. This means the CGAL module will work out of the box under Windows \u2013 no need for a conda virtual environment. On Linux/macOS, the only dependency to install system-wide are GMP+MPFR. CMake targets and options have been renamed based on the module category: regular/copyleft/restricted. This eliminates long module names ( igl::open_glfw_imgui ) that didn\u2019t bring much to the table, in favor of three root classes based on available licenses for each module. There is now a LibiglOptions.cmake sample file at the root of the project repository, which should make it easier to document/update available CMake options. There is now a unique entry point for the project, which is the root CMakeLists.txt . This facilitates maintenance, as before either tutorial/CMakeLists.txt and cmake/libigl.cmake could serve as potential entry points. The default behavior for module compilation is: When compiling libigl on its own, all modules are enabled by default. When compiling libigl as a subproject, all modules are disabled by default. On Linux/macOS, if GMP/MPFR is not installed on the system, shows a warning and disable CGAL by default. If Mosek/Matlab are not installed on the system, shows a warning and disable the Mosek/Matlab libigl wrappers respectively. If the user explicitly enables those modules, but they do not have GMP/MPFR/Mosek/Matlab installed on the system, CMake configuration will fail. Big cleanup of the tutorial CMake definitions. With the new setup adding a new tutorial is even easier! Cleaned up dependency setup for imgui/stb (among others) Unit tests have been split into different CMake target, based on which module is tested. Add support for Hunter + install() for the igl::core module (should be the same as before). Use a more generic igl_copy_dll() function to copy GMP/MPFR dlls on Windows (should work to copy the CoMiSo dll as well). Cleaned up our .gitignore file. Fix blue noise random shuffle for C++17 ( #1949 ) Bump triangle version ( #1813 ) and tetgen version ( #1815 ) Templates EmbreeRenderer ( #1788 ) Fix Cuda compilation issue on Windows ( #1747 ) Split min_quad_with_fixed implementation into separate cpp ( #1746 ) Silence MSVC warning with std::getenv ( #1744 ) Fix usage of find_package(OpenGL) on Linux ( #1733 ) Version 2.3.0 Changes \u00b6 Warning This is our last stable release before some planned major reorganization (see #1696 for details). The upcoming reorganization is aimed at facilitating maintenance and packaging of various libigl components. The next release will be a new major version of libigl (3.0.0). New Features \u00b6 Dual contouring ( #1716 ) Viewer: Selection Plugin ( #1654 ) Implements \u201c Polygon Laplacian Made Simple \u201d ( #1653 ) Offscreen meshes rendering using Embree ( #1652 ) Signing distances with Fast Winding Number ( #1630 ) Turn ImGuizmo tutorial into a viewer plugin ( #1618 ) Adds MATLAB-like function igl::blkdiag to build a block-diagonal matrix ( #1617 ) Kelvinlet mesh deformation ( #1614 ) Blue noise sampling on triangle meshes + adds igl::barycentric_interpolation ( #1597 ) Direct Delta Mush skinning ( #1541 ) New exploded view tutorial ( #1510 ) B\u00e9zier curve evaluation ( igl::bezier ) and fitting ( igl::fit_cubic_bezier ) ( #1476 ) Replace .ply reader/writer with tinyply library ( #1422 ) igl::copyleft::cgal::wire_mesh now support per-edge thickness. Adds igl::copyleft::cgal::coplanar test ( #1488 ) New generic function for connected components ( igl::connected_components ) ( #1487 ) Viewer: matcap support ( #1482 ) + tutorial entry ( #1646 ) Viewer: option for double-sided lighting ( #1480 ) Viewer: new 3D text rendering feature, supporting proper label depth ( #1549 ) Build System \u00b6 Update ImGui to 1.81 ( #1723 ), fixing rendering issue with newer Visual Studio Fix mosek to work with 9.2; fix mosek dynamic link via CMake ( #1675 ) Reimplement igl::marching_cubes outside of the copyleft/ folder ( #1666 , #1687 ) Update GLFW to fix an issue on macOS with CMake 3.19.0 ( #1657 ) Update Embree to v3.12.1 ( #1648 ) Use new gitlab remote to clone Eigen ( #1631 ) Update compiler versions in github actions ( #1629 ) Update CoMiSo version ( #1608 ). Note that CoMiSo support for libigl is deprecated and will be removed in version 3.0. Removed _bin suffix from executable files ( #1594 ) Moved SCAF to triangle folder ( #1590 ) Various fixes to github actions ( #1649 , #1651 , #1721 ) Misc \u00b6 Control number of threads in parallel_for with env variable IGL_NUM_THREADS ( #1684 ) Support msh in igl::read_triangle_mesh ( #1645 ) Change boundary weight from length to length squared in igl::per_vertex_point_to_plane_quadrics ( #1644 ) Update STL read to work on problematic thingi10K meshes ( #1628 ) Use an enum to specify file encoding when writing files ( #1619 ) Removed some functions marked as deprecated ( #1610 ) Fix bug with epsilon parameter in igl::remove_duplicate_vertices ( #1603 ) Removed unused function igl::barycentric_to_global ( #1596 ) Fix align_camera_center in Viewer::init() for multiple cores ( #1349 ) Add floating point exceptions in unit tests ( #1001 ) Extended serialization functionality to Eigen::Array ( #1113 ) SCAF: Expose linear system to be solved by user code ( #1553 ) Fix issue with igl::heat_geodesic ( #1497 ) Refactored igl::is_edge_manifold ( #1509 ) Various bugfixes, compile fixes, template fixes ( #1335 , #1361 , #1400 , #1402 , #1430 , #1438 , #1441 , #1471 , #1475 , #1484 , #1494 , #1495 , #1497 , #1525 , #1538 , #1544 , #1546 , #1581 , #1582 , #1625 , #1627 , #1638 , #1640 , #1642 , #1658 , #1673 , #1674 , #1679 , #1694 , #1704 , #1709 ) Version 2.2.0 Changes \u00b6 Python Bindings \u00b6 The python bindings have been moved to a separate repository . These are now available as an conda package . New Features \u00b6 Fast winding number for triangle soups ( #1218 ) Iterative closest point algorithm + tutorial ( #1347 ) Ear clipping triangulation ( #1169 ) Added igl::path_to_edges function ( #1259 ) igl::dijkstra can now use mesh edge length ( #1170 ) Keep reference to multiple material when reading obj ( #1280 ) Added igl::sharp_edges for sharp edges extraction ( #1364 ) Added igl::unproject_on_line , igl::unproject_on_plane and igl::projection_constraint to compute cursor (un)-projections ( #1368 ) Added igl::quad_grid and igl::triangulated_grid to create meshes from regular grids ( #1369 ) Added igl::isolines_map , ViewerData::set_data and ViewerData::set_colormap to improve scalar field visualization in the Viewer, and updated tutorials accordingly ( #1371 ) Added new COLOR_MAP_TYPE_TURBO colormap, based on Turbo . Jet is now an alias for Turbo, and switched to Viridis as default colormap in the viewer ( #1372 ) Added igl::slice_sorted and removed deprecated Eigen::DynamicSparsematrix from igl::slice ( #1370 ) Build System \u00b6 Overhauled function signatures in preparation of new python bindings ( #1162 , #1228 , #1271 , #1274 ) Added a conda environment cmake/libigl-cgal.yml to provide boost for Windows users ( #1239 ) Added experimental support for Hunter ( #1242 ) Now libigl.cmake will define a CMake target Eigen3::Eigen if not provided by the user ( #1299 ) Added igl_set_folders() to sort CMake targets into folders in IDEs such as Visual Studio or Xcode ( #1383 ) Minor fixes to our CMake build system ( #1363 ) Github actions for CI replacing appveyor and travis ( #1389 ) Misc \u00b6 Fix underflow issue when computing normalization in igl::heat_geodesics ( #1344 ) Update nrosy to match the MIQ paper ( #1303 ) Delete Embree_convenience.h ( #1314 ) Refactored igl::cut_mesh ( #1332 ) Various improvements to the viewer ( #1196 , #1251 , #1366 ) Unit tests: cleand up test_common.h ( #1365 ) Made call to igl::predicates::exactinit() thread-safe + marked internal functions in predicates.c as static to prevent name collisions ( #1377 ) Doc cleanup ( #1376 ) Allows igl::hsv_to_rgb to work on negative hues ( #1399 ) Explicitly marked the following functions as deprecated ( #1380 ): igl::all_edges igl::internal_angles_using_edge_lengths (only a specific overload is affected) igl::is_border_vertex (only a specific overload is affected) igl::remove_duplicates Various bugfixes, code cleanup and explicit template instantiations ( #1197 , #1210 , #1216 , #1231 , #1247 , #1258 , #1288 , #1309 , #1320 , #1337 , #1345 , #1379 , #1396 , #1327 ) Version 2.1.0 Changes \u00b6 Various code cleanup, compilation fixes, and explicit template instantiations Added wrapper around Shewchuk\u2019s predicates ( #1163 ) libigl now also compiles with Eigen 3.3 ( #1110 ). Extended igl::cat functionalities ( #1108 ) Extended boundary_facets with outputs revealing which element facet comes from ( #1067 ) Use std::shuffle instead of std::random_shuffle in igl/randperm ( #1062 ) Fixed an Eigen alignment issue in the viewer ( #1029 ) Removed LIM tutorial ( #1012 , #1014 ) Fixed current python bindings ( #1008 ) Intrinsic Delaunay triangulation ( #988 ) New Heat Geodesics feature ( #988 , #1140 ). See also tutorial 716. Switched from Google Test to Catch2 ( #961 ), and added various unit tests Fixed an issue with transparent window on macOS that was introduced in v2.0.0 ( #953 ) Updated dependencies: Embree 3 ( #947 ), GLFW ( #977 , #1153 ), ImGui ( #1039 ), std-image ( #1072 ) Added sparse voxel grids ( #937 , #942 ) and tutorial 715 for meshing implicit functions. Added tutorial 714 for marching tets ( #716 ) Version 2.0.0 Changes \u00b6 This release is a result of the 2018 libigl hackathon at NYU. The major changes are: a simplified cmake set up that can build a static library, tutorials, tests, and python bindings; cmake now uses ExternalProject_Add to download necessary/requested dependency source code and tutorial/test data as a result, git clone --recursive ... is no longer required unit tests are now part of main repo and included in continuous integration ( libigl/libigl-unit-tests is obsolete); tutorial data has been moved to libigl/libigl-tutorial-data ; unit test data has been moved to libigl/libigl-tests-data ; all dependencies previously in libigl/external have been removed or moved to repos (and added via ExternalProject_Add ); documentation and the tutorial webpage has been moved to libigl/libigl.github.io ; .git history of these files has been purged using bfg unfortunately this means that SHA hashes have changed and any external projects using libigl as a submodule will need to be refreshed to the new hashes. More information and instructions for troubleshooting at https://libigl.github.io/rewritten-history/ . A legacy version with SHA hashes matching old repo is hosted at libigl/libigl-legacy . The major upshot is that the old git clone --recursive that resulted in a 1.8GB libigl/ directory is now a git clone that results in 16.5MB, more than a 100x reduction in size. Name changes: Old New igl::components igl::vertex_components igl::slice_tets igl::marching_tets Version 1.3.2 Changes \u00b6 First version after all pull requests were merged during the libigl hackaton, and before switching from submodules to CMake external projects. Version 1.3.1 Changes \u00b6 Last version before pull requests were merged during the libigl hackaton. igl::components has been renamed to igl::vertex_components . viewer.core.model matrix is gone ( #700 ). Version 1.3.0 Changes \u00b6 List of changes related to this version: The CMake build system has been rewritten to be more modular and modern. libigl modules are now available as CMake target, e.g. igl::triangle or igl::opengl . See the libigl-example-project for an example of typical usage. igl/antweakbar and igl/opengl2 support has been removed from the CMake. The files are still available, but their use is discouraged. The viewer has been refactored and now supports multiple meshes. See related tutorial entry for more information. The viewer files are now split according to their dependencies. E.g. igl::viewer::Viewer has been renamed igl::opengl::glfw::Viewer . NanoGui has been replaced by ImGui, and is now available as a viewer plugin instead of #define Polyvector code has been moved to libdirectional ( #630 ). Version 1.2 Changes \u00b6 This change introduces better organization of dependencies and removes some deprecated/repeated functions. The 3x3 svd code and dependent functions (including ARAP) were absorbed into the main library. Similarly, the boost dependency extra was absorbed. External libraries as git subrepos \u00b6 The core functionality of libigl (still) just depends on stl, c++11 and Eigen. There are additional optional dependencies (e.g. CGAL, embree, glfw, tetgen, triangle). Libigl functions using these are located (still) in sub-folders of the include directory (e.g. include/igl/cgal/ , include/igl/embree/ ). Prior to version 1.2 we included copies of the code for some of these dependencies in the external/ directory. As of version 1.2, these have been replaced with git sub-repos. If you have cloned libigl before version 1.2 then you should issue git submodule update --init --recursive Deprecated/repeated functions \u00b6 Old New igl::angles igl::internal_angles igl::get_modifiers [deleted] igl::nchoosek(offset,K,N,std::vector) igl::nchoosek(Eigen,K,Eigen) #include <igl/boost/components.h> #include <igl/components.h> #include <igl/boost/bfs_orient.h> #include <igl/bfs_orient.h> #include <igl/boost/orientable_patches.h> #include <igl/orientable_patches.h> #include <igl/svd3x3/arap.h> #include <igl/arap.h> #include <igl/svd3x3/arap_dof.h> #include <igl/arap_dof.h> #include <igl/svd3x3/fit_rotations.h> #include <igl/fit_rotations.h> #include <igl/svd3x3/polar_svd3x3.h> #include <igl/polar_svd3x3.h> #include <igl/svd3x3/svd3x3.h> #include <igl/svd3x3.h> #include <igl/svd3x3/svd3x3_avx.h> #include <igl/svd3x3_avx.h> #include <igl/svd3x3/svd3x3_sse.h> #include <igl/svd3x3_sse.h> Version 1.0 Changes \u00b6 Our beta release marks our confidence that this library can be used outside of casual experimenting. To maintain order, we have made a few changes which current users should read and adapt their code accordingly. Renamed functions \u00b6 The following table lists functions which have changed name as of version 1.0.0: Old New igl::add_barycenter igl::false_barycentric_subdivision igl::areamatrix igl::vector_area_matrix igl::barycentric2global igl::barycentric_to_global igl::boundary_faces igl::boundary_facets igl::boundary_vertices_sorted igl::boundary_loop igl::cotangent igl::cotmatrix_entries igl::edgetopology igl::edge_topology igl::gradMat igl::grad igl::is_manifold igl::is_edge_manifold igl::mexStream igl::MexStream igl::moveFV igl::average_onto_vertices igl::moveVF igl::average_onto_faces igl::plot_vector igl::print_vector igl::pos igl::HalfEdgeIterator igl::plane_project igl::project_isometrically_to_plane igl::project_points_mesh igl::line_mesh_intersection igl::read igl::read_triangle_mesh igl::removeDuplicates.cpp igl::remove_duplicates igl::removeUnreferenced igl::remove_unreferenced igl::tt igl::triangle_triangle_adjacency igl::vf igl::vertex_triangle_adjacency igl::write igl::write_triangle_mesh igl::manifold_patches igl::orientable_patches igl::selfintersect igl::remesh_self_intersections igl::project_mesh igl::line_mesh_intersection igl::triangulate igl::polygon_mesh_to_triangle_mesh igl::is_manifold igl::is_edge_manifold igl::triangle_wrapper igl::triangulate Miscellaneous \u00b6 To match interfaces provided by (all) other quadratic optimization libraries, igl::min_quad_with_fixed and igl::active_set now expect as input twice the quadratic coefficients matrix, i.e. the Hessian. For example, igl::min_quad_with_fixed(H,B,...) minimizes \\frac{1}{2}x^T H x+x^T B \\frac{1}{2}x^T H x+x^T B . We have inverted the IGL_HEADER_ONLY macro to IGL_STATIC_LIBRARY . To compile using libigl as a header-only library, simply include headers and libigl in the header search path. To link to libigl, you must define the IGL_STATIC_LIBRARY macro at compile time and link to the libigl*.a libraries. Building libigl as a static library is now more organized. There is a build/ directory with Makefiles for the main library ( Makefile ) and each dependency (e.g. Makefile_mosek for libiglmosek.a ) igl::polar_svd now always returns a rotation in R , never a reflection. This mirrors the behavior of igl::polar_svd3x3 . Consequently the T part may have negative skews. We have organized the static library build The previous igl::grad function, which computed the per-triangle gradient of a per-vertex scalar function has been replaced. Now igl::grad computes the linear operator (previous computed using igl::gradMat ). The gradient values can still be recovered by multiplying the operator against the scalar field as a vector and reshaping to have gradients per row. MASSMATRIX_* has become MASSMATRIX_TYPE_* The function igl::project_normals , which cast a line for each vertex of mesh A in the normal direction and found the closest intersection along these lines with mesh B , has been removed.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#version-summary-table","text":"Click to unroll. Version Short description main \u2026 2.4.0 Bug fixes, CMake tidying, imgui widgets, broad M1 mac support, dependency bumps 2.3.0 Dual Contouring, DDM skinning, B\u00e9zier, PLY reader, 3D text rendering, matcap 2.2.0 New python bindings, fast winding number for soups, ICP algorithm 2.1.0 Various improvements and bug fixes, updated dependencies 2.0.0 Lighter, simpler CMake build, rewritten history 1.3.3 Switched the build system from submodules to CMake external projects 1.3.2 After merging PRs in the 2018 hackaton 1.3.1 Before merging PRs in the 2018 hackaton 1.3.0 Modernized cmake build, multi-mesh viewer, replace nanogui with imgui 1.2.1 Reorganization opengl-dependent functions: opengl and opengl2 extras 1.2.0 Reorganization of \u201cextras\u201d, rm deprecated funcs, absorb boost & svd3x3 1.1.7 Switch build for static library to cmake. 1.1.6 Major boolean robustness fix, drop CGAL dependency for AABB/distances 1.1.5 Bug fix in booleans 1.1.4 Edge collapsing and linear program solving 1.1.3 Bug fixes in active set and boundary_conditions 1.1.1 PLY file format support 1.1.0 Mesh boolean operations using CGAL and cork, implementing [Attene 14] 1.0.3 Bone heat method 1.0.2 Bug fix in winding number code 1.0.1 Bug fixes and more CGAL support 1.0.0 Major beta release: many renames, tutorial, triangle, org. build 0.4.6 Generalized Winding Numbers 0.4.5 CGAL extra: mesh selfintersection 0.4.4 STL file format support 0.4.3 ARAP implementation 0.4.1 Migrated much of the FAST code including extra for Sifakis\u2019 3x3 svd 0.4.0 Release under MPL2 license 0.3.7 Embree2.0 support 0.3.6 boost extra, patches, mosek 7 support, libiglbbw (mosek optional) 0.3.5 More examples, naive primitive sorting 0.3.3 Many more examples, ambient occlusion with Embree. 0.3.1 Linearly dependent constraints in min_quad_with_fixed, SparseQR buggy 0.3.0 Better active set method support 0.2.3 More explicits, active set method, opengl/anttweakbar guards 0.2.2 More explicit instantiations, faster sorts and uniques 0.2.1 Bug fixes in barycenter and doublearea found by Martin Bisson 0.2.0 XML serializer more stable and fixed bug in remove_duplicate_vertices 0.1.8 Embree and xml (windows only) extras 0.1.5 Compilation on windows, bug fix for compilation with cygwin 0.1.1 Alpha release with core functions, extras, examples","title":"Version Summary Table"},{"location":"changelog/#upcoming-version-250-changes","text":"The following changes are represent in the main branch of libigl, but not yet included in a tagged release.","title":"Upcoming Version 2.5.0 Changes"},{"location":"changelog/#bugfixes","text":"ViewerData::set_data() now accepts #F-long data vectors ( 1f44d1e )","title":"Bugfixes"},{"location":"changelog/#enhancements","text":"ismember_rows split into its own file (may need to change #include <igl/ismember.h> to #include <igl/ismember_rows.h> ( #1989 ) igl::predicates::delaunay_triangulation and igl::predicates::lexicographic_triangulation routines ( #1988 ) properly expose edge-markers in igl::triangle::triangulate ( #1983 )","title":"Enhancements"},{"location":"changelog/#compilation","text":"","title":"Compilation"},{"location":"changelog/#version-240-changes","text":"","title":"Version 2.4.0 Changes"},{"location":"changelog/#breaking-changes","text":"Libigl v2.4.0 introduced a number of breaking changes regarding its CMake build system . If you follow the upgrade guide below, these breaking changes should be easy to resolve. Tip When starting a new project using libigl, use the libigl-example-project as a starting point.","title":"Breaking Changes"},{"location":"changelog/#cmake-entry-point","text":"The main entry point for CMake is now the CMakeLists.txt at the root of the libigl repository. If you were using a FindLibigl.cmake , or were including libigl.cmake directly, please update your project. If you are using the libigl-example-project , you may update the content of cmake/libigl.cmake to the following: if ( TARGET igl::core ) return () endif () include ( FetchContent ) FetchContent_Declare ( libigl GIT_REPOSITORY https://github.com/libigl/libigl.git GIT_TAG <TARGET_SHA1> ) FetchContent_MakeAvailable ( libigl )","title":"CMake entry point"},{"location":"changelog/#cmake-targets","text":"The CMake targets for many libigl modules have been renamed in v2.4.0. This provides greater visibility into each module category (between regular, copyleft and restricted modules). Here is the table mapping the old names to the new names: Old target name (v2.3.0) New target name (v2.4.0) igl::embree Unchanged igl::opengl_glfw igl::glfw igl::opengl_glfw_imgui igl::imgui igl::opengl Unchanged igl::png Unchanged igl::predicates Unchanged igl::xml Unchanged igl_copyleft::core ( New ) igl::cgal igl_copyleft::cgal igl::comiso igl_copyleft::comiso igl::cork Removed igl::tetgen igl_copyleft::tetgen igl::matlab igl_restricted::matlab igl::mosek igl_restricted::mosek igl::triangle igl_restricted::triangle Important The libigl cork wrapper was removed from this release. A standalone repository with a libigl-style wrapper around cork is available here .","title":"CMake targets"},{"location":"changelog/#cmake-options","text":"Many libigl CMake options have changed in v2.4.0. Here is a mapping from the old name to the new names: Old option (v2.3.0) New option (v2.4.0) LIBIGL_COPYLEFT_CORE ( New ) LIBIGL_BUILD_TESTS Unchanged LIBIGL_BUILD_TUTORIALS Unchanged LIBIGL_EXPORT_TARGETS LIBIGL_INSTALL LIBIGL_USE_STATIC_LIBRARY Unchanged LIBIGL_WITH_CGAL LIBIGL_COPYLEFT_CGAL LIBIGL_WITH_COMISO LIBIGL_COPYLEFT_COMISO LIBIGL_WITH_CORK Removed LIBIGL_WITH_EMBREE LIBIGL_EMBREE LIBIGL_WITH_MATLAB LIBIGL_RESTRICTED_MATLAB LIBIGL_WITH_MOSEK LIBIGL_RESTRICTED_MOSEK LIBIGL_WITH_OPENGL LIBIGL_OPENGL LIBIGL_WITH_OPENGL_GLFW LIBIGL_GLFW LIBIGL_WITH_OPENGL_GLFW_IMGUI LIBIGL_IMGUI LIBIGL_WITH_PNG LIBIGL_PNG LIBIGL_WITH_PREDICATES LIBIGL_PREDICATES LIBIGL_WITH_PYTHON Removed LIBIGL_WITH_TETGEN LIBIGL_COPYLEFT_TETGEN LIBIGL_WITH_TRIANGLE LIBIGL_RESTRICTED_TRIANGLE LIBIGL_WITH_XML Unchanged Tip There is a now a sample file LibiglOption.cmake.sample at the root of the libigl repository. Simply remove the .sample extension and edit this file to modify libigl compilation options. If you are using libigl as a subdirectory (e.g. in a parent project), then please set your options in the parent project instead.","title":"CMake options"},{"location":"changelog/#imgui-headers","text":"We are also updating our ImGui dependency to use the base repository as include folder, rather than forcing headers to be copied into a imgui/ subfolder. This helps be consistent with other projects that might be using ImGui. This requires users changing their include headers as follows: #include <imgui/imgui.h> \u2192 #include <imgui.h> #include <imgui/imgui_internal.h> \u2192 #include <imgui_internal.h> #include <imgui_impl_glfw.h> \u2192 #include <backends/imgui_impl_glfw.h> #include <imgui_impl_opengl3.h> \u2192 #include <backends/imgui_impl_opengl3.h>","title":"ImGui headers"},{"location":"changelog/#imguimenuimguizmopluginselectionplugin-imguiwidgets","text":"We\u2019ve introduced a new \u201cparent\u201d ImGuiPlugin which handles ImGui IO functions and converted the old ImGuiMenu , ImGuizmoPlugin , SelectionPlugin plugins to inherit from a new ImGuiWidget class. In this way, a single ImGuiPlugin can be registered to the viewer\u2019s plugins list and one or many widgets are registered to this plugin\u2019s widgets list. For folks just using the menu, this incurs a few extra lines. To add the menu: #include <igl/opengl/glfw/imgui/ImGuiPlugin.h> #include <igl/opengl/glfw/imgui/ImGuiMenu.h> \u2026 igl :: opengl :: glfw :: imgui :: ImGuiPlugin plugin ; viewer . plugins . push_back ( & plugin ); igl :: opengl :: glfw :: imgui :: ImGuiMenu menu ; plugin . widgets . push_back ( & menu ); The reward is that now we can use all of these plugins (and any new user created plugins using ImGui subroutines) without conflict.","title":"ImGuiMenu,ImGuizmoPlugin,SelectionPlugin \u2192 ImGuiWidgets"},{"location":"changelog/#other-changes","text":"","title":"Other Changes"},{"location":"changelog/#bugfixes_1","text":"Fix #1656 \u201cCan only have one ImGuiMenu plugin at a time\u201d ( #1973 ) Fix #1924 \u201cPLY with no faces throw SIGFPE in ReadPLY\u201d ( #1927 ) LSCM: fix sign for the area term ( #1853 ) Fix bug in igl::read_file_binary ( #1821 ) Fix #1795 \u201cCan\u2019t convert CGAL::Polyhedron_3 to mesh\u201d ( #1796 ) Fix the order of principal curvature ( #1767 ) Fix dirty flag for ViewerData::set_labels ( #1761 )","title":"Bugfixes"},{"location":"changelog/#enhancements_1","text":"Modified arap interface to accept Eigen::Map ( #1922 ) Wrapper around CGAL\u2019s 2D constrained delaunay triangulation ( #1811 ) Delete obsolete function igl::point_in_poly ( #1810 ) Instead of calling exit(1), triangle now throws an exception ( #1800 ) Use igl::default_num_threads in cgal module ( #1768 ) Added double_sided flag to embree renderer ( #1765 ) Replace Eigen::PlainObjectBase with Eigen::MatrixBase for input of ambient_occlusion ( #1752 ) 10-100x speedup on per corner normals + caching adjacency ( #1745 )","title":"Enhancements"},{"location":"changelog/#compilation_1","text":"Update Catch2 to v2.13.8 ( #1972 ) Update Embree to v13.3.3 ( #1976 ) Broad support for M1 macs ( #1976 , #1975 ) Update ImGui to v1.85 + use default include folders for ImGui ( #1970 ) CMake refactor ( #1805 ) CGAL and Boost are now built entirely from source via CMake. This means the CGAL module will work out of the box under Windows \u2013 no need for a conda virtual environment. On Linux/macOS, the only dependency to install system-wide are GMP+MPFR. CMake targets and options have been renamed based on the module category: regular/copyleft/restricted. This eliminates long module names ( igl::open_glfw_imgui ) that didn\u2019t bring much to the table, in favor of three root classes based on available licenses for each module. There is now a LibiglOptions.cmake sample file at the root of the project repository, which should make it easier to document/update available CMake options. There is now a unique entry point for the project, which is the root CMakeLists.txt . This facilitates maintenance, as before either tutorial/CMakeLists.txt and cmake/libigl.cmake could serve as potential entry points. The default behavior for module compilation is: When compiling libigl on its own, all modules are enabled by default. When compiling libigl as a subproject, all modules are disabled by default. On Linux/macOS, if GMP/MPFR is not installed on the system, shows a warning and disable CGAL by default. If Mosek/Matlab are not installed on the system, shows a warning and disable the Mosek/Matlab libigl wrappers respectively. If the user explicitly enables those modules, but they do not have GMP/MPFR/Mosek/Matlab installed on the system, CMake configuration will fail. Big cleanup of the tutorial CMake definitions. With the new setup adding a new tutorial is even easier! Cleaned up dependency setup for imgui/stb (among others) Unit tests have been split into different CMake target, based on which module is tested. Add support for Hunter + install() for the igl::core module (should be the same as before). Use a more generic igl_copy_dll() function to copy GMP/MPFR dlls on Windows (should work to copy the CoMiSo dll as well). Cleaned up our .gitignore file. Fix blue noise random shuffle for C++17 ( #1949 ) Bump triangle version ( #1813 ) and tetgen version ( #1815 ) Templates EmbreeRenderer ( #1788 ) Fix Cuda compilation issue on Windows ( #1747 ) Split min_quad_with_fixed implementation into separate cpp ( #1746 ) Silence MSVC warning with std::getenv ( #1744 ) Fix usage of find_package(OpenGL) on Linux ( #1733 )","title":"Compilation"},{"location":"changelog/#version-230-changes","text":"Warning This is our last stable release before some planned major reorganization (see #1696 for details). The upcoming reorganization is aimed at facilitating maintenance and packaging of various libigl components. The next release will be a new major version of libigl (3.0.0).","title":"Version 2.3.0 Changes"},{"location":"changelog/#new-features","text":"Dual contouring ( #1716 ) Viewer: Selection Plugin ( #1654 ) Implements \u201c Polygon Laplacian Made Simple \u201d ( #1653 ) Offscreen meshes rendering using Embree ( #1652 ) Signing distances with Fast Winding Number ( #1630 ) Turn ImGuizmo tutorial into a viewer plugin ( #1618 ) Adds MATLAB-like function igl::blkdiag to build a block-diagonal matrix ( #1617 ) Kelvinlet mesh deformation ( #1614 ) Blue noise sampling on triangle meshes + adds igl::barycentric_interpolation ( #1597 ) Direct Delta Mush skinning ( #1541 ) New exploded view tutorial ( #1510 ) B\u00e9zier curve evaluation ( igl::bezier ) and fitting ( igl::fit_cubic_bezier ) ( #1476 ) Replace .ply reader/writer with tinyply library ( #1422 ) igl::copyleft::cgal::wire_mesh now support per-edge thickness. Adds igl::copyleft::cgal::coplanar test ( #1488 ) New generic function for connected components ( igl::connected_components ) ( #1487 ) Viewer: matcap support ( #1482 ) + tutorial entry ( #1646 ) Viewer: option for double-sided lighting ( #1480 ) Viewer: new 3D text rendering feature, supporting proper label depth ( #1549 )","title":"New Features"},{"location":"changelog/#build-system","text":"Update ImGui to 1.81 ( #1723 ), fixing rendering issue with newer Visual Studio Fix mosek to work with 9.2; fix mosek dynamic link via CMake ( #1675 ) Reimplement igl::marching_cubes outside of the copyleft/ folder ( #1666 , #1687 ) Update GLFW to fix an issue on macOS with CMake 3.19.0 ( #1657 ) Update Embree to v3.12.1 ( #1648 ) Use new gitlab remote to clone Eigen ( #1631 ) Update compiler versions in github actions ( #1629 ) Update CoMiSo version ( #1608 ). Note that CoMiSo support for libigl is deprecated and will be removed in version 3.0. Removed _bin suffix from executable files ( #1594 ) Moved SCAF to triangle folder ( #1590 ) Various fixes to github actions ( #1649 , #1651 , #1721 )","title":"Build System"},{"location":"changelog/#misc","text":"Control number of threads in parallel_for with env variable IGL_NUM_THREADS ( #1684 ) Support msh in igl::read_triangle_mesh ( #1645 ) Change boundary weight from length to length squared in igl::per_vertex_point_to_plane_quadrics ( #1644 ) Update STL read to work on problematic thingi10K meshes ( #1628 ) Use an enum to specify file encoding when writing files ( #1619 ) Removed some functions marked as deprecated ( #1610 ) Fix bug with epsilon parameter in igl::remove_duplicate_vertices ( #1603 ) Removed unused function igl::barycentric_to_global ( #1596 ) Fix align_camera_center in Viewer::init() for multiple cores ( #1349 ) Add floating point exceptions in unit tests ( #1001 ) Extended serialization functionality to Eigen::Array ( #1113 ) SCAF: Expose linear system to be solved by user code ( #1553 ) Fix issue with igl::heat_geodesic ( #1497 ) Refactored igl::is_edge_manifold ( #1509 ) Various bugfixes, compile fixes, template fixes ( #1335 , #1361 , #1400 , #1402 , #1430 , #1438 , #1441 , #1471 , #1475 , #1484 , #1494 , #1495 , #1497 , #1525 , #1538 , #1544 , #1546 , #1581 , #1582 , #1625 , #1627 , #1638 , #1640 , #1642 , #1658 , #1673 , #1674 , #1679 , #1694 , #1704 , #1709 )","title":"Misc"},{"location":"changelog/#version-220-changes","text":"","title":"Version 2.2.0 Changes"},{"location":"changelog/#python-bindings","text":"The python bindings have been moved to a separate repository . These are now available as an conda package .","title":"Python Bindings"},{"location":"changelog/#new-features_1","text":"Fast winding number for triangle soups ( #1218 ) Iterative closest point algorithm + tutorial ( #1347 ) Ear clipping triangulation ( #1169 ) Added igl::path_to_edges function ( #1259 ) igl::dijkstra can now use mesh edge length ( #1170 ) Keep reference to multiple material when reading obj ( #1280 ) Added igl::sharp_edges for sharp edges extraction ( #1364 ) Added igl::unproject_on_line , igl::unproject_on_plane and igl::projection_constraint to compute cursor (un)-projections ( #1368 ) Added igl::quad_grid and igl::triangulated_grid to create meshes from regular grids ( #1369 ) Added igl::isolines_map , ViewerData::set_data and ViewerData::set_colormap to improve scalar field visualization in the Viewer, and updated tutorials accordingly ( #1371 ) Added new COLOR_MAP_TYPE_TURBO colormap, based on Turbo . Jet is now an alias for Turbo, and switched to Viridis as default colormap in the viewer ( #1372 ) Added igl::slice_sorted and removed deprecated Eigen::DynamicSparsematrix from igl::slice ( #1370 )","title":"New Features"},{"location":"changelog/#build-system_1","text":"Overhauled function signatures in preparation of new python bindings ( #1162 , #1228 , #1271 , #1274 ) Added a conda environment cmake/libigl-cgal.yml to provide boost for Windows users ( #1239 ) Added experimental support for Hunter ( #1242 ) Now libigl.cmake will define a CMake target Eigen3::Eigen if not provided by the user ( #1299 ) Added igl_set_folders() to sort CMake targets into folders in IDEs such as Visual Studio or Xcode ( #1383 ) Minor fixes to our CMake build system ( #1363 ) Github actions for CI replacing appveyor and travis ( #1389 )","title":"Build System"},{"location":"changelog/#misc_1","text":"Fix underflow issue when computing normalization in igl::heat_geodesics ( #1344 ) Update nrosy to match the MIQ paper ( #1303 ) Delete Embree_convenience.h ( #1314 ) Refactored igl::cut_mesh ( #1332 ) Various improvements to the viewer ( #1196 , #1251 , #1366 ) Unit tests: cleand up test_common.h ( #1365 ) Made call to igl::predicates::exactinit() thread-safe + marked internal functions in predicates.c as static to prevent name collisions ( #1377 ) Doc cleanup ( #1376 ) Allows igl::hsv_to_rgb to work on negative hues ( #1399 ) Explicitly marked the following functions as deprecated ( #1380 ): igl::all_edges igl::internal_angles_using_edge_lengths (only a specific overload is affected) igl::is_border_vertex (only a specific overload is affected) igl::remove_duplicates Various bugfixes, code cleanup and explicit template instantiations ( #1197 , #1210 , #1216 , #1231 , #1247 , #1258 , #1288 , #1309 , #1320 , #1337 , #1345 , #1379 , #1396 , #1327 )","title":"Misc"},{"location":"changelog/#version-210-changes","text":"Various code cleanup, compilation fixes, and explicit template instantiations Added wrapper around Shewchuk\u2019s predicates ( #1163 ) libigl now also compiles with Eigen 3.3 ( #1110 ). Extended igl::cat functionalities ( #1108 ) Extended boundary_facets with outputs revealing which element facet comes from ( #1067 ) Use std::shuffle instead of std::random_shuffle in igl/randperm ( #1062 ) Fixed an Eigen alignment issue in the viewer ( #1029 ) Removed LIM tutorial ( #1012 , #1014 ) Fixed current python bindings ( #1008 ) Intrinsic Delaunay triangulation ( #988 ) New Heat Geodesics feature ( #988 , #1140 ). See also tutorial 716. Switched from Google Test to Catch2 ( #961 ), and added various unit tests Fixed an issue with transparent window on macOS that was introduced in v2.0.0 ( #953 ) Updated dependencies: Embree 3 ( #947 ), GLFW ( #977 , #1153 ), ImGui ( #1039 ), std-image ( #1072 ) Added sparse voxel grids ( #937 , #942 ) and tutorial 715 for meshing implicit functions. Added tutorial 714 for marching tets ( #716 )","title":"Version 2.1.0 Changes"},{"location":"changelog/#version-200-changes","text":"This release is a result of the 2018 libigl hackathon at NYU. The major changes are: a simplified cmake set up that can build a static library, tutorials, tests, and python bindings; cmake now uses ExternalProject_Add to download necessary/requested dependency source code and tutorial/test data as a result, git clone --recursive ... is no longer required unit tests are now part of main repo and included in continuous integration ( libigl/libigl-unit-tests is obsolete); tutorial data has been moved to libigl/libigl-tutorial-data ; unit test data has been moved to libigl/libigl-tests-data ; all dependencies previously in libigl/external have been removed or moved to repos (and added via ExternalProject_Add ); documentation and the tutorial webpage has been moved to libigl/libigl.github.io ; .git history of these files has been purged using bfg unfortunately this means that SHA hashes have changed and any external projects using libigl as a submodule will need to be refreshed to the new hashes. More information and instructions for troubleshooting at https://libigl.github.io/rewritten-history/ . A legacy version with SHA hashes matching old repo is hosted at libigl/libigl-legacy . The major upshot is that the old git clone --recursive that resulted in a 1.8GB libigl/ directory is now a git clone that results in 16.5MB, more than a 100x reduction in size. Name changes: Old New igl::components igl::vertex_components igl::slice_tets igl::marching_tets","title":"Version 2.0.0 Changes"},{"location":"changelog/#version-132-changes","text":"First version after all pull requests were merged during the libigl hackaton, and before switching from submodules to CMake external projects.","title":"Version 1.3.2 Changes"},{"location":"changelog/#version-131-changes","text":"Last version before pull requests were merged during the libigl hackaton. igl::components has been renamed to igl::vertex_components . viewer.core.model matrix is gone ( #700 ).","title":"Version 1.3.1 Changes"},{"location":"changelog/#version-130-changes","text":"List of changes related to this version: The CMake build system has been rewritten to be more modular and modern. libigl modules are now available as CMake target, e.g. igl::triangle or igl::opengl . See the libigl-example-project for an example of typical usage. igl/antweakbar and igl/opengl2 support has been removed from the CMake. The files are still available, but their use is discouraged. The viewer has been refactored and now supports multiple meshes. See related tutorial entry for more information. The viewer files are now split according to their dependencies. E.g. igl::viewer::Viewer has been renamed igl::opengl::glfw::Viewer . NanoGui has been replaced by ImGui, and is now available as a viewer plugin instead of #define Polyvector code has been moved to libdirectional ( #630 ).","title":"Version 1.3.0 Changes"},{"location":"changelog/#version-12-changes","text":"This change introduces better organization of dependencies and removes some deprecated/repeated functions. The 3x3 svd code and dependent functions (including ARAP) were absorbed into the main library. Similarly, the boost dependency extra was absorbed.","title":"Version 1.2 Changes"},{"location":"changelog/#external-libraries-as-git-subrepos","text":"The core functionality of libigl (still) just depends on stl, c++11 and Eigen. There are additional optional dependencies (e.g. CGAL, embree, glfw, tetgen, triangle). Libigl functions using these are located (still) in sub-folders of the include directory (e.g. include/igl/cgal/ , include/igl/embree/ ). Prior to version 1.2 we included copies of the code for some of these dependencies in the external/ directory. As of version 1.2, these have been replaced with git sub-repos. If you have cloned libigl before version 1.2 then you should issue git submodule update --init --recursive","title":"External libraries as git subrepos"},{"location":"changelog/#deprecatedrepeated-functions","text":"Old New igl::angles igl::internal_angles igl::get_modifiers [deleted] igl::nchoosek(offset,K,N,std::vector) igl::nchoosek(Eigen,K,Eigen) #include <igl/boost/components.h> #include <igl/components.h> #include <igl/boost/bfs_orient.h> #include <igl/bfs_orient.h> #include <igl/boost/orientable_patches.h> #include <igl/orientable_patches.h> #include <igl/svd3x3/arap.h> #include <igl/arap.h> #include <igl/svd3x3/arap_dof.h> #include <igl/arap_dof.h> #include <igl/svd3x3/fit_rotations.h> #include <igl/fit_rotations.h> #include <igl/svd3x3/polar_svd3x3.h> #include <igl/polar_svd3x3.h> #include <igl/svd3x3/svd3x3.h> #include <igl/svd3x3.h> #include <igl/svd3x3/svd3x3_avx.h> #include <igl/svd3x3_avx.h> #include <igl/svd3x3/svd3x3_sse.h> #include <igl/svd3x3_sse.h>","title":"Deprecated/repeated functions"},{"location":"changelog/#version-10-changes","text":"Our beta release marks our confidence that this library can be used outside of casual experimenting. To maintain order, we have made a few changes which current users should read and adapt their code accordingly.","title":"Version 1.0 Changes"},{"location":"changelog/#renamed-functions","text":"The following table lists functions which have changed name as of version 1.0.0: Old New igl::add_barycenter igl::false_barycentric_subdivision igl::areamatrix igl::vector_area_matrix igl::barycentric2global igl::barycentric_to_global igl::boundary_faces igl::boundary_facets igl::boundary_vertices_sorted igl::boundary_loop igl::cotangent igl::cotmatrix_entries igl::edgetopology igl::edge_topology igl::gradMat igl::grad igl::is_manifold igl::is_edge_manifold igl::mexStream igl::MexStream igl::moveFV igl::average_onto_vertices igl::moveVF igl::average_onto_faces igl::plot_vector igl::print_vector igl::pos igl::HalfEdgeIterator igl::plane_project igl::project_isometrically_to_plane igl::project_points_mesh igl::line_mesh_intersection igl::read igl::read_triangle_mesh igl::removeDuplicates.cpp igl::remove_duplicates igl::removeUnreferenced igl::remove_unreferenced igl::tt igl::triangle_triangle_adjacency igl::vf igl::vertex_triangle_adjacency igl::write igl::write_triangle_mesh igl::manifold_patches igl::orientable_patches igl::selfintersect igl::remesh_self_intersections igl::project_mesh igl::line_mesh_intersection igl::triangulate igl::polygon_mesh_to_triangle_mesh igl::is_manifold igl::is_edge_manifold igl::triangle_wrapper igl::triangulate","title":"Renamed functions"},{"location":"changelog/#miscellaneous","text":"To match interfaces provided by (all) other quadratic optimization libraries, igl::min_quad_with_fixed and igl::active_set now expect as input twice the quadratic coefficients matrix, i.e. the Hessian. For example, igl::min_quad_with_fixed(H,B,...) minimizes \\frac{1}{2}x^T H x+x^T B \\frac{1}{2}x^T H x+x^T B . We have inverted the IGL_HEADER_ONLY macro to IGL_STATIC_LIBRARY . To compile using libigl as a header-only library, simply include headers and libigl in the header search path. To link to libigl, you must define the IGL_STATIC_LIBRARY macro at compile time and link to the libigl*.a libraries. Building libigl as a static library is now more organized. There is a build/ directory with Makefiles for the main library ( Makefile ) and each dependency (e.g. Makefile_mosek for libiglmosek.a ) igl::polar_svd now always returns a rotation in R , never a reflection. This mirrors the behavior of igl::polar_svd3x3 . Consequently the T part may have negative skews. We have organized the static library build The previous igl::grad function, which computed the per-triangle gradient of a per-vertex scalar function has been replaced. Now igl::grad computes the linear operator (previous computed using igl::gradMat ). The gradient values can still be recovered by multiplying the operator against the scalar field as a vector and reshaping to have gradients per row. MASSMATRIX_* has become MASSMATRIX_TYPE_* The function igl::project_normals , which cast a line for each vertex of mesh A in the normal direction and found the closest intersection along these lines with mesh B , has been removed.","title":"Miscellaneous"},{"location":"coding-guidelines/","text":"Libigl Coding Tips (aka \u201cHow to code a SIGGRAPH project\u201d) \u00b6 This is a short list of coding tips that will greatly reduce your pain and suffering before (and after) the SIGGRAPH deadline. 1. Serialize it all \u00b6 The entire state of your application should be serializable, i.e. It should be possible to save it into a binary file and reload it at any point. This drastically simplifies debugging, since you can serialize just before a crash happens and debug from that point without running your complete algorithm again. Serializing all results shown in the paper\u2019s figures enables quicker editing iterations before (and after) the deadline. It also allows you to share your results with others that wish to compare with your method. An additional tip is to serialize the state of the application on the window close event and automatically reload it when you launch it again. 2. Always assert \u00b6 Even if you know what you are doing, always assert, you will be surprised. Assertion is a powerful but underused feature available in all programming languages. It is essential for writing research code since often you will have to implement algorithms that turns out to not be doing what you expect: in these cases it is important to know if the algorithm is flawed or if there is a bug in your implementation. Discarding a good idea because of a coding bug is frustrating and unfortunately common. Assertion is an ideal way to reduce the chances of introducing bugs in your code and, differently from unit testing, requires a very minor programming effort. You should use them extensively. 3. Plot everything \u00b6 If you can visually plot the results or some intermediate steps of your algorithm, do it, even if you think your implementation is correct! It is a lot easier to find bugs or to get an intuition on an algorithm by looking at a plot than by looking at the code. 4. If the compilation time after a code change is more than five seconds, you are doing it wrong \u00b6 You will change your code hundreds of times every day for months. Let\u2019s say that you will change it a hundred times a day (which is a very conservative estimate): if the compilation takes one minute, you will waste almost two hours every day, just waiting! What is even worse, is that since it is only 1-2 minutes at a time, it will not even be sufficient to prepare a coffee. Spend the hour or two that is needed to get your code to compile in a few seconds, you will benefit from it in the same day already, and the time saved over an entire project will be gigantic. 5. Commit often (and with a meaningful description) \u00b6 Use a distributed version control system (git,hg), and keep the repository on a remote host. Commit often and put meaningful comments. This will serve you as an emergency backup and it will always allow you to have a running version of your code whenever your advisor is passing by and asking to see some results. She will be impressed and you will not have to quickly fix your build with your boss breathing down your neck. 6. Dependencies are evil, avoid them \u00b6 Keep your code simple and with minimal external dependencies. Spending a day or two to code something from scratch while avoiding to use third party code is usually an investment that pays off. The more code you have in your algorithm that is not written by you, the harder debugging becomes. In particular, refrain from building your entire project on code that you do not understand to avoid bad surprises just before the deadline. If you must use code written by others, spend the time that is needed to fully understand what it does, and link it statically so that it will be easy to place breakpoints inside it. 7. Global variables are not evil, use them \u00b6 Global variables are often extremely useful \u2014 if you think you need one, use it. They are indeed dangerous for large projects, but you are not coding one of those, you are coding a prototype to test a research idea. I suggest to keep one single copy of your entire application state in a global variable (or a singleton class) that can be serialized (see tip 1). This variable should include everything rendered on screen and all the temporary data produced by your algorithm. This will allow you to easily access all the data in your project for plotting or debugging purposes. 8. Prototype first \u00b6 Don\u2019t preemptively optimize and try to quickly write code that is clean and correct. It is common to try multiple different approaches to solve a new problem before finding the right one. This means that the majority of the code that you will write will not be used at the end of the project. While you should still write high-quality and bug-free code to make sure that your results is correct, you definitely do not want to spend time optimizing it before you are sure that is the right approach. In particular, it is helpful to learn a good prototyping language (Python, matlab) and use it for the early stages of the project and switch to (or mix it with) c++ only after finding a promising direction. 9. Avoid explicit pointers \u00b6 Do yourself a favor, do not use explicit pointers. If you use a language that supports explicit pointers, use them only if you really have to. And even in that case, keep them isolated in a single file and be very careful with them. Writing data inside another variable by accident might not trigger a crash, and simply produce strange artifacts that might convince you that a promising research direction does not work, while the problem lies in a nasty bug in your code. There is no reason to take that risk during prototyping, just avoid them and leave them for the end of the project in case they become necessary to optimize your code. 10. If your program crashes, fix it now! \u00b6 If your program crashes, don\u2019t close your eyes and move on. Try to make it happen again, debug it and fix it immediately. These bugs are a nightmare to find, and the more code you add on top of a bug will just make it harder to find. If you don\u2019t fix it, due to Murphy\u2019s law, it will start to be problematic only a few days before the deadline and you will have no time to fix it at that point. Daniele Panozzo","title":"Coding Tips"},{"location":"coding-guidelines/#libigl-coding-tips-aka-how-to-code-a-siggraph-project","text":"This is a short list of coding tips that will greatly reduce your pain and suffering before (and after) the SIGGRAPH deadline.","title":"Libigl Coding Tips (aka \"How to code a SIGGRAPH project\")"},{"location":"coding-guidelines/#1-serialize-it-all","text":"The entire state of your application should be serializable, i.e. It should be possible to save it into a binary file and reload it at any point. This drastically simplifies debugging, since you can serialize just before a crash happens and debug from that point without running your complete algorithm again. Serializing all results shown in the paper\u2019s figures enables quicker editing iterations before (and after) the deadline. It also allows you to share your results with others that wish to compare with your method. An additional tip is to serialize the state of the application on the window close event and automatically reload it when you launch it again.","title":"1. Serialize it all"},{"location":"coding-guidelines/#2-always-assert","text":"Even if you know what you are doing, always assert, you will be surprised. Assertion is a powerful but underused feature available in all programming languages. It is essential for writing research code since often you will have to implement algorithms that turns out to not be doing what you expect: in these cases it is important to know if the algorithm is flawed or if there is a bug in your implementation. Discarding a good idea because of a coding bug is frustrating and unfortunately common. Assertion is an ideal way to reduce the chances of introducing bugs in your code and, differently from unit testing, requires a very minor programming effort. You should use them extensively.","title":"2. Always assert"},{"location":"coding-guidelines/#3-plot-everything","text":"If you can visually plot the results or some intermediate steps of your algorithm, do it, even if you think your implementation is correct! It is a lot easier to find bugs or to get an intuition on an algorithm by looking at a plot than by looking at the code.","title":"3. Plot everything"},{"location":"coding-guidelines/#4-if-the-compilation-time-after-a-code-change-is-more-than-five-seconds-you-are-doing-it-wrong","text":"You will change your code hundreds of times every day for months. Let\u2019s say that you will change it a hundred times a day (which is a very conservative estimate): if the compilation takes one minute, you will waste almost two hours every day, just waiting! What is even worse, is that since it is only 1-2 minutes at a time, it will not even be sufficient to prepare a coffee. Spend the hour or two that is needed to get your code to compile in a few seconds, you will benefit from it in the same day already, and the time saved over an entire project will be gigantic.","title":"4. If the compilation time after a code change is more than five seconds, you are doing it wrong"},{"location":"coding-guidelines/#5-commit-often-and-with-a-meaningful-description","text":"Use a distributed version control system (git,hg), and keep the repository on a remote host. Commit often and put meaningful comments. This will serve you as an emergency backup and it will always allow you to have a running version of your code whenever your advisor is passing by and asking to see some results. She will be impressed and you will not have to quickly fix your build with your boss breathing down your neck.","title":"5. Commit often (and with a meaningful description)"},{"location":"coding-guidelines/#6-dependencies-are-evil-avoid-them","text":"Keep your code simple and with minimal external dependencies. Spending a day or two to code something from scratch while avoiding to use third party code is usually an investment that pays off. The more code you have in your algorithm that is not written by you, the harder debugging becomes. In particular, refrain from building your entire project on code that you do not understand to avoid bad surprises just before the deadline. If you must use code written by others, spend the time that is needed to fully understand what it does, and link it statically so that it will be easy to place breakpoints inside it.","title":"6. Dependencies are evil, avoid them"},{"location":"coding-guidelines/#7-global-variables-are-not-evil-use-them","text":"Global variables are often extremely useful \u2014 if you think you need one, use it. They are indeed dangerous for large projects, but you are not coding one of those, you are coding a prototype to test a research idea. I suggest to keep one single copy of your entire application state in a global variable (or a singleton class) that can be serialized (see tip 1). This variable should include everything rendered on screen and all the temporary data produced by your algorithm. This will allow you to easily access all the data in your project for plotting or debugging purposes.","title":"7. Global variables are not evil, use them"},{"location":"coding-guidelines/#8-prototype-first","text":"Don\u2019t preemptively optimize and try to quickly write code that is clean and correct. It is common to try multiple different approaches to solve a new problem before finding the right one. This means that the majority of the code that you will write will not be used at the end of the project. While you should still write high-quality and bug-free code to make sure that your results is correct, you definitely do not want to spend time optimizing it before you are sure that is the right approach. In particular, it is helpful to learn a good prototyping language (Python, matlab) and use it for the early stages of the project and switch to (or mix it with) c++ only after finding a promising direction.","title":"8. Prototype first"},{"location":"coding-guidelines/#9-avoid-explicit-pointers","text":"Do yourself a favor, do not use explicit pointers. If you use a language that supports explicit pointers, use them only if you really have to. And even in that case, keep them isolated in a single file and be very careful with them. Writing data inside another variable by accident might not trigger a crash, and simply produce strange artifacts that might convince you that a promising research direction does not work, while the problem lies in a nasty bug in your code. There is no reason to take that risk during prototyping, just avoid them and leave them for the end of the project in case they become necessary to optimize your code.","title":"9. Avoid explicit pointers"},{"location":"coding-guidelines/#10-if-your-program-crashes-fix-it-now","text":"If your program crashes, don\u2019t close your eyes and move on. Try to make it happen again, debug it and fix it immediately. These bugs are a nightmare to find, and the more code you add on top of a bug will just make it harder to find. If you don\u2019t fix it, due to Murphy\u2019s law, it will start to be problematic only a few days before the deadline and you will have no time to fix it at that point. Daniele Panozzo","title":"10. If your program crashes, fix it now!"},{"location":"example-project/","text":"libigl example project \u00b6 A blank project example showing how to use libigl and cmake can be found here . Feel free and encouraged to copy or fork this project as a way of starting a new personal project using libigl. See the tutorial first \u00b6 Then build, run and understand the libigl tutorial . Dependencies \u00b6 The only dependencies are the STL, libigl , Eigen3 (included in libigl) and the dependencies of the igl::opengl::glfw::Viewer . libigl can be installed by cloning the git repository on your computer: git clone https://github.com/libigl/libigl.git In the next section we discuss how to find an existing copy of libigl when compiling the example project. For ease of use, it can be a good idea to place your example project right next to the libigl folder. For example, if libigl is installed in ~/foo/libigl , then you can create a copy of the example project right next to it: git clone https://github.com/libigl/libigl-example-project.git ~/foo/libigl-example-project Compilation \u00b6 Compile this project using the standard CMake routine: mkdir build cd build cmake ../ make Just make sure that CMake is able to find libigl. To do so CMake checks a few directories and environment variables, see FindLIBIGL.cmake . If your libigl version is located elsewhere, you can set the environment variable LIBIGL_DIR to the root directory of libigl, or pass this variable when invoking CMake from the command line: cmake -DLIBIGL_DIR = <path-to-libigl> .. This should find and build the dependencies and create a example_bin binary. Run \u00b6 From within the build directory just issue: ./example_bin A glfw app should launch displaying a 3D cube. Libigl example project: libigl/libigl-example-project Enabling optional modules via cmake \u00b6 The example project already requires the glfw module. This shows up in the CMakeLists.txt in two places: igl_include(glfw) \u2026 target_link_libraries(${PROJECT_NAME} PUBLIC igl::glfw) Suppose you\u2019d like to add another module, for example, so that you can include #include <igl/copyleft/tetgen/tetrahedralize.h> then you\u2019d change these to: igl_include(copyleft tetgen) \u2026 target_link_libraries(${PROJECT_NAME} PUBLIC igl::glfw igl_copyleft::tetgen)","title":"Example Project"},{"location":"example-project/#libigl-example-project","text":"A blank project example showing how to use libigl and cmake can be found here . Feel free and encouraged to copy or fork this project as a way of starting a new personal project using libigl.","title":"libigl example project"},{"location":"example-project/#see-the-tutorial-first","text":"Then build, run and understand the libigl tutorial .","title":"See the tutorial first"},{"location":"example-project/#dependencies","text":"The only dependencies are the STL, libigl , Eigen3 (included in libigl) and the dependencies of the igl::opengl::glfw::Viewer . libigl can be installed by cloning the git repository on your computer: git clone https://github.com/libigl/libigl.git In the next section we discuss how to find an existing copy of libigl when compiling the example project. For ease of use, it can be a good idea to place your example project right next to the libigl folder. For example, if libigl is installed in ~/foo/libigl , then you can create a copy of the example project right next to it: git clone https://github.com/libigl/libigl-example-project.git ~/foo/libigl-example-project","title":"Dependencies"},{"location":"example-project/#compilation","text":"Compile this project using the standard CMake routine: mkdir build cd build cmake ../ make Just make sure that CMake is able to find libigl. To do so CMake checks a few directories and environment variables, see FindLIBIGL.cmake . If your libigl version is located elsewhere, you can set the environment variable LIBIGL_DIR to the root directory of libigl, or pass this variable when invoking CMake from the command line: cmake -DLIBIGL_DIR = <path-to-libigl> .. This should find and build the dependencies and create a example_bin binary.","title":"Compilation"},{"location":"example-project/#run","text":"From within the build directory just issue: ./example_bin A glfw app should launch displaying a 3D cube. Libigl example project: libigl/libigl-example-project","title":"Run"},{"location":"example-project/#enabling-optional-modules-via-cmake","text":"The example project already requires the glfw module. This shows up in the CMakeLists.txt in two places: igl_include(glfw) \u2026 target_link_libraries(${PROJECT_NAME} PUBLIC igl::glfw) Suppose you\u2019d like to add another module, for example, so that you can include #include <igl/copyleft/tetgen/tetrahedralize.h> then you\u2019d change these to: igl_include(copyleft tetgen) \u2026 target_link_libraries(${PROJECT_NAME} PUBLIC igl::glfw igl_copyleft::tetgen)","title":"Enabling optional modules via cmake"},{"location":"faq/","text":"FAQ \u00b6 I\u2019d like to merge two 3D meshes into one. How to do it with igl? It sounds like you\u2019re trying to compute a union. Are your two meshes closed, watertight manifolds? Then you could call igl/boolean/mesh_boolean with the union option. If not, then there\u2019s still hope with something else. [Alec] In other apps I have seen the the user is asked to specify singularities , and the then the rosy field is generated. But in libigl it seems like you have to specify faces and direction vectors to design a field. Is it possible to specify singularities? It is not possible to specify singularities right now. To specify the directions, the vectors should be in global coordinates (the vectors are 3D vectors, the libigl function takes care of projecting them onto the corresponding face), you can take a look here for a basic example that fixes only one face: Example 505 [Daniele] Does Libigl use the same 2D Triangle code (my search in the Libigl source code indicates NO, but a confirmation would be reassuring)? No, it uses CGAL for triangulation. [Alec] Libigl\u2019s Boolean depends on some GPL-licensed header files from CGAL. Is it possible to remove this dependency? No, the dependency on CGAL would require severely rewriting a core function. It is possible to do, but I will not do it. [Alec] Do you have a ready to run command line program so that I can run a test with a few of my sample data sets? No, but it would be very easy to alter the boolean tutorial example to do that. Basically drop the viewer and change the hardcoded paths to command line arguments and write out the result to an obj. [Alec] I see that it can generate N-rosy fields, but is it possible to remesh based on the rosy field? Here is an example that uses libigl to produce a seamless parametrization: Example 505 If you want a mesh, you can pass this parametrization to libQEX ( hcebke/libQEx ) to extract it. We do not have it built in in the tutorial due to a more restrictive licence used by libQEx. [Daniele] I am having issues with parameterization (igl::miq). Even at 100 iterations, there are still distortions. What is the cause? This is unfortunately the expected behaviour, the MIQ parametrization tends to concentrate the distortion around singularities. [Daniele] I am receiving compilation errors along the lines of \u201cISO C++ forbids declaration of \u2026 with no type\u201d when compiling under Windows using gcc. We never tried to compile libigl on Windows with gcc, but we did test our library on: windows using visual studio linux with gcc macosx with clang You might have a version of gcc that doesn\u2019t support (enough of) c++11. Try using Cygwin and g++ 4.9.2. [Alec, Daniele] What\u2019s the deal with CGAL and GCC 4.8? It has come to our attention that CGAL does not work properly with GCC 4.8. Please read see #650 , and in particular this thread , for more detailed information. [J\u00e9r\u00e9mie] Why do a get a compilation error when writing contexpr a = 1.0 / 2.0; ? You are likely facing this issue because you are using CGAL 4.12+ with gcc. Starting from 4.12, CGAL now properly supports CMake. In particular, it will propagates flags such as -frounding-math , which will cause gcc to produce a compilation error on the code above. You can read more about this issue in the CGAL bug tracker, and how it may impact your code. Our current recommendation is to keep the CGAL parts self-contained as much as possible, and avoid such constructs in the parts of the code that use CGAL. [J\u00e9r\u00e9mie] Should I use Eigen::MatrixBase or Eigen::PlainObjectBase as an argument for my templated functions? Use Eigen::MatrixBase for inputs (so you can pass plain matrices, maps and matrix expressions); Use Eigen::PlainObjectBase for outputs (so the memory can be allocated by the libigl function). I get an error: Server does not allow request for unadvertised object when cloning a repository using libigl as a submodule. You are probably getting this error because the libigl history rewriting that happened on XXX. Read more about this breaking change [here]. I have some old GUI code that uses NanoGUI. How can I update it to the latest version of libigl? In 2017, libigl switched from NanoGUI to ImGui for its viewer\u2019s user interface. The main reason was to remove nested dependencies in common with libigl, thus providing an overall lighter experience. ImGui also has other advantages, such as more dynamic menus (where you can add/remove elements on the fly), inject UI debugging code in user-code (with ImGuiOnceUponAFrame ), etc. Porting UI code to ImGui should be relatively straightforward. Have a look at tutorial 106 , or read issue #719 for more discussion. If you would like to keep NanoGUI as your interface library for whatever reason, you are welcome to write a ViewerPlugin reusing the old binding code, and we would be happy to advertise it somewhere. How to write custom shader code in the viewer? See #657 . How to draw text in the viewer? See #876 . Issues with multi-threading and cgal::CSGTree There is a known race condition that can occur in rare occasions when doing CSG operations with duplicated nodes in the CSG tree, e.g., igl :: copyleft :: cgal :: CSGTree inter ( tree , tree , \"i\" ); See an detailed explanation of the problem here , and please use this thread to discuss the bug if it affects you. So far the problem has only been observed on macOS. Commenting out viewer.launch() causes linker errors with imgui/glad (no imgui/glad functions called) This issue only happens on macOS with the Xcode project generator, when libigl is compiled in header-only mode. Possible solutions: Add an unused function in your project calling viewer.launch() . Compile libigl as a static library. Compile your project using another project generator (Makefile or Ninja). For a more detailed explanation of the problem, see this answer .","title":"FAQ"},{"location":"faq/#faq","text":"I\u2019d like to merge two 3D meshes into one. How to do it with igl? It sounds like you\u2019re trying to compute a union. Are your two meshes closed, watertight manifolds? Then you could call igl/boolean/mesh_boolean with the union option. If not, then there\u2019s still hope with something else. [Alec] In other apps I have seen the the user is asked to specify singularities , and the then the rosy field is generated. But in libigl it seems like you have to specify faces and direction vectors to design a field. Is it possible to specify singularities? It is not possible to specify singularities right now. To specify the directions, the vectors should be in global coordinates (the vectors are 3D vectors, the libigl function takes care of projecting them onto the corresponding face), you can take a look here for a basic example that fixes only one face: Example 505 [Daniele] Does Libigl use the same 2D Triangle code (my search in the Libigl source code indicates NO, but a confirmation would be reassuring)? No, it uses CGAL for triangulation. [Alec] Libigl\u2019s Boolean depends on some GPL-licensed header files from CGAL. Is it possible to remove this dependency? No, the dependency on CGAL would require severely rewriting a core function. It is possible to do, but I will not do it. [Alec] Do you have a ready to run command line program so that I can run a test with a few of my sample data sets? No, but it would be very easy to alter the boolean tutorial example to do that. Basically drop the viewer and change the hardcoded paths to command line arguments and write out the result to an obj. [Alec] I see that it can generate N-rosy fields, but is it possible to remesh based on the rosy field? Here is an example that uses libigl to produce a seamless parametrization: Example 505 If you want a mesh, you can pass this parametrization to libQEX ( hcebke/libQEx ) to extract it. We do not have it built in in the tutorial due to a more restrictive licence used by libQEx. [Daniele] I am having issues with parameterization (igl::miq). Even at 100 iterations, there are still distortions. What is the cause? This is unfortunately the expected behaviour, the MIQ parametrization tends to concentrate the distortion around singularities. [Daniele] I am receiving compilation errors along the lines of \u201cISO C++ forbids declaration of \u2026 with no type\u201d when compiling under Windows using gcc. We never tried to compile libigl on Windows with gcc, but we did test our library on: windows using visual studio linux with gcc macosx with clang You might have a version of gcc that doesn\u2019t support (enough of) c++11. Try using Cygwin and g++ 4.9.2. [Alec, Daniele] What\u2019s the deal with CGAL and GCC 4.8? It has come to our attention that CGAL does not work properly with GCC 4.8. Please read see #650 , and in particular this thread , for more detailed information. [J\u00e9r\u00e9mie] Why do a get a compilation error when writing contexpr a = 1.0 / 2.0; ? You are likely facing this issue because you are using CGAL 4.12+ with gcc. Starting from 4.12, CGAL now properly supports CMake. In particular, it will propagates flags such as -frounding-math , which will cause gcc to produce a compilation error on the code above. You can read more about this issue in the CGAL bug tracker, and how it may impact your code. Our current recommendation is to keep the CGAL parts self-contained as much as possible, and avoid such constructs in the parts of the code that use CGAL. [J\u00e9r\u00e9mie] Should I use Eigen::MatrixBase or Eigen::PlainObjectBase as an argument for my templated functions? Use Eigen::MatrixBase for inputs (so you can pass plain matrices, maps and matrix expressions); Use Eigen::PlainObjectBase for outputs (so the memory can be allocated by the libigl function). I get an error: Server does not allow request for unadvertised object when cloning a repository using libigl as a submodule. You are probably getting this error because the libigl history rewriting that happened on XXX. Read more about this breaking change [here]. I have some old GUI code that uses NanoGUI. How can I update it to the latest version of libigl? In 2017, libigl switched from NanoGUI to ImGui for its viewer\u2019s user interface. The main reason was to remove nested dependencies in common with libigl, thus providing an overall lighter experience. ImGui also has other advantages, such as more dynamic menus (where you can add/remove elements on the fly), inject UI debugging code in user-code (with ImGuiOnceUponAFrame ), etc. Porting UI code to ImGui should be relatively straightforward. Have a look at tutorial 106 , or read issue #719 for more discussion. If you would like to keep NanoGUI as your interface library for whatever reason, you are welcome to write a ViewerPlugin reusing the old binding code, and we would be happy to advertise it somewhere. How to write custom shader code in the viewer? See #657 . How to draw text in the viewer? See #876 . Issues with multi-threading and cgal::CSGTree There is a known race condition that can occur in rare occasions when doing CSG operations with duplicated nodes in the CSG tree, e.g., igl :: copyleft :: cgal :: CSGTree inter ( tree , tree , \"i\" ); See an detailed explanation of the problem here , and please use this thread to discuss the bug if it affects you. So far the problem has only been observed on macOS. Commenting out viewer.launch() causes linker errors with imgui/glad (no imgui/glad functions called) This issue only happens on macOS with the Xcode project generator, when libigl is compiled in header-only mode. Possible solutions: Add an unused function in your project calling viewer.launch() . Compile libigl as a static library. Compile your project using another project generator (Makefile or Ninja). For a more detailed explanation of the problem, see this answer .","title":"FAQ"},{"location":"license/","text":"License \u00b6 Libigl is primarily licensed under MPL2: http://www.mozilla.org/MPL/2.0/ http://www.mozilla.org/MPL/2.0/FAQ.html All .h and .cpp files directly in include/igl (but not necessarily in sub-directories) are subject only to the terms of the MPL2; they should not include any code that is covered by other/less-permissive licenses. The .h and .cpp files in sub-directories of include/igl allow libigl to integrate with external third-party libraries (e.g., those in external/ ) and are subject to the MPL2, and also the terms of licenses of the corresponding external library. The licenses used by these libraries fall under three categories: common \u201cfree, non-copyleft licenses\u201d (such as zlib, BSD, MIT, and public domain) include/igl/anttweakbar include/igl/embree include/igl/opengl include/igl/opengl/glfw include/igl/opengl2 include/igl/png include/igl/viewer include/igl/xml common \u201ccopyleft\u201d licences (such as GPL, LGPL, and AGPL) include/igl/copyleft include/igl/copyleft/cgal include/igl/copyleft/comiso include/igl/copyleft/cork include/igl/copyleft/tetgen other \u201cuncommon\u201d licenses or commercial software include/igl/lim include/igl/matlab include/igl/mosek include/igl/triangle The Libigl code that interfaces with \u201ccopyleft\u201d libraries is in include/igl/copyleft . Only include these headers if you are accept the licensing terms of the corresponding external library. For example, using include/igl/copyleft/tetgen requires that you accept the terms of the AGPLv3.","title":"License"},{"location":"license/#license","text":"Libigl is primarily licensed under MPL2: http://www.mozilla.org/MPL/2.0/ http://www.mozilla.org/MPL/2.0/FAQ.html All .h and .cpp files directly in include/igl (but not necessarily in sub-directories) are subject only to the terms of the MPL2; they should not include any code that is covered by other/less-permissive licenses. The .h and .cpp files in sub-directories of include/igl allow libigl to integrate with external third-party libraries (e.g., those in external/ ) and are subject to the MPL2, and also the terms of licenses of the corresponding external library. The licenses used by these libraries fall under three categories: common \u201cfree, non-copyleft licenses\u201d (such as zlib, BSD, MIT, and public domain) include/igl/anttweakbar include/igl/embree include/igl/opengl include/igl/opengl/glfw include/igl/opengl2 include/igl/png include/igl/viewer include/igl/xml common \u201ccopyleft\u201d licences (such as GPL, LGPL, and AGPL) include/igl/copyleft include/igl/copyleft/cgal include/igl/copyleft/comiso include/igl/copyleft/cork include/igl/copyleft/tetgen other \u201cuncommon\u201d licenses or commercial software include/igl/lim include/igl/matlab include/igl/mosek include/igl/triangle The Libigl code that interfaces with \u201ccopyleft\u201d libraries is in include/igl/copyleft . Only include these headers if you are accept the licensing terms of the corresponding external library. For example, using include/igl/copyleft/tetgen requires that you accept the terms of the AGPLv3.","title":"License"},{"location":"matlab-to-eigen/","text":"","title":"Matlab-libigl Cheatsheet"},{"location":"python-bindings/","text":"","title":"Python Bindings"},{"location":"rewritten-history/","text":".md-nav--secondary .md-nav__list .md-nav__list { display: none } Danger On October 15, 2018, a lighter version of the libigl repository has been pushed to the master branch. This new version has its history rewritten, which does invalidate all commit SHA1 numbers pointing to previous versions of libigl. See the full list of changes in the changelog . Why Are We Doing This? \u00b6 libigl was always intended as lightweight library. Over the year, the size of the git repository grew significantly for various reasons: large binary assets being committed to the main repository, optional submodules growing in size, etc. To remedy this, we have changed the way external dependencies are handled. But to truly reduce the size of the repository to something manageable, it was necessary to prune large binary files from the git history. This means introducing breaking changes and invalidating existing commit SHA1 numbers. How To Upgrade? \u00b6 If you are using libigl as a submodule , I suggest you simply remove the submodule and add it again. To remove a submodule you can write (replacing external/libigl with the relative path to libigl in your repo): git submodule deinit external/libigl git rm -rf external/libigl And to add it again: git submodule add https://github.com/libigl/libigl.git external/libigl Before commmit your changes, here is what the output of git status should look like: On branch master Your branch is up to date with 'origin/master'. Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: .gitmodules modified: external/libigl Submodule changes to be committed: * external/libigl 7371494...ed363da: Warn: external/libigl doesn't contain commit 737149498ad3d25ea1a56dc4234a66d2876764ef The warning is normal: this is because submodule was referencing an old commit ( 7371494 ) that no longer exists in the new history, but the new commit ( ed363da ) does. If you have an existing fork of libigl, we strongly suggest that you delete it and fork the project anew. You will not be able to create a PR with a fork that has the old history. If you have existing changes (e.g. from a pending PR), then simply apply the same changes on the newly forked project, and submit your PR again. If you are new to libigl, there is nothing to do: use the new repository normally, and enjoy the new lightness! What About My Old Code? \u00b6 We maintain a copy of libigl with the old history in the repository libigl-legacy . If you have an old code the depends on a specific version of libigl, simply update the url (e.g. by editing the .gitmodules file), and it will pick up the matching commit with the SHA1 number from the old history. Troubleshooting \u00b6 Problem 1 \u00b6 I have an old project with a submodule using libigl, but it is pointing to an invalid commit number: Submodule 'libigl' (git@github.com:libigl/libigl.git) registered for path 'external/libigl' Cloning into '/home/user/foo/libigl-example-project/external/libigl'... error: Server does not allow request for unadvertised object 03536c4aa44a399ed7134b68f04cf3773edebc73 Fetched in submodule path 'external/libigl', but it did not contain 03536c4aa44a399ed7134b68f04cf3773edebc73. Direct fetching of that commit failed. How to fix Steps to reproduce the problem: \u00b6 Suppose we have a parent project with libigl submodule in external/libigl/ . Clone the parent repository git clone git@github.com:gabuzome/libigl-example-project.git Try to initialize the submodules with the command git submodule update --init --recursive this should produces the error you see above. Steps to fix the problem (execute in that order ): \u00b6 Delete the local folder that contained the submodule rm -rf external/libigl/ Delete the corrupted copy in the .git/ folder rm -rf .git/modules/external/libigl/ Change the libigl/libigl.git to libigl/libigl-legacy.git in the .gitmodules file. Or issue, on Linux sed -i 's|libigl/libigl.git|libigl/libigl-legacy.git|' .gitmodules Or issue, on Mac OS X sed -i '' 's|libigl/libigl.git|libigl/libigl-legacy.git|' .gitmodules Update local configuration of your submodule repos with the new URL git submodule sync Clone the submodule with the new address git submodule update --init --recursive Problem 2 \u00b6 I have a problem with my current project that I want to update to the latest version, but I messed up my submodule and somehow get this error message: A git directory for 'external/libigl' is found locally with remote(s): origin https://github.com/libigl/libigl.git If you want to reuse this local git directory instead of cloning again from https://github.com/libigl/libigl.git use the '--force' option. If the local git directory is not the correct repo or you are unsure what this means choose another name with the '--name' option. How to fix Steps to fix the problem (execute in that order ): \u00b6 Delete the local folder that contained the submodule rm -rf external/libigl/ Delete the corrupted copy in the .git/ folder rm -rf .git/modules/external/libigl/ Update local configuration of your submodule repos with the new URL git submodule sync Clone the submodule to the current tip of the repository git submodule update --init --recursive Problem 3 \u00b6 I have updated my submodule to the latest version of libigl, but the CMake script is complaining about missing targets. How to fix The files in the libigl repository have been restructured a little bit. The CMake build script are now located under cmake/ instead of shared/cmake/ . Please check out the latest version of the FindLIBIGL.cmake from the libigl-example-project . Problem 4 \u00b6 I have an existing fork with some changes, how do I update it to the latest version of libigl? How to fix For now we advise that you keep a copy of your legacy fork (you can rename/archive your existing fork, etc.), and create a new fork from the current libigl repository. If you have existing changes that you would like to merge, you can also try to cherry-pick the individual commits, but the simplest solution might to recreate new commits with the desired changes. Other Problems \u00b6 Please check out the changelog page for the list of changes that have been merged into the main branch.","title":"Rewritten History"},{"location":"rewritten-history/#why-are-we-doing-this","text":"libigl was always intended as lightweight library. Over the year, the size of the git repository grew significantly for various reasons: large binary assets being committed to the main repository, optional submodules growing in size, etc. To remedy this, we have changed the way external dependencies are handled. But to truly reduce the size of the repository to something manageable, it was necessary to prune large binary files from the git history. This means introducing breaking changes and invalidating existing commit SHA1 numbers.","title":"Why Are We Doing This?"},{"location":"rewritten-history/#how-to-upgrade","text":"If you are using libigl as a submodule , I suggest you simply remove the submodule and add it again. To remove a submodule you can write (replacing external/libigl with the relative path to libigl in your repo): git submodule deinit external/libigl git rm -rf external/libigl And to add it again: git submodule add https://github.com/libigl/libigl.git external/libigl Before commmit your changes, here is what the output of git status should look like: On branch master Your branch is up to date with 'origin/master'. Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: .gitmodules modified: external/libigl Submodule changes to be committed: * external/libigl 7371494...ed363da: Warn: external/libigl doesn't contain commit 737149498ad3d25ea1a56dc4234a66d2876764ef The warning is normal: this is because submodule was referencing an old commit ( 7371494 ) that no longer exists in the new history, but the new commit ( ed363da ) does. If you have an existing fork of libigl, we strongly suggest that you delete it and fork the project anew. You will not be able to create a PR with a fork that has the old history. If you have existing changes (e.g. from a pending PR), then simply apply the same changes on the newly forked project, and submit your PR again. If you are new to libigl, there is nothing to do: use the new repository normally, and enjoy the new lightness!","title":"How To Upgrade?"},{"location":"rewritten-history/#what-about-my-old-code","text":"We maintain a copy of libigl with the old history in the repository libigl-legacy . If you have an old code the depends on a specific version of libigl, simply update the url (e.g. by editing the .gitmodules file), and it will pick up the matching commit with the SHA1 number from the old history.","title":"What About My Old Code?"},{"location":"rewritten-history/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"rewritten-history/#problem-1","text":"I have an old project with a submodule using libigl, but it is pointing to an invalid commit number: Submodule 'libigl' (git@github.com:libigl/libigl.git) registered for path 'external/libigl' Cloning into '/home/user/foo/libigl-example-project/external/libigl'... error: Server does not allow request for unadvertised object 03536c4aa44a399ed7134b68f04cf3773edebc73 Fetched in submodule path 'external/libigl', but it did not contain 03536c4aa44a399ed7134b68f04cf3773edebc73. Direct fetching of that commit failed. How to fix","title":"Problem 1"},{"location":"rewritten-history/#steps-to-reproduce-the-problem","text":"Suppose we have a parent project with libigl submodule in external/libigl/ . Clone the parent repository git clone git@github.com:gabuzome/libigl-example-project.git Try to initialize the submodules with the command git submodule update --init --recursive this should produces the error you see above.","title":"Steps to reproduce the problem:"},{"location":"rewritten-history/#steps-to-fix-the-problem-execute-in-that-order","text":"Delete the local folder that contained the submodule rm -rf external/libigl/ Delete the corrupted copy in the .git/ folder rm -rf .git/modules/external/libigl/ Change the libigl/libigl.git to libigl/libigl-legacy.git in the .gitmodules file. Or issue, on Linux sed -i 's|libigl/libigl.git|libigl/libigl-legacy.git|' .gitmodules Or issue, on Mac OS X sed -i '' 's|libigl/libigl.git|libigl/libigl-legacy.git|' .gitmodules Update local configuration of your submodule repos with the new URL git submodule sync Clone the submodule with the new address git submodule update --init --recursive","title":"Steps to fix the problem (execute in that order):"},{"location":"rewritten-history/#problem-2","text":"I have a problem with my current project that I want to update to the latest version, but I messed up my submodule and somehow get this error message: A git directory for 'external/libigl' is found locally with remote(s): origin https://github.com/libigl/libigl.git If you want to reuse this local git directory instead of cloning again from https://github.com/libigl/libigl.git use the '--force' option. If the local git directory is not the correct repo or you are unsure what this means choose another name with the '--name' option. How to fix","title":"Problem 2"},{"location":"rewritten-history/#steps-to-fix-the-problem-execute-in-that-order_1","text":"Delete the local folder that contained the submodule rm -rf external/libigl/ Delete the corrupted copy in the .git/ folder rm -rf .git/modules/external/libigl/ Update local configuration of your submodule repos with the new URL git submodule sync Clone the submodule to the current tip of the repository git submodule update --init --recursive","title":"Steps to fix the problem (execute in that order):"},{"location":"rewritten-history/#problem-3","text":"I have updated my submodule to the latest version of libigl, but the CMake script is complaining about missing targets. How to fix The files in the libigl repository have been restructured a little bit. The CMake build script are now located under cmake/ instead of shared/cmake/ . Please check out the latest version of the FindLIBIGL.cmake from the libigl-example-project .","title":"Problem 3"},{"location":"rewritten-history/#problem-4","text":"I have an existing fork with some changes, how do I update it to the latest version of libigl? How to fix For now we advise that you keep a copy of your legacy fork (you can rename/archive your existing fork, etc.), and create a new fork from the current libigl repository. If you have existing changes that you would like to merge, you can also try to cherry-pick the individual commits, but the simplest solution might to recreate new commits with the desired changes.","title":"Problem 4"},{"location":"rewritten-history/#other-problems","text":"Please check out the changelog page for the list of changes that have been merged into the main branch.","title":"Other Problems"},{"location":"static-library/","text":".md-nav--secondary .md-nav__list .md-nav__list { display: none } Compiling libigl As A Static Library \u00b6 Warning Compiling libigl as a static library is considerably more difficult than using it as a header-only library (see installation instruction instead). Do it only if you are experienced with C++, cmake and make, and you want to improve your compilation times. Libigl is developed most often on Mac OS X, though has current users in Linux and Windows. Linux/Mac OS X/Cygwin \u00b6 Libigl may also be compiled to a static library. This is advantageous when building a project with libigl, since when used as an header-only library can slow down compile times. To build the entire libigl library producing at least lib/libigl.a and possible other (automatically detected) extras, e.g. lib/libiglcgal.a issue: cmake ../ -DCMAKE_BUILD_TYPE = Release \\ -DLIBIGL_USE_STATIC_LIBRARY = ON \\ -DCMAKE_INSTALL_PREFIX = /path/to/custom/installation make make install This will install libigl into the directory specified by CMAKE_INSTALL_PREFIX , which is set to /usr/local by deafault on macOS and Linux. The installation process does not only create ${CMAKE_INSTALL_PREFIX}/lib/libigl.a , it copies the libigl headers into ${CMAKE_INSTALL_PREFIX}/include/igl/ too. Or if you base your project on the libigl-example-project you can add option ( LIBIGL_USE_STATIC_LIBRARY \"Use libIGL as static librarie\" ON ) before the following line find_package ( LIBIGL REQUIRED QUIET ) in the CMakeLists.txt to always build libigl as static library for your project. See example-project aswell. Tip If you have changed the value for LIBIGL_USE_STATIC_LIBRARY in your CMakeLists.txt make sure to remove or update the CMakeCache.txt in your build directory. Warning You should expect to see a few linker warnings of the form: /opt/local/bin/ranlib: file: libigl.a ( *.cpp.o ) has no symbols These are (admittedly unpopular) functions that have never been used by us statically so we haven\u2019t explicit instantiations (yet). Development \u00b6 Further documentation for developers is listed in style-guidelines . License \u00b6 See LICENSE.txt Zipping \u00b6 Zip this directory without .git litter and binaries using: git archive -prefix = libigl/ -o libigl.zip master Explicit Instantiations Of Templated Functions \u00b6 Special care must be taken by the developers of each function and class in the libigl library that uses C++ templates. If this function is intended to be compiled into the statically linked libigl library then function is only compiled for each explicitly instantiated declaration. These should be added at the bottom of the corresponding .cpp file surrounded by a #ifdef IGL_STATIC_LIBRARY Of course, a developer may not know ahead of time which instantiations should be explicitly included in the igl static lib. One way to find out is to add one explicit instantiation for each call in one\u2019s own project. This only ever needs to be done once for each template. The process is somewhat mechanical using a linker with reasonable error output. Supposed for example we have compiled the igl static lib, including the cat.h and cat.cpp functions, without any explicit instantiation. Say using the makefile in the libigl directory: cd $LIBIGL make Now if we try to compile a project and link against it we may get an error like: Undefined symbols for architecture x86_64: \"Eigen::Matrix<int, -1, -1, 0, -1, -1> igl::cat<Eigen::Matrix<int, -1, -1, 0, -1, -1> >(int, Eigen::Matrix<int, -1, -1, 0, -1, -1> const&, Eigen::Matrix<int, -1, -1, 0, -1, -1> const&)\" , referenced from: uniform_sample ( Eigen::Matrix<double, -1, -1, 0 , -1, -1> const & , Eigen::Matrix<int, -1, -1, 0 , -1, -1> const & , int, double, Eigen::Matrix<double, -1, -1, 0 , -1, -1> & ) in Skinning.o \"Eigen::SparseMatrix<double, 0, int> igl::cat<Eigen::SparseMatrix<double, 0, int> >(int, Eigen::SparseMatrix<double, 0, int> const&, Eigen::SparseMatrix<double, 0, int> const&)\" , referenced from: covariance_scatter_matrix ( Eigen::Matrix<double, -1, -1, 0 , -1, -1> const & , Eigen::Matrix<int, -1, -1, 0 , -1, -1> const & , ArapEnergy, Eigen::SparseMatrix<double, 0 , int> & ) in arap_dof.o arap_rhs ( Eigen::Matrix<double, -1, -1, 0 , -1, -1> const & , Eigen::Matrix<int, -1, -1, 0 , -1, -1> const & , ArapEnergy, Eigen::SparseMatrix<double, 0 , int> & ) in arap_dof.o This looks like a mess, but luckily we don\u2019t really need to read it all. Just copy the first part in quotes Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > igl :: cat < Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > > ( int , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & ) , then append it to the list of explicit template instantiations at the end of cat.cpp after the word template and followed by a semi-colon. Like this: #ifdef IGL_STATIC_LIBRARY // Explicit template instantiation template Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > igl :: cat < Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > > ( int , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & ); #endif Then you must recompile the IGL static library. cd $LIBIGL make And try to compile your project again, potentially repeating this process until no more symbols are undefined. Note It may be useful to check that you code compiles with no errors first using the headers-only version to be sure that all errors are from missing template instantiations. If you\u2019re using make then the following command will reveal each missing symbol on its own line: make 2 > & 1 | grep \"referenced from\" | sed -e \"s/, referenced from.*//\" Benefits Of Static Library \u00b6 Faster compile time : Because the libigl library is already compiled, only the new code in ones project must be compiled and then linked to IGL. This means compile times are generally faster. Debug or optimized : The IGL static library may be compiled in debug mode or optimized release mode regardless of whether one\u2019s project is being optimized or debugged. Drawbacks Of Static Library \u00b6 Hard to use templates : Special care (by the developers of the library) needs to be taken when exposing templated functions.","title":"Static Library"},{"location":"static-library/#compiling-libigl-as-a-static-library","text":"Warning Compiling libigl as a static library is considerably more difficult than using it as a header-only library (see installation instruction instead). Do it only if you are experienced with C++, cmake and make, and you want to improve your compilation times. Libigl is developed most often on Mac OS X, though has current users in Linux and Windows.","title":"Compiling libigl As A Static Library"},{"location":"static-library/#linuxmac-os-xcygwin","text":"Libigl may also be compiled to a static library. This is advantageous when building a project with libigl, since when used as an header-only library can slow down compile times. To build the entire libigl library producing at least lib/libigl.a and possible other (automatically detected) extras, e.g. lib/libiglcgal.a issue: cmake ../ -DCMAKE_BUILD_TYPE = Release \\ -DLIBIGL_USE_STATIC_LIBRARY = ON \\ -DCMAKE_INSTALL_PREFIX = /path/to/custom/installation make make install This will install libigl into the directory specified by CMAKE_INSTALL_PREFIX , which is set to /usr/local by deafault on macOS and Linux. The installation process does not only create ${CMAKE_INSTALL_PREFIX}/lib/libigl.a , it copies the libigl headers into ${CMAKE_INSTALL_PREFIX}/include/igl/ too. Or if you base your project on the libigl-example-project you can add option ( LIBIGL_USE_STATIC_LIBRARY \"Use libIGL as static librarie\" ON ) before the following line find_package ( LIBIGL REQUIRED QUIET ) in the CMakeLists.txt to always build libigl as static library for your project. See example-project aswell. Tip If you have changed the value for LIBIGL_USE_STATIC_LIBRARY in your CMakeLists.txt make sure to remove or update the CMakeCache.txt in your build directory. Warning You should expect to see a few linker warnings of the form: /opt/local/bin/ranlib: file: libigl.a ( *.cpp.o ) has no symbols These are (admittedly unpopular) functions that have never been used by us statically so we haven\u2019t explicit instantiations (yet).","title":"Linux/Mac OS X/Cygwin"},{"location":"static-library/#development","text":"Further documentation for developers is listed in style-guidelines .","title":"Development"},{"location":"static-library/#license","text":"See LICENSE.txt","title":"License"},{"location":"static-library/#zipping","text":"Zip this directory without .git litter and binaries using: git archive -prefix = libigl/ -o libigl.zip master","title":"Zipping"},{"location":"static-library/#explicit-instantiations-of-templated-functions","text":"Special care must be taken by the developers of each function and class in the libigl library that uses C++ templates. If this function is intended to be compiled into the statically linked libigl library then function is only compiled for each explicitly instantiated declaration. These should be added at the bottom of the corresponding .cpp file surrounded by a #ifdef IGL_STATIC_LIBRARY Of course, a developer may not know ahead of time which instantiations should be explicitly included in the igl static lib. One way to find out is to add one explicit instantiation for each call in one\u2019s own project. This only ever needs to be done once for each template. The process is somewhat mechanical using a linker with reasonable error output. Supposed for example we have compiled the igl static lib, including the cat.h and cat.cpp functions, without any explicit instantiation. Say using the makefile in the libigl directory: cd $LIBIGL make Now if we try to compile a project and link against it we may get an error like: Undefined symbols for architecture x86_64: \"Eigen::Matrix<int, -1, -1, 0, -1, -1> igl::cat<Eigen::Matrix<int, -1, -1, 0, -1, -1> >(int, Eigen::Matrix<int, -1, -1, 0, -1, -1> const&, Eigen::Matrix<int, -1, -1, 0, -1, -1> const&)\" , referenced from: uniform_sample ( Eigen::Matrix<double, -1, -1, 0 , -1, -1> const & , Eigen::Matrix<int, -1, -1, 0 , -1, -1> const & , int, double, Eigen::Matrix<double, -1, -1, 0 , -1, -1> & ) in Skinning.o \"Eigen::SparseMatrix<double, 0, int> igl::cat<Eigen::SparseMatrix<double, 0, int> >(int, Eigen::SparseMatrix<double, 0, int> const&, Eigen::SparseMatrix<double, 0, int> const&)\" , referenced from: covariance_scatter_matrix ( Eigen::Matrix<double, -1, -1, 0 , -1, -1> const & , Eigen::Matrix<int, -1, -1, 0 , -1, -1> const & , ArapEnergy, Eigen::SparseMatrix<double, 0 , int> & ) in arap_dof.o arap_rhs ( Eigen::Matrix<double, -1, -1, 0 , -1, -1> const & , Eigen::Matrix<int, -1, -1, 0 , -1, -1> const & , ArapEnergy, Eigen::SparseMatrix<double, 0 , int> & ) in arap_dof.o This looks like a mess, but luckily we don\u2019t really need to read it all. Just copy the first part in quotes Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > igl :: cat < Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > > ( int , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & ) , then append it to the list of explicit template instantiations at the end of cat.cpp after the word template and followed by a semi-colon. Like this: #ifdef IGL_STATIC_LIBRARY // Explicit template instantiation template Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > igl :: cat < Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > > ( int , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & , Eigen :: Matrix < int , -1 , -1 , 0 , -1 , -1 > const & ); #endif Then you must recompile the IGL static library. cd $LIBIGL make And try to compile your project again, potentially repeating this process until no more symbols are undefined. Note It may be useful to check that you code compiles with no errors first using the headers-only version to be sure that all errors are from missing template instantiations. If you\u2019re using make then the following command will reveal each missing symbol on its own line: make 2 > & 1 | grep \"referenced from\" | sed -e \"s/, referenced from.*//\"","title":"Explicit Instantiations Of Templated Functions"},{"location":"static-library/#benefits-of-static-library","text":"Faster compile time : Because the libigl library is already compiled, only the new code in ones project must be compiled and then linked to IGL. This means compile times are generally faster. Debug or optimized : The IGL static library may be compiled in debug mode or optimized release mode regardless of whether one\u2019s project is being optimized or debugged.","title":"Benefits Of Static Library"},{"location":"static-library/#drawbacks-of-static-library","text":"Hard to use templates : Special care (by the developers of the library) needs to be taken when exposing templated functions.","title":"Drawbacks Of Static Library"},{"location":"style-guidelines/","text":".md-nav--secondary .md-nav__list .md-nav__list { display: none } Libigl Style Guidelines \u00b6 Libigl is used and developed by many people. This document highlights some style guidelines for developers of the library, but also acts as best-practices for users. One function, one .h/.cpp pair \u00b6 The structure of libigl is very flat and function-based. For every function/sub-routine, create a single .h and .cpp file. For example, if you have a function that determines connected components from a face list F you would create the header connected_components.h and connected_components.cpp and the only function defined should be void connected_components(const ... F, ... C) . If the implementation of connected_components requires a subroutine to compute an adjacency matrix then create another pair adjacency_matrix.h and adjacency_matrix.cpp with a single function void adjacency_matrix(const ... F, ... A) . Example \u00b6 Here is an example function that would be defined in include/igl/example_fun.h and implemented in include/igl/example_fun.cpp . example_fun.h \u00b6 // This file is part of libigl, a simple c++ geometry processing library. // // Copyright (C) 2015 [Your Name] [your email address] // // This Source Code Form is subject to the terms of the Mozilla Public License // v. 2.0. If a copy of the MPL was not distributed with this file, You can // obtain one at http://mozilla.org/MPL/2.0/ #ifndef IGL_EXAMPLE_FUN_H #define IGL_EXAMPLE_FUN_H #include \"igl_inline.h\" namespace igl { // This is an example of a function, it takes a templated parameter and // shovels it into cout // // Input: // input some input of a Printable type // Returns true for the sake of returning something template < typename Printable > IGL_INLINE bool example_fun ( const Printable & input ); } #ifndef IGL_STATIC_LIBRARY # include \"example_fun.cpp\" #endif #endif example_fun.cpp \u00b6 // This file is part of libigl, a simple c++ geometry processing library. // // Copyright (C) 2015 [Your Name] [your email address] // // This Source Code Form is subject to the terms of the Mozilla Public License // v. 2.0. If a copy of the MPL was not distributed with this file, You can // obtain one at http://mozilla.org/MPL/2.0/ #include \"igl/example_fun.h\" #include <iostream> template < typename Printable > IGL_INLINE bool igl :: example_fun ( const Printable & input ) { using namespace std ; cout << \"example_fun: \" << input << endl ; return true ; } #ifdef IGL_STATIC_LIBRARY template bool igl :: example_fun < double > ( const double & input ); template bool igl :: example_fun < int > ( const int & input ); #endif Avoid static \u201chelper\u201d functions \u00b6 Strive to encapsulate sub-functions that could possibly be useful outside of the implementation of your current function. This might mean abstracting the interface a bit. If it doesn\u2019t dramatically effect performance then create a new pair of .h/.cpp files with this sub-function. Lambda functions \u00b6 If encapsulation in a separate file is not possible or does not make sense, then avoid crowding the namespace by creating lambda functions within the function implementation. These lambda functions must still be documented with clear input and output arguments . Avoid using full capturing of all automatic variables: do not use [&] or [=] . Rather specify each captured variable individually. Avoid \u201chelper\u201d classes \u00b6 Libigl is built around the high-performance paradigm of \u201cstruct of arrays\u201d rather than \u201carray of structs\u201d. The way we achieve this is to avoid classes and pass \u201cbasic types\u201d directly. The price we pay is long function interfaces, but this increases code reuse dramatically. A \u201cbasic type\u201d in our context is a Eigen type, stl type, or basic C type. Header Documentation \u00b6 Each function prototype should be well documented in its corresponding .h header file. A typical documentation consists of four parts: // [A human readable description of what the function does.] // // Inputs: // [variable name of first (const) input] [dimensions and description of // this input variable] // [variable name of second (const) input] [dimensions and description of // this input variable] // ... // Outputs: // [variable name of first output ] [dimensions and description of this // output variable] // [variable name of second output ] [dimensions and description of this // output variable] // ... // Returns [description of return value] Example \u00b6 For example the header barycenter.h // Computes the barycenter of every simplex // // Inputs: // V #V by dim matrix of vertex coordinates // F #F by simplex_size matrix of indices of simplex corners into V // Output: // BC #F by dim matrix of 3d vertices // Const inputs \u00b6 All input parameters should be demarcated const . If an input is also an output than consider exposing two parameters (one const ) or be sure to list the variable under both // Inputs: and // Outputs: in the header comments. Reference parameters \u00b6 All but simple types should be passed by reference (e.g. Matrix & mat ) rather than pointers (e.g. Matrix * mat ) or value (e.g. Matrix mat ). Returns vs output parameters \u00b6 All functions should be implemented with at least one overload that has a void or simple return type (e.g. bool on success/failure). With this implementation its then possible to write an overload that returns a single output. Please see Templating with Eigen . For example: template < typename Atype > void adjacency_matrix ( const ... & F , Eigen :: SparseMatrix < AType > & A ); template < typename Atype > Eigen :: SparseMatrix < Atype > adjacency_matrix ( const ... & F ); Templating with Eigen \u00b6 Functions taking Eigen dense matrices/arrays as inputs and outputs (but not return arguments), should template on top of Eigen::MatrixBase . Each parameter should be derived using its own template. For example, template < typename DerivedV , typename DerivedF , typename DerivedBC > void barycenter ( const Eigen :: MatrixBase < DerivedV > & V , const Eigen :: MatrixBase < DerivedF > & F , const Eigen :: MatrixBase < DerivedBC > & BC ); The Derived* template encodes the scalar type (e.g. double , int ), the number of rows and cols at compile time, and the data storage (Row-major vs. column-major). Returning Eigen types is discouraged. In cases where the size and scalar type are a fixed and matching function of an input Derived* template, then return that Derived* type. Do not return Eigen::PlainObjectBase<...> types. For example, this function scales fits a given set of points to the unit cube. The return is a new set of vertex positions so its type should match that of the input points: template < typename DerivedV > void DerivedV fit_to_unit_cube ( const Eigen :: PlainObjectBase < DerivedV > & V ); To implement this function, it is required to implement a more generic output-argument version and call that. So a full implementation looks like: In igl/fit_in_unit_cube.h : template < typename DerivedV , typename DerivedW > void fit_to_unit_cube ( const Eigen :: MatrixBase < DerivedV > & V , Eigen :: PlainObjectBase < DerivedW > & W ); template < typename DerivedV > void DerivedV fit_to_unit_cube ( const Eigen :: PlainObjectBase < DerivedV > & V ); In igl/fit_in_unit_cube.cpp : template < typename DerivedV , typename DerivedW > void fit_to_unit_cube ( const Eigen :: MatrixBase < DerivedV > & V , Eigen :: PlainObjectBase < DerivedW > & W ) { W = ( V . rowwise () - V . colwise (). minCoeff ()). array () / ( V . maxCoeff () - V . minCoeff ()); } template < typename DerivedV > void DerivedV fit_to_unit_cube ( const Eigen :: MatrixBase < DerivedV > & V ) { DerivedV W ; fit_to_unit_cube ( V , W ); return W ; } Notice that W is declared as a DerivedV type and not Eigen::PlainObjectBase<DerivedV> type. Note: Not all functions are suitable for returning Eigen types. For example igl::barycenter above outputs a #F by dim list of barycenters. Returning a DerivedV type would be inappropriate since the number of rows in DerivedV will be #V and may not match the number of rows in DerivedF (#F). Function naming conventions \u00b6 Functions (and thus also files ) should have simple, descriptive names using lowercase letters and underscores between words. Avoid unnecessary prefaces. For example, instead of compute_adjacency_matrix , construct_adjacency_matrix , extract_adjacency_matrix , get_adjacency_matrix , or set_adjacency_matrix just call the function adjacency_matrix . Variable naming conventions \u00b6 Libigl prefers short (even single character) variable names with heavy documentation in the comments in the header file or above the declaration of the function. When possible use V to mean a list of vertex positions and F to mean a list of faces/triangles. Class naming conventions \u00b6 Classes should be avoided. When naming a class use CamelCase (e.g. SortableRow.h). Enum naming conversion \u00b6 Enums types should be placed in the appropriate igl:: namespace and should be named in CamelCase (e.g. igl::SolverStatus ) and instances should be named in ALL_CAPS with underscores between words and prefaced with the name of the enum. For example: namespace igl { enum SolverStatus { // Good SOLVER_STATUS_CONVERGED = 0 , // OK SOLVER_STATUS_MAX_ITER = 1 , // Bad SOLVER_STATUS_ERROR = 2 , NUM_SOLVER_STATUSES = 3 , }; }; Exception for file IO \u00b6 For legacy reasons, file reading and writing functions use a different naming convention. A functions reading a .xyz file should be named readXYZ and a function writing .xyz files should be names writeXYZ . using namespace ... in global scope \u00b6 Writing using namespace std; , using namespace Eigen; etc. outside of a global scope is strictly forbidden. Place these lines at the top of each function instead. Namespaces and external dependencies \u00b6 Functions in the main library (directly in include/igl ) should only depend on Eigen and stl. These functions should have the igl:: namespace. Functions with other dependencies should be placed into appropriate sub-directories (e.g. if myfunction depends on tetgen then create igl/copyleft/tetgen/myfunction.h and igl/copyleft/tetgen/myfunction.cpp and give the function the namespace igl::copyleft::tetgen::myfunction . copyleft subdirectory/namespace \u00b6 Dependencies that require users of libigl to release their projects open source (e.g. GPL) are considered aggressively \u201ccopyleft\u201d and should be placed in the include/igl/copyleft/ sub-directory and igl::copyleft:: namespace. Assertions \u00b6 Be generous with assertions and always identify the assertion with strings: assert ( m < n && \"m must be less than n\" ); ifndef include guard \u00b6 Every header file should be wrapped in an #ifndef compiler directive. The name of the guard should be in direct correspondence with the path of the .h file. For example, include/igl/copyleft/tetgen/tetrahedralize.h should be #ifndef IGL_COPYLEFT_TETGEN_TETRAHEDRALIZE_H #define IGL_COPYLEFT_TETGEN_TETRAHEDRALIZE_H ... #endif Spaces vs. tabs indentation \u00b6 Do not use tabs. Use 2 spaces for each indentation level. Max line length \u00b6 Limit lines to 80 characters. Break up long lines into many operations (this also helps performance). Include order \u00b6 #include directives at the top of a .h or .cpp file should be sorted according to a simple principle: place headers of files most likely to be edited by you first. This means for include/igl/copyleft/tetgen/tetrahedralize.cpp you might see // [Includes of headers in this directory] #include \"tetrahedralize.h\" #include \"mesh_to_tetgenio.h\" #include \"tetgenio_to_tetmesh.h\" // [Includes of headers in this project] #include \"../../matrix_to_list.h\" #include \"../../list_to_matrix.h\" #include \"../../boundary_facets.h\" // [Includes of headers of related projects] #include <Eigen/Core> // [Includes of headers of standard libraries] #include <cassert> #include <iostream> Placement of includes \u00b6 Whenever possible #include directives should be placed in the .cpp implementation file rather than the .h header file. Warnings \u00b6 Code should compile without firing any warnings. An Exception \u00b6 The only exception is for the use of the deprecated Eigen::DynamicSparseMatrix in core sub-routines (e.g. igl::cat ). This class is still supported and faster than the standard, non-deprecated Eigen implementation so we\u2019re keeping it as long as possible and profitable.","title":"Style Guidelines"},{"location":"style-guidelines/#libigl-style-guidelines","text":"Libigl is used and developed by many people. This document highlights some style guidelines for developers of the library, but also acts as best-practices for users.","title":"Libigl Style Guidelines"},{"location":"style-guidelines/#one-function-one-hcpp-pair","text":"The structure of libigl is very flat and function-based. For every function/sub-routine, create a single .h and .cpp file. For example, if you have a function that determines connected components from a face list F you would create the header connected_components.h and connected_components.cpp and the only function defined should be void connected_components(const ... F, ... C) . If the implementation of connected_components requires a subroutine to compute an adjacency matrix then create another pair adjacency_matrix.h and adjacency_matrix.cpp with a single function void adjacency_matrix(const ... F, ... A) .","title":"One function, one .h/.cpp pair"},{"location":"style-guidelines/#example","text":"Here is an example function that would be defined in include/igl/example_fun.h and implemented in include/igl/example_fun.cpp .","title":"Example"},{"location":"style-guidelines/#example_funh","text":"// This file is part of libigl, a simple c++ geometry processing library. // // Copyright (C) 2015 [Your Name] [your email address] // // This Source Code Form is subject to the terms of the Mozilla Public License // v. 2.0. If a copy of the MPL was not distributed with this file, You can // obtain one at http://mozilla.org/MPL/2.0/ #ifndef IGL_EXAMPLE_FUN_H #define IGL_EXAMPLE_FUN_H #include \"igl_inline.h\" namespace igl { // This is an example of a function, it takes a templated parameter and // shovels it into cout // // Input: // input some input of a Printable type // Returns true for the sake of returning something template < typename Printable > IGL_INLINE bool example_fun ( const Printable & input ); } #ifndef IGL_STATIC_LIBRARY # include \"example_fun.cpp\" #endif #endif","title":"example_fun.h"},{"location":"style-guidelines/#example_funcpp","text":"// This file is part of libigl, a simple c++ geometry processing library. // // Copyright (C) 2015 [Your Name] [your email address] // // This Source Code Form is subject to the terms of the Mozilla Public License // v. 2.0. If a copy of the MPL was not distributed with this file, You can // obtain one at http://mozilla.org/MPL/2.0/ #include \"igl/example_fun.h\" #include <iostream> template < typename Printable > IGL_INLINE bool igl :: example_fun ( const Printable & input ) { using namespace std ; cout << \"example_fun: \" << input << endl ; return true ; } #ifdef IGL_STATIC_LIBRARY template bool igl :: example_fun < double > ( const double & input ); template bool igl :: example_fun < int > ( const int & input ); #endif","title":"example_fun.cpp"},{"location":"style-guidelines/#avoid-static-helper-functions","text":"Strive to encapsulate sub-functions that could possibly be useful outside of the implementation of your current function. This might mean abstracting the interface a bit. If it doesn\u2019t dramatically effect performance then create a new pair of .h/.cpp files with this sub-function.","title":"Avoid static \"helper\" functions"},{"location":"style-guidelines/#lambda-functions","text":"If encapsulation in a separate file is not possible or does not make sense, then avoid crowding the namespace by creating lambda functions within the function implementation. These lambda functions must still be documented with clear input and output arguments . Avoid using full capturing of all automatic variables: do not use [&] or [=] . Rather specify each captured variable individually.","title":"Lambda functions"},{"location":"style-guidelines/#avoid-helper-classes","text":"Libigl is built around the high-performance paradigm of \u201cstruct of arrays\u201d rather than \u201carray of structs\u201d. The way we achieve this is to avoid classes and pass \u201cbasic types\u201d directly. The price we pay is long function interfaces, but this increases code reuse dramatically. A \u201cbasic type\u201d in our context is a Eigen type, stl type, or basic C type.","title":"Avoid \"helper\" classes"},{"location":"style-guidelines/#header-documentation","text":"Each function prototype should be well documented in its corresponding .h header file. A typical documentation consists of four parts: // [A human readable description of what the function does.] // // Inputs: // [variable name of first (const) input] [dimensions and description of // this input variable] // [variable name of second (const) input] [dimensions and description of // this input variable] // ... // Outputs: // [variable name of first output ] [dimensions and description of this // output variable] // [variable name of second output ] [dimensions and description of this // output variable] // ... // Returns [description of return value]","title":"Header Documentation"},{"location":"style-guidelines/#example_1","text":"For example the header barycenter.h // Computes the barycenter of every simplex // // Inputs: // V #V by dim matrix of vertex coordinates // F #F by simplex_size matrix of indices of simplex corners into V // Output: // BC #F by dim matrix of 3d vertices //","title":"Example"},{"location":"style-guidelines/#const-inputs","text":"All input parameters should be demarcated const . If an input is also an output than consider exposing two parameters (one const ) or be sure to list the variable under both // Inputs: and // Outputs: in the header comments.","title":"Const inputs"},{"location":"style-guidelines/#reference-parameters","text":"All but simple types should be passed by reference (e.g. Matrix & mat ) rather than pointers (e.g. Matrix * mat ) or value (e.g. Matrix mat ).","title":"Reference parameters"},{"location":"style-guidelines/#returns-vs-output-parameters","text":"All functions should be implemented with at least one overload that has a void or simple return type (e.g. bool on success/failure). With this implementation its then possible to write an overload that returns a single output. Please see Templating with Eigen . For example: template < typename Atype > void adjacency_matrix ( const ... & F , Eigen :: SparseMatrix < AType > & A ); template < typename Atype > Eigen :: SparseMatrix < Atype > adjacency_matrix ( const ... & F );","title":"Returns vs output parameters"},{"location":"style-guidelines/#templating-with-eigen","text":"Functions taking Eigen dense matrices/arrays as inputs and outputs (but not return arguments), should template on top of Eigen::MatrixBase . Each parameter should be derived using its own template. For example, template < typename DerivedV , typename DerivedF , typename DerivedBC > void barycenter ( const Eigen :: MatrixBase < DerivedV > & V , const Eigen :: MatrixBase < DerivedF > & F , const Eigen :: MatrixBase < DerivedBC > & BC ); The Derived* template encodes the scalar type (e.g. double , int ), the number of rows and cols at compile time, and the data storage (Row-major vs. column-major). Returning Eigen types is discouraged. In cases where the size and scalar type are a fixed and matching function of an input Derived* template, then return that Derived* type. Do not return Eigen::PlainObjectBase<...> types. For example, this function scales fits a given set of points to the unit cube. The return is a new set of vertex positions so its type should match that of the input points: template < typename DerivedV > void DerivedV fit_to_unit_cube ( const Eigen :: PlainObjectBase < DerivedV > & V ); To implement this function, it is required to implement a more generic output-argument version and call that. So a full implementation looks like: In igl/fit_in_unit_cube.h : template < typename DerivedV , typename DerivedW > void fit_to_unit_cube ( const Eigen :: MatrixBase < DerivedV > & V , Eigen :: PlainObjectBase < DerivedW > & W ); template < typename DerivedV > void DerivedV fit_to_unit_cube ( const Eigen :: PlainObjectBase < DerivedV > & V ); In igl/fit_in_unit_cube.cpp : template < typename DerivedV , typename DerivedW > void fit_to_unit_cube ( const Eigen :: MatrixBase < DerivedV > & V , Eigen :: PlainObjectBase < DerivedW > & W ) { W = ( V . rowwise () - V . colwise (). minCoeff ()). array () / ( V . maxCoeff () - V . minCoeff ()); } template < typename DerivedV > void DerivedV fit_to_unit_cube ( const Eigen :: MatrixBase < DerivedV > & V ) { DerivedV W ; fit_to_unit_cube ( V , W ); return W ; } Notice that W is declared as a DerivedV type and not Eigen::PlainObjectBase<DerivedV> type. Note: Not all functions are suitable for returning Eigen types. For example igl::barycenter above outputs a #F by dim list of barycenters. Returning a DerivedV type would be inappropriate since the number of rows in DerivedV will be #V and may not match the number of rows in DerivedF (#F).","title":"Templating with Eigen"},{"location":"style-guidelines/#function-naming-conventions","text":"Functions (and thus also files ) should have simple, descriptive names using lowercase letters and underscores between words. Avoid unnecessary prefaces. For example, instead of compute_adjacency_matrix , construct_adjacency_matrix , extract_adjacency_matrix , get_adjacency_matrix , or set_adjacency_matrix just call the function adjacency_matrix .","title":"Function naming conventions"},{"location":"style-guidelines/#variable-naming-conventions","text":"Libigl prefers short (even single character) variable names with heavy documentation in the comments in the header file or above the declaration of the function. When possible use V to mean a list of vertex positions and F to mean a list of faces/triangles.","title":"Variable naming conventions"},{"location":"style-guidelines/#class-naming-conventions","text":"Classes should be avoided. When naming a class use CamelCase (e.g. SortableRow.h).","title":"Class naming conventions"},{"location":"style-guidelines/#enum-naming-conversion","text":"Enums types should be placed in the appropriate igl:: namespace and should be named in CamelCase (e.g. igl::SolverStatus ) and instances should be named in ALL_CAPS with underscores between words and prefaced with the name of the enum. For example: namespace igl { enum SolverStatus { // Good SOLVER_STATUS_CONVERGED = 0 , // OK SOLVER_STATUS_MAX_ITER = 1 , // Bad SOLVER_STATUS_ERROR = 2 , NUM_SOLVER_STATUSES = 3 , }; };","title":"Enum naming conversion"},{"location":"style-guidelines/#exception-for-file-io","text":"For legacy reasons, file reading and writing functions use a different naming convention. A functions reading a .xyz file should be named readXYZ and a function writing .xyz files should be names writeXYZ .","title":"Exception for file IO"},{"location":"style-guidelines/#using-namespace-in-global-scope","text":"Writing using namespace std; , using namespace Eigen; etc. outside of a global scope is strictly forbidden. Place these lines at the top of each function instead.","title":"using namespace ... in global scope"},{"location":"style-guidelines/#namespaces-and-external-dependencies","text":"Functions in the main library (directly in include/igl ) should only depend on Eigen and stl. These functions should have the igl:: namespace. Functions with other dependencies should be placed into appropriate sub-directories (e.g. if myfunction depends on tetgen then create igl/copyleft/tetgen/myfunction.h and igl/copyleft/tetgen/myfunction.cpp and give the function the namespace igl::copyleft::tetgen::myfunction .","title":"Namespaces and external dependencies"},{"location":"style-guidelines/#copyleft-subdirectorynamespace","text":"Dependencies that require users of libigl to release their projects open source (e.g. GPL) are considered aggressively \u201ccopyleft\u201d and should be placed in the include/igl/copyleft/ sub-directory and igl::copyleft:: namespace.","title":"copyleft subdirectory/namespace"},{"location":"style-guidelines/#assertions","text":"Be generous with assertions and always identify the assertion with strings: assert ( m < n && \"m must be less than n\" );","title":"Assertions"},{"location":"style-guidelines/#ifndef-include-guard","text":"Every header file should be wrapped in an #ifndef compiler directive. The name of the guard should be in direct correspondence with the path of the .h file. For example, include/igl/copyleft/tetgen/tetrahedralize.h should be #ifndef IGL_COPYLEFT_TETGEN_TETRAHEDRALIZE_H #define IGL_COPYLEFT_TETGEN_TETRAHEDRALIZE_H ... #endif","title":"ifndef include guard"},{"location":"style-guidelines/#spaces-vs-tabs-indentation","text":"Do not use tabs. Use 2 spaces for each indentation level.","title":"Spaces vs. tabs indentation"},{"location":"style-guidelines/#max-line-length","text":"Limit lines to 80 characters. Break up long lines into many operations (this also helps performance).","title":"Max line length"},{"location":"style-guidelines/#include-order","text":"#include directives at the top of a .h or .cpp file should be sorted according to a simple principle: place headers of files most likely to be edited by you first. This means for include/igl/copyleft/tetgen/tetrahedralize.cpp you might see // [Includes of headers in this directory] #include \"tetrahedralize.h\" #include \"mesh_to_tetgenio.h\" #include \"tetgenio_to_tetmesh.h\" // [Includes of headers in this project] #include \"../../matrix_to_list.h\" #include \"../../list_to_matrix.h\" #include \"../../boundary_facets.h\" // [Includes of headers of related projects] #include <Eigen/Core> // [Includes of headers of standard libraries] #include <cassert> #include <iostream>","title":"Include order"},{"location":"style-guidelines/#placement-of-includes","text":"Whenever possible #include directives should be placed in the .cpp implementation file rather than the .h header file.","title":"Placement of includes"},{"location":"style-guidelines/#warnings","text":"Code should compile without firing any warnings.","title":"Warnings"},{"location":"style-guidelines/#an-exception","text":"The only exception is for the use of the deprecated Eigen::DynamicSparseMatrix in core sub-routines (e.g. igl::cat ). This class is still supported and faster than the standard, non-deprecated Eigen implementation so we\u2019re keeping it as long as possible and profitable.","title":"An Exception"},{"location":"third-party/","text":"The external/ directory contains external libraries which are either difficult to obtain, difficult to compile or patched for libigl. Embree \u00b6 Install ispc and tbb for example ( brew install ispc tbb ), then mkdir build cd build cmake -DCMAKE_C_COMPILER = /usr/bin/gcc -DCMAKE_CXX_COMPILER = /usr/bin/g++ -DCMAKE_BUILD_TYPE = Release .. make TinyXML2 \u00b6 double precision bug fixes: tinyxml2.h line 1286 add function: void SetAttribute ( const char * name , float value ) { XMLAttribute * a = FindOrCreateAttribute ( name ); a -> SetAttribute ( value ); } tinyxml2.cpp line 434 replace with: TIXML_SNPRINTF ( buffer , bufferSize , \"%.15e\" , v ); CGAL \u00b6 CGAL can be built as a CMake external project thanks to the CMakeLists.txt provided in this folder. While this is mainly intended as a convenience for Windows users, and CI builds on AppVeyor, this should work on Linux/macOS as well. To build CGAL and Boost with the provided CMake script, build this folder as you would compile any CMake project (use CMake GUI and MSVC on Windows): mkdir build cd build cmake .. make -j4 Once this is done, just build the libigl tutorials, and it should properly detect CGAL and Boost. bbw \u00b6 This library extra contains functions for computing Bounded Biharmonic Weights, can be used with and without the mosek extra via the IGL_NO_MOSEK macro. boolean \u00b6 This library extra contains functions for computing mesh-mesh booleans, depending on CGAL and optionally Cork. embree \u00b6 This library extra utilizes embree\u2019s efficient ray tracing queries. matlab \u00b6 This library extra provides support for reading and writing .mat workspace files, interfacing with Matlab at run time and compiling mex functions. mosek \u00b6 This library extra utilizes mosek\u2019s efficient interior-point solver for quadratic programs. png \u00b6 This library extra uses libpng and YImage to read and write .png files. tetgen \u00b6 This library extra provides a simplified wrapper to the tetgen 3d tetrahedral meshing library. Triangle \u00b6 This library extra provides a simplified wrapper to the triangle 2d triangle meshing library. xml \u00b6 This library extra utilizes tinyxml2 to read and write serialized classes containing Eigen matrices and other standard simple data-structures. Optional \u00b6 OpenGL (disable with LIBIGL_WITH_OPENGL set to OFF ) OpenGL >= 4 (enable with IGL_OPENGL_4 ) GLEW Windows and Linux OpenMP libpng libiglpng extra only Mosek libiglmosek extra only Matlab libiglmatlab extra only boost libiglboost, libiglcgal extra only SSE/AVX libiglsvd3x3 extra only CGAL libiglcgal extra only boost gmp mpfr CoMiSo libcomiso extra only Optional (included in external/) \u00b6 TetGen libigltetgen extra only Embree libiglembree extra only tinyxml2 libiglxml extra only glfw libviewer extra only LIM liblim extra only","title":"External Dependencies"},{"location":"third-party/#embree","text":"Install ispc and tbb for example ( brew install ispc tbb ), then mkdir build cd build cmake -DCMAKE_C_COMPILER = /usr/bin/gcc -DCMAKE_CXX_COMPILER = /usr/bin/g++ -DCMAKE_BUILD_TYPE = Release .. make","title":"Embree"},{"location":"third-party/#tinyxml2","text":"double precision bug fixes: tinyxml2.h line 1286 add function: void SetAttribute ( const char * name , float value ) { XMLAttribute * a = FindOrCreateAttribute ( name ); a -> SetAttribute ( value ); } tinyxml2.cpp line 434 replace with: TIXML_SNPRINTF ( buffer , bufferSize , \"%.15e\" , v );","title":"TinyXML2"},{"location":"third-party/#cgal","text":"CGAL can be built as a CMake external project thanks to the CMakeLists.txt provided in this folder. While this is mainly intended as a convenience for Windows users, and CI builds on AppVeyor, this should work on Linux/macOS as well. To build CGAL and Boost with the provided CMake script, build this folder as you would compile any CMake project (use CMake GUI and MSVC on Windows): mkdir build cd build cmake .. make -j4 Once this is done, just build the libigl tutorials, and it should properly detect CGAL and Boost.","title":"CGAL"},{"location":"third-party/#bbw","text":"This library extra contains functions for computing Bounded Biharmonic Weights, can be used with and without the mosek extra via the IGL_NO_MOSEK macro.","title":"bbw"},{"location":"third-party/#boolean","text":"This library extra contains functions for computing mesh-mesh booleans, depending on CGAL and optionally Cork.","title":"boolean"},{"location":"third-party/#embree_1","text":"This library extra utilizes embree\u2019s efficient ray tracing queries.","title":"embree"},{"location":"third-party/#matlab","text":"This library extra provides support for reading and writing .mat workspace files, interfacing with Matlab at run time and compiling mex functions.","title":"matlab"},{"location":"third-party/#mosek","text":"This library extra utilizes mosek\u2019s efficient interior-point solver for quadratic programs.","title":"mosek"},{"location":"third-party/#png","text":"This library extra uses libpng and YImage to read and write .png files.","title":"png"},{"location":"third-party/#tetgen","text":"This library extra provides a simplified wrapper to the tetgen 3d tetrahedral meshing library.","title":"tetgen"},{"location":"third-party/#triangle","text":"This library extra provides a simplified wrapper to the triangle 2d triangle meshing library.","title":"Triangle"},{"location":"third-party/#xml","text":"This library extra utilizes tinyxml2 to read and write serialized classes containing Eigen matrices and other standard simple data-structures.","title":"xml"},{"location":"third-party/#optional","text":"OpenGL (disable with LIBIGL_WITH_OPENGL set to OFF ) OpenGL >= 4 (enable with IGL_OPENGL_4 ) GLEW Windows and Linux OpenMP libpng libiglpng extra only Mosek libiglmosek extra only Matlab libiglmatlab extra only boost libiglboost, libiglcgal extra only SSE/AVX libiglsvd3x3 extra only CGAL libiglcgal extra only boost gmp mpfr CoMiSo libcomiso extra only","title":"Optional"},{"location":"third-party/#optional-included-in-external","text":"TetGen libigltetgen extra only Embree libiglembree extra only tinyxml2 libiglxml extra only glfw libviewer extra only LIM liblim extra only","title":"Optional (included in external/)"},{"location":"tutorial/","text":"libigl tutorial Libigl is an open source C++ library for geometry processing research and development. Dropping the heavy data structures of tradition geometry libraries, libigl is a simple header-only library of encapsulated functions. This combines the rapid prototyping familiar to Matlab or Python programmers with the performance and versatility of C++. The tutorial is a self-contained, hands-on introduction to libigl. Via interactive, step-by-step examples, we demonstrate how to accomplish common geometry processing tasks such as computation of differential quantities and operators, real-time deformation, parametrization, numerical optimization and remeshing. Each section of the lecture notes links to a cross-platform example application. Chapter 1 \u00b6 We introduce libigl with a series of self-contained examples. The purpose of each example is to showcase a feature of libigl while applying to a practical problem in geometry processing. In this chapter, we will present the basic concepts of libigl and introduce a simple mesh viewer that allows to visualize a surface mesh and its attributes. All the tutorial examples are cross-platform and can be compiled on MacOSX, Linux and Windows. Libigl Design Principles \u00b6 Before getting into the examples, we summarize the main design principles in libigl: No complex data types. We mostly use matrices and vectors. This greatly favors code reusability and forces the function authors to expose all the parameters used by the algorithm. Minimal dependencies. We use external libraries only when necessary and we wrap them in a small set of functions. Header-only. It is straight forward to use our library since it is only one additional include directory in your project. (if you are worried about compilation speed, it is also possible to build the library as a static library ) Function encapsulation. Every function (including its full implementation) is contained in a pair of .h/.cpp files with the same name of the function. Downloading Libigl \u00b6 libigl can be downloaded from our github repository or cloned with git: git clone https://github.com/libigl/libigl.git The core libigl functionality only depends on the C++ Standard Library and Eigen. Optional dependencies will be downloaded upon issuing cmake , below. To build all the examples in the tutorial (and tests), you can use the CMakeLists.txt in the root folder: cd libigl/ mkdir build cd build cmake ../ make Note about CGAL The optional dependency CGAL has been notoriously difficult to setup (as it also depends on boost/gmp/mpfr). By default, it will only be enabled on Linux/macOS if GMP and MPFR are installed system-wide. On Windows, all its dependencies will be downloaded by CMake, thus requiring no setup on your part. The examples can also be built independently using the CMakeLists.txt inside each example folder. Note for linux users Many linux distributions do not include gcc and the basic development tools in their default installation. On Ubuntu, you need to install the following packages: sudo apt-get install \\ git \\ build-essential \\ cmake \\ libx11-dev \\ mesa-common-dev libgl1-mesa-dev libglu1-mesa-dev \\ libxrandr-dev \\ libxi-dev \\ libxmu-dev \\ libblas-dev \\ libxinerama-dev \\ libxcursor-dev Note for Windows users libigl only supports the Microsoft Visual Studio 2015 compiler and later, in 64bit mode. It will not work with a 32bit build and it will not work with older versions of visual studio. A few examples in Chapter 5 requires the CoMiSo solver . We provide a mirror of CoMISo that works out of the box with libigl. A copy will be downloaded automatically by CMake the first time you build the libigl root project. You can build the tutorials as usual and libigl will automatically find and compile CoMISo. Note 1 : CoMISo is distributed under the GPL3 license, it does impose restrictions on commercial usage. Note 2 : CoMISo requires a blas implementation. We use the built-in blas in macosx and linux, and we bundle a precompiled binary for VS2015 64 bit. Do NOT compile the tutorials in 32 bit on windows. Libigl Example Project We provide a blank project example showing how to use libigl and CMake. This is the recommended way of using libigl in your project . Feel free and encouraged to use this repository as a template to start a new personal project using libigl. Mesh Representation \u00b6 libigl uses the Eigen library to encode vector and matrices. We suggest that you keep the dense and sparse quick reference guides at hand while you read the examples in this tutorial. A triangular mesh is encoded as a pair of matrices: Eigen :: MatrixXd V ; Eigen :: MatrixXi F ; V is a #N by 3 matrix which stores the coordinates of the vertices. Each row stores the coordinate of a vertex, with its x,y and z coordinates in the first, second and third column, respectively. The matrix F stores the triangle connectivity: each line of F denotes a triangle whose 3 vertices are represented as indices pointing to rows of V . A simple mesh made of 2 triangles and 4 vertices. Note that the order of the vertex indices in F determines the orientation of the triangles and it should thus be consistent for the entire surface. This simple representation has many advantages: it is memory efficient and cache friendly the use of indices instead of pointers greatly simplifies debugging the data can be trivially copied and serialized libigl provides input [output] functions to read [write] many common mesh formats. The IO functions are contained in the files read*.h and write*.h. As a general rule each libigl function is contained in a pair of .h/.cpp files with the same name. By default, the .h files include the corresponding cpp files, making the library header-only. Reading a mesh from a file requires a single libigl function call: igl :: readOFF ( TUTORIAL_SHARED_PATH \"/cube.off\" , V , F ); The function reads the mesh cube.off and it fills the provided V and F matrices. Similarly, a mesh can be written in an OBJ file using: igl :: writeOBJ ( \"cube.obj\" , V , F ); Example 101 contains a simple mesh converter from OFF to OBJ format. Visualizing Surfaces \u00b6 Libigl provides an glfw-based OpenGL 3.2 viewer to visualize surfaces, their properties and additional debugging information. The following code ( Example 102 ) is a basic skeleton for all the examples that will be used in the tutorial. It is a standalone application that loads a mesh and uses the viewer to render it. #include <igl/readOFF.h> #include <igl/opengl/glfw/Viewer.h> Eigen :: MatrixXd V ; Eigen :: MatrixXi F ; int main ( int argc , char * argv []) { // Load a mesh in OFF format igl :: readOFF ( TUTORIAL_SHARED_PATH \"/bunny.off\" , V , F ); // Plot the mesh igl :: opengl :: glfw :: Viewer viewer ; viewer . data (). set_mesh ( V , F ); viewer . launch (); } The function set_mesh copies the mesh into the viewer. Viewer.launch() creates a window, an OpenGL context and it starts the draw loop. The default camera motion mode is 2-axis ( ROTATION_TYPE_TWO_AXIS_VALUATOR_FIXED_UP ), which can be changed to 3-axis trackball style by adding this line: viewer.core().set_rotation_type(igl::opengl::ViewerCore::ROTATION_TYPE_TRACKBALL); Additional properties can be plotted on the mesh (as we will see later), and it is possible to extend the viewer with standard OpenGL code. Please see the documentation in Viewer.h for more details. ( Example 102 ) loads and draws a mesh. Interaction With Keyboard And Mouse \u00b6 Keyboard and mouse events triggers callbacks that can be registered in the viewer. The viewer supports the following callbacks: bool ( * callback_pre_draw )( Viewer & viewer ); bool ( * callback_post_draw )( Viewer & viewer ); bool ( * callback_mouse_down )( Viewer & viewer , int button , int modifier ); bool ( * callback_mouse_up )( Viewer & viewer , int button , int modifier ); bool ( * callback_mouse_move )( Viewer & viewer , int mouse_x , int mouse_y ); bool ( * callback_mouse_scroll )( Viewer & viewer , float delta_y ); bool ( * callback_key_down )( Viewer & viewer , unsigned char key , int modifiers ); bool ( * callback_key_up )( Viewer & viewer , unsigned char key , int modifiers ); A keyboard callback can be used to visualize multiple meshes or different stages of an algorithm, as demonstrated in Example 103 , where the keyboard callback changes the visualized mesh depending on the key pressed: bool key_down ( igl :: opengl :: glfw :: Viewer & viewer , unsigned char key , int modifier ) { if ( key == '1' ) { viewer . data (). clear (); viewer . data (). set_mesh ( V1 , F1 ); viewer . core . align_camera_center ( V1 , F1 ); } else if ( key == '2' ) { viewer . data (). clear (); viewer . data (). set_mesh ( V2 , F2 ); viewer . core . align_camera_center ( V2 , F2 ); } return false ; } The callback is registered in the viewer as follows: viewer . callback_key_down = & key_down ; Note that the mesh is cleared before using set_mesh. This has to be called every time the number of vertices or faces of the plotted mesh changes. Every callback returns a boolean value that tells the viewer if the event has been handled by the plugin, or if the viewer should process it normally. This is useful, for example, to disable the default mouse event handling if you want to control the camera directly in your code. The viewer can be extended using plugins, which are classes that implements all the viewer\u2019s callbacks. See the Viewer_plugin for more details. Scalar Field Visualization \u00b6 Colors can be associated to faces or vertices using the set_colors function: viewer . data (). set_colors ( C ); C is a #C by 3 matrix with one RGB color per row. C must have as many rows as the number of faces or the number of vertices of the mesh. Depending on the size of C , the viewer applies the color to the faces or to the vertices. In Example 104, the colors of mesh vertices are set according to their Cartesian coordinates. ( Example 104 ) Set the colors of a mesh. Per-Vertex scalar fields can be directly visualized using set_data function: viewer . data (). set_data ( D ); D is a #V by 1 vector with one value corresponding to each vertex. set_data will color according to linearly interpolating the data within a triangle (in the fragment shader ) and use this interpolated data to look up a color in a colormap (stored as a texture). The colormap defaults to igl::COLOR_MAP_TYPE_VIRIDIS with 21 discrete intervals. A custom colormap may be set with set_colormap . Overlays \u00b6 In addition to plotting the surface, the viewer supports the visualization of points, lines and text labels: these overlays can be very helpful while developing geometric processing algorithms to plot debug information. viewer . data (). add_points ( P , Eigen :: RowVector3d ( r , g , b )); Draws a point of color r,g,b for each row of P. The point is placed at the coordinates specified in each row of P, which is a #P by 3 matrix. Size of the points (in pixels) can be changed globally by setting viewer.data().point_size . viewer . data (). add_edges ( P1 , P2 , Eigen :: RowVector3d ( r , g , b )); Draws a line of color r,g,b for each row of P1 and P2, which connects the 3D point in to the point in P2. Both P1 and P2 are of size #P by 3. viewer . data (). add_label ( p , str ); Draws a label containing the string str at the position p, which is a vector of length 3. These functions are demonstrate in Example 105 where the bounding box of a mesh is plotted using lines and points. Using matrices to encode the mesh and its attributes allows to write short and efficient code for many operations, avoiding to write for loops. For example, the bounding box of a mesh can be found by taking the colwise maximum and minimum of V : Eigen :: Vector3d m = V . colwise (). minCoeff (); Eigen :: Vector3d M = V . colwise (). maxCoeff (); ( Example 105 ) The bounding box of a mesh is shown using overlays. Viewer Menu \u00b6 As of latest version, the viewer uses a new menu and completely replaces AntTweakBar and nanogui with Dear ImGui . To extend the default menu of the viewer and to expose more user defined variables you have to implement a custom interface, as in Example 106 : // Add content to the default menu window menu . callback_draw_viewer_menu = [ & ]() { // Draw parent menu content menu . draw_viewer_menu (); // Add new group if ( ImGui :: CollapsingHeader ( \"New Group\" , ImGuiTreeNodeFlags_DefaultOpen )) { // Expose variable directly ... ImGui :: InputFloat ( \"float\" , & floatVariable , 0 , 0 , 3 ); // ... or using a custom callback static bool boolVariable = true ; if ( ImGui :: Checkbox ( \"bool\" , & boolVariable )) { // do something std :: cout << \"boolVariable: \" << std :: boolalpha << boolVariable << std :: endl ; } // Expose an enumeration type enum Orientation { Up = 0 , Down , Left , Right }; static Orientation dir = Up ; ImGui :: Combo ( \"Direction\" , ( int * )( & dir ), \"Up \\0 Down \\0 Left \\0 Right \\0\\0 \" ); // We can also use a std::vector<std::string> defined dynamically static int num_choices = 3 ; static std :: vector < std :: string > choices ; static int idx_choice = 0 ; if ( ImGui :: InputInt ( \"Num letters\" , & num_choices )) { num_choices = std :: max ( 1 , std :: min ( 26 , num_choices )); } if ( num_choices != ( int ) choices . size ()) { choices . resize ( num_choices ); for ( int i = 0 ; i < num_choices ; ++ i ) choices [ i ] = std :: string ( 1 , 'A' + i ); if ( idx_choice >= num_choices ) idx_choice = num_choices - 1 ; } ImGui :: Combo ( \"Letter\" , & idx_choice , choices ); // Add a button if ( ImGui :: Button ( \"Print Hello\" , ImVec2 ( -1 , 0 ))) { std :: cout << \"Hello \\n \" ; } } }; If you need a separate new menu window implement: // Draw additional windows menu . callback_draw_custom_window = [ & ]() { // Define next window position + size ImGui :: SetNextWindowPos ( ImVec2 ( 180.f * menu . menu_scaling (), 10 ), ImGuiSetCond_FirstUseEver ); ImGui :: SetNextWindowSize ( ImVec2 ( 200 , 160 ), ImGuiSetCond_FirstUseEver ); ImGui :: Begin ( \"New Window\" , nullptr , ImGuiWindowFlags_NoSavedSettings ); // Expose the same variable directly ... ImGui :: PushItemWidth ( -80 ); ImGui :: DragFloat ( \"float\" , & floatVariable , 0.0 , 0.0 , 3.0 ); ImGui :: PopItemWidth (); static std :: string str = \"bunny\" ; ImGui :: InputText ( \"Name\" , str ); ImGui :: End (); }; ( Example 106 ) The UI of the viewer can be easily customized. Multiple Meshes \u00b6 Libigl\u2019s igl::opengl::glfw::Viewer provides basic support for rendering multiple meshes. Which mesh is selected is controlled via the viewer.selected_data_index field. By default the index is set to 0 , so in the typical case of a single mesh viewer.data() returns the igl::ViewerData corresponding to the one and only mesh. ( Example 107 ) The igl::opengl::glfw::Viewer can render multiple meshes, each with its own attributes like colors. Multiple Views \u00b6 Libigl\u2019s igl::opengl::glfw::Viewer provides basic support for rendering meshes with multiple views. A new view core can be added to the viewer using the Viewer::append_core() method. There can be a maximum of 31 cores created through the life of any viewer. Each core is assigned an unsigned int id that is guaranteed to be unique. A core can be accessed by its id calling the Viewer::core(id) method. When there are more than one view core, the user is responsible for specifying each viewport\u2019s size and position by setting their viewport attribute. The user must also indicates how to resize each viewport when the size of the window changes. For example: viewer . callback_post_resize = [ & ]( igl :: opengl :: glfw :: Viewer & v , int w , int h ) { v . core ( left_view ). viewport = Eigen :: Vector4f ( 0 , 0 , w / 2 , h ); v . core ( right_view ). viewport = Eigen :: Vector4f ( w / 2 , 0 , w - ( w / 2 ), h ); return true ; }; Note that the viewport currently hovered by the mouse can be selected using the Viewer::selected_core_index() method, and the selected view core can then be accessed by calling viewer.core_list[viewer.selected_core_index] . Finally, the visibility of a mesh on a given view core is controlled by a bitmask flag per mesh. This property can be easily controlled by calling the method viewer . data ( mesh_id ). set_visible ( false , view_id ); When appending a new mesh or a new view core, an optional argument controls the visibility of the existing objects with respect to the new mesh/view. Please refer to the documentation of Viewer::append_mesh() and Viewer::append_core() for more details. ( Example 108 ) The igl::opengl::glfw::Viewer can render the same scene using multiple views, each with its own attributes like colors, and individual mesh visibility. Viewer Guizmos \u00b6 Bug It is currently not possible to have more than one ImGui-related viewer plugin active at the same time (that includes ImGuiMenu , ImGuizmoPlugin and SelectionPlugin ). Please follow #1656 for more information. The viewer integrates with ImGuizmo to provide widgets for manipulating a mesh. Mesh manipulations consist of translations, rotations, and scaling, where W,w , E,e , and R,r can be used to toggle between them, respectively. First, register the ImGuizmoPlugin plugin with the Viewer: #include <igl/opengl/glfw/imgui/ImGuizmoPlugin.h> // ImGuizmoPlugin replaces the ImGuiMenu plugin entirely igl :: opengl :: glfw :: imgui :: ImGuizmoPlugin plugin ; vr . plugins . push_back ( & plugin ); On initialization, ImGuizmo must be provided with the mesh centroid, as shown in Example 109 : // Initialize ImGuizmo at mesh centroid plugin . T . block ( 0 , 3 , 3 , 1 ) = 0.5 * ( V . colwise (). maxCoeff () + V . colwise (). minCoeff ()). transpose (). cast < float > (); To apply the mesh manipulations invoked by the guizmos, the resulting transformation matrix is computed and applied to the input geometric data explicitly through the viewer\u2019s API: // Update can be applied relative to this remembered initial transform const Eigen :: Matrix4f T0 = plugin . T ; // Attach callback to apply imguizmo's transform to mesh plugin . callback = [ & ]( const Eigen :: Matrix4f & T ) { const Eigen :: Matrix4d TT = ( T * T0 . inverse ()). cast < double > (). transpose (); vr . data (). set_vertices ( ( V . rowwise (). homogeneous () * TT ). rowwise (). hnormalized ()); vr . data (). compute_normals (); }; ([Example 109](https://github.com/libigl/libigl/tree/main/tutorial/109_ImGuizmo/main.cpp)) The Libigl Viewer integrates with ImGuizmo to provide transformation widgets. Msh Viewer \u00b6 Libigl can read mixed meshes stored in Gmsh .msh version 2 file format. These files can contain mixture of different meshes, as well as additional scalar and vector fields defined on element level and vertex level. Eigen :: MatrixXd X ; // Vertex coorinates (Xx3) Eigen :: MatrixXi Tri ; // Triangular elements (Yx3) Eigen :: MatrixXi Tet ; // Tetrahedral elements (Zx4) Eigen :: VectorXi TriTag ; // Integer tags defining triangular submeshes Eigen :: VectorXi TetTag ; // Integer tags defining tetrahedral submeshes std :: vector < std :: string > XFields ; // headers (names) of fields defined on vertex level std :: vector < std :: string > EFields ; // headers (names) of fields defined on element level std :: vector < Eigen :: MatrixXd > XF ; // fields defined on vertex std :: vector < Eigen :: MatrixXd > TriF ; // fields defined on triangular elements std :: vector < Eigen :: MatrixXd > TetF ; // fields defined on tetrahedral elements // loading mixed mesh from Gmsh file igl :: readMSH ( \"hand.msh\" , X , Tri , Tet , TriTag , TetTag , XFields , XF , EFields , TriF , TetF ); The interactive viewer is unable to directly draw tetrahedra though. So for visualization purposes each tetrahedron can be converted to four triangles. ( Example 110 ) Shows a slice of tetrahedral mesh with scalar field defined on element level MatCaps \u00b6 MatCaps (material captures), also known as environment maps, are a simple image-based rendering technique to achieve complex lighting without a complex shader program. Using offline rendering or even a painting program, an image of a rendered unit sphere is created, such as this image of a sphere with a jade material viewed under studio lighting : The position \\mathbf{p} \\mathbf{p} of each point on the sphere is also its unit normal vector \\hat{\\mathbf{n}} = \\mathbf{p} \\hat{\\mathbf{n}} = \\mathbf{p} . The idea of matcaps is to use this image of the sphere as a lookup table keyed on an input normal value and outputting the rgb color: I(\\hat{\\mathbf{n}}) \\rightarrow (r,g,b) I(\\hat{\\mathbf{n}}) \\rightarrow (r,g,b) . When rendering a non-spherical shape, in the fragment shader we compute the normal vector \\hat{\\mathbf{n}} \\hat{\\mathbf{n}} and then use its x- x- and y- y- components as texture coordinates to look up the corresponding point in the matcap image. In this way, there is no lighting model or lighting computation done in the fragment shader, it is simply a texture lookup, but rather than requiring a UV-mapping (parameterization) of the model, we use the per-fragment normals. By using the normal relative to the camera\u2019s coordinate system we get view dependent complex lighting \u201cfor free\u201d: Example 111 demonstrates using a jade matcap to add complex lighting to the libigl viewer. In libigl, if the rgba data for a matcap image is stored in R , G , B , and A (as output, e.g., by igl::png::readPNG ) then this can be attached to the igl::opengl::ViewerData by setting it as the texture data and then turning on matcap rendering: viewer . data (). set_texture ( R , G , B , A ); viewer . data (). use_matcap = true ; Chapter 2: Discrete Geometric Quantities And Operators \u00b6 This chapter illustrates a few discrete quantities that libigl can compute on a mesh and the libigl functions that construct popular discrete differential geometry operators. It also provides an introduction to basic drawing and coloring routines of our viewer. Normals \u00b6 Surface normals are a basic quantity necessary for rendering a surface. There are a variety of ways to compute and store normals on a triangle mesh. Example 201 demonstrates how to compute and visualize normals with libigl. Per-face \u00b6 Normals are well defined on each triangle of a mesh as the vector orthogonal to triangle\u2019s plane. These piecewise-constant normals produce piecewise-flat renderings: the surface appears non-smooth and reveals its underlying discretization. Per-vertex \u00b6 Normals can be computed and stored on vertices, and interpolated in the interior of the triangles to produce smooth renderings ( Phong shading ). Most techniques for computing per-vertex normals take an average of incident face normals. The main difference between these techniques is their weighting scheme: Uniform weighting is heavily biased by the discretization choice, whereas area-based or angle-based weighting is more forgiving. The typical half-edge style computation of area-based weights has this structure: N . setZero ( V . rows (), 3 ); for ( int i : vertices ) { for ( face : incident_faces ( i )) { N . row ( i ) += face . area * face . normal ; } } N . rowwise (). normalize (); At first glance, it might seem inefficient to loop over incident faces\u2014and thus constructing the per-vertex normals\u2014 without using an half-edge data structure. However, per-vertex normals may be throwing each face normal to running sums on its corner vertices: N . setZero ( V . rows (), 3 ); for ( int f = 0 ; f < F . rows (); f ++ ) { for ( int c = 0 ; c < 3 ; c ++ ) { N . row ( F ( f , c )) += area ( f ) * face_normal . row ( f ); } } N . rowwise (). normalize (); Per-corner \u00b6 Storing normals per-corner is an efficient and convenient way of supporting both smooth and sharp (e.g. creases and corners) rendering. This format is common to OpenGL and the .obj mesh file format. Often such normals are tuned by the mesh designer, but creases and corners can also be computed automatically. Libigl implements a simple scheme which computes corner normals as averages of normals of faces incident on the corresponding vertex which do not deviate by more than a specified dihedral angle (e.g. 20\u00b0). The Normals example computes per-face (left), per-vertex (middle) and per-corner (right) normals Gaussian Curvature \u00b6 Gaussian curvature on a continuous surface is defined as the product of the principal curvatures: k_G = k_1 k_2. k_G = k_1 k_2. As an intrinsic measure, it depends on the metric and not the surface\u2019s embedding. Intuitively, Gaussian curvature tells how locally spherical or elliptic the surface is ( k_G>0 k_G>0 ), how locally saddle-shaped or hyperbolic the surface is ( k_G<0 k_G<0 ), or how locally cylindrical or parabolic ( k_G=0 k_G=0 ) the surface is. In the discrete setting, one definition for a \u201cdiscrete Gaussian curvature\u201d on a triangle mesh is via a vertex\u2019s angular deficit : k_G(v_i) = 2\u03c0 - \\sum\\limits_{j\\in N(i)}\u03b8_{ij}, k_G(v_i) = 2\u03c0 - \\sum\\limits_{j\\in N(i)}\u03b8_{ij}, where N(i) N(i) are the triangles incident on vertex i i and \u03b8_{ij} \u03b8_{ij} is the angle at vertex i i in triangle j j 3 . Just like the continuous analog, our discrete Gaussian curvature reveals elliptic, hyperbolic and parabolic vertices on the domain, as demonstrated in Example 202 . The GaussianCurvature example computes discrete Gaussian curvature and visualizes it in pseudocolor. Curvature Directions \u00b6 The two principal curvatures (k_1,k_2) (k_1,k_2) at a point on a surface measure how much the surface bends in different directions. The directions of maximum and minimum (signed) bending are called principal directions and are always orthogonal. Mean curvature is defined as the average of principal curvatures: H = \\frac{1}{2}(k_1 + k_2). H = \\frac{1}{2}(k_1 + k_2). One way to extract mean curvature is by examining the Laplace-Beltrami operator applied to the surface positions. The result is a so-called mean-curvature normal: -\\Delta \\mathbf{x} = H \\mathbf{n}. -\\Delta \\mathbf{x} = H \\mathbf{n}. It is easy to compute this on a discrete triangle mesh in libigl using the cotangent Laplace-Beltrami operator 3 . #include <igl/cotmatrix.h> #include <igl/massmatrix.h> #include <igl/invert_diag.h> ... MatrixXd HN ; SparseMatrix < double > L , M , Minv ; igl :: cotmatrix ( V , F , L ); igl :: massmatrix ( V , F , igl :: MASSMATRIX_TYPE_VORONOI , M ); igl :: invert_diag ( M , Minv ); HN = - Minv * ( L * V ); H = HN . rowwise (). norm (); //up to sign Combined with the angle defect definition of discrete Gaussian curvature, one can define principal curvatures and use least squares fitting to find directions 3 . Alternatively, a robust method for determining principal curvatures is via quadric fitting 5 . In the neighborhood around every vertex, a best-fit quadric is found and principal curvature values and directions are analytically computed on this quadric ( Example 203 ). The CurvatureDirections example computes principal curvatures via quadric fitting and visualizes mean curvature in pseudocolor and principal directions with a cross field. Gradient \u00b6 Scalar functions on a surface can be discretized as a piecewise linear function with values defined at each mesh vertex: f(\\mathbf{x}) \\approx \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i, f(\\mathbf{x}) \\approx \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i, where \\phi_i \\phi_i is a piecewise linear hat function defined by the mesh so that for each triangle \\phi_i \\phi_i is the linear function which is one only at vertex i i and zero at the other corners. Hat function \\phi_i \\phi_i is one at vertex i i , zero at all other vertices, and linear on incident triangles. Thus gradients of such piecewise linear functions are simply sums of gradients of the hat functions: \\nabla f(\\mathbf{x}) \\approx \\nabla \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i = \\sum\\limits_{i=1}^n \\nabla \\phi_i(\\mathbf{x})\\, f_i. \\nabla f(\\mathbf{x}) \\approx \\nabla \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i = \\sum\\limits_{i=1}^n \\nabla \\phi_i(\\mathbf{x})\\, f_i. This reveals that the gradient is a linear function of the vector of f_i f_i values. Because the \\phi_i \\phi_i are linear in each triangle, their gradients are constant in each triangle. Thus our discrete gradient operator can be written as a matrix multiplication taking vertex values to triangle values: \\nabla f \\approx \\mathbf{G}\\,\\mathbf{f}, \\nabla f \\approx \\mathbf{G}\\,\\mathbf{f}, where \\mathbf{f} \\mathbf{f} is n\\times 1 n\\times 1 and \\mathbf{G} \\mathbf{G} is an md\\times n md\\times n sparse matrix. This matrix \\mathbf{G} \\mathbf{G} can be derived geometrically, e.g. ch. 2 1 . Libigl\u2019s grad function computes \\mathbf{G} \\mathbf{G} for triangle and tetrahedral meshes ( Example 204 ): The Gradient example computes gradients of an input function on a mesh and visualizes the vector field. Laplacian \u00b6 The discrete Laplacian is an essential geometry processing tool. Many interpretations and flavors of the Laplace and Laplace-Beltrami operator exist. In open Euclidean space, the Laplace operator is the usual divergence of gradient (or equivalently the Laplacian of a function is the trace of its Hessian): \\Delta f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}. \\Delta f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}. The Laplace-Beltrami operator generalizes this to surfaces. When considering piecewise-linear functions on a triangle mesh, a discrete Laplacian may be derived in a variety of ways. The most popular in geometry processing is the so-called ``cotangent Laplacian\u2019\u2019 \\mathbf{L} \\mathbf{L} , arising simultaneously from FEM, DEC and applying divergence theorem to vertex one-rings. As a linear operator taking vertex values to vertex values, the Laplacian \\mathbf{L} \\mathbf{L} is a n\\times n n\\times n matrix with elements: L_{ij} = \\begin{cases}j \\in N(i) &\\cot \\alpha_{ij} + \\cot \\beta_{ij},\\\\ j \\notin N(i) & 0,\\\\ i = j & -\\sum\\limits_{k\\neq i} L_{ik}, \\end{cases} L_{ij} = \\begin{cases}j \\in N(i) &\\cot \\alpha_{ij} + \\cot \\beta_{ij},\\\\ j \\notin N(i) & 0,\\\\ i = j & -\\sum\\limits_{k\\neq i} L_{ik}, \\end{cases} where N(i) N(i) are the vertices adjacent to (neighboring) vertex i i , and \\alpha_{ij},\\beta_{ij} \\alpha_{ij},\\beta_{ij} are the angles opposite to edge {ij} {ij} . This formula leads to a typical half-edge style implementation for constructing \\mathbf{L} \\mathbf{L} : for ( int i : vertices ) { for ( int j : one_ring ( i )) { for ( int k : triangle_on_edge ( i , j )) { L ( i , j ) += cot ( angle ( i , j , k )); L ( i , i ) -= cot ( angle ( i , j , k )); } } } Similarly as before, it may seem to loop over one-rings without having an half-edge data structure. However, this is not the case, since the Laplacian may be built by summing together contributions for each triangle, much in spirit with its FEM discretization of the Dirichlet energy (sum of squared gradients): for ( triangle t : triangles ) { for ( edge i , j : t ) { L ( i , j ) += cot ( angle ( i , j , k )); L ( j , i ) += cot ( angle ( i , j , k )); L ( i , i ) -= cot ( angle ( i , j , k )); L ( j , j ) -= cot ( angle ( i , j , k )); } } Libigl implements discrete \u201ccotangent\u201d Laplacians for triangles meshes and tetrahedral meshes, building both with fast geometric rules rather than \u201cby the book\u201d FEM construction which involves many (small) matrix inversions, cf. 6 . The operator applied to mesh vertex positions amounts to smoothing by flowing the surface along the mean curvature normal direction ( Example 205 ). Note that this is equivalent to minimizing surface area. The Laplacian example computes conformalized mean curvature flow using the cotangent Laplacian 2 . Mass Matrix \u00b6 The mass matrix \\mathbf{M} \\mathbf{M} is another n \\times n n \\times n matrix which takes vertex values to vertex values. From an FEM point of view, it is a discretization of the inner-product: it accounts for the area around each vertex. Consequently, \\mathbf{M} \\mathbf{M} is often a diagonal matrix, such that M_{ii} M_{ii} is the barycentric or voronoi area around vertex i i in the mesh 3 . The inverse of this matrix is also very useful as it transforms integrated quantities into point-wise quantities, e.g.: \\Delta f \\approx \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f}. \\Delta f \\approx \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f}. In general, when encountering squared quantities integrated over the surface, the mass matrix will be used as the discretization of the inner product when sampling function values at vertices: \\int_S x\\, y\\ dA \\approx \\mathbf{x}^T\\mathbf{M}\\,\\mathbf{y}. \\int_S x\\, y\\ dA \\approx \\mathbf{x}^T\\mathbf{M}\\,\\mathbf{y}. An alternative mass matrix \\mathbf{T} \\mathbf{T} is a md \\times md md \\times md matrix which takes triangle vector values to triangle vector values. This matrix represents an inner-product accounting for the area associated with each triangle (i.e. the triangles true area). Alternative Construction Of Laplacian \u00b6 An alternative construction of the discrete cotangent Laplacian is by \u201csquaring\u201d the discrete gradient operator. This may be derived by applying Green\u2019s identity (ignoring boundary conditions for the moment): \\int_S \\|\\nabla f\\|^2 dA = \\int_S f \\Delta f dA \\int_S \\|\\nabla f\\|^2 dA = \\int_S f \\Delta f dA Or in matrix form which is immediately translatable to code: \\mathbf{f}^T \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{f} = \\mathbf{f}^T \\mathbf{M} \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f} = \\mathbf{f}^T \\mathbf{L} \\mathbf{f}. \\mathbf{f}^T \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{f} = \\mathbf{f}^T \\mathbf{M} \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f} = \\mathbf{f}^T \\mathbf{L} \\mathbf{f}. So we have that \\mathbf{L} = \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{L} = \\mathbf{G}^T \\mathbf{T} \\mathbf{G} . This also hints that we may consider \\mathbf{G}^T \\mathbf{G}^T as a discrete divergence operator, since the Laplacian is the divergence of the gradient. Naturally, \\mathbf{G}^T \\mathbf{G}^T is a n \\times md n \\times md sparse matrix which takes vector values stored at triangle faces to scalar divergence values at vertices. Exact Discrete Geodesic Distances \u00b6 The discrete geodesic distance between two points is the length of the shortest path between then restricted to the surface. For triangle meshes, such a path is made of a set of segments which can be either edges of the mesh or crossing a triangle. Libigl includes a wrapper for the exact geodesic algorithm 4 developed by Danil Kirsanov ( https://code.google.com/archive/p/geodesic/ ), exposing it through an Eigen-based API. The function igl :: exact_geodesic ( V , F , VS , FS , VT , FT , d ); computes the closest geodesic distances of each vertex in VT or face in FT, from the source vertices VS or faces FS of the input mesh V,F. The output is written in the vector d, which lists first the distances for the vertices in VT, and then for the faces in FT. For example, if you want to compute the distance from the vertex with id vid , to all vertices of F you can use: Eigen :: VectorXi VS , FS , VT , FT ; // The selected vertex is the source VS . resize ( 1 ); VS << vid ; // All vertices are the targets VT . setLinSpaced ( V . rows (), 0 , V . rows () -1 ); Eigen :: VectorXd d ; igl :: exact_geodesic ( V , F , VS , FS , VT , FT , d ); [Example 206 allows to interactively pick the source vertex and displays the distance using a periodic color pattern.](images/geodesicdistance.jpg) Chapter 3: Matrices And Linear Algebra \u00b6 Libigl relies heavily on the Eigen library for dense and sparse linear algebra routines. Besides geometry processing routines, libigl has linear algebra routines which bootstrap Eigen and make it feel even more similar to a high-level algebra library such as Matlab. Slice \u00b6 A very familiar and powerful routine in Matlab is array slicing. This allows reading from or writing to a possibly non-contiguous sub-matrix. Let\u2019s consider the Matlab code: B = A ( R , C ); If A is a m \\times n m \\times n matrix and R is a j j -long list of row-indices (between 1 and m m ) and C is a k k -long list of column-indices, then as a result B will be a j \\times k j \\times k matrix drawing elements from A according to R and C . In libigl, the same functionality is provided by the slice function ( Example 301 ): VectorXi R , C ; MatrixXd A , B ; ... igl :: slice ( A , R , C , B ); Note that A and B could also be sparse matrices. Similarly, consider the Matlab code: A ( R , C ) = B ; Now, the selection is on the left-hand side so the j \\times k j \\times k matrix B is being written into the submatrix of A determined by R and C . This functionality is provided in libigl using slice_into : igl :: slice_into ( B , R , C , A ); The example Slice shows how to use igl::slice to change the colors for triangles on a mesh. Sort \u00b6 Matlab and other higher-level languages make it very easy to extract indices of sorting and comparison routines. For example in Matlab, one can write: [ Y , I ] = sort ( X , 1 , 'ascend' ); so if X is a m \\times n m \\times n matrix then Y will also be an m \\times n m \\times n matrix with entries sorted along dimension 1 in 'ascend' ing order. The second output I is a m \\times n m \\times n matrix of indices such that Y(i,j) = X(I(i,j),j); . That is, I reveals how X is sorted into Y . This same functionality is supported in libigl: igl :: sort ( X , 1 , true , Y , I ); Similarly, sorting entire rows can be accomplished in Matlab using: [ Y , I ] = sortrows ( X , 'ascend' ); where now I is a m m vector of indices such that Y = X(I,:) . In libigl, this is supported with igl :: sortrows ( X , true , Y , I ); where again I reveals the index of sort so that it can be reproduced with igl::slice(X,I,1,Y) . Analogous functions are available in libigl for: max , min , and unique . The example Sort shows how to use igl::sortrows to pseudocolor triangles according to their barycenters\u2019 sorted order ( Example 302 ). Other Matlab-style Functions \u00b6 Libigl implements a variety of other routines with the same api and functionality as common Matlab functions. Name Description igl::all Whether all elements are non-zero (true) igl::any Whether any elements are non-zero (true) igl::cat Concatenate two matrices (especially useful for dealing with Eigen sparse matrices) igl::ceil Round entries up to nearest integer igl::cumsum Cumulative sum of matrix elements igl::colon Act like Matlab\u2019s : , similar to Eigen\u2019s LinSpaced igl::components Connected components of graph (cf. Matlab\u2019s graphconncomp ) igl::count Count non-zeros in rows or columns igl::cross Cross product per-row igl::cumsum Cumulative summation igl::dot dot product per-row igl::eigs Solve sparse eigen value problem igl::find Find subscripts of non-zero entries igl::floor Round entries down to nearest integer igl::histc Counting occurrences for building a histogram igl::hsv_to_rgb Convert HSV colors to RGB (cf. Matlab\u2019s hsv2rgb ) igl::intersect Set intersection of matrix elements. igl::isdiag Determine whether matrix is diagonal igl::ismember Determine whether elements in A occur in B igl::jet Quantized colors along the rainbow. igl::max Compute maximum entry per row or column igl::median Compute the median per column igl::min Compute minimum entry per row or column igl::mod Compute per element modulo igl::mode Compute the mode per column igl::null Compute the null space basis of a matrix igl::nchoosek Compute all k-size combinations of n-long vector igl::orth Orthogonalization of a basis igl::parula Generate a quantized colormap from blue to yellow igl::pinv Compute Moore-Penrose pseudoinverse igl::randperm Generate a random permutation of [0,\u2026,n-1] igl::rgb_to_hsv Convert RGB colors to HSV (cf. Matlab\u2019s rgb2hsv ) igl::repmat Repeat a matrix along columns and rows igl::round Per-element round to whole number igl::setdiff Set difference of matrix elements igl::setunion Set union of matrix elements igl::setxor Set exclusive \u201cor\u201d of matrix elements igl::slice Slice parts of matrix using index lists: (cf. Matlab\u2019s B = A(I,J) ) igl::slice_mask Slice parts of matrix using boolean masks: (cf. Matlab\u2019s B = A(M,N) ) igl::slice_into Slice left-hand side of matrix assignment using index lists (cf. Matlab\u2019s B(I,J) = A ) igl::sort Sort elements or rows of matrix igl::speye Identity as sparse matrix igl::sum Sum along columns or rows (of sparse matrix) igl::unique Extract unique elements or rows of matrix Laplace Equation \u00b6 A common linear system in geometry processing is the Laplace equation: \u2206z = 0 \u2206z = 0 subject to some boundary conditions, for example Dirichlet boundary conditions (fixed value): \\left.z\\right|_{\\partial{S}} = z_{bc} \\left.z\\right|_{\\partial{S}} = z_{bc} In the discrete setting, the linear system can be written as: \\mathbf{L} \\mathbf{z} = \\mathbf{0} \\mathbf{L} \\mathbf{z} = \\mathbf{0} where \\mathbf{L} \\mathbf{L} is the n \\times n n \\times n discrete Laplacian and \\mathbf{z} \\mathbf{z} is a vector of per-vertex values. Most of \\mathbf{z} \\mathbf{z} correspond to interior vertices and are unknown, but some of \\mathbf{z} \\mathbf{z} represent values at boundary vertices. Their values are known so we may move their corresponding terms to the right-hand side. Conceptually, this is very easy if we have sorted \\mathbf{z} \\mathbf{z} so that interior vertices come first and then boundary vertices: \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\\\ \\mathbf{L}_{b,in} & \\mathbf{L}_{b,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\left(\\begin{array}{c} \\mathbf{0}_{in}\\\\ \\mathbf{z}_{bc}\\end{array}\\right) \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\\\ \\mathbf{L}_{b,in} & \\mathbf{L}_{b,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\left(\\begin{array}{c} \\mathbf{0}_{in}\\\\ \\mathbf{z}_{bc}\\end{array}\\right) The bottom block of equations is no longer meaningful so we\u2019ll only consider the top block: \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\mathbf{0}_{in} \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\mathbf{0}_{in} We can move the known values to the right-hand side: \\mathbf{L}_{in,in} \\mathbf{z}_{in} = - \\mathbf{L}_{in,b} \\mathbf{z}_{b} \\mathbf{L}_{in,in} \\mathbf{z}_{in} = - \\mathbf{L}_{in,b} \\mathbf{z}_{b} Finally we can solve this equation for the unknown values at interior vertices \\mathbf{z}_{in} \\mathbf{z}_{in} . However, our vertices will often not be sorted in this way. One option would be to sort V , then proceed as above and then unsort the solution Z to match V . However, this solution is not very general. With array slicing no explicit sort is needed. Instead we can slice-out submatrix blocks ( \\mathbf{L}_{in,in} \\mathbf{L}_{in,in} , \\mathbf{L}_{in,b} \\mathbf{L}_{in,b} , etc.) and follow the linear algebra above directly. Then we can slice the solution into the rows of Z corresponding to the interior vertices ( Example 303 ). The LaplaceEquation example solves a Laplace equation with Dirichlet boundary conditions. Quadratic Energy Minimization \u00b6 The same Laplace equation may be equivalently derived by minimizing Dirichlet energy subject to the same boundary conditions: \\mathop{\\text{minimize }}_z \\frac{1}{2}\\int\\limits_S \\|\\nabla z\\|^2 dA \\mathop{\\text{minimize }}_z \\frac{1}{2}\\int\\limits_S \\|\\nabla z\\|^2 dA On our discrete mesh, recall that this becomes \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{G}^T \\mathbf{D} \\mathbf{G} \\mathbf{z} \\rightarrow \\mathop{\\text{minimize }}_\\mathbf{z} \\mathbf{z}^T \\mathbf{L} \\mathbf{z} \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{G}^T \\mathbf{D} \\mathbf{G} \\mathbf{z} \\rightarrow \\mathop{\\text{minimize }}_\\mathbf{z} \\mathbf{z}^T \\mathbf{L} \\mathbf{z} The general problem of minimizing some energy over a mesh subject to fixed value boundary conditions is so wide spread that libigl has a dedicated api for solving such systems. Let us consider a general quadratic minimization problem subject to different common constraints: \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant}, \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant}, subject to \\mathbf{z}_b = \\mathbf{z}_{bc} \\text{ and } \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq}, \\mathbf{z}_b = \\mathbf{z}_{bc} \\text{ and } \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq}, where \\mathbf{Q} \\mathbf{Q} is a (usually sparse) n \\times n n \\times n positive semi-definite matrix of quadratic coefficients (Hessian), \\mathbf{B} \\mathbf{B} is a n \\times 1 n \\times 1 vector of linear coefficients, \\mathbf{z}_b \\mathbf{z}_b is a |b| \\times 1 |b| \\times 1 portion of \\mathbf{z} \\mathbf{z} corresponding to boundary or fixed vertices, \\mathbf{z}_{bc} \\mathbf{z}_{bc} is a |b| \\times 1 |b| \\times 1 vector of known values corresponding to \\mathbf{z}_b \\mathbf{z}_b , \\mathbf{A}_{eq} \\mathbf{A}_{eq} is a (usually sparse) m \\times n m \\times n matrix of linear equality constraint coefficients (one row per constraint), and \\mathbf{B}_{eq} \\mathbf{B}_{eq} is a m \\times 1 m \\times 1 vector of linear equality constraint right-hand side values. This specification is overly general as we could write \\mathbf{z}_b = \\mathbf{z}_{bc} \\mathbf{z}_b = \\mathbf{z}_{bc} as rows of \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq} \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq} , but these fixed value constraints appear so often that they merit a dedicated place in the API. In libigl, solving such quadratic optimization problems is split into two routines: precomputation and solve. Precomputation only depends on the quadratic coefficients, known value indices and linear constraint coefficients: igl :: min_quad_with_fixed_data mqwf ; igl :: min_quad_with_fixed_precompute ( Q , b , Aeq , true , mqwf ); The output is a struct mqwf which contains the system matrix factorization and is used during solving with arbitrary linear terms, known values, and constraint in the right-hand sides: igl :: min_quad_with_fixed_solve ( mqwf , B , bc , Beq , Z ); The output Z is a n \\times 1 n \\times 1 vector of solutions with fixed values correctly placed to match the mesh vertices V . Linear Equality Constraints \u00b6 We saw above that min_quad_with_fixed_* in libigl provides a compact way to solve general quadratic programs. Let\u2019s consider another example, this time with active linear equality constraints. Specifically let\u2019s solve the bi-Laplace equation or equivalently minimize the Laplace energy: \\Delta^2 z = 0 \\leftrightarrow \\mathop{\\text{minimize }}\\limits_z \\frac{1}{2} \\int\\limits_S (\\Delta z)^2 dA \\Delta^2 z = 0 \\leftrightarrow \\mathop{\\text{minimize }}\\limits_z \\frac{1}{2} \\int\\limits_S (\\Delta z)^2 dA subject to fixed value constraints and a linear equality constraint: z_{a} = 1, z_{b} = -1 z_{a} = 1, z_{b} = -1 and z_{c} = z_{d} z_{c} = z_{d} . Notice that we can rewrite the last constraint in the familiar form from above: z_{c} - z_{d} = 0. z_{c} - z_{d} = 0. Now we can assembly Aeq as a 1 \\times n 1 \\times n sparse matrix with a coefficient 1 1 in the column corresponding to vertex c c and a -1 -1 at d d . The right-hand side Beq is simply zero. Internally, min_quad_with_fixed_* solves using the Lagrange Multiplier method. This method adds additional variables for each linear constraint (in general a m \\times 1 m \\times 1 vector of variables \\lambda \\lambda ) and then solves the saddle problem: \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant} + \\lambda^T\\left(\\mathbf{A}_{eq} \\mathbf{z} - \\mathbf{B}_{eq}\\right) \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant} + \\lambda^T\\left(\\mathbf{A}_{eq} \\mathbf{z} - \\mathbf{B}_{eq}\\right) This can be rewritten in a more familiar form by stacking \\mathbf{z} \\mathbf{z} and \\lambda \\lambda into one (m+n) \\times 1 (m+n) \\times 1 vector of unknowns: \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2} \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{cc} \\mathbf{Q} & \\mathbf{A}_{eq}^T\\\\ \\mathbf{A}_{eq} & 0 \\end{array} \\right) \\left( \\begin{array}{c} \\mathbf{z}\\\\ \\lambda \\end{array} \\right) + \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{c} \\mathbf{B}\\\\ -\\mathbf{B}_{eq} \\end{array} \\right) + \\text{constant} \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2} \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{cc} \\mathbf{Q} & \\mathbf{A}_{eq}^T\\\\ \\mathbf{A}_{eq} & 0 \\end{array} \\right) \\left( \\begin{array}{c} \\mathbf{z}\\\\ \\lambda \\end{array} \\right) + \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{c} \\mathbf{B}\\\\ -\\mathbf{B}_{eq} \\end{array} \\right) + \\text{constant} Differentiating with respect to \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\mathbf{z}^T \\lambda^T \\right) reveals a linear system and we can solve for \\mathbf{z} \\mathbf{z} and \\lambda \\lambda . The only difference from the straight quadratic minimization system, is that this saddle problem system will not be positive definite. Thus, we must use a different factorization technique (LDLT rather than LLT): libigl\u2019s min_quad_with_fixed_precompute automatically chooses the correct solver in the presence of linear equality constraints ( Example 304 ). The example LinearEqualityConstraints first solves with just fixed value constraints (left: 1 and -1 on the left hand and foot respectively), then solves with an additional linear equality constraint (right: points on right hand and foot constrained to be equal). Quadratic Programming \u00b6 We can generalize the quadratic optimization in the previous section even more by allowing inequality constraints. Specifically box constraints (lower and upper bounds): \\mathbf{l} \\le \\mathbf{z} \\le \\mathbf{u}, \\mathbf{l} \\le \\mathbf{z} \\le \\mathbf{u}, where \\mathbf{l},\\mathbf{u} \\mathbf{l},\\mathbf{u} are n \\times 1 n \\times 1 vectors of lower and upper bounds and general linear inequality constraints: \\mathbf{A}_{ieq} \\mathbf{z} \\le \\mathbf{B}_{ieq}, \\mathbf{A}_{ieq} \\mathbf{z} \\le \\mathbf{B}_{ieq}, where \\mathbf{A}_{ieq} \\mathbf{A}_{ieq} is a k \\times n k \\times n matrix of linear coefficients and \\mathbf{B}_{ieq} \\mathbf{B}_{ieq} is a k \\times 1 k \\times 1 matrix of constraint right-hand sides. Again, we are overly general as the box constraints could be written as rows of the linear inequality constraints, but bounds appear frequently enough to merit a dedicated api. Libigl implements its own active set routine for solving quadratric programs (QPs). This algorithm works by iteratively \u201cactivating\u201d violated inequality constraints by enforcing them as equalities and \u201cdeactivating\u201d constraints which are no longer needed. After deciding which constraints are active at each iteration, the problem reduces to a quadratic minimization subject to linear equality constraints, and the method from the previous section is invoked. This is repeated until convergence. Currently the implementation is efficient for box constraints and sparse non-overlapping linear inequality constraints. Unlike alternative interior-point methods, the active set method benefits from a warm-start (initial guess for the solution vector \\mathbf{z} \\mathbf{z} ). igl :: active_set_params as ; // Z is optional initial guess and output igl :: active_set ( Q , B , b , bc , Aeq , Beq , Aieq , Bieq , lx , ux , as , Z ); Example 305 uses an active set solver to optimize discrete biharmonic kernels 9 at multiple scales . Eigen Decomposition \u00b6 Libigl has rudimentary support for extracting eigen pairs of a generalized eigen value problem: Ax = \\lambda B x Ax = \\lambda B x where A A is a sparse symmetric matrix and B B is a sparse positive definite matrix. Most commonly in geometry processing, we let A=L A=L the cotangent Laplacian and B=M B=M the per-vertex mass matrix (e.g. 10 ). Typically applications will make use of the low frequency eigen modes. Analogous to the Fourier decomposition, a function f f on a surface can be represented via its spectral decomposition of the eigen modes of the Laplace-Beltrami: f = \\sum\\limits_{i=1}^\\infty a_i \\phi_i f = \\sum\\limits_{i=1}^\\infty a_i \\phi_i where each \\phi_i \\phi_i is an eigen function satisfying: \\Delta \\phi_i = \\lambda_i \\phi_i \\Delta \\phi_i = \\lambda_i \\phi_i and a_i a_i are scalar coefficients. For a discrete triangle mesh, a completely analogous decomposition exists, albeit with finite sum: \\mathbf{f} = \\sum\\limits_{i=1}^n a_i \\phi_i \\mathbf{f} = \\sum\\limits_{i=1}^n a_i \\phi_i where now a column vector of values at vertices \\mathbf{f} \\in \\mathcal{R}^n \\mathbf{f} \\in \\mathcal{R}^n specifies a piecewise linear function and \\phi_i \\in \\mathcal{R}^n \\phi_i \\in \\mathcal{R}^n is an eigen vector satisfying: \\mathbf{L} \\phi_i = \\lambda_i \\mathbf{M} \\phi_i \\mathbf{L} \\phi_i = \\lambda_i \\mathbf{M} \\phi_i . Note that Vallet & Levy 10 propose solving a symmetrized standard eigen problem \\mathbf{M}^{-1/2}\\mathbf{L}\\mathbf{M}^{-1/2} \\phi_i = \\lambda_i \\phi_i \\mathbf{M}^{-1/2}\\mathbf{L}\\mathbf{M}^{-1/2} \\phi_i = \\lambda_i \\phi_i . Libigl implements a generalized eigen problem solver so this unnecessary symmetrization can be avoided. Often the sum above is truncated to the first k k eigen vectors. If the low frequency modes are chosen, i.e. those corresponding to small \\lambda_i \\lambda_i values, then this truncation effectively regularizes \\mathbf{f} \\mathbf{f} to smooth, slowly changing functions over the mesh (e.g. 8 ). Modal analysis and model subspaces have been used frequently in real-time deformation (e.g. 7 ). In Example 306 ), the first 5 eigen vectors of the discrete Laplace-Beltrami operator are computed and displayed in pseudo-color atop the beetle. Eigen vectors are computed using igl::eigs (mirroring MATLAB\u2019s eigs ). The 5 eigen vectors are placed into the columns of U and the eigen values are placed into the entries of S : SparseMatrix < double > L , M ; igl :: cotmatrix ( V , F , L ); igl :: massmatrix ( V , F , igl :: MASSMATRIX_TYPE_DEFAULT , M ); Eigen :: MatrixXd U ; Eigen :: VectorXd S ; igl :: eigs ( L , M , 5 , igl :: EIGS_TYPE_SM , U , S ); ( Example 306 ) Low frequency eigen vectors of the discrete Laplace-Beltrami operator vary smoothly and slowly over the Beetle . .md-nav--secondary .md-nav__list .md-nav__list .md-nav__list { display: none } Chapter 4: Shape Deformation \u00b6 Modern mesh-based shape deformation methods satisfy user deformation constraints at handles (selected vertices or regions on the mesh) and propagate these handle deformations to the rest of shape smoothly and without removing or distorting details . Libigl provides implementations of a variety of state-of-the-art deformation techniques, ranging from quadratic mesh-based energy minimizers, to skinning methods, to non-linear elasticity-inspired techniques. Biharmonic Deformation \u00b6 The period of research between 2000 and 2010 produced a collection of techniques that cast the problem of handle-based shape deformation as a quadratic energy minimization problem or equivalently the solution to a linear partial differential equation. There are many flavors of these techniques, but a prototypical subset are those that consider solutions to the bi-Laplace equation, that is a biharmonic function 11 . This fourth-order PDE provides sufficient flexibility in boundary conditions to ensure C^1 C^1 continuity at handle constraints (in the limit under refinement) 15 . Biharmonic Surfaces \u00b6 Let us first begin our discussion of biharmonic deformation , by considering biharmonic surfaces . We will casually define biharmonic surfaces as surface whose position functions are biharmonic with respect to some initial parameterization: \\Delta^2 \\mathbf{x}' = 0 \\Delta^2 \\mathbf{x}' = 0 and subject to some handle constraints, conceptualized as \u201cboundary conditions\u201d: \\mathbf{x}'_{b} = \\mathbf{x}_{bc}. \\mathbf{x}'_{b} = \\mathbf{x}_{bc}. where \\mathbf{x}' \\mathbf{x}' is the unknown 3D position of a point on the surface. So we are asking that the bi-Laplacian of each of spatial coordinate function to be zero. In libigl, one can solve a biharmonic problem with igl::harmonic and setting k=2 k=2 ( bi -harmonic): // U_bc contains deformation of boundary vertices b igl :: harmonic ( V , F , b , U_bc , 2 , U ); This produces a smooth surface that interpolates the handle constraints, but all original details on the surface will be smoothed away . Most obviously, if the original surface is not already biharmonic, then giving all handles the identity deformation (keeping them at their rest positions) will not reproduce the original surface. Rather, the result will be the biharmonic surface that does interpolate those handle positions. Thus, we may conclude that this is not an intuitive technique for shape deformation. Biharmonic Deformation Fields \u00b6 Now we know that one useful property for a deformation technique is \u201crest pose reproduction\u201d: applying no deformation to the handles should apply no deformation to the shape. To guarantee this by construction we can work with deformation fields (ie. displacements) \\mathbf{d} \\mathbf{d} rather than directly with positions \\mathbf{x} \\mathbf{x} . Then the deformed positions can be recovered as \\mathbf{x}' = \\mathbf{x}+\\mathbf{d}. \\mathbf{x}' = \\mathbf{x}+\\mathbf{d}. A smooth deformation field \\mathbf{d} \\mathbf{d} which interpolates the deformation fields of the handle constraints will impose a smooth deformed shape \\mathbf{x}' \\mathbf{x}' . Naturally, we consider biharmonic deformation fields : \\Delta^2 \\mathbf{d} = 0 \\Delta^2 \\mathbf{d} = 0 subject to the same handle constraints, but rewritten in terms of their implied deformation field at the boundary (handles): \\mathbf{d}_b = \\mathbf{x}_{bc} - \\mathbf{x}_b. \\mathbf{d}_b = \\mathbf{x}_{bc} - \\mathbf{x}_b. Again we can use igl::harmonic with k=2 k=2 , but this time solve for the deformation field and then recover the deformed positions: // U_bc contains deformation of boundary vertices b D_bc = U_bc - igl :: slice ( V , b , 1 ); igl :: harmonic ( V , F , b , D_bc , 2 , D ); U = V + D ; The BiharmonicDeformation example deforms a statue\u2019s head as a biharmonic surface (top) and using a biharmonic displacements (bottom). Relationship To \u201cdifferential Coordinates\u201d And Laplacian Surface Editing \u00b6 Biharmonic functions (whether positions or displacements) are solutions to the bi-Laplace equation, but also minimizers of the \u201cLaplacian energy\u201d. For example, for displacements \\mathbf{d} \\mathbf{d} , the energy reads \\int\\limits_S \\|\\Delta \\mathbf{d}\\|^2 dA, \\int\\limits_S \\|\\Delta \\mathbf{d}\\|^2 dA, where we define \\Delta \\mathbf{d} \\Delta \\mathbf{d} to simply apply the Laplacian coordinate-wise. By linearity of the Laplace(-Beltrami) operator we can reexpress this energy in terms of the original positions \\mathbf{x} \\mathbf{x} and the unknown positions \\mathbf{x}' = \\mathbf{x} - \\mathbf{d} \\mathbf{x}' = \\mathbf{x} - \\mathbf{d} : \\int\\limits_S \\|\\Delta (\\mathbf{x}' - \\mathbf{x})\\|^2 dA = \\int\\limits_S \\|\\Delta \\mathbf{x}' - \\Delta \\mathbf{x})\\|^2 dA. \\int\\limits_S \\|\\Delta (\\mathbf{x}' - \\mathbf{x})\\|^2 dA = \\int\\limits_S \\|\\Delta \\mathbf{x}' - \\Delta \\mathbf{x})\\|^2 dA. In the early work of Sorkine et al., the quantities \\Delta \\mathbf{x}' \\Delta \\mathbf{x}' and \\Delta \\mathbf{x} \\Delta \\mathbf{x} were dubbed \u201cdifferential coordinates\u201d 21 . Their deformations (without linearized rotations) is thus equivalent to biharmonic deformation fields. Polyharmonic Deformation \u00b6 We can generalize biharmonic deformation by considering different powers of the Laplacian, resulting in a series of PDEs of the form: \\Delta^k \\mathbf{d} = 0. \\Delta^k \\mathbf{d} = 0. with k\\in{1,2,3,\\dots} k\\in{1,2,3,\\dots} . The choice of k k determines the level of continuity at the handles. In particular, k=1 k=1 implies C^0 C^0 at the boundary, k=2 k=2 implies C^1 C^1 , k=3 k=3 implies C^2 C^2 and in general k k implies C^{k-1} C^{k-1} . int k = 2 ; // or 1,3,4,... igl :: harmonic ( V , F , b , bc , k , Z ); The PolyharmonicDeformation example deforms a flat domain (left) into a bump as a solution to various k k -harmonic PDEs. Bounded Biharmonic Weights \u00b6 In computer animation, shape deformation is often referred to as \u201cskinning\u201d. Constraints are posed as relative rotations of internal rigid \u201cbones\u201d inside a character. The deformation method, or skinning method, determines how the surface of the character (i.e. its skin) should move as a function of the bone rotations. The most popular technique is linear blend skinning. Each point on the shape computes its new location as a linear combination of bone transformations: \\mathbf{x}' = \\sum\\limits_{i = 1}^m w_i(\\mathbf{x}) \\mathbf{T}_i \\left(\\begin{array}{c}\\mathbf{x}_i\\\\1\\end{array}\\right), \\mathbf{x}' = \\sum\\limits_{i = 1}^m w_i(\\mathbf{x}) \\mathbf{T}_i \\left(\\begin{array}{c}\\mathbf{x}_i\\\\1\\end{array}\\right), where w_i(\\mathbf{x}) w_i(\\mathbf{x}) is the scalar weight function of the ith bone evaluated at \\mathbf{x} \\mathbf{x} and \\mathbf{T}_i \\mathbf{T}_i is the bone transformation as a 4 \\times 3 4 \\times 3 matrix. This formula is embarassingly parallel (computation at one point does not depend on shared data need by computation at another point). It is often implemented as a vertex shader. The weights and rest positions for each vertex are sent as vertex shader attributes and bone transformations are sent as uniforms . Then vertices are transformed within the vertex shader, just in time for rendering. As the skinning formula is linear (hence its name), we can write it as matrix multiplication: \\mathbf{X}' = \\mathbf{M} \\mathbf{T}, \\mathbf{X}' = \\mathbf{M} \\mathbf{T}, where \\mathbf{X}' \\mathbf{X}' is n \\times 3 n \\times 3 stack of deformed positions as row vectors, \\mathbf{M} \\mathbf{M} is a n \\times m\\cdot dim n \\times m\\cdot dim matrix containing weights and rest positions and \\mathbf{T} \\mathbf{T} is a m\\cdot (dim+1) \\times dim m\\cdot (dim+1) \\times dim stack of transposed bone transformations. Traditionally, the weight functions w_j w_j are painted manually by skilled rigging professionals. Modern techniques now exist to compute weight functions automatically given the shape and a description of the skeleton (or in general any handle structure such as a cage, collection of points, selected regions, etc.). Bounded biharmonic weights are one such technique that casts weight computation as a constrained optimization problem 13 . The weights enforce smoothness by minimizing the familiar Laplacian energy: \\sum\\limits_{i = 1}^m \\int_S (\\Delta w_i)^2 dA \\sum\\limits_{i = 1}^m \\int_S (\\Delta w_i)^2 dA subject to constraints which enforce interpolation of handle constraints: w_i(\\mathbf{x}) = \\begin{cases} 1 & \\text{ if } \\mathbf{x} \\in H_i\\\\ 0 & \\text{ otherwise } \\end{cases}, w_i(\\mathbf{x}) = \\begin{cases} 1 & \\text{ if } \\mathbf{x} \\in H_i\\\\ 0 & \\text{ otherwise } \\end{cases}, where H_i H_i is the ith handle, and constraints which enforce non-negativity, parition of unity and encourage sparsity: 0\\le w_i \\le 1 0\\le w_i \\le 1 and \\sum\\limits_{i=1}^m w_i = 1. \\sum\\limits_{i=1}^m w_i = 1. This is a quadratic programming problem and libigl solves it using its active set solver or by calling out to Mosek . The example BoundedBiharmonicWeights computes weights for a tetrahedral mesh given a skeleton (top) and then animates a linear blend skinning deformation (bottom). Dual Quaternion Skinning \u00b6 Even with high quality weights, linear blend skinning is limited. In particular, it suffers from known artifacts stemming from blending rotations as matrices: a weight combination of rotation matrices is not necessarily a rotation. Consider an equal blend between rotating by -\\pi/2 -\\pi/2 and by \\pi/2 \\pi/2 about the z z -axis. Intuitively one might expect to get the identity matrix, but instead the blend is a degenerate matrix scaling the x x and y y coordinates by zero: 0.5\\left(\\begin{array}{ccc}0&-1&0\\\\1&0&0\\\\0&0&1\\end{array}\\right)+ 0.5\\left(\\begin{array}{ccc}0&1&0\\\\-1&0&0\\\\0&0&1\\end{array}\\right)= \\left(\\begin{array}{ccc}0&0&0\\\\0&0&0\\\\0&0&1\\end{array}\\right) 0.5\\left(\\begin{array}{ccc}0&-1&0\\\\1&0&0\\\\0&0&1\\end{array}\\right)+ 0.5\\left(\\begin{array}{ccc}0&1&0\\\\-1&0&0\\\\0&0&1\\end{array}\\right)= \\left(\\begin{array}{ccc}0&0&0\\\\0&0&0\\\\0&0&1\\end{array}\\right) In practice, this means the shape shrinks and collapses in regions where bone weights overlap: near joints. Dual quaternion skinning presents a solution 17 . This method represents rigid transformations as a pair of unit quaternions, \\hat{\\mathbf{q}} \\hat{\\mathbf{q}} . The linear blend skinning formula is replaced with a linear blend of dual quaternions: \\mathbf{x}' = \\cfrac{\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}} {\\left\\|\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}\\right\\|} \\mathbf{x}, \\mathbf{x}' = \\cfrac{\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}} {\\left\\|\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}\\right\\|} \\mathbf{x}, where \\hat{\\mathbf{q}_i} \\hat{\\mathbf{q}_i} is the dual quaternion representation of the rigid transformation of bone i i . The normalization forces the result of the linear blending to again be a unit dual quaternion and thus also a rigid transformation. Like linear blend skinning, dual quaternion skinning is best performed in the vertex shader. The only difference being that bone transformations are sent as dual quaternions rather than affine transformation matrices. Libigl supports CPU-side dual quaternion skinning with the igl::dqs function, which takes a more traditional representation of rigid transformations as input and internally converts to the dual quaternion representation before blending: // vQ is a list of rotations as quaternions // vT is a list of translations igl :: dqs ( V , W , vQ , vT , U ); The example DualQuaternionSkinning compares linear blend skinning (top) to dual quaternion skinning (bottom), highlighting LBS\u2019s candy wrapper effect (middle) and joint collapse (right). As-rigid-as-possible \u00b6 Skinning and other linear methods for deformation are inherently limited. Difficult arises especially when large rotations are imposed by the handle constraints. In the context of energy-minimization approaches, the problem stems from comparing positions (our displacements) in the coordinate frame of the undeformed shape. These quadratic energies are at best invariant to global rotations of the entire shape, but not smoothly varying local rotations. Thus linear techniques will not produce non-trivial bending and twisting. Furthermore, when considering solid shapes (e.g. discretized with tetrahedral meshes) linear methods struggle to maintain local volume, and they often suffer from shrinking and bulging artifacts. Non-linear deformation techniques present a solution to these problems. They work by comparing the deformation of a mesh vertex to its rest position rotated to a new coordinate frame which best matches the deformation. The non-linearity stems from the mutual dependence of the deformation and the best-fit rotation. These techniques are often labeled \u201cas-rigid-as-possible\u201d as they penalize the sum of all local deformations\u2019 deviations from rotations. To arrive at such an energy, let\u2019s consider a simple per-triangle energy: E_\\text{linear}(\\mathbf{X}') = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) - \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2 E_\\text{linear}(\\mathbf{X}') = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) - \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2 where \\mathbf{X}' \\mathbf{X}' are the mesh\u2019s unknown deformed vertex positions, t t is a triangle in a list of triangles T T , a_t a_t is the area of triangle t t and \\{i,j\\} \\{i,j\\} is an edge in triangle t t . Thus, this energy measures the norm of change between an edge vector in the original mesh \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right) \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right) and the unknown mesh \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) . This energy is not rotation invariant. If we rotate the mesh by 90 degrees the change in edge vectors not aligned with the axis of rotation will be large, despite the overall deformation being perfectly rigid. So, the \u201cas-rigid-as-possible\u201d solution is to append auxiliary variables \\mathbf{R}_t \\mathbf{R}_t for each triangle t t which are constrained to be rotations. Then the energy is rewritten, this time comparing deformed edge vectors to their rotated rest counterparts: E_\\text{arap}(\\mathbf{X}',\\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\}) = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right)- \\mathbf{R}_t\\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2. E_\\text{arap}(\\mathbf{X}',\\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\}) = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right)- \\mathbf{R}_t\\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2. The separation into the primary vertex position variables \\mathbf{X}' \\mathbf{X}' and the rotations \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} lead to strategy for optimization, too. If the rotations \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} are held fixed then the energy is quadratic in the remaining variables \\mathbf{X}' \\mathbf{X}' and can be optimized by solving a (sparse) global linear system. Alternatively, if \\mathbf{X}' \\mathbf{X}' are held fixed then each rotation is the solution to a localized Procrustes problem (found via 3 \\times 3 3 \\times 3 SVD or polar decompostion). These two steps\u2014local and global\u2014each weakly decrease the energy, thus we may safely iterate them until convergence. The different flavors of \u201cas-rigid-as-possible\u201d depend on the dimension and codimension of the domain and the edge-sets T T . The proposed surface manipulation technique by Sorkine and Alexa 22 , considers T T to be the set of sets of edges emanating from each vertex (spokes). Later, Chao et al. derived the relationship between \u201cas-rigid-as-possible\u201d mesh energies and co-rotational elasticity considering 0-codimension elements as edge-sets: triangles in 2D and tetrahedra in 3D 12 . They also showed how Sorkine and Alexa\u2019s edge-sets are not a discretization of a continuous energy, proposing instead edge-sets for surfaces containing all edges of elements incident on a vertex (spokes and rims). They show that this amounts to measuring bending, albeit in a discretization-dependent way. Libigl, supports these common flavors. Selecting one is a matter of setting the energy type before the precompuation phase: igl :: ARAPData arap_data ; arap_data . energy = igl :: ARAP_ENERGY_TYPE_SPOKES ; //arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS; //arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS; //triangles or tets igl :: arap_precomputation ( V , F , dim , b , arap_data ); Just like igl::min_quad_with_fixed_* , this precomputation phase only depends on the mesh, fixed vertex indices b and the energy parameters. To solve with certain constraints on the positions of vertices in b , we may call: igl :: arap_solve ( bc , arap_data , U ); which uses U as an initial guess and then computes the solution into it. Libigl\u2019s implementation of as-rigid-as-possible deformation takes advantage of the highly optimized singular value decomposition code from McAdams et al. 20 which leverages SSE intrinsics. The example AsRigidAsPossible deforms a surface as if it were made of an elastic material The concept of local rigidity will be revisited shortly in the context of surface parameterization. Fast Automatic Skinning Transformations \u00b6 Non-linear optimization is, unsurprisingly, slower than its linear cousins. In the case of the as-rigid-as-possible optimization, the bottleneck is typically the large number of polar decompositions necessary to recover best fit rotations for each edge-set (i.e. for each triangle, tetrahedron, or vertex cell). Even if this code is optimized, the number of primary degrees of freedom is tied to the discretization level, despite the deformations\u2019 low frequency behavior. This invites two routes toward fast non-linear optimization. First, is it necessary (or even advantageous) to find so many best-fit rotations? Second, can we reduce the degrees of freedom to better reflect the frequency of the desired deformations. Taken in turn, these optimizations culminate in a method which optimizes over the space of linear blend skinning deformations spanned by high-quality weights (i.e. manually painted ones or bounded biharmonic weights). This space is a low-dimensional subspace of all possible mesh deformations, captured by writing linear blend skinning in matrix form: \\mathbf{X}' = \\mathbf{M}\\mathbf{T} \\mathbf{X}' = \\mathbf{M}\\mathbf{T} where the mesh vertex positions in the n \\times 3 n \\times 3 matrix \\mathbf{X}' \\mathbf{X}' are replaced by a linear combination of a small number of degrees of freedom in the (3+1)m \\times 3 (3+1)m \\times 3 stack of transposed \u201chandle\u201d transformations. Swapping in \\mathbf{M}\\mathbf{T} \\mathbf{M}\\mathbf{T} for \\mathbf{X}' \\mathbf{X}' in the ARAP energies above immediately sees performance gains during the global solve step as m << n m << n . The complexity of the local step\u2014fitting rotations\u2014is still bound to the original mesh discretization. However, if the skinning is well behaved, we can make the assumption that places on the shape with similar skinning weights will deform similarly and thus imply similar best-fit rotations. Therefore, we cluster edge-sets according to their representation in weight-space : where a vertex \\mathbf{x} \\mathbf{x} takes the coordinates [w_1(\\mathbf{x}),w_2(\\mathbf{x}),\\dots,w_m(\\mathbf{x})] [w_1(\\mathbf{x}),w_2(\\mathbf{x}),\\dots,w_m(\\mathbf{x})] . The number of clustered edge-sets show diminishing returns on the deformation quality so we may choose a small number of clusters, proportional to the number of skinning weight functions (rather than the number of discrete mesh vertices). This proposed deformation model 14 , can simultaneously be seen as a fast, subspace optimization for ARAP and as an automatic method for finding the best skinning transformation degrees of freedom. A variety of user interfaces are supported via linear equality constraints on the skinning transformations associated with handles. To fix a transformation entirely we simply add the constraint: \\left(\\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{T}}_i^T, \\left(\\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{T}}_i^T, where \\hat{\\mathbf{T}}_i^T \\hat{\\mathbf{T}}_i^T is the (3+1) \\times 3 (3+1) \\times 3 transposed fixed transformation for handle i i . To fix only the origin of a handle, we add a constraint requiring the transformation to interpolate a point in space (typically the centroid of all points with w_i = 1 w_i = 1 : \\mathbf{c}'^T\\mathbf{T}_i^T = \\mathbf{c}^T, \\mathbf{c}'^T\\mathbf{T}_i^T = \\mathbf{c}^T, where \\mathbf{c}^T \\mathbf{c}^T is the 1 \\times (3+1) 1 \\times (3+1) position of the point at rest in transposed homogeneous coordinates, and \\mathbf{c}'^T \\mathbf{c}'^T the point given by the user. We can similarly fix just the linear part of the transformation at a handle, freeing the translation component (producing a \u201cchickenhead\u201d effect): \\left(\\begin{array}{cccc} 1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&1&0\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{L}}_i^T, \\left(\\begin{array}{cccc} 1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&1&0\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{L}}_i^T, where \\hat{\\mathbf{L}}_i^T \\hat{\\mathbf{L}}_i^T is the fixed 3 \\times 3 3 \\times 3 linear part of the transformation at handle i i . And lastly we can allow the user to entirely free the transformation\u2019s degrees of freedom, delegating the optimization to find the best possible values for all elements. To do this, we simply abstain from adding a corresponding constraint. Arap With Grouped Edge-sets \u00b6 Being a subspace method, an immediate disadvantage is the reduced degrees of freedom. This brings performance, but in some situations limits behavior too much. In such cases one can use the skinning subspace to build an effective clustering of rotation edge-sets for a traditional ARAP optimization: forgoing the subspace substitution. This has a two-fold effect. The cost of the rotation fitting, local step drastically reduces, and the deformations are \u201cregularized\u201d according the clusters. From a high level point of view, if the clusters are derived from skinning weights, then they will discourage bending, especially along isolines of the weight functions. If handles are not known in advance, one could also cluster according to a \u201cgeodesic embedding\u201d like the biharmonic distance embedding. In this light, we can think of the \u201cspokes+rims\u201d style surface ARAP as a (slight and redundant) clustering of the per-triangle edge-sets. The example FastAutomaticSkinningTransformations compares a full (slow) ARAP deformation on a detailed shape (left of middle), to ARAP with grouped rotation edge sets (right of middle), to the very fast subpsace method (right). Biharmonic Coordinates \u00b6 Linear blend skinning (as above ) deforms a mesh by propagating full affine transformations at handles (bones, points, regions, etc.) to the rest of the shape via weights. Another deformation framework, called \u201cgeneralized barycentric coordinates\u201d, is a special case of linear blend skinning 16 : transformations are restricted to pure translations and weights are required to retain affine precision . This latter requirement means that we can write the rest-position of any vertex in the mesh as the weighted combination of the control handle locations: \\mathbf{x} = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i, \\mathbf{x} = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i, where \\mathbf{c}_i \\mathbf{c}_i is the rest position of the i i th control point. This simplifies the deformation formula at run-time. We can simply take the new position of each point of the shape to be the weighted combination of the translated control point positions: \\mathbf{x}' = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i'. \\mathbf{x}' = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i'. There are many different flavors of \u201cgeneralized barycentric coordinates\u201d (see table in \u201cAutomatic Methods\u201d section, 16 ). The vague goal of \u201cgeneralized barycentric coordinates\u201d is to capture as many properties of simplicial barycentric coordinates (e.g. for triangles in 2D and tetrahedral in 3D) for larger sets of points or polyhedra. Some generalized barycentric coordinates can be computed in closed form; others require optimization-based precomputation. Nearly all flavors require connectivity information describing how the control points form a external polyhedron around the input shape: a cage. However, a recent techinique does not require a cage 23 . This method ensures affine precision during optimization over weights of a smoothness energy with affine functions in its kernel: \\mathop{\\text{min}}_\\mathbf{W}\\,\\, \\text{trace}(\\frac{1}{2}\\mathbf{W}^T \\mathbf{A} \\mathbf{W}), \\text{subject to: } \\mathbf{C} = \\mathbf{W}\\mathbf{C} \\mathop{\\text{min}}_\\mathbf{W}\\,\\, \\text{trace}(\\frac{1}{2}\\mathbf{W}^T \\mathbf{A} \\mathbf{W}), \\text{subject to: } \\mathbf{C} = \\mathbf{W}\\mathbf{C} subject to interpolation constraints at selected vertices. If \\mathbf{A} \\mathbf{A} has affine functions in its kernel\u2014that is, if \\mathbf{A}\\mathbf{V} = 0 \\mathbf{A}\\mathbf{V} = 0 \u2014then the weights \\mathbf{W} \\mathbf{W} will retain affine precision and we\u2019ll have that: \\mathbf{V} = \\mathbf{W}\\mathbf{C} \\mathbf{V} = \\mathbf{W}\\mathbf{C} the matrix form of the equality above. The proposed way to define \\mathbf{A} \\mathbf{A} is to construct a matrix \\mathbf{K} \\mathbf{K} that measures the Laplacian at all interior vertices and at all boundary vertices . The usual definition of the discrete Laplacian (e.g. what libigl returns from igl::cotmatrix ), measures the Laplacian of a function for interior vertices, but measures the Laplacian of a function minus the normal derivative of a function for boundary vertices. Thus, we can let: \\mathbf{K} = \\mathbf{L} + \\mathbf{N} \\mathbf{K} = \\mathbf{L} + \\mathbf{N} where \\mathbf{L} \\mathbf{L} is the usual Laplacian and \\mathbf{N} \\mathbf{N} is matrix that computes normal derivatives of a piecewise-linear function at boundary vertices of a mesh. Then \\mathbf{A} \\mathbf{A} is taken as quadratic form computing the square of the integral-average of \\mathbf{K} \\mathbf{K} applied to a function and integrated over the mesh: \\mathbf{A} = (\\mathbf{M}^{-1}\\mathbf{K})^2_\\mathbf{M} = \\mathbf{K}^T \\mathbf{M}^{-1} \\mathbf{K}. \\mathbf{A} = (\\mathbf{M}^{-1}\\mathbf{K})^2_\\mathbf{M} = \\mathbf{K}^T \\mathbf{M}^{-1} \\mathbf{K}. Since the Laplacian \\mathbf{K} \\mathbf{K} is a second-order derivative it measures zero on affine functions, thus \\mathbf{A} \\mathbf{A} has affine functions in its null space. A short derivation proves that this implies \\mathbf{W} \\mathbf{W} will be affine precise (see 23 ). Minimizers of this \u201csquared Laplacian\u201d energy are in some sense discrete biharmonic functions . Thus they\u2019re dubbed \u201cbiharmonic coordinates\u201d (not the same as bounded biharmonic weights , which are not generalized barycentric coordinates). In libigl, one can compute biharmonic coordinates given a mesh (V,F) and a list S of selected control points or control regions (which act like skinning handles): igl :: biharmonic_coordinates ( V , F , S , W ); ( Example 407 ) shows a physics simulation on a coarse orange mesh. The vertices of this mesh become control points for a biharmonic coordinates deformation of the blue high-resolution mesh. Direct Delta Mush \u00b6 To produce a smooth deformation, linear blend skinning requires smooth skinning weights. These could be painted manually or computed automatically (e.g., using Bounded Biharmonic Weights 13 ). Even still, linear blend skinning suffers from shrinkage and collapse artifacts due to its inherent linearity (see earlier ). \u201cDirect Delta Mush\u201d 18 skinning attempts to solve both of these issues by providing a direct skinning method that takes as input a rig with piecewise-constant weight functions (weights are either =0 =0 or =1 =1 everywhere). Direct delta mush is an adaptation of a less performant method called simply \u201cDelta Mush\u201d 19 . The computation of Delta Mush separates into \u201cbind pose\u201d precomputation and runtime evaluation. At bind time, Laplacian smoothing is conducted on the bind pose, moving each vertex from its rest position \\mathbf{v}_i \\mathbf{v}_i to a new position \\tilde{\\mathbf{v}}_i \\tilde{\\mathbf{v}}_i . The \u201cdelta\u201d describing undoing this smoothing procedure, is computed and stored in a local coordinate frame associated with the vertex: \\delta_i = \\mathbf{T}_i^{-1} (\\mathbf{v}_i - \\tilde{\\mathbf{v}}_i). \\delta_i = \\mathbf{T}_i^{-1} (\\mathbf{v}_i - \\tilde{\\mathbf{v}}_i). At run time, the mesh is deformed using linear blend skinning and piecewise-constant weights. Near bones, the deformation is perfectly rigid, while near joints where bones meet, the mesh tears apart with a sudden change to the next rigid transformation. The same amount of Laplacian smoothing is applied at run time to this posed mesh. Moving each vertex to a location \\tilde{\\mathbf{u}}_i \\tilde{\\mathbf{u}}_i . A local frame \\mathbf{S}_i \\mathbf{S}_i is computed at this location and the cached deltas are adding in this resolved frame to restore the shape\u2019s original details: \\mathbf{u}_i = \\tilde{\\mathbf{u}}_i + \\mathbf{S}_i \\delta_i. \\mathbf{u}_i = \\tilde{\\mathbf{u}}_i + \\mathbf{S}_i \\delta_i. The key insight of \u201cDelta Mush\u201d is that Laplacian smoothing acts similarly on the rest and posed models. The key insight of \u201cDirect Delta Mush\u201d is that this process of Laplacian smoothing at runtime is nearly linear and local frames can be computed in a embarrassingly parallel fashion using SVD (cf. ARAP ). Direct delta mush moves the smoothing step into precomputation, resulting in \u201cvector-valued\u201d skinning weights per-vertex per-bone, stored in a matrix \\Omega \\Omega . In libigl, for a mesh (V,F) and (e.g., piecewise-constant) weights W this precomputation is computed using: igl :: direct_delta_mush_precomputation ( V , F , Wsparse , p , lambda , kappa , alpha , Omega ); the parameters p, lambda, kappa, alpha control the smoothness and compactness of the resulting deformation. The precomputation\u2019s output is the matrix Omega . At runtime, \\Omega \\Omega is used to deform the mesh to its final locations. In libigl, this is computed using: igl :: direct_delta_mush ( V , T_list , Omega , U ); where T_list is the input pose (affine) transformations associated with each bone and the final locations are stored in U . ( Example 408 ) Direct Delta Mush. (left) input piecewise-rigid skinning, (middle) skeleton animation, (right) smooth Direct Delta Mush skinning Mesh Deformation with Kelvinlet \u00b6 Kelvinlets 24 is a technique for real-time physically based volume sculpting of virtual elastic materials. The technique treats meshes as fluids made of compressible materials and deforms them by advecting points along a displacement field. It relies on analytical solutions to the equations of elasticity. A quick primer on linear elastostatics 25 \u00b6 The equilibrium state of linear elasticity is determined by a displacement field \\mathbf{u} : R^3 \\rightarrow R^3 \\mathbf{u} : R^3 \\rightarrow R^3 that minimizes the elastic potential energy E(\\mathbf{u}) = \\frac{\\mu}{2}\\left\\|\\nabla\\mathbf{u}\\right\\|^2 + \\frac{\\mu}{2(1-2\\nu)}\\left\\|\\nabla \\cdot \\mathbf{u}\\right\\|^2 - \\langle\\mathbf{b}, \\mathbf{u}\\rangle E(\\mathbf{u}) = \\frac{\\mu}{2}\\left\\|\\nabla\\mathbf{u}\\right\\|^2 + \\frac{\\mu}{2(1-2\\nu)}\\left\\|\\nabla \\cdot \\mathbf{u}\\right\\|^2 - \\langle\\mathbf{b}, \\mathbf{u}\\rangle where \\mu \\mu is the elastic shear modulus, \\nu \\nu is the Poisson ratio, and \\mathbf{b} \\mathbf{b} represents the external body forces. The first term controls the smoothness of the displacement field, the second term penalizes infinitesimal volume change, and the last term indicates the external body forces to be counteracted. One can associate the optimal displacement field with the solution to the critical point of the above equation, also known as the Navier-Cauchy equation: \\mu\\Delta\\mathbf{u} + \\frac{\\mu}{(1 - 2\\nu)}\\nabla(\\nabla \\cdot \\mathbf{u}) + \\mathbf{b} = 0 \\mu\\Delta\\mathbf{u} + \\frac{\\mu}{(1 - 2\\nu)}\\nabla(\\nabla \\cdot \\mathbf{u}) + \\mathbf{b} = 0 The Kelvinlet is the solution to the Navier-Cauchy equation in the case of a concentrated body load due to a force vector \\mathbf{f} \\mathbf{f} at a point \\mathbf{x}_{0} \\mathbf{x}_{0} , i.e., where \\mathbf{b}(\\mathbf{x}) = \\mathbf{f} \\delta(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{b}(\\mathbf{x}) = \\mathbf{f} \\delta(\\mathbf{x} \u2212 \\mathbf{x}_{0}) and can be written as: \\mathbf{u}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r}I + \\frac{\\mathbf{b}}{\\mathit{r}^3}\\mathbf{r}\\mathbf{r}^{t}\\right] \\mathbf{f} \\equiv \\mathbf{K}(\\mathbf{r})\\mathbf{f} \\mathbf{u}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r}I + \\frac{\\mathbf{b}}{\\mathit{r}^3}\\mathbf{r}\\mathbf{r}^{t}\\right] \\mathbf{f} \\equiv \\mathbf{K}(\\mathbf{r})\\mathbf{f} where \\mathbf{K} \\mathbf{K} is the Kelvinlet function, \\mathbf{r} = \\mathbf{x} \u2212 \\mathbf{x}_{0} \\mathbf{r} = \\mathbf{x} \u2212 \\mathbf{x}_{0} is the relative position vector from the load location \\mathbf{x}_{0} \\mathbf{x}_{0} to an observation point \\mathbf{x} \\mathbf{x} , \\mathit{r} \\mathit{r} is the norm of \\mathbf{r} \\mathbf{r} , a = \\frac{1}{4\\pi\\mu} a = \\frac{1}{4\\pi\\mu} and b = \\frac{a}{(1-\\nu)} b = \\frac{a}{(1-\\nu)} The displacement field \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) deforms a point \\mathbf{x} \\mathbf{x} in a linear elastic material to \\mathbf{x} + \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{x} + \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) . The associated deformation gradient is then defined by a 3\u00d73 3\u00d73 matrix of the form \\mathbf{G}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) = \\mathbf{I} + \\nabla\\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{G}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) = \\mathbf{I} + \\nabla\\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) . This gradient \\mathbf{G}(\\mathbf{r}) \\mathbf{G}(\\mathbf{r}) determines the different properties of the displacement field \\mathbf{u(\\mathbf{r})} \\mathbf{u(\\mathbf{r})} . For instance, the skew-symmetric part of \\nabla\\mathbf{u}(\\mathbf{r}) \\nabla\\mathbf{u}(\\mathbf{r}) indicates the rotation induced by \\mathbf{u(\\mathbf{r})} \\mathbf{u(\\mathbf{r})} , while its symmetric part corresponds to the elastic strain and determines the stretching. The strain tensor can also be decomposed into a trace term that represents the scaling of the volume of the elastic medium, and a traceless term that represents the pinching deformation. This forms the fundamentals of the Kelvinlet brushes. Regularized kelvinlets \u00b6 The concentrated body load at a single point \\mathbf{x}_{0} \\mathbf{x}_{0} introduces a singularity to the Kelvinlet solution at \\mathbf{x}_{0} \\mathbf{x}_{0} . For this reason, the kelvinlet equation is modified to: \\mathbf{u_{\\epsilon}}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r_{\\epsilon}}I + \\frac{\\mathbf{b}}{\\mathit{r_{\\epsilon}}^3}\\mathbf{r_{\\epsilon}}\\mathbf{r_{\\epsilon}}^{t} + \\frac{a}{2}\\frac{\\epsilon^2}{r_{\\epsilon}^3}I\\right] \\equiv \\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{f} \\mathbf{u_{\\epsilon}}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r_{\\epsilon}}I + \\frac{\\mathbf{b}}{\\mathit{r_{\\epsilon}}^3}\\mathbf{r_{\\epsilon}}\\mathbf{r_{\\epsilon}}^{t} + \\frac{a}{2}\\frac{\\epsilon^2}{r_{\\epsilon}^3}I\\right] \\equiv \\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{f} where \\mathbf{r}_{\\epsilon} = \\sqrt{r^2 + \\epsilon^2} \\mathbf{r}_{\\epsilon} = \\sqrt{r^2 + \\epsilon^2} is the regularized distance, \\epsilon > 0 \\epsilon > 0 is the radius of the sculpting brush. Thus, given a force vector \\mathbf{f} \\mathbf{f} , the displacement for any point in R^3 R^3 can be calculated, thus defining the physically based space deformation. In practice, the force vector is parameterized in terms of the brush tip displacement \\mathbf{\\bar{u}} \\mathbf{\\bar{u}} . To this end, we can expand the regularized kelvinlet equation with the constraint \\mathbf{u}_{\\epsilon}(0) = \\mathbf{\\bar{u}} \\mathbf{u}_{\\epsilon}(0) = \\mathbf{\\bar{u}} to end up with \\mathbf{u_{\\epsilon}} = c\\epsilon\\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{\\bar{u}} \\mathbf{u_{\\epsilon}} = c\\epsilon\\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{\\bar{u}} where c = 2/(3a - 2b) c = 2/(3a - 2b) Kelvinlets of different radial scales can be linearly combined to construct brushes with arbitrarily fast decays: \\mathbf{u}_{\\epsilon_{1},..\\epsilon_{n}}(\\mathbf{r}) = c \\left( \\sum_{i} \\frac{w_{i}}{\\epsilon_{i}}\\right)^{-1} \\left[\\sum_{i} w_{i}\\mathbf{K_{\\epsilon_{i}}}(\\mathbf{r}) \\right] \\mathbf{\\bar{u}} \\mathbf{u}_{\\epsilon_{1},..\\epsilon_{n}}(\\mathbf{r}) = c \\left( \\sum_{i} \\frac{w_{i}}{\\epsilon_{i}}\\right)^{-1} \\left[\\sum_{i} w_{i}\\mathbf{K_{\\epsilon_{i}}}(\\mathbf{r}) \\right] \\mathbf{\\bar{u}} where w_{i} w_{i} are weights and \\epsilon_{i} < \\epsilon_{i+1} \\epsilon_{i} < \\epsilon_{i+1} . Due to the superposition principle, these compound brushes still satisfy the Navier-Cauchy equation. Regularized kelvinlets can further be extended by replacing the vector-based load distribution with a matrix-based distribution to achieve non-affine transformations like twist, pinch, and scale as described earlier. In libigl, this is computed using: igl :: KelvinletParams < double > brushParams { brushRadius , scale , brushType }; igl :: kelvinlets ( V , origin , forceVec , forceMatrix , brushParams , result ); where brushRadius, scale, brushType correspond to \\epsilon \\epsilon , the falloff, and operation(grab, pinch, scale, twist). ( Example 409 ) pinch, twist, grab and scale in action Chapter 5: Parametrization \u00b6 In computer graphics, we denote as surface parametrization a map from the surface to \\(\\mathbf{R}^2\\). It is usually encoded by a new set of 2D coordinates for each vertex of the mesh (and possibly also by a new set of faces in one to one correspondence with the faces of the original surface). Note that this definition is the inverse of the classical differential geometry definition. A parametrization has many applications, ranging from texture mapping to surface remeshing. Many algorithms have been proposed, and they can be broadly divided in four families: Single patch, fixed boundary : these algorithm can parametrize a disk-like part of the surface given fixed 2D positions for its boundary. These algorithms are efficient and simple, but they usually produce high-distortion maps due to the fixed boundary. Single patch, free boundary: these algorithms let the boundary deform freely, greatly reducing the map distortion. Care should be taken to prevent the border from self-intersecting. Global parametrization : these algorithms work on meshes with arbitrary genus. They initially cut the mesh in multiple patches that can be separately parametrized. The generated maps are discontinuous on the cuts (often referred as seams ). Global seamless parametrization : these are global parametrization algorithm that hides the seams, making the parametrization \u201ccontinuous\u201d, under specific assumptions that we will discuss later. Harmonic Parametrization \u00b6 Harmonic parametrization 28 is a single patch, fixed boundary parametrization algorithm that computes the 2D coordinates of the flattened mesh as two harmonic functions. The algorithm is divided in 3 steps: Detect of the boundary vertices Map the boundary vertices to a circle Compute two harmonic functions (one for u and one for the v coordinate). The harmonic functions use the fixed vertices on the circle as boundary constraints. The algorithm can be coded using libigl as follows: Eigen :: VectorXi bnd ; igl :: boundary_loop ( V , F , bnd ); Eigen :: MatrixXd bnd_uv ; igl :: map_vertices_to_circle ( V , bnd , bnd_uv ); igl :: harmonic ( V , F , bnd , bnd_uv , 1 , V_uv ); where bnd contains the indices of the boundary vertices, bnd_uv their position on the UV plane, and \u201c1\u201d denotes that we want to compute an harmonic function (2 will be for biharmonic, 3 for triharmonic, etc.). Note that each of the three functions is designed to be reusable in other parametrization algorithms. A UV parametrization can be visualized in the viewer with: viewer . data (). set_uv ( V_uv ); The UV coordinates are then used to apply a procedural checkerboard texture to the mesh ( Example 501 ). ( Example 501 ) Harmonic parametrization. (left) mesh with texture, (right) UV parametrization with texture Least Squares Conformal Maps \u00b6 Least squares conformal maps parametrization 29 minimizes the conformal (angular) distortion of the parametrization. Differently from harmonic parametrization, it does not need to have a fixed boundary. LSCM minimizes the following energy: \\[ E_{LSCM}(\\mathbf{u},\\mathbf{v}) = \\int_X \\frac{1}{2}| \\nabla \\mathbf{u}^{\\perp} - \\nabla \\mathbf{v} |^2 dA \\] which can be rewritten in matrix form as 32 : \\[ E_{LSCM}(\\mathbf{u},\\mathbf{v}) = \\frac{1}{2} [\\mathbf{u},\\mathbf{v}]^t (L_c - 2A) [\\mathbf{u},\\mathbf{v}] \\] where L_c L_c is the cotangent Laplacian matrix and A A is a matrix such that [\\mathbf{u},\\mathbf{v}]^t A [\\mathbf{u},\\mathbf{v}] [\\mathbf{u},\\mathbf{v}]^t A [\\mathbf{u},\\mathbf{v}] is equal to the vector area of the mesh. Using libigl, this matrix energy can be written in a few lines of code. The cotangent matrix can be computed using igl::cotmatrix : SparseMatrix < double > L ; igl :: cotmatrix ( V , F , L ); Note that we want to apply the Laplacian matrix to the u and v coordinates at the same time, thus we need to extend it taking the left Kronecker product with a 2x2 identity matrix: SparseMatrix < double > L_flat ; igl :: repdiag ( L , 2 , L_flat ); The area matrix is computed with igl::vector_area_matrix : SparseMatrix < double > A ; igl :: vector_area_matrix ( F , A ); The final energy matrix is L_{flat} - 2A L_{flat} - 2A . Note that in this case we do not need to fix the boundary. To remove the null space of the energy and make the minimum unique, it is sufficient to fix two arbitrary vertices to two arbitrary positions. The full source code is provided in Example 502 . ( Example 502 ) LSCM parametrization. (left) mesh with texture, (right) UV parametrization As-rigid-as-possible Parametrization \u00b6 As-rigid-as-possible parametrization 31 is a powerful single-patch, non-linear algorithm to compute a parametrization that strives to preserve distances (and thus angles). The idea is very similar to ARAP surface deformation: each triangle is mapped to the plane trying to preserve its original shape, up to a rigid rotation. The algorithm can be implemented reusing the functions discussed in the deformation chapter: igl::arap_precomputation and igl::arap_solve . The only difference is that the optimization has to be done in 2D instead of 3D and that we need to compute a starting point. While for 3D deformation the optimization is bootstrapped with the original mesh, this is not the case for ARAP parametrization since the starting point must be a 2D mesh. In Example 503 , we initialize the optimization with harmonic parametrization. Similarly to LSCM, the boundary is free to deform to minimize the distortion. ( Example 503 ) As-Rigid-As-Possible parametrization. (left) mesh with texture, (right) UV parametrization with texture N-rotationally Symmetric Tangent Fields \u00b6 The design of tangent fields is a basic tool used to design guidance fields for uniform quadrilateral and hexahedral remeshing. Libigl contains an implementation of all the state-of-the-art algorithms to design N-RoSy fields and their generalizations. In libigl, tangent unit-length vector fields are piece-wise constant on the faces of a triangle mesh, and they are described by one or more vectors per-face. The function igl :: nrosy ( V , F , b , bc , b_soft , b_soft_weight , bc_soft , N , 0.5 , output_field , output_singularities ); creates a smooth unit-length vector field (N=1) starting from a sparse set of constrained faces, whose indices are listed in b and their constrained value is specified in bc. The functions supports soft_constraints (b_soft, b_soft_weight, bc_soft), and returns the interpolated field for each face of the triangle mesh (output_field), plus the singularities of the field (output_singularities). Design of a unit-length vector field The singularities are vertices where the field vanishes (highlighted in red in the figure above). igl::nrosy can also generate N-RoSy fields 30 , which are a generalization of vector fields where in every face the vector is defined up to a constant rotation of 2\\pi / N 2\\pi / N . As can be observed in the following figure, the singularities of the fields generated with different N are of different types and they appear in different positions. Design of a 2-,4- and 9-RoSy field We demonstrate how to call and plot N-RoSy fields in Example 504 , where the degree of the field can be change pressing the number keys. igl::nrosy implements the algorithm proposed in 26 . N-RoSy fields can also be interpolated with many other algorithms, see the library libdirectional for a reference implementation of the most popular ones. For a complete categorization of fields used in various applications see Vaxman et al. 2016 34 . Global, Seamless Integer-grid Parametrization \u00b6 The previous parametrization methods were focusing on creating parametrizations of surface patches aimed at texture mapping or baking of other surface properties such as normals and high-frequency details. Global, seamless parametrization aims at parametrizing complex shapes with a parametrization that is aligned with a given set of directions for the purpose of surface remeshing. In libigl, we provide a reference implementation of the pipeline proposed in the mixed integer quadrangulation paper 26 . The first step involves the design of a 4-RoSy field (sometimes called cross field) that describes the alignment of the edges of the desired quadrilateral remeshing. The field constraints are usually manually specified or extracted from the principal curvature directions. In Example 506 , we simply fix one face in a random direction. Initial cross field prescribing the edge alignment. Combing And Cutting \u00b6 Given the cross field, we now want to cut the surface so that it becomes homeomorphic to a disk. While this could be done directly on the cross-field, we opt to perform this operation on its bisector field (a copy of the field rotated by 45 degrees) since it is more stable and generic. Working on the bisectors allow us to take as input generalized, non-orthogonal and non-unit length cross fields. We thus rotate the field, Bisector field. and we remove the rotation ambiguity by assigning to each face a u and a v direction. The assignment is done with a breadth-first search starting from a random face. Combed bisector field. You can imagine this process as combing a hairy surface: you will be able to comb part of it, but at some point you will not be able to consistently comb the entire surface ( Hairy ball theorem ). The discontinuities in the combing define the cut graph: Cut graph. Finally, we rotate the combed field by 45 degrees to undo the initial degrees rotation: Combed cross field. The combed cross field can be seen as the ideal Jacobian of the parametrization that will be computed in the next section. Poisson Parametrization \u00b6 The mesh is cut along the seams and a parametrization is computed trying to find two scalar functions whose gradient matches the combed cross field directions. This is a classical Poisson problem, that is solved minimizing the following quadratic energy: \\[ E(\\mathbf{u},\\mathbf{v}) = |\\nabla \\mathbf{u} - X_u|^2 + |\\nabla \\mathbf{v} - X_v|^2 \\] where X_u X_u and X_u X_u denotes the combed cross field. Solving this problem generates a parametrization whose u and v isolines are aligned with the input cross field. Poisson parametrization. We hide the seams by adding integer constraints to the Poisson problem that align the isolines on both sides of each seam 26 . Seamless Poisson parametrization. Note that this parametrization can only be used for remeshing purposes, since it contains many overlaps. Seamless Poisson parametrization (in 2D). A quad mesh can be extracted from this parametrization using libQEx (not included in libigl). The full pipeline is implemented in Example 505 . Anisotropic Remeshing \u00b6 Anisotropic and non-uniform quad remeshing is important to concentrate the elements in the regions with more details. It is possible to extend the MIQ quad meshing framework to generate anisotropic quad meshes using a mesh deformation approach 33 . The input of the anisotropic remeshing algorithm is a sparse set of constraints that define the shape and scale of the desired quads. This can be encoded as a frame field, which is a pair of non-orthogonal and non-unit length vectors. The frame field can be interpolated by decomposing it in a 4-RoSy field and a unique affine transformation. The two parts can then be interpolated separately, using igl::nrosy for the cross field, and an harmonic interpolant for the affine part. Interpolation of a frame field. Colors on the vectors denote the desired scale. The red faces contains the frame field constraints. After the interpolation, the surface is warped to transform each frame into an orthogonal and unit length cross (i.e. removing the scaling and skewness from the frame). This deformation defines a new embedding (and a new metric) for the surface. The surface is deformed to transform the frame field in a cross field. The deformed surface can the be isotropically remeshed using the MIQ algorithm that has been presented in the previous section. The deformed surface is isotropically remeshed. The UV coordinates of the deformed surface can then be used to transport the parametrization to the original surface, where the isolines will trace a quad mesh whose elements are similar to the shape prescribed in the input frame field. The global parametrization is lifted to the original surface to create the anisotropic quad meshing. Our implementation ( Example 506 ) uses MIQ to generate the UV parametrization, but other algorithms could be applied: the only desiderata is that the generated quad mesh should be as isotropic as possible. Planarization \u00b6 A quad mesh can be transformed in a planar quad mesh with Shape-Up 27 , a local/global approach that uses the global step to enforce surface continuity and the local step to enforce planarity. Example 507 planarizes a quad mesh until it satisfies a user-given planarity threshold. A non-planar quad mesh (left) is planarized using the libigl function igl::planarize (right). The colors represent the planarity of the quads. Chapter 6: External Libraries \u00b6 An additional positive side effect of using matrices as basic types is that it is easy to exchange data between libigl and other software and libraries. State Serialization \u00b6 Geometry processing applications often require a considerable amount of computational time and/or manual input. Serializing the state of the application is a simple strategy to greatly increase the development efficiency. It allows to quickly start debugging just before the crash happens, avoiding to wait for the precomputation to take place every time and it also makes your experiments reproducible, allowing to quickly test algorithms variants on the same input data. Serialization is often not considered in geometry processing due to the extreme difficulty in serializing pointer-based data structures, such as an half-edge data structure ( OpenMesh , CGAL ), or a pointer based indexed structure ( VCG ). In libigl, serialization is much simpler, since the majority of the functions use basic types, and pointers are used in very rare cases (usually to interface with external libraries). Libigl bundles a simple and self-contained binary and XML serialization framework, that drastically reduces the overhead required to add serialization to your applications. To de-/serialize a set of variables use the following method: #include \"igl/serialize.h\" bool b = true ; unsigned int num = 10 ; std :: vector < float > vec = { 0.1 , 0.002 , 5.3 }; // use overwrite = true for the first serialization to create or overwrite an // existing file igl :: serialize ( b , \"B\" , \"filename\" , true ); // append following serialization to existing file igl :: serialize ( num , \"Number\" , \"filename\" ); igl :: serialize ( vec , \"VectorName\" , \"filename\" ); // deserialize back to variables igl :: deserialize ( b , \"B\" , \"filename\" ); igl :: deserialize ( num , \"Number\" , \"filename\" ); igl :: deserialize ( vec , \"VectorName\" , \"filename\" ); Currently all fundamental data types (bool, int, float, double, \u2026) are supported, as well as std::string, basic STL containers, dense and sparse Eigen matrices and nestings of those. Some limitations apply to pointers. Currently, loops or many to one type of link structures are not handled correctly. Each pointer is assumed to point to a different independent object. Uninitialized pointers must be set to nullptr before de-/serialization to avoid memory leaks. Cross-platform issues like little-, big-endianess is currently not supported. To make user defined types serializable, just derive from igl::Serializable and trivially implementing the InitSerialization method. Assume that the state of your application is a mesh and a set of integer ids: #include \"igl/serialize.h\" struct State : public igl :: Serializable { Eigen :: MatrixXd V ; Eigen :: MatrixXi F ; std :: vector < int > ids ; void InitSerialization () { this -> Add ( V , \"V\" ); this -> Add ( F , \"F\" ); this -> Add ( ids , \"ids\" ); } }; If you need more control over the serialization of your types, you can override the following functions or directly inherit from the interface igl::SerializableBase . bool Serializable::PreSerialization () const ; void Serializable::PostSerialization () const ; bool Serializable::PreDeserialization (); void Serializable::PostDeserialization (); Alternatively, if you want a non-intrusive way of serializing your state you can overload the following functions: namespace igl { namespace serialization { template <> inline void serialize ( const State & obj , std :: vector < char >& buffer ) { :: igl :: serialize ( obj . V , std :: string ( \"V\" ), buffer ); :: igl :: serialize ( obj . F , std :: string ( \"F\" ), buffer ); :: igl :: serialize ( obj . ids , std :: string ( \"ids\" ), buffer ); } template <> inline void deserialize ( State & obj , const std :: vector < char >& buffer ) { :: igl :: deserialize ( obj . V , std :: string ( \"V\" ), buffer ); :: igl :: deserialize ( obj . F , std :: string ( \"F\" ), buffer ); :: igl :: deserialize ( obj . ids , std :: string ( \"ids\" ), buffer ); } } } Equivalently, you can use the following macros: SERIALIZE_TYPE ( State , SERIALIZE_MEMBER ( V ) SERIALIZE_MEMBER ( F ) SERIALIZE_MEMBER_NAME ( ids , \"ids\" ) ) All the former code is for binary serialization which is especially useful if you have to handle larger data where the loading and saving times become more important. For cases where you want to read and edit the serialized data by hand we provide a serialization to XML files which is based on the library tinyxml2 . There you also have the option to create a partial binary serialization of your data by using the binary parameter, exposed in the function serialize_xml() : #include \"igl/xml/serialize_xml.h\" int number ; // binary = false, overwrite = true igl :: serialize_xml ( vec , \"VectorXML\" , xmlFile , false , true ); // binary = true, overwrite = true igl :: serialize_xml ( vec , \"VectorBin\" , xmlFile , true , true ); igl :: deserialize_xml ( vec , \"VectorXML\" , xmlFile ); igl :: deserialize_xml ( vec , \"VectorBin\" , xmlFile ); For user defined types derive from XMLSerializable . The code snippets above are extracted from Example 601 . We strongly suggest that you make the entire state of your application always serializable since it will save you a lot of troubles when you will be preparing figures for a scientific report. It is very common to have to do small changes to figures, and being able to serialize the entire state just before you take screenshots will save you many painful hours before a submission deadline. Mixing Matlab Code \u00b6 Libigl can be interfaced with Matlab to offload numerically heavy computation to a Matlab script. The major advantage of this approach is that you will be able to develop efficient and complex user-interfaces in C++, while exploring the syntax and fast protototyping features of matlab. In particular, the use of an external Matlab script in a libigl application allows to change the Matlab code while the C++ application is running, greatly increasing coding efficiency. We demonstrate how to integrate Matlab in a libigl application in Example 602 . The example uses Matlab to compute the Eigenfunctions of the discrete Laplacian operator, relying on libigl for mesh IO, visualization and for computing the Laplacian operator. Libigl can connect to an existing instance of Matlab (or launching a new one on Linux/MacOSX) using: igl :: mlinit ( & engine ); The cotangent Laplacian is computed using igl::cotmatrix and uploaded to the Matlab workspace: igl :: cotmatrix ( V , F , L ); igl :: mlsetmatrix ( & engine , \"L\" , L ); It is now possible to use any Matlab function on the data. For example, we can see the sparsity pattern of L using spy: igl :: mleval ( & engine , \"spy(L)\" ); The Matlab spy function is called from a libigl-based application. The results of Matlab computations can be returned back to the C++ application igl :: mleval ( & engine , \"[EV,~] = eigs(-L,10,'sm')\" ); igl :: mlgetmatrix ( & engine , \"EV\" , EV ); and plotted using the libigl viewer. Eigenfunctions of the Laplacian computed in Matlab, plotted in the libigl viewer. Saving A Matlab Workspace \u00b6 To aid debugging, libigl also supplies functions to write Matlab .mat \u201cWorkspaces\u201d. This C++ snippet saves a mesh and it\u2019s sparse Laplacian matrix to a file: igl :: readOFF ( TUTORIAL_SHARED_PATH \"/fertility.off\" , V , F ); igl :: cotmatrix ( V , F , L ); igl :: MatlabWorkspace mw ; mw . save ( V , \"V\" ); mw . save_index ( F , \"F\" ); mw . save ( L , \"L\" ); mw . write ( \"fertility.mat\" ); Then this workspace can be loaded into a Matlab IDE: load fertility . mat The igl::MatlabWorkspace depends on Matlab libraries to compile and run, but\u2014in contrast to the engine routines above\u2014will avoid launching a Matlab instance upon execution. Dumping Eigen Matrices To Copy And Paste Into Matlab \u00b6 Eigen supplies a sophisticated API for printing its matrix types to the screen. Libigl has wrapped up a particularly useful formatting which makes it simple to copy standard output from a C++ program into a Matlab IDE. The code: igl :: readOFF ( TUTORIAL_SHARED_PATH \"/2triangles.off\" , V , F ); igl :: cotmatrix ( V , F , L ); std :: cout << igl :: matlab_format ( V , \"V\" ) << std :: endl ; std :: cout << igl :: matlab_format (( F . array () + 1 ). eval (), \"F\" ) << std :: endl ; std :: cout << igl :: matlab_format ( L , \"L\" ) << std :: endl ; produces the output: V = [ 0 0 0 1 0 0 1 1 1 2 1 0 ]; F = [ 1 2 3 2 4 3 ]; LIJV = [ 1 1 - 0.7071067811865476 2 1 0.7071067811865475 3 1 1.570092458683775e-16 1 2 0.7071067811865475 2 2 - 1.638010440969447 3 2 0.6422285251880865 4 2 0.2886751345948129 1 3 1.570092458683775e-16 2 3 0.6422285251880865 3 3 - 0.9309036597828995 4 3 0.2886751345948129 2 4 0.2886751345948129 3 4 0.2886751345948129 4 4 - 0.5773502691896258 ]; L = sparse ( LIJV (:, 1 ), LIJV (:, 2 ), LIJV (:, 3 )); which is easily copied and pasted into Matlab for debugging, etc. Calling Libigl Functions From Matlab \u00b6 It is also possible to call libigl functions from matlab, compiling them as MEX functions. This can be used to offload to C++ code the computationally intensive parts of a Matlab application. We provide a wrapper for igl::readOBJ in Example 603 . We plan to provide wrappers for all our functions in the future, if you are interested in this feature (or if you want to help implementing it) please let us know. Triangulation Of Closed Polygons \u00b6 The generation of high-quality triangle and tetrahedral meshes is a very common task in geometry processing. We provide wrappers in libigl to triangle and Tetgen . A triangle mesh with a given boundary can be created with: igl :: triangulate ( V , E , H , V2 , F2 , \"a0.005q\" ); where E is a set of boundary edges (#E by 2), H is a set of 2D positions of points contained in holes of the triangulation (#H by 2) and ( V2 , F2 ) is the generated triangulation. Additional parameters can be passed to triangle , to control the quality: \"a0.005q\" enforces a bound on the maximal area of the triangles and a minimal angle of 20 degrees. In Example 604 , the interior of a square (excluded a smaller square in its interior) is triangulated. Triangulation of the interior of a polygon. Tetrahedralization Of Closed Surfaces \u00b6 Similarly, the interior of a closed manifold surface can be tetrahedralized using the function igl::tetrahedralize which wraps the Tetgen library ( Example 605 ): igl :: tetrahedralize ( V , F , \"pq1.414\" , TV , TT , TF ); Tetrahedralization of the interior of a surface mesh. Baking Ambient Occlusion \u00b6 Ambient occlusion is a rendering technique used to calculate the exposure of each point in a surface to ambient lighting. It is usually encoded as a scalar (normalized between 0 and 1) associated with the vertice of a mesh. Formally, ambient occlusion is defined as: \\[ A_p = \\frac{1}{\\pi} \\int_\\omega V_{p,\\omega}(n \\cdot \\omega) d\\omega \\] where V_{p,\\omega} V_{p,\\omega} is the visibility function at p, defined to be zero if p is occluded in the direction \\omega \\omega and one otherwise, and d\\omega d\\omega is the infinitesimal solid angle step of the integration variable \\omega \\omega . The integral is usually approximated by casting rays in random directions around each vertex. This approximation can be computed using the function: igl :: ambient_occlusion ( V , F , V_samples , N_samples , 500 , AO ); that given a scene described in V and F , computes the ambient occlusion of the points in V_samples whose associated normals are N_samples . The number of casted rays can be controlled (usually at least 300-500 rays are required to get a smooth result) and the result is returned in AO , as a single scalar for each sample. Ambient occlusion can be used to darken the surface colors, as shown in Example 606 A mesh rendered without (left) and with (right) ambient occlusion. Screen Capture \u00b6 Libigl supports read and writing to .png files via the stb image code. With the viewer used in this tutorial, it is possible to render the scene in a memory buffer using the function, igl::opengl::ViewerCore::draw_buffer : // Allocate temporary buffers for 1280x800 image Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > R ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > G ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > B ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > A ( 1280 , 800 ); // Draw the scene in the buffers viewer . core . draw_buffer ( viewer . data (), false , R , G , B , A ); // Save it to a PNG igl :: png :: writePNG ( R , G , B , A , \"out.png\" ); In Example 607 a scene is rendered in a temporary png and used to texture a quadrilateral. Off-screen rendering using ray tracing with Embree \u00b6 If libigl is compiled without OpenGL support, or when the interactive viewer is not practical, it is still possible to render view in memory using Embree library. Currently only triangular meshes are supported. The usage is very similar to the Screen Capture tutorial. // Create embree renderer object igl :: embree :: EmbreeRenderer er ; // Specify mesh, tell embree to optimize for static scene er . set_mesh ( V , F , true ); // Specify scalar data, use JET color map to convert to colors er . set_data ( K , igl :: COLOR_MAP_TYPE_JET ); // Since the render is not interactive, need to specify scene parameters // the default view is identical to the interactive viewer Eigen :: Matrix3d rot_matrix ; // Specify rotation matrix: // 10 degrees around X axis // 5 degrees around Y axis // 4 degrees around Z axis rot_matrix = Eigen :: AngleAxisd ( 10 * igl :: PI / 180.0 , Eigen :: Vector3d :: UnitX ()) * Eigen :: AngleAxisd ( 5 * igl :: PI / 180.0 , Eigen :: Vector3d :: UnitY ()) * Eigen :: AngleAxisd ( 4 * igl :: PI / 180.0 , Eigen :: Vector3d :: UnitZ ()); er . set_rot ( rot_matrix ); // Specify relative zoom factor er . set_zoom ( 1.5 ); // Request orthographic projection er . set_orthographic ( false ); // Allocate temporary buffers for 1280x800 image Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > R ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > G ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > B ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > A ( 1280 , 800 ); // Render view er . render_buffer ( R , G , B , A ); // Save it to a PNG igl :: png :: writePNG ( R , G , B , A , png_file ); Fertility statue showing curvature as scalar field, rendered with embree In Example 608 a scene is rendered in a memory buffer and saved as png file. Boolean Operations On Meshes \u00b6 Constructive solid geometry (CSG) is a technique to define a complex surface as the result of a number of set operations on solid regions of space: union, intersection, set difference, symmetric difference, complement. Typically, CSG libraries represent the inputs and outputs to these operations implicitly : the solid A A is defined as the open set of points \\mathbf{x} \\mathbf{x} for which some function a(\\mathbf{x}) a(\\mathbf{x}) \u201creturns true\u201d. The surface of this shape is the closure of all points x x in A A . With this sort of representation, boolean operations are straightforward. For example, the union of solids A A and B B is simply A \\cup B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ or } b(\\mathbf{x})\\}, A \\cup B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ or } b(\\mathbf{x})\\}, the intersection is A \\cap B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and } b(\\mathbf{x})\\}, A \\cap B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and } b(\\mathbf{x})\\}, the difference A A minus B B is A \\setminus B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and _not_ } b(\\mathbf{x})\\}, A \\setminus B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and _not_ } b(\\mathbf{x})\\}, and the symmetric difference (XOR) is A \\triangle B = \\{\\mathbf{x} \\left.\\right| \\text{either } a(\\mathbf{x}) \\text{ or } b(\\mathbf{x}) \\text{ but not both }\\}. A \\triangle B = \\{\\mathbf{x} \\left.\\right| \\text{either } a(\\mathbf{x}) \\text{ or } b(\\mathbf{x}) \\text{ but not both }\\}. Stringing together many of these operations, one can design quite complex shapes. A typical CSG library might only keep explicit base-case representations of canonical shapes: half-spaces, quadrics, etc. In libigl, we currently do not have an implicit surface representation. Instead we expect our users to be working with explicit triangle mesh boundary representations of solid shapes. CSG operations are much hard to compute robustly with boundary representations, but are nonetheless useful. To compute a boolean operation on a triangle mesh with vertices VA and triangles FA and another mesh VB and FB , libigl first computes a unified \u201cmesh arrangement\u201d (see 36 []) with vertices V and triangles F where all triangle-triangle intersections have been \u201cresolved\u201d. That is, edges and vertices are added exactly at the intersection lines, so the resulting non-manifold mesh (V,F) has no self-intersections. Then libigl labels each \u201ccell\u201d bounded by surfaces of the arrangement according to its winding number vector : winding number with respect to each input mesh (w_A,w_B) (w_A,w_B) . Finally, according to the desired operation (e.g. union, intersection) the boundary of the corresponding cells are extracted. Calling libigl\u2019s boolean operations is simple. To compute the union of (VA,FA) and (VB,FB) into a new mesh (VC,FC) , use: igl :: copyleft :: cgal :: mesh_boolean ( VA , FA , VB , FB , MESH_BOOLEAN_TYPE_UNION , VC , FC ); The following figure shows each boolean operation on two meshes. The example Boolean conducts boolean operations on the Cheburashka (red) and Knight (green). From left to right: union, intersection, set minus, symmetric difference (XOR), \u201cresolve\u201d. Bottom row reveals inner surfaces, darker color indicates back-facing triangles. The union, symmetric difference and \u201cresolve\u201d have the same outward appearance, but differ in their treatment of internal structures. The union has no internal surfaces: the triangles are not included in the output. The symmetric difference is the same set of triangles as the \u201cresolve\u201d, but internal surfaces have been reversed in orientation, indicating that the solid result of the operation. The \u201cresolve\u201d operation is not really a boolean operation, it is simply the result of resolving all intersections and gluing together coincident vertices, maintaining original triangle orientations. Libigl also provides a wrapper igl::copyleft::cork::mesh_boolean to the cork , which is typically faster, but is not always robust. Csg Tree \u00b6 The previous section discusses using igl::copyleft::cgal::mesh_boolean to compute the result of a single boolean operation on two input triangle meshes. When employing constructive solid geometry (CSG) as a modeling paradigm, shapes are represented as the result of many such binary operations. The sequence is stored in a binary tree. Libigl uses exact arithmetic internally to construct the intermediary boolean results robustly. \u201cRounding\u201d this result to floating point (even double precision) would cause problems if re-injected into a further boolean operation. To facilitate CSG tree operations and encourage callers not to call igl::copyleft::cgal::mesh_boolean multiple times explicitly, libigl implements a class igl::copyleft::cgal::CSGTree . Leaf nodes of this class are simply \u201csolid\u201d meshes (otherwise good input to igl::copyleft::cgal::mesh_boolean ). Interior nodes of the tree combine two children with a boolean operation. Using the intializer list constructor it is easy to hard-code specific tree constructions. Here\u2019s an example taking the intersection of a cube A and sphere B minus the union of three cylinders: // Compute result of (A \u2229 B) \\ ((C \u222a D) \u222a E) igl :: copyleft :: cgal :: CSGTree < MatrixXi > CSGTree = { { { VA , FA },{ VB , FB }, \"i\" },{ { { VC , FC },{ VD , FD }, \"u\" }, { VE , FE }, \"u\" }, \"m\" }; A CSG Tree represents a shape as a combination of binary boolean operations Example 610 computes each intermediary CSG result and then the final composite. Example 610 computes complex CSG Tree operation on 5 input meshes. Chapter 7: Miscellaneous \u00b6 Libigl contains a wide variety of geometry processing tools and functions for dealing with meshes and the linear algebra related to them: far too many to discuss in this introductory tutorial. We\u2019ve pulled out a couple of the interesting functions in this chapter to highlight. Mesh Statistics \u00b6 Libigl contains various mesh statistics, including face angles, face areas and the detection of singular vertices, which are vertices with more or less than 6 neighbours in triangulations or 4 in quadrangulations. The example Statistics computes these quantities and does a basic statistic analysis that allows to estimate the isometry and regularity of a mesh: Irregular vertices: 136 /2400 ( 5 .67% ) Areas ( Min/Max ) /Avg_Area Sigma: 0 .01/5.33 ( 0 .87 ) Angles in degrees ( Min/Max ) Sigma: 17 .21/171.79 ( 15 .36 ) The first row contains the number and percentage of irregular vertices, which is particularly important for quadrilateral meshes when they are used to define subdivision surfaces: every singular point will result in a point of the surface that is only C^1. The second row reports the area of the minimal element, maximal element and the standard deviation. These numbers are normalized by the mean area, so in the example above 5.33 max area means that the biggest face is 5 times larger than the average face. An ideal isotropic mesh would have both min and max area close to 1. The third row measures the face angles, which should be close to 60 degrees (90 for quads) in a perfectly regular triangulation. For FEM purposes, the closer the angles are to 60 degrees the more stable will the optimization be. In this case, it is clear that the mesh is of bad quality and it will probably result in artifacts if used for solving PDEs. Generalized Winding Number \u00b6 The problem of tetrahedralizing the interior of closed watertight surface mesh is a difficult, but well-posed problem (see our Tetgen wrappers ). But black-box tet-meshers like TetGen will refuse input triangle meshes with self-intersections, open boundaries, non-manifold edges from multiple connected components. The problem is two-fold: self-intersections present contradictory facet constraints and self-intersections/open-boundaries/non-manifold edges make the problem of determining inside from outside ill-posed without further assumptions. The first problem is easily solved by \u201cresolving\u201d all self-intersections. That is, meshing intersecting triangles so that intersects occur exactly at edges and vertices. This is accomplished using igl::selfintersect . TetGen can usually tetrahedralize the convex hull of this \u201cresolved\u201d mesh, and then the problem becomes determining which of these tets are inside the input mesh and which are outside. That is, which should be kept and which should be removed. The \u201cGeneralized Winding Number\u201d is a robust method for determined inside and outside for troublesome meshes 40 . The generalized winding number with respect to (V,F) at some point \\mathbf{p} \\in \\mathcal{R}^3 \\mathbf{p} \\in \\mathcal{R}^3 is defined as scalar function: w(\\mathbf{p}) = \\sum\\limits_{f_i\\in F} \\frac{1}{4\\pi}\\Omega_{f_i}(\\mathbf{p}) w(\\mathbf{p}) = \\sum\\limits_{f_i\\in F} \\frac{1}{4\\pi}\\Omega_{f_i}(\\mathbf{p}) where \\Omega_{f_i} \\Omega_{f_i} is the solid angle subtended by f_i f_i (the ith face in F ) at the point \\mathbf{p} \\mathbf{p} . This solid angle contribution is a simple, closed-form expression involving atan2 and some dot-products. If (V,F) does form a closed watertight surface, then w(\\mathbf{p})=1 w(\\mathbf{p})=1 if \\mathbf{p} \\mathbf{p} lies inside (V,F) and w(\\mathbf{p})=0 w(\\mathbf{p})=0 if outside (V,F) . If (V,F) is closed but overlaps itself then w(\\mathbf{p}) w(\\mathbf{p}) is an integer value counting how many (signed) times (V,F) wraps around \\mathbf{p} \\mathbf{p} . Finally, if (V,F) is not closed or not even manifold (but at least consistently oriented), then w(\\mathbf{p}) w(\\mathbf{p}) tends smoothly toward 1 as \\mathbf{p} \\mathbf{p} is more inside (V,F) , and toward 0 as \\mathbf{p} \\mathbf{p} is more outside. Example 702 computes the generalized winding number function for a tetrahedral mesh inside a cat with holes and self intersections (gold). The silver mesh is surface of the extracted interior tets, and slices show the winding number function on all tets in the convex hull: blue (~0), green (~1), yellow (~2). Mesh Decimation \u00b6 The study of mesh simplification or decimation is nearly as old as meshes themselves. Given a high resolution mesh with too many triangles, find a \u201cwell approximating\u201d low resolution mesh with far fewer triangles. By now there are a variety of different paradigms for solving this problem and state-of-the-art methods are fairly advanced. One family of mesh decimation methods operates by successively remove elements from the mesh. In particular, Hoppe advocates for successively remove or rather collapsing edges 39 []. The generic form of this technique is to construct a sequence of n meshes from the initial high-resolution mesh M_0 M_0 to the lowest resolution mesh M_n M_n by collapsing a single edge: M_0 \\mathop{\\longrightarrow}_\\text{edge collapse} M_1 \\mathop{\\longrightarrow}_\\text{edge collapse} \\dots \\mathop{\\longrightarrow}_\\text{edge collapse} M_{n-1} \\mathop{\\longrightarrow}_\\text{edge collapse} M_n. M_0 \\mathop{\\longrightarrow}_\\text{edge collapse} M_1 \\mathop{\\longrightarrow}_\\text{edge collapse} \\dots \\mathop{\\longrightarrow}_\\text{edge collapse} M_{n-1} \\mathop{\\longrightarrow}_\\text{edge collapse} M_n. Hoppe\u2019s original method and subsequent follow-up works propose various ways to choose the next edge to collapse in this sequence. Using a cost-based paradigm, one can maintain a priority queue of edges based on their \u201ccost\u201d (how much \u201cworse\u201d will my approximation be if I remove this edge?). The cheapest edge is collapsed and costs of neighboring edges are updated. In order to maintain the topology (e.g. if the mesh is combinatorially as sphere or a torus etc.), one should assign infinite cost to edges whose collapse would alter the mesh topology. Indeed this happens if and only if the number of mutual neighbors of the endpoints of the collapsing edge is not exactly two! If there exists a third shared vertex, then another face will be removed, but 2 edges will be removed. This can result in unwanted holes or non-manifold \u201cflaps\u201d. A valid edge collapse and an invalid edge collapse. There is also a one-off condition that no edges of a tetrahedron should be collapsed. Because libigl (purposefully) does not center its implementations around a dynamic mesh data structure (e.g. half-edge datastructure), support for topology changes are limited. Nonetheless, libigl has support for isolated edge collapses, sequences of edge-collapses (each in O(log) time) and priority queue based decimation. The simplest is igl::decimation . By calling igl :: decimate ( V , F , 1000 , U , G ); the mesh (V,F) will be decimated to a new mesh (U,G) so that G has at most 1000 faces. This uses default (naive) criteria for determining the cost of an edge collapse and the placement of the merged vertex. Shortest edges are collapsed first, and merged vertices are placed at edge midpoints. One can also provide function handles ( c++ lambda functions are convenient here) cost_and_placement and stopping_condition for determining the cost/placement of an edge collapse and the stopping condition respectively. For example, the default version above is implemented as: igl :: decimate ( V , F , shortest_edge_and_midpoint , max_m , U , G ); where shortest_edge_and_midpoint assign the edge\u2019s length as cost and its midpoint as the merged vertex placement and max_m counts the current number of faces (valid collapses decrease count by 2) and returns true if the count drops below m=1000 . One can also scratch deeper inside the decimation loop and call igl::collapse_edge directly. In order to operate efficiently, this routine needs more than the usual (V,F) mesh representation. We need E a list of edge indices, where E.row(i) --> [s,d] ; we need EMAP which maps the \u201chalf\u201d-edges of each triangle in F to its corresponding edge in E so that E.row(EMAP(f+i*F.rows)) --> [s,d] if the edge across from the ith corner of the fth face is [s,d] (up to orientation); we need EF and EI which keep track of the faces incident on each edge and across from which corner of those faces the edges appears, so that EF(e,o) = f and EI(e,o) = i means that the edge E.row(e) --> [s,d] appears in the fth face across from its ith corner (for o=0 the edge orientations should match, for o=1 the orientations are opposite). When a collapse occurs, the sizes of the F , E , etc. matrices do not change. Rather rows corresponding to \u201cremoved\u201d faces and edges are set to a special constant value IGL_COLLAPSE_EDGE_NULL . Doing this ensures that we\u2019re able to remove edges in truly constant time O(1). Conveniently IGL_COLLAPSE_EDGE_NULL==0 . This means most OPENGL style renderings of F will simply draw a bunch of 0-area triangles at the first vertex. The following will collapse the first edge and place its merged vertex at the origin: igl :: collapse_edge ( 0 , RowVector3d ( 0 , 0 , 0 ), V , F , E , EMAP , EF , EI ); If valid, then V , F , E , EF , EI are adjusted accordingly. This is powerful, but low level. To build a decimator around this you\u2019d need to keep track which edges are left to collapse and which to collapse next. Fortunately, libigl also exposes a priority queue based edge collapse with function handles to adjust costs and placements. The priority queue is implemented as a (ordered) set Q or (cost,edge index) pairs and a list of iterators Qit so that Qit[e] reveals the iterator in Q corresponding to the eth edge. Placements are stored in a #E list of positions C . When the following is called: igl :: collapse_edge ( cost_and_placement , V , F , E , EMAP , EF , EI , Q , Qit , C ); the lowest cost edge collapse according to Q is attempted. If valid, then V , F ,etc. are adjusted accordingly and that edge is \u201cpopped\u201d from Q . Using Qit its neighboring edges are also popped from Q and re-inserted after updating their costs according to cost_and_placement , new placements are remembered in C . If not valid, then the edge is \u201cpopped\u201d from Q and reinserted with infinite cost. Example 703 conducts edge collapses on the fertility model. The Example 703 demonstrates using this priority queue based approach with the simple shortest-edge-midpoint cost/placement strategy discussed above. Signed Distances \u00b6 In the Generalized Winding Number section , we examined a robust method for determining whether points lie inside or outside of a given triangle soup mesh. Libigl complements this algorithm with accelerated signed and unsigned distance queries and \u201cin element\u201d queries for planar triangle meshes and 3D tetrahedral meshes. These routines make use of libigl\u2019s general purpose axis-aligned bounding box hierarchy ( igl/AABB.h ). This class is lightweight and\u2014by design\u2014does not store a copy of the mesh (taking it as inputs to its member functions instead). Point Location \u00b6 For tetrahedral meshes, this is useful for \u201cin element\u201d or \u201cpoint location\u201d queries: given a point \\mathbf{q}\\in\\mathcal{R}^3 \\mathbf{q}\\in\\mathcal{R}^3 and a tetrahedral mesh (V,T) (V,T) determine in which tetrahedron \\mathbf{q} \\mathbf{q} lies. This is accomplished in libigl for a tet mesh V,T and a list of query points in the rows of Q via the igl::in_element() : // Initialize AABB tree igl :: AABB < MatrixXd , 3 > tree ; tree . init ( V , T ); VectorXi I ; igl :: in_element ( V , T , Q , tree , I ); the resulting vector I is a list of indices into T revealing the first tetrahedron found to contain the corresponding point in Q . For overlapping meshes, a point \\mathbf{q} \\mathbf{q} may belong to more than one tetrahedron. In those cases, one can find them all (not just the first) by using the igl::in_element overload with a SparseMatrix as the output: SparseMatrix < int > I ; igl :: in_element ( V , T , Q , tree , I ); now each row of I reveals whether each tet contains the corresponding row in Q : I(q,e)!=0 means that point q is in element e . Closest Points \u00b6 For Triangle meshes, we use the AABB tree to accelerate point-mesh closest point queries: given a mesh (V,F) (V,F) and a query point \\mathbf{q}\\in\\mathcal{R}^3 \\mathbf{q}\\in\\mathcal{R}^3 find the closest point \\mathbf{c} \\in (V,F) \\mathbf{c} \\in (V,F) (where \\mathbf{c} \\mathbf{c} is not necessarily a vertex of (V,F) (V,F) ). This is accomplished for a triangle mesh V,F and a list of points in the rows of P via igl::point_mesh_squared_distance : VectorXd sqrD ; VectorXi I ; MatrixXd C ; igl :: point_mesh_squared_distance ( P , V , F , sqrD , I , C ); the output sqrD contains the (unsigned) squared distance from each point in P to its closest point given in C which lies on the element in F given by I (e.g. from which one could recover barycentric coordinates, using igl::barycentric_coordinates ). If the mesh V,F is static, but the point set P is changing dynamically then it\u2019s best to reuse the AABB hierarchy that\u2019s being built during igl::point_mesh_squared_distance : igl :: AABB tree ; tree . init ( V , F ); tree . squared_distance ( V , F , P , sqrD , I , C ); ... // P changes, but (V,F) does not tree . squared_distance ( V , F , P , sqrD , I , C ); Signed Distance \u00b6 Finally, from the closest point or the winding number it\u2019s possible to sign this distance. In igl::signed_distance we provide two methods for signing: the so-called \u201cpseudo-normal test\u201d 37 [] and the generalized winding number 40 []. The pseudo-normal test (see also igl::pseudonormal_test ) assumes the input mesh is a watertight (closed, non-self-intersecting, manifold) mesh. Then given a query point \\mathbf{q} \\mathbf{q} and its closest point \\mathbf{c} \\in (V,F) \\mathbf{c} \\in (V,F) , it carefully chooses an outward normal \\mathbf{n} \\mathbf{n} at \\mathbf{c} \\mathbf{c} so that \\text{sign}(\\mathbf{q}-\\mathbf{c})\\cdot \\mathbf{n} \\text{sign}(\\mathbf{q}-\\mathbf{c})\\cdot \\mathbf{n} reveals whether \\mathbf{q} \\mathbf{q} is inside (V,F) (V,F) : -1, or outside: +1. This is a fast O(1) O(1) test once \\mathbf{c} \\mathbf{c} is located, but may fail if V,F is not watertight. An alternative is to use the generalized winding number to determine the sign. This is very robust to unclean meshes V,F but slower: something like O(\\sqrt{n}) O(\\sqrt{n}) once \\mathbf{c} \\mathbf{c} is located. In either case, the interface via igl::signed_distance is: // Choose type of signing to use igl :: SignedDistanceType type = SIGNED_DISTANCE_TYPE_PSEUDONORMAL ; igl :: signed_distance ( P , V , F , sign_type , S , I , C , N ); the outputs are as above for igl::point_mesh_squared_distance but now S contains signed (unsquared) distances and the extra output N (only set when type == SIGNED_DISTANCE_TYPE_PSEUDON ) contains the normals used for signing with the pseudo-normal test. Example 704 computes signed distance on slices through the bunny. Marching Cubes \u00b6 Often 3D data is captured as scalar field defined over space f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} . Lurking within this field, iso-surfaces of the scalar field are often salient geometric objects. The iso-surface at value v v is composed of all points \\mathbf{x} \\mathbf{x} in \\mathcal{R}^3 \\mathcal{R}^3 such that f(\\mathbf{x}) = v f(\\mathbf{x}) = v . A core problem in geometry processing is to extract an iso-surface as a triangle mesh for further mesh-based processing or visualization. This is referred to as iso-contouring. \u201cMarching Cubes\u201d 42 is a famous method for iso-contouring tri-linear functions f f on a regular lattice (aka grid). The core idea of this method is to contour the iso-surface passing through each cell (if it does at all) with a predefined topology (aka connectivity) chosen from a look up table depending on the function values at each vertex of the cell. The method iterates (\u201cmarches\u201d) over all cells (\u201ccubes\u201d) in the grid and stitches together the final, watertight mesh. In libigl, igl::marching_cubes constructs a triangle mesh (V,F) from an input scalar field S sampled at vertex locations GV of a nx by ny by nz regular grid: igl :: marching_cubes ( S , GV , nx , ny , nz , V , F ); ( Example 705 ) samples signed distance to the input mesh (left) and then reconstructs the surface using marching cubes to contour the 0-level set (center). For comparison, clamping this signed distance field to an indicator function and contouring reveals serious aliasing artifacts. Facet Orientation \u00b6 Models from the web occasionally arrive unorientated in the sense that the orderings of each triangles vertices do not consistently agree. Determining a consistent facet orientation for a mesh is essential for two-sided lighting (e.g., a cloth with red velvet on one side and gold silk on the other side) and for inside-outside determination(e.g., using generalized winding numbers ). For (open) surfaces representing two-sided sheets, libigl provides a routine to force consistent orientations within each orientable patch ( igl::orientable_patches ) of a mesh: igl :: bfs_orient ( F , FF , C ); This simple routine will use breadth-first search on each patch of the mesh to enforce a consistent facet orientation in the output faces FF . For (closed or nearly closed) surfaces representing the boundary of a solid object, libigl provides a routine to reorient faces so that the vertex ordering corresponds to a counter-clockwise ordering of the vertices with a right-hand-rule normal pointing outward. This method 45 [] assumes that most of the universe is empty . That is, most points in space are outside of the solid object than inside. Points are sampled over surface patches. For each sample point, rays are shot into both hemispheres to compute average of the (distance weighted) ambient occlusion on each side. A patch is oriented so that the outward side is less occluded (lighter, i.e., facing more void space). igl :: embree :: reorient_facets_raycast ( V , F , FF , I ); The boolean vector I reveals which rows of F have been flipped in FF . ( Example 706 ) loads a truck model with inconsistent orientations (back facing triangles shown darker). Orientable patches are uniquely colored and then oriented to face outward (middle left). Alternatively, each individual triangle is considered a \u201cpatch\u201d (middle right) and oriented outward independently. Swept Volume \u00b6 The swept volume S S of a moving solid object A A can be defined as any point in space such that at one moment in time the point lies inside the solid. In other words, it is the union of the solid object transformed by the rigid motion f(t) f(t) over time: S = \\bigcup \\limits_{t\\in [0,1]} f(t) A. S = \\bigcup \\limits_{t\\in [0,1]} f(t) A. The surface of the swept volume of a solid bounded by a triangle mesh undergoing a rigid motion with non-trivial rotation is not a surface exactly representably by triangle mesh: it will be a piecewise-ruled surface. To see this, consider the surface swept by a single edge\u2019s line segment as it performs a screw motion. This means that if we\u2019d like to the surface of the swept volume of a triangle mesh undergoing a rigid motion and we\u2019d like the output to be another triangle mesh, then we\u2019re going to have to be happy with some amount of approximation error. With this in mind, the simplest method for computing an approximate swept volume is by exploiting an alternative definition of the swept volume based on signed distances: S = \\left\\{ \\mathbf{p}\\ \\middle| \\ d(\\mathbf{p},\\partial S) < 0 \\right\\} = \\left\\{ \\mathbf{p}\\ \\middle|\\ \\min\\limits_{t \\in [0,1]} d(\\mathbf{p},f(t)\\ \\partial A) < 0 \\right\\} S = \\left\\{ \\mathbf{p}\\ \\middle| \\ d(\\mathbf{p},\\partial S) < 0 \\right\\} = \\left\\{ \\mathbf{p}\\ \\middle|\\ \\min\\limits_{t \\in [0,1]} d(\\mathbf{p},f(t)\\ \\partial A) < 0 \\right\\} If \\partial A \\partial A is a triangle mesh, then we can approximate this by 1) discretizing time at a finite step of steps [0,\\Delta t,2\\Delta t, \\dots, 1] [0,\\Delta t,2\\Delta t, \\dots, 1] and by 2) discretizing space with a regular grid and representing the distance field using trilinear interpolation of grid values. Finally the output mesh, \\partial S \\partial S is approximated by contouring using Marching Cubes 42 . This method is similar to one described by Schroeder et al. in 1994 44 , and the one used in conjunction with boolean operations by Garg et al. 2016 38 . In libigl, if your input solid\u2019s surface is represented by (V,F) then the output surface mesh will be (SV,SF) after calling: igl :: copyleft :: swept_volume ( V , F , num_time_steps , grid_size , isolevel , SV , SF ); The isolevel parameter can be set to zero to approximate the exact swept volume, greater than zero to approximate a positive offset of the swept volume or less than zero to approximate a negative offset. ( Example 707 ) computes the surface of the swept volume (silver) of the bunny model undergoing a rigid motion (gold). Picking \u00b6 Picking vertices and faces using the mouse is very common in geometry processing applications. While this might seem a simple operation, its implementation is not straightforward. Libigl contains a function that solves this problem using the Embree raycaster. Its usage is demonstrated in Example 708 : bool hit = igl :: unproject_onto_mesh ( Vector2f ( x , y ), F , viewer . core . view * viewer . core . model , viewer . core . proj , viewer . core . viewport , * ei , fid , bc ); This function casts a ray from the view plane in the view direction. Variables x and y are the mouse screen coordinates; view , model , proj are the view, model and projection matrix respectively; viewport is the viewport in OpenGL format; ei contains a Bounding Volume Hierarchy constructed by Embree, and fid and bc are the picked face and barycentric coordinate of the picked position, respectively. ( Example 708 ) Picking via ray casting. The selected faces are colored in red. Scalable Locally Injective Maps \u00b6 The Scalable Locally Injective Maps 43 algorithm allows to compute locally injective maps on massive datasets. The algorithm shares many similarities with ARAP, but uses a reweighting scheme to minimize arbitrary distortion energies, including those that prevent the introduction of flips. Example 709 contains three demos: (1) an example of large scale 2D parametrization, (2) an example of 2D deformation with soft constraints, and (3) an example of 3D deformation with soft constraints. The implementation in libigl is self-contained and relies on Eigen for the solution of the linear system used in the global step. An optimized version that relies on Pardiso is available here . A locally injective parametrization of a mesh with 50k faces is computed using the SLIM algorithm in 10 iterations. Simplicial Complex Augmentation Framework For Bijective Maps \u00b6 The Simplicial Complex Augmentation Framework 49 algorithm allows to compute bijective maps efficiently and robustly. The algorithm constructed a scaffold structure to take advantage of efficient locally injective mapping algorithms like SLIM, guarantees a overlapping free map with low distortion while being efficient and scalable. Example 710 contains a demo of bijective parameterizing a camel mesh. Subdivision Surfaces \u00b6 Given a coarse mesh (aka cage) with vertices V and faces F , one can create a higher-resolution mesh with more vertices and faces by subdividing every face. That is, each coarse triangle in the input is replaced by many smaller triangles. Libigl has three different methods for subdividing a triangle mesh. An \u201cin plane\u201d subdivision method will not change the point set or carrier surface of the mesh. New vertices are added on the planes of existing triangles and vertices surviving from the original mesh are not moved. By adding new faces, a subdivision algorithm changes the combinatorics of the mesh. The change in combinatorics and the formula for positioning the high-resolution vertices is called the \u201csubdivision rule\u201d. For example, in the in plane subdivision method of igl::upsample , vertices are added at the midpoint of every edge: v_{ab} = \\frac{1}{2}(v_a + v_b) v_{ab} = \\frac{1}{2}(v_a + v_b) and each triangle (i_a,i_b,i_c) (i_a,i_b,i_c) is replaced with four triangles: (i_a,i_{ab},i_{ca}) (i_a,i_{ab},i_{ca}) , (i_b,i_{bc},i_{ab}) (i_b,i_{bc},i_{ab}) , (i_{ab},i_{bc},i_{ca}) (i_{ab},i_{bc},i_{ca}) , and (i_{bc},i_{c},i_{ca}) (i_{bc},i_{c},i_{ca}) . This process may be applied recursively, resulting in a finer and finer mesh. The subdivision method of igl::loop is not in plane. The vertices of the refined mesh are moved to weight combinations of their neighbors: the mesh is smoothed as it is refined 41 . This and other smooth subdivision methods can be understood as generalizations of spline curves to surfaces. In particular the Loop subdivision method will converge to a C^1 C^1 surface as we consider the limit of recursive applications of subdivision. Away from \u201cirregular\u201d or \u201cextraordinary\u201d vertices (vertices of the original cage with valence not equal to 6), the surface is C^2 C^2 . The combinatorics (connectivity and number of faces) of igl::loop and igl::upsample are identical: the only difference is that the vertices have been smoothed in igl::loop . Finally, libigl also implements a form of in plane \u201cfalse barycentric subdivision\u201d in igl::false_barycentric_subdivision . This method simply adds the barycenter of every triangle as a new vertex v_{abc} v_{abc} and replaces each triangle with three triangles (i_a,i_b,i_{abc}) (i_a,i_b,i_{abc}) , (i_b,i_c,i_{abc}) (i_b,i_c,i_{abc}) , and (i_c,i_a,i_{abc}) (i_c,i_a,i_{abc}) . In contrast to igl::upsample , this method will create triangles with smaller and smaller internal angles and new vertices will sample the carrier surfaces with extreme bias. The original coarse mesh and three different subdivision methods: igl::upsample , igl::loop and igl::false_barycentric_subdivision . Data Smoothing \u00b6 A noisy function f f defined on a surface \\Omega \\Omega can be smoothed using an energy minimization that balances a smoothing term E_S E_S with a quadratic fitting term: u = \\operatorname{argmin}_u \\alpha E_S(u) + (1-\\alpha)\\int_\\Omega ||u-f||^2 dx u = \\operatorname{argmin}_u \\alpha E_S(u) + (1-\\alpha)\\int_\\Omega ||u-f||^2 dx The parameter \\alpha \\alpha determines how aggressively the function is smoothed. A classical choice for the smoothness energy is the Laplacian energy of the function with zero Neumann boundary conditions, which is a form of the biharmonic energy. It is constructed using the cotangent Laplacian L and the mass matrix M : QL = L'*(M\\L) . Because of the implicit zero Neumann boundary conditions however, the function behavior is significantly warped at the boundary if f f does not have zero normal gradient at the boundary. In 51 it is suggested to use the Biharmonic energy with natural Hessian boundary conditions instead, which corresponds to the Hessian energy with the matrix QH = H'*(M2\\H) , where H is a finite element Hessian and M2 is a stacked mass matrix. The matrices H and QH are implemented in libigl as igl::hessian and igl::hessian_energy respectively. An example of how to use the function is given in Example 712 . In the following image the differences between the Laplacian energy with zero Neumann boundary conditions and the Hessian energy can be clearly seen: whereas the zero Neumann boundary condition in the third image bias the isolines of the function to be perpendicular to the boundary, the Hessian energy gives an unbiased result. ( Example 712 ) From left to right: a function on the beetle mesh, the function with added noise, the result of smoothing with the Laplacian energy and zero Neumann boundary conditions, and the result of smoothing with the Hessian energy. Shapeup Projections \u00b6 Our input is a set of points P_0 P_0 (not necessarily part of any mesh), and a set of constraints S=\\left\\{S_1,S_2,...S_m\\right\\} S=\\left\\{S_1,S_2,...S_m\\right\\} , where each constraint is defined on a different, and sparse, subset of P_0 P_0 . We wish to create a new set of points P P that are close to the original set P_0 P_0 (each point with corresponding indices), while adhering to the constraints. Other objectives, such as smoothness, can be employed. The constraints can be nonlinear, which makes the problem nonconvex, difficult, and without a guaranteed global optimum. A very popular lightweight approach to such problems is a local-global iterative algorithm, comprising these two steps: For iteration k k : 1. Local step : compute the projections of the set P_{k-1} P_{k-1} onto S S , individually per constraint; that would mean fragmenting each point that appears in multiple constraints. That can be a nonlinear operation, but if the constraints are sparse, it is a a set of many small systems. 2. Global step : integrate the set P_k P_k to be as close as possible to the projected fragmented set, with auxiliary objective functions possible. That results in a global, but quadratic objective function. Moreover, the resulting linear system has a constant matrix, and therefore can be pre-factored. The version we implement in libigl is the general version described by 27 , and is in two files: <igl/shapeup.h> and <igl/shapeup_local_projections.h> . A demo implementing regularity constraints (creating a mesh in which each face is as regular as possible) is in Example 713 . The local step is instantiated by a function of type igl::shapeup_projection_function . The global step is done by two functions: igl::shapeup_precomputation() , which precomputes the matrices required for the global step, and igl::shapeup_solve() , which solves the problem, according to the initial solution P_0 P_0 and the input local projection function. The data struct igl::ShapeUpData contains the information necessary to run the algorithm, and can be configured; for instance, the self-explanatory variable Maxiterations . The global step minimizes the following energy: E_{total}=\\lambda_{shape}E_{shape}+\\lambda_{close}E_{close}+\\lambda_{smooth}E_{smooth}, E_{total}=\\lambda_{shape}E_{shape}+\\lambda_{close}E_{close}+\\lambda_{smooth}E_{smooth}, where the \\lambda \\lambda coefficients are encoded in igl::ShapeUpData , and can be updated prior to calling igl::shapeup_precomputation() . The E_{shape} E_{shape} component is the integration energy (fitting P_k P_k to the local projections). The E_{close} E_{close} component is adherence to positional constraints, given by b and bc parameters. The E_{smooth} E_{smooth} component is an optional objective function, to minimize differences (in the Dirichlet sense) between points, encodes by \u201cedges\u201d in parameter E . Both E_{close} E_{close} and E_{shape} E_{shape} are also weighted by wClose and wShape function parameters, respectively. ( Example 713 ) The half-tunnel mesh (left) has been optimized to be almost perfectly regular (right). The color scale is between \\lbrack 0,0.05 \\rbrack \\lbrack 0,0.05 \\rbrack , measuring the average normalized deviation of the angles of each face from 90^{\\circ} 90^{\\circ} . Marching Tetrahedra \u00b6 Often 3D data is captured as scalar field defined over space f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} . Lurking within this field, iso-surfaces of the scalar field are often salient geometric objects. The iso-surface at value v v is composed of all points \\mathbf{x} \\mathbf{x} in \\mathcal{R}^3 \\mathcal{R}^3 such that f(\\mathbf{x}) = v f(\\mathbf{x}) = v . A core problem in geometry processing is to extract an iso-surface as a triangle mesh for further mesh-based processing or visualization. This is referred to as iso-contouring. \u201cMarching Tetrahedra\u201d 46 is a famous method for iso-contouring tri-linear functions f f on a 3D simplicial complex (aka a tet mesh). The core idea of this method is to contour the iso-surface passing through each cell (if it does at all) with a predefined topology (aka connectivity) chosen from a look up table depending on the function values at each vertex of the cell. The method iterates (\u201cmarches\u201d) over all cells (\u201ctetrahedra\u201d) in the complex and stitches together the final mesh. In libigl, igl::marching_tets constructs a triangle mesh (V,F) approximating the iso-level set for the value isovalue from an input scalar field S sampled at the vertices of a tet mesh locations (TV, TT) : igl :: marching_tets ( TV , TT , S , isovalue , V , F ); Implicit Function Meshing \u00b6 715_MeshImplicitFunction Entry Missing Heat Method For Fast Geodesic Distance Approximation \u00b6 In the Exact Discrete Geodesic Distances example above, geodesic distances are computed exactly . This is an expensive operation: O(n\u00b2 log(n)) O(n\u00b2 log(n)) for a mesh with n n edges. In 2013, Crane et al. 47 proposed a method to compute approximate geodesic distances much faster by solving heat equation on the surface, filtering the result and then reconstructing a smooth solution by solving a Poisson equation. The method begins with the observation of Varadhan that the geodesic distance d(\\mathbf{x},\\mathbf{y}) d(\\mathbf{x},\\mathbf{y}) between two points \\mathbf{x} \\mathbf{x} and \\mathbf{y} \\mathbf{y} is equal to the square root of the logarithm of the heat diffused from \\mathbf{x} \\mathbf{x} to \\mathbf{y} \\mathbf{y} after a time t t : \\[ d(\\mathbf{x},\\mathbf{y}) = \\lim_{t\u21920} \\sqrt{ -4 t \\log k_{t,\\mathbf{x}} (\\mathbf{y}) }, \\] where k_{t,\\mathbf{x}} k_{t,\\mathbf{x}} is the heat kernel . We can think of this heat diffusion problem as placing a hot needle on \\mathbf{x} \\mathbf{x} and then after t t seconds, measuring the temperature at point \\mathbf{y} \\mathbf{y} . On triangle meshes we know how to solve the heat equation for any finite time t t : \\[ (-\\mathbf{L}+\\frac{1}{t}\\mathbf{M}) \\mathbf{u} = \u03b4_{x}, \\] where \\mathbf{L} \u2208 \\mathbb{R}^{n\u00d7n} \\mathbf{L} \u2208 \\mathbb{R}^{n\u00d7n} is the discrete Laplacian matrix, \\mathbf{M} \u2208 \\mathbb{R}^{n\u00d7n} \\mathbf{M} \u2208 \\mathbb{R}^{n\u00d7n} is the discrete mass matrix, \\mathbf{u} \u2208 \\mathbb{R}^n \\mathbf{u} \u2208 \\mathbb{R}^n are the resulting temperatures at each vertex, and \u03b4_x \u2208 \\mathbb{R}^n \u03b4_x \u2208 \\mathbb{R}^n is a vector of all zeros except a one at the vertex at the source \\mathbf{x} \\mathbf{x} . If we had sufficient numerical accuracy and precision, we could simply evaluate \\sqrt{-4 t \\log u} \\sqrt{-4 t \\log u} for a small time parameter t t . The problem observed by Crane et al. is that our numerical accuracy of the value of \\mathbf{u} \\mathbf{u} is far from sufficient. However, the direction of the gradient \u2207 \\mathbf{u} \u2207 \\mathbf{u} is surprisingly accurate. Hence, their idea is to acquire the gradient of \\mathbf{u} \\mathbf{u} , normalize these vectors to get a gradient direction (unit vector). And then solve a Poisson equation to integrate these directions into actual distance values. This method involves inverting n\u00d7n n\u00d7n sparse matrices (a O(n^{1.\\cdots}) O(n^{1.\\cdots}) operation), but if Cholesky factorizations are used then the factorization is precomputation that can be reused even if the source of the geodesic distances is changed. For a new source, only back-substitution needs to be performed. In libigl, you can compute approximate geodesic distances for a mesh ( V , F ) from a list of source vertex indices gamma into a vector D using this method via two steps: igl :: HeatGeodesicsData < double > data ; igl :: heat_geodesics_precompute ( V , F , data ); ... igl :: heat_geodesics_solve ( data , gamma , D ); ) ([Example 716 loads a mesh and computes approximate geodesics distances from wherever the user clicks.](images/heat-geodesic-beetle.gif) Intrinsic Delaunay Triangulation \u00b6 The original heat method for geodesic distances works well on regular, unbiased meshes: i.e., where the finite-element cotangent and mass matrices are well-behaved. For poor quality meshes, however, this method may show arbitrarily poor results. Increasing the time parameter t t can reduce this instability but but simultaneously smoothes the resulting approximate distances. Instead, one avenue of improvement is to employ the so-called intrinsic Delaunay triangulation discrete Laplace operator 48 . Since the cotangent Laplacian only depends on the edge-lengths of a triangle mesh, this new operator will be constructed by intrinsically flipping edges and recording changes to edge-lengths. Edges are flipped until every edge is locally Delaunay (i.e., its corresponding cotangent weights are positive). You can compute the intrinsic Delaunay triangulation of mesh ( V , F ) in libigl using: Eigen :: MatrixXd l ; igl :: edge_lengths ( V , F , l ); Eigen :: MatrixXd l_intrinsic ; Eigen :: MatrixXi F_intrinsic ; igl :: intrinsic_delaunay_triangulation ( l , F , l_intrinsic , F_intrinsic ); Notice that the mesh vertex positions V are not used, since this is a purely intrinsic operation. The method inputs and outputs edge-lengths and triangle indices. You may construct the intrinsic Delaunay cotangent Laplacian matrix directly using: Eigen :: SparseMatrix < double > L ; igl :: intrinsic_delaunay_cotmatrix ( V , F , L ); And finally you can compute heat geodesics using this matrix via: igl :: HeatGeodesicsData < double > data ; data . use_intrinsic_delaunay = true ; igl :: heat_geodesics_precompute ( V , F , data ); ... igl :: heat_geodesics_solve ( data , gamma , D ); Fast Winding Number For Soups And Clouds \u00b6 In 2018, Barill et al. 50 demonstrated how to significantly expediate the computation of the generalized winding numbers mentioned above. The original definition of generalized winding numbers for triangle meshes is also extended to (oriented) point clouds. Soups \u00b6 For triangle soups, the exact divide-and-conquer approach of 40 ideally scales logarithmically O(\\log{n}) O(\\log{n}) in the number of triangles. However, this method has failure modes where the computation becomes linear O(n) O(n) . This can be dramatically improved with a tree method similar to those used in n-body graviational system simulations or electrostatics problems. The result is approximate, but much more closely follows a O(\\log{n}) O(\\log{n}) trend and with much smaller constant factors. ) ([Example 717 loads a mesh, samples 1,000,000 random queries and then discards all those outside the given model.](images/bunny-fwn-soup.jpg) Computing fast winding numbers for soups has two steps: building the tree data structure and then evaluating at query points. In libigl, this is programmed as follows: igl :: FastWindingNumberBVH fwn_bvh ; igl :: fast_winding_number ( V . cast < float > (), F , 2 , fwn_bvh ); Eigen :: VectorXf W ; igl :: fast_winding_number ( fwn_bvh , 2 , Q . cast < float > (), W ); Clouds \u00b6 For point clouds, the process is similar, but more precomputation may be necessary. The winding number for point clouds is defined so long as each point comes with an outward-facing normal and an area value. Areas can be estimated by using a libigl function that computes a tangents space Voronoi diagram for each point igl::copyleft::cgal::point_areas . This function in turn relies on first computing k nearest neighbors igl::knn . And that function and the eventual winding number computation uses libigl\u2019s igl::octree as a bounding volume hierarchy. To estimate areas use for a point cloud P with normals N use: // Build octree std :: vector < std :: vector < int > > O_PI ; Eigen :: MatrixXi O_CH ; Eigen :: MatrixXd O_CN ; Eigen :: VectorXd O_W ; igl :: octree ( P , O_PI , O_CH , O_CN , O_W ); Eigen :: VectorXd A ; { Eigen :: MatrixXi I ; igl :: knn ( P , 20 , O_PI , O_CH , O_CN , O_W , I ); // CGAL is only used to help get point areas igl :: copyleft :: cgal :: point_areas ( P , I , N , A ); } Then it is possible to compute fast winding numbers for a list of queries Q : Eigen :: MatrixXd O_CM ; Eigen :: VectorXd O_R ; Eigen :: MatrixXd O_EC ; igl :: fast_winding_number ( P , N , A , O_PI , O_CH , 2 , O_CM , O_R , O_EC ); Eigen :: VectorXd W ; igl :: fast_winding_number ( P , N , A , O_PI , O_CH , O_CM , O_R , O_EC , Q , 2 , W ); Iterative Closest Point \u00b6 718_IterativeClosestPoint Entry Missing Exploded View \u00b6 719_ExplodedView Entry Missing Blue Noise Surface Sampling \u00b6 720_BlueNoise Entry Missing Vector Field Smoothing \u00b6 721_VectorFieldSmoothing Entry Missing Vector Parallel Transport \u00b6 722_VectorParallelTransport Entry Missing Outlook For Continuing Development \u00b6 Libigl is in active development, and we plan to focus on the following features in the next months: A better and more consistent documentation , plus extending this tutorial to cover more libigl features. Implement a mixed-integer solver which only uses Eigen to remove the dependency on CoMiSo. Improve the robustness and performance of the active set QP solver. In particular, handle linearly dependent constraints. Implement more mesh analysis functions, including structural analysis for masonry and 3D-printability analysis. Increase support for point clouds and general polygonal meshes. Wrangle/unify the many bounding volume hierarchies that now exist within libigl. What would you like to see in libigl? Contact us! or post a feature request . We encourage you to contribute to the library and to report problems and bugs. The best way to contribute new feature or bug fixes is to fork the libigl repository and to open a pull request on our github repository . Past Libigl Courses At Conferences \u00b6 This tutorial was originally presented by Daniele Panozzo and Alec Jacobson at SGP Graduate School 2014. It has also been presented at SGP 2017 ( video ), ACM SIGGRAPH Asia 2017, Eurographics 2019, and SGP 2020. References \u00b6 Alec Jacobson, Algorithms and Interfaces for Real-Time Deformation of 2D and 3D Shapes , 2013. \u21a9 Michael Kazhdan, Jake Solomon, Mirela Ben-Chen, Can Mean-Curvature Flow Be Made Non-Singular , 2012. \u21a9 Mark Meyer, Mathieu Desbrun, Peter Schr\u00f6der and Alan H. Barr, Discrete Differential-Geometry Operators for Triangulated 2-Manifolds , 2003. \u21a9 \u21a9 \u21a9 \u21a9 Joseph S. B. Mitchell, David M. Mount, Christos H. Papadimitriou. The Discrete Geodesic Problem , 1987 \u21a9 Daniele Panozzo, Enrico Puppo, Luigi Rocca, Efficient Multi-scale Curvature and Crease Estimation , 2010. \u21a9 Andrei Sharf, Thomas Lewiner, Gil Shklarski, Sivan Toledo, and Daniel Cohen-Or. Interactive topology-aware surface reconstruction , 2007. \u21a9 Jernej Barbic and Doug James. Real-Time Subspace Integration for St.Venant-Kirchhoff Deformable Models , 2005. \u21a9 Klaus Hildebrandt, Christian Schulz, Christoph von Tycowicz, and Konrad Polthier. Interactive Surface Modeling using Modal Analysis , 2011. \u21a9 Raid M. Rustamov, Multiscale Biharmonic Kernels , 2011. \u21a9 Bruno Vallet and Bruno L\u00e9vy. Spectral Geometry Processing with Manifold Harmonics , 2008. \u21a9 \u21a9 Mario Botsch and Leif Kobbelt. An Intuitive Framework for Real-Time Freeform Modeling , 2004. \u21a9 Isaac Chao, Ulrich Pinkall, Patrick Sanan, Peter Schr\u00f6der. A Simple Geometric Model for Elastic Deformations , 2010. \u21a9 Alec Jacobson, Ilya Baran, Jovan Popovi\u0107, and Olga Sorkine. Bounded Biharmonic Weights for Real-Time Deformation , 2011. \u21a9 \u21a9 Alec Jacobson, Ilya Baran, Ladislav Kavan, Jovan Popovi\u0107, and Olga Sorkine. Fast Automatic Skinning Transformations , 2012. \u21a9 Alec Jacobson, Elif Tosun, Olga Sorkine, and Denis Zorin. Mixed Finite Elements for Variational Surface Modeling , 2010. \u21a9 Alec Jacobson, Zhigang Deng, Ladislav Kavan, J.P. Lewis. Skinning: Real-Time Shape Deformation , 2014. \u21a9 \u21a9 Ladislav Kavan, Steven Collins, Jiri Zara, and Carol O\u2019Sullivan. Geometric Skinning with Approximate Dual Quaternion Blending , 2008. \u21a9 Binh Huy Le, J.P. Lewis. Direct delta mush skinning and variants , 2019. \u21a9 Joe Mancewicz, Matt L. Derksen, Hans Rijpkema, and Cyrus A. Wilson. Delta Mush: smoothing deformations while preserving detail , 2014. \u21a9 Alexa McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis. Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations , 2011. \u21a9 Olga Sorkine, Yaron Lipman, Daniel Cohen-Or, Marc Alexa, Christian R\u00f6ssl and Hans-Peter Seidel. Laplacian Surface Editing , 2004. \u21a9 Olga Sorkine and Marc Alexa. As-rigid-as-possible Surface Modeling , 2007. \u21a9 Yu Wang, Alec Jacobson, Jernej Barbic, Ladislav Kavan. Linear Subspace Design for Real-Time Shape Deformation , 2015 \u21a9 \u21a9 Fernando de Goes, Doug L. James. Regularized Kelvinlets: Sculpting Brushes based on Fundamental Solutions of Elasticity , 2017 \u21a9 W. S. Slaughter. The Linearized Theory of Elasticity , 2002 \u21a9 David Bommes, Henrik Zimmer, Leif Kobbelt. Mixed-integer quadrangulation , 2009. \u21a9 \u21a9 \u21a9 Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly Shape-Up: Shaping Discrete Geometry with Projections , 2012 \u21a9 \u21a9 Matthias Eck, Tony DeRose, Tom Duchamp, Hugues Hoppe, Michael Lounsbery, Werner Stuetzle. Multiresolution Analysis of Arbitrary Meshes , 2005. \u21a9 Bruno L\u00e9vy, Sylvain Petitjean, Nicolas Ray, J\u00e9rome Maillot. Least Squares Conformal Maps, for Automatic Texture Atlas Generation , 2002. \u21a9 Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno L\u00e9vy. N-Symmetry Direction Field Design , 2008. \u21a9 Ligang Liu, Lei Zhang, Yin Xu, Craig Gotsman, Steven J. Gortler. A Local/Global Approach to Mesh Parameterization , 2008. \u21a9 Patrick Mullen, Yiying Tong, Pierre Alliez, Mathieu Desbrun. Spectral Conformal Parameterization , 2008. \u21a9 Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung. Frame Fields: Anisotropic and Non-Orthogonal Cross Fields , 2014. \u21a9 Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen. Directional Field Synthesis, Design, and Processing , 2016 \u21a9 Christian Sch\u00fcller, Ladislav Kavan, Daniele Panozzo, Olga Sorkine-Hornung. Locally Injective Mappings , 2013. \u21a9 Qingnan Zhou, Eitan Grinspun, Denis Zorin. Mesh Arrangements for Solid Geometry , 2016 \u21a9 J Andreas Baerentzen and Henrik Aanaes. Signed distance computation using the angle weighted pseudonormal , 2005. \u21a9 Akash Garg, Alec Jacobson, Eitan Grinspun. Computational Design of Reconfigurables , 2016 \u21a9 Hugues Hoppe. Progressive Meshes , 1996 \u21a9 Alec Jacobson, Ladislav Kavan, and Olga Sorkine. Robust Inside-Outside Segmentation using Generalized Winding Numbers , 2013. \u21a9 \u21a9 \u21a9 Charles Loop. Smooth Subdivision Surfaces Based on Triangles , 1987. \u21a9 W.E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3d surface construction algorithm , 1987. \u21a9 \u21a9 Michael Rabinovich, Roi Poranne, Daniele Panozzo, Olga Sorkine-Hornung. Scalable Locally Injective Mappings , 2016. \u21a9 William J. Schroeder, William E. Lorensen, and Steve Linthicum. Implicit Modeling of Swept Surfaces and Volumes , 1994. \u21a9 Kenshi Takayama, Alec Jacobson, Ladislav Kavan, Olga Sorkine-Hornung. A Simple Method for Correcting Facet Orientations in Polygon Meshes Based on Ray Casting , 2014. \u21a9 G.M. Treece, R.W. Prager, and A.H.Gee Regularised marching tetrahedra: improved iso-surface extraction , 1999. \u21a9 Keenan Crane, Clarisse Weischedel, and Max Wardetzky. Geodesics in Heat: A New Approach to Computing Distance Based on Heat Flow , 2013. \u21a9 Alexander I. Bobenko and Boris A. Springborn. A discrete Laplace-Beltrami operator for simplicial surfaces , 2005. \u21a9 Zhongshi Jiang, Scott Schaefer, Daniele Panozzo. SCAF: Simplicial Complex Augmentation Framework for Bijective Maps , 2017 \u21a9 Gavin Barill, Neil G. Dickson, Ryan Schmidt, David I.W. Levin, Alec Jacobson. Fast Winding Numbers for Soups and Clouds , 2018. \u21a9 Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson. Natural Boundary Conditions for Smoothing in Geometry Processing , 2018. \u21a9","title":"Tutorial"},{"location":"tutorial/#chapter-1","text":"We introduce libigl with a series of self-contained examples. The purpose of each example is to showcase a feature of libigl while applying to a practical problem in geometry processing. In this chapter, we will present the basic concepts of libigl and introduce a simple mesh viewer that allows to visualize a surface mesh and its attributes. All the tutorial examples are cross-platform and can be compiled on MacOSX, Linux and Windows.","title":"Chapter 1"},{"location":"tutorial/#libigl-design-principles","text":"Before getting into the examples, we summarize the main design principles in libigl: No complex data types. We mostly use matrices and vectors. This greatly favors code reusability and forces the function authors to expose all the parameters used by the algorithm. Minimal dependencies. We use external libraries only when necessary and we wrap them in a small set of functions. Header-only. It is straight forward to use our library since it is only one additional include directory in your project. (if you are worried about compilation speed, it is also possible to build the library as a static library ) Function encapsulation. Every function (including its full implementation) is contained in a pair of .h/.cpp files with the same name of the function.","title":"Libigl Design Principles"},{"location":"tutorial/#downloading-libigl","text":"libigl can be downloaded from our github repository or cloned with git: git clone https://github.com/libigl/libigl.git The core libigl functionality only depends on the C++ Standard Library and Eigen. Optional dependencies will be downloaded upon issuing cmake , below. To build all the examples in the tutorial (and tests), you can use the CMakeLists.txt in the root folder: cd libigl/ mkdir build cd build cmake ../ make Note about CGAL The optional dependency CGAL has been notoriously difficult to setup (as it also depends on boost/gmp/mpfr). By default, it will only be enabled on Linux/macOS if GMP and MPFR are installed system-wide. On Windows, all its dependencies will be downloaded by CMake, thus requiring no setup on your part. The examples can also be built independently using the CMakeLists.txt inside each example folder. Note for linux users Many linux distributions do not include gcc and the basic development tools in their default installation. On Ubuntu, you need to install the following packages: sudo apt-get install \\ git \\ build-essential \\ cmake \\ libx11-dev \\ mesa-common-dev libgl1-mesa-dev libglu1-mesa-dev \\ libxrandr-dev \\ libxi-dev \\ libxmu-dev \\ libblas-dev \\ libxinerama-dev \\ libxcursor-dev Note for Windows users libigl only supports the Microsoft Visual Studio 2015 compiler and later, in 64bit mode. It will not work with a 32bit build and it will not work with older versions of visual studio. A few examples in Chapter 5 requires the CoMiSo solver . We provide a mirror of CoMISo that works out of the box with libigl. A copy will be downloaded automatically by CMake the first time you build the libigl root project. You can build the tutorials as usual and libigl will automatically find and compile CoMISo. Note 1 : CoMISo is distributed under the GPL3 license, it does impose restrictions on commercial usage. Note 2 : CoMISo requires a blas implementation. We use the built-in blas in macosx and linux, and we bundle a precompiled binary for VS2015 64 bit. Do NOT compile the tutorials in 32 bit on windows. Libigl Example Project We provide a blank project example showing how to use libigl and CMake. This is the recommended way of using libigl in your project . Feel free and encouraged to use this repository as a template to start a new personal project using libigl.","title":"Downloading Libigl"},{"location":"tutorial/#mesh-representation","text":"libigl uses the Eigen library to encode vector and matrices. We suggest that you keep the dense and sparse quick reference guides at hand while you read the examples in this tutorial. A triangular mesh is encoded as a pair of matrices: Eigen :: MatrixXd V ; Eigen :: MatrixXi F ; V is a #N by 3 matrix which stores the coordinates of the vertices. Each row stores the coordinate of a vertex, with its x,y and z coordinates in the first, second and third column, respectively. The matrix F stores the triangle connectivity: each line of F denotes a triangle whose 3 vertices are represented as indices pointing to rows of V . A simple mesh made of 2 triangles and 4 vertices. Note that the order of the vertex indices in F determines the orientation of the triangles and it should thus be consistent for the entire surface. This simple representation has many advantages: it is memory efficient and cache friendly the use of indices instead of pointers greatly simplifies debugging the data can be trivially copied and serialized libigl provides input [output] functions to read [write] many common mesh formats. The IO functions are contained in the files read*.h and write*.h. As a general rule each libigl function is contained in a pair of .h/.cpp files with the same name. By default, the .h files include the corresponding cpp files, making the library header-only. Reading a mesh from a file requires a single libigl function call: igl :: readOFF ( TUTORIAL_SHARED_PATH \"/cube.off\" , V , F ); The function reads the mesh cube.off and it fills the provided V and F matrices. Similarly, a mesh can be written in an OBJ file using: igl :: writeOBJ ( \"cube.obj\" , V , F ); Example 101 contains a simple mesh converter from OFF to OBJ format.","title":"Mesh Representation"},{"location":"tutorial/#visualizing-surfaces","text":"Libigl provides an glfw-based OpenGL 3.2 viewer to visualize surfaces, their properties and additional debugging information. The following code ( Example 102 ) is a basic skeleton for all the examples that will be used in the tutorial. It is a standalone application that loads a mesh and uses the viewer to render it. #include <igl/readOFF.h> #include <igl/opengl/glfw/Viewer.h> Eigen :: MatrixXd V ; Eigen :: MatrixXi F ; int main ( int argc , char * argv []) { // Load a mesh in OFF format igl :: readOFF ( TUTORIAL_SHARED_PATH \"/bunny.off\" , V , F ); // Plot the mesh igl :: opengl :: glfw :: Viewer viewer ; viewer . data (). set_mesh ( V , F ); viewer . launch (); } The function set_mesh copies the mesh into the viewer. Viewer.launch() creates a window, an OpenGL context and it starts the draw loop. The default camera motion mode is 2-axis ( ROTATION_TYPE_TWO_AXIS_VALUATOR_FIXED_UP ), which can be changed to 3-axis trackball style by adding this line: viewer.core().set_rotation_type(igl::opengl::ViewerCore::ROTATION_TYPE_TRACKBALL); Additional properties can be plotted on the mesh (as we will see later), and it is possible to extend the viewer with standard OpenGL code. Please see the documentation in Viewer.h for more details. ( Example 102 ) loads and draws a mesh.","title":"Visualizing Surfaces"},{"location":"tutorial/#interaction-with-keyboard-and-mouse","text":"Keyboard and mouse events triggers callbacks that can be registered in the viewer. The viewer supports the following callbacks: bool ( * callback_pre_draw )( Viewer & viewer ); bool ( * callback_post_draw )( Viewer & viewer ); bool ( * callback_mouse_down )( Viewer & viewer , int button , int modifier ); bool ( * callback_mouse_up )( Viewer & viewer , int button , int modifier ); bool ( * callback_mouse_move )( Viewer & viewer , int mouse_x , int mouse_y ); bool ( * callback_mouse_scroll )( Viewer & viewer , float delta_y ); bool ( * callback_key_down )( Viewer & viewer , unsigned char key , int modifiers ); bool ( * callback_key_up )( Viewer & viewer , unsigned char key , int modifiers ); A keyboard callback can be used to visualize multiple meshes or different stages of an algorithm, as demonstrated in Example 103 , where the keyboard callback changes the visualized mesh depending on the key pressed: bool key_down ( igl :: opengl :: glfw :: Viewer & viewer , unsigned char key , int modifier ) { if ( key == '1' ) { viewer . data (). clear (); viewer . data (). set_mesh ( V1 , F1 ); viewer . core . align_camera_center ( V1 , F1 ); } else if ( key == '2' ) { viewer . data (). clear (); viewer . data (). set_mesh ( V2 , F2 ); viewer . core . align_camera_center ( V2 , F2 ); } return false ; } The callback is registered in the viewer as follows: viewer . callback_key_down = & key_down ; Note that the mesh is cleared before using set_mesh. This has to be called every time the number of vertices or faces of the plotted mesh changes. Every callback returns a boolean value that tells the viewer if the event has been handled by the plugin, or if the viewer should process it normally. This is useful, for example, to disable the default mouse event handling if you want to control the camera directly in your code. The viewer can be extended using plugins, which are classes that implements all the viewer\u2019s callbacks. See the Viewer_plugin for more details.","title":"Interaction With Keyboard And Mouse"},{"location":"tutorial/#scalar-field-visualization","text":"Colors can be associated to faces or vertices using the set_colors function: viewer . data (). set_colors ( C ); C is a #C by 3 matrix with one RGB color per row. C must have as many rows as the number of faces or the number of vertices of the mesh. Depending on the size of C , the viewer applies the color to the faces or to the vertices. In Example 104, the colors of mesh vertices are set according to their Cartesian coordinates. ( Example 104 ) Set the colors of a mesh. Per-Vertex scalar fields can be directly visualized using set_data function: viewer . data (). set_data ( D ); D is a #V by 1 vector with one value corresponding to each vertex. set_data will color according to linearly interpolating the data within a triangle (in the fragment shader ) and use this interpolated data to look up a color in a colormap (stored as a texture). The colormap defaults to igl::COLOR_MAP_TYPE_VIRIDIS with 21 discrete intervals. A custom colormap may be set with set_colormap .","title":"Scalar Field Visualization"},{"location":"tutorial/#overlays","text":"In addition to plotting the surface, the viewer supports the visualization of points, lines and text labels: these overlays can be very helpful while developing geometric processing algorithms to plot debug information. viewer . data (). add_points ( P , Eigen :: RowVector3d ( r , g , b )); Draws a point of color r,g,b for each row of P. The point is placed at the coordinates specified in each row of P, which is a #P by 3 matrix. Size of the points (in pixels) can be changed globally by setting viewer.data().point_size . viewer . data (). add_edges ( P1 , P2 , Eigen :: RowVector3d ( r , g , b )); Draws a line of color r,g,b for each row of P1 and P2, which connects the 3D point in to the point in P2. Both P1 and P2 are of size #P by 3. viewer . data (). add_label ( p , str ); Draws a label containing the string str at the position p, which is a vector of length 3. These functions are demonstrate in Example 105 where the bounding box of a mesh is plotted using lines and points. Using matrices to encode the mesh and its attributes allows to write short and efficient code for many operations, avoiding to write for loops. For example, the bounding box of a mesh can be found by taking the colwise maximum and minimum of V : Eigen :: Vector3d m = V . colwise (). minCoeff (); Eigen :: Vector3d M = V . colwise (). maxCoeff (); ( Example 105 ) The bounding box of a mesh is shown using overlays.","title":"Overlays"},{"location":"tutorial/#viewer-menu","text":"As of latest version, the viewer uses a new menu and completely replaces AntTweakBar and nanogui with Dear ImGui . To extend the default menu of the viewer and to expose more user defined variables you have to implement a custom interface, as in Example 106 : // Add content to the default menu window menu . callback_draw_viewer_menu = [ & ]() { // Draw parent menu content menu . draw_viewer_menu (); // Add new group if ( ImGui :: CollapsingHeader ( \"New Group\" , ImGuiTreeNodeFlags_DefaultOpen )) { // Expose variable directly ... ImGui :: InputFloat ( \"float\" , & floatVariable , 0 , 0 , 3 ); // ... or using a custom callback static bool boolVariable = true ; if ( ImGui :: Checkbox ( \"bool\" , & boolVariable )) { // do something std :: cout << \"boolVariable: \" << std :: boolalpha << boolVariable << std :: endl ; } // Expose an enumeration type enum Orientation { Up = 0 , Down , Left , Right }; static Orientation dir = Up ; ImGui :: Combo ( \"Direction\" , ( int * )( & dir ), \"Up \\0 Down \\0 Left \\0 Right \\0\\0 \" ); // We can also use a std::vector<std::string> defined dynamically static int num_choices = 3 ; static std :: vector < std :: string > choices ; static int idx_choice = 0 ; if ( ImGui :: InputInt ( \"Num letters\" , & num_choices )) { num_choices = std :: max ( 1 , std :: min ( 26 , num_choices )); } if ( num_choices != ( int ) choices . size ()) { choices . resize ( num_choices ); for ( int i = 0 ; i < num_choices ; ++ i ) choices [ i ] = std :: string ( 1 , 'A' + i ); if ( idx_choice >= num_choices ) idx_choice = num_choices - 1 ; } ImGui :: Combo ( \"Letter\" , & idx_choice , choices ); // Add a button if ( ImGui :: Button ( \"Print Hello\" , ImVec2 ( -1 , 0 ))) { std :: cout << \"Hello \\n \" ; } } }; If you need a separate new menu window implement: // Draw additional windows menu . callback_draw_custom_window = [ & ]() { // Define next window position + size ImGui :: SetNextWindowPos ( ImVec2 ( 180.f * menu . menu_scaling (), 10 ), ImGuiSetCond_FirstUseEver ); ImGui :: SetNextWindowSize ( ImVec2 ( 200 , 160 ), ImGuiSetCond_FirstUseEver ); ImGui :: Begin ( \"New Window\" , nullptr , ImGuiWindowFlags_NoSavedSettings ); // Expose the same variable directly ... ImGui :: PushItemWidth ( -80 ); ImGui :: DragFloat ( \"float\" , & floatVariable , 0.0 , 0.0 , 3.0 ); ImGui :: PopItemWidth (); static std :: string str = \"bunny\" ; ImGui :: InputText ( \"Name\" , str ); ImGui :: End (); }; ( Example 106 ) The UI of the viewer can be easily customized.","title":"Viewer Menu"},{"location":"tutorial/#multiple-meshes","text":"Libigl\u2019s igl::opengl::glfw::Viewer provides basic support for rendering multiple meshes. Which mesh is selected is controlled via the viewer.selected_data_index field. By default the index is set to 0 , so in the typical case of a single mesh viewer.data() returns the igl::ViewerData corresponding to the one and only mesh. ( Example 107 ) The igl::opengl::glfw::Viewer can render multiple meshes, each with its own attributes like colors.","title":"Multiple Meshes"},{"location":"tutorial/#multiple-views","text":"Libigl\u2019s igl::opengl::glfw::Viewer provides basic support for rendering meshes with multiple views. A new view core can be added to the viewer using the Viewer::append_core() method. There can be a maximum of 31 cores created through the life of any viewer. Each core is assigned an unsigned int id that is guaranteed to be unique. A core can be accessed by its id calling the Viewer::core(id) method. When there are more than one view core, the user is responsible for specifying each viewport\u2019s size and position by setting their viewport attribute. The user must also indicates how to resize each viewport when the size of the window changes. For example: viewer . callback_post_resize = [ & ]( igl :: opengl :: glfw :: Viewer & v , int w , int h ) { v . core ( left_view ). viewport = Eigen :: Vector4f ( 0 , 0 , w / 2 , h ); v . core ( right_view ). viewport = Eigen :: Vector4f ( w / 2 , 0 , w - ( w / 2 ), h ); return true ; }; Note that the viewport currently hovered by the mouse can be selected using the Viewer::selected_core_index() method, and the selected view core can then be accessed by calling viewer.core_list[viewer.selected_core_index] . Finally, the visibility of a mesh on a given view core is controlled by a bitmask flag per mesh. This property can be easily controlled by calling the method viewer . data ( mesh_id ). set_visible ( false , view_id ); When appending a new mesh or a new view core, an optional argument controls the visibility of the existing objects with respect to the new mesh/view. Please refer to the documentation of Viewer::append_mesh() and Viewer::append_core() for more details. ( Example 108 ) The igl::opengl::glfw::Viewer can render the same scene using multiple views, each with its own attributes like colors, and individual mesh visibility.","title":"Multiple Views"},{"location":"tutorial/#viewer-guizmos","text":"Bug It is currently not possible to have more than one ImGui-related viewer plugin active at the same time (that includes ImGuiMenu , ImGuizmoPlugin and SelectionPlugin ). Please follow #1656 for more information. The viewer integrates with ImGuizmo to provide widgets for manipulating a mesh. Mesh manipulations consist of translations, rotations, and scaling, where W,w , E,e , and R,r can be used to toggle between them, respectively. First, register the ImGuizmoPlugin plugin with the Viewer: #include <igl/opengl/glfw/imgui/ImGuizmoPlugin.h> // ImGuizmoPlugin replaces the ImGuiMenu plugin entirely igl :: opengl :: glfw :: imgui :: ImGuizmoPlugin plugin ; vr . plugins . push_back ( & plugin ); On initialization, ImGuizmo must be provided with the mesh centroid, as shown in Example 109 : // Initialize ImGuizmo at mesh centroid plugin . T . block ( 0 , 3 , 3 , 1 ) = 0.5 * ( V . colwise (). maxCoeff () + V . colwise (). minCoeff ()). transpose (). cast < float > (); To apply the mesh manipulations invoked by the guizmos, the resulting transformation matrix is computed and applied to the input geometric data explicitly through the viewer\u2019s API: // Update can be applied relative to this remembered initial transform const Eigen :: Matrix4f T0 = plugin . T ; // Attach callback to apply imguizmo's transform to mesh plugin . callback = [ & ]( const Eigen :: Matrix4f & T ) { const Eigen :: Matrix4d TT = ( T * T0 . inverse ()). cast < double > (). transpose (); vr . data (). set_vertices ( ( V . rowwise (). homogeneous () * TT ). rowwise (). hnormalized ()); vr . data (). compute_normals (); }; ([Example 109](https://github.com/libigl/libigl/tree/main/tutorial/109_ImGuizmo/main.cpp)) The Libigl Viewer integrates with ImGuizmo to provide transformation widgets.","title":"Viewer Guizmos"},{"location":"tutorial/#msh-viewer","text":"Libigl can read mixed meshes stored in Gmsh .msh version 2 file format. These files can contain mixture of different meshes, as well as additional scalar and vector fields defined on element level and vertex level. Eigen :: MatrixXd X ; // Vertex coorinates (Xx3) Eigen :: MatrixXi Tri ; // Triangular elements (Yx3) Eigen :: MatrixXi Tet ; // Tetrahedral elements (Zx4) Eigen :: VectorXi TriTag ; // Integer tags defining triangular submeshes Eigen :: VectorXi TetTag ; // Integer tags defining tetrahedral submeshes std :: vector < std :: string > XFields ; // headers (names) of fields defined on vertex level std :: vector < std :: string > EFields ; // headers (names) of fields defined on element level std :: vector < Eigen :: MatrixXd > XF ; // fields defined on vertex std :: vector < Eigen :: MatrixXd > TriF ; // fields defined on triangular elements std :: vector < Eigen :: MatrixXd > TetF ; // fields defined on tetrahedral elements // loading mixed mesh from Gmsh file igl :: readMSH ( \"hand.msh\" , X , Tri , Tet , TriTag , TetTag , XFields , XF , EFields , TriF , TetF ); The interactive viewer is unable to directly draw tetrahedra though. So for visualization purposes each tetrahedron can be converted to four triangles. ( Example 110 ) Shows a slice of tetrahedral mesh with scalar field defined on element level","title":"Msh Viewer"},{"location":"tutorial/#matcaps","text":"MatCaps (material captures), also known as environment maps, are a simple image-based rendering technique to achieve complex lighting without a complex shader program. Using offline rendering or even a painting program, an image of a rendered unit sphere is created, such as this image of a sphere with a jade material viewed under studio lighting : The position \\mathbf{p} \\mathbf{p} of each point on the sphere is also its unit normal vector \\hat{\\mathbf{n}} = \\mathbf{p} \\hat{\\mathbf{n}} = \\mathbf{p} . The idea of matcaps is to use this image of the sphere as a lookup table keyed on an input normal value and outputting the rgb color: I(\\hat{\\mathbf{n}}) \\rightarrow (r,g,b) I(\\hat{\\mathbf{n}}) \\rightarrow (r,g,b) . When rendering a non-spherical shape, in the fragment shader we compute the normal vector \\hat{\\mathbf{n}} \\hat{\\mathbf{n}} and then use its x- x- and y- y- components as texture coordinates to look up the corresponding point in the matcap image. In this way, there is no lighting model or lighting computation done in the fragment shader, it is simply a texture lookup, but rather than requiring a UV-mapping (parameterization) of the model, we use the per-fragment normals. By using the normal relative to the camera\u2019s coordinate system we get view dependent complex lighting \u201cfor free\u201d: Example 111 demonstrates using a jade matcap to add complex lighting to the libigl viewer. In libigl, if the rgba data for a matcap image is stored in R , G , B , and A (as output, e.g., by igl::png::readPNG ) then this can be attached to the igl::opengl::ViewerData by setting it as the texture data and then turning on matcap rendering: viewer . data (). set_texture ( R , G , B , A ); viewer . data (). use_matcap = true ;","title":"MatCaps"},{"location":"tutorial/#chapter-2-discrete-geometric-quantities-and-operators","text":"This chapter illustrates a few discrete quantities that libigl can compute on a mesh and the libigl functions that construct popular discrete differential geometry operators. It also provides an introduction to basic drawing and coloring routines of our viewer.","title":"Chapter 2: Discrete Geometric Quantities And Operators"},{"location":"tutorial/#normals","text":"Surface normals are a basic quantity necessary for rendering a surface. There are a variety of ways to compute and store normals on a triangle mesh. Example 201 demonstrates how to compute and visualize normals with libigl.","title":"Normals"},{"location":"tutorial/#per-face","text":"Normals are well defined on each triangle of a mesh as the vector orthogonal to triangle\u2019s plane. These piecewise-constant normals produce piecewise-flat renderings: the surface appears non-smooth and reveals its underlying discretization.","title":"Per-face"},{"location":"tutorial/#per-vertex","text":"Normals can be computed and stored on vertices, and interpolated in the interior of the triangles to produce smooth renderings ( Phong shading ). Most techniques for computing per-vertex normals take an average of incident face normals. The main difference between these techniques is their weighting scheme: Uniform weighting is heavily biased by the discretization choice, whereas area-based or angle-based weighting is more forgiving. The typical half-edge style computation of area-based weights has this structure: N . setZero ( V . rows (), 3 ); for ( int i : vertices ) { for ( face : incident_faces ( i )) { N . row ( i ) += face . area * face . normal ; } } N . rowwise (). normalize (); At first glance, it might seem inefficient to loop over incident faces\u2014and thus constructing the per-vertex normals\u2014 without using an half-edge data structure. However, per-vertex normals may be throwing each face normal to running sums on its corner vertices: N . setZero ( V . rows (), 3 ); for ( int f = 0 ; f < F . rows (); f ++ ) { for ( int c = 0 ; c < 3 ; c ++ ) { N . row ( F ( f , c )) += area ( f ) * face_normal . row ( f ); } } N . rowwise (). normalize ();","title":"Per-vertex"},{"location":"tutorial/#per-corner","text":"Storing normals per-corner is an efficient and convenient way of supporting both smooth and sharp (e.g. creases and corners) rendering. This format is common to OpenGL and the .obj mesh file format. Often such normals are tuned by the mesh designer, but creases and corners can also be computed automatically. Libigl implements a simple scheme which computes corner normals as averages of normals of faces incident on the corresponding vertex which do not deviate by more than a specified dihedral angle (e.g. 20\u00b0). The Normals example computes per-face (left), per-vertex (middle) and per-corner (right) normals","title":"Per-corner"},{"location":"tutorial/#gaussian-curvature","text":"Gaussian curvature on a continuous surface is defined as the product of the principal curvatures: k_G = k_1 k_2. k_G = k_1 k_2. As an intrinsic measure, it depends on the metric and not the surface\u2019s embedding. Intuitively, Gaussian curvature tells how locally spherical or elliptic the surface is ( k_G>0 k_G>0 ), how locally saddle-shaped or hyperbolic the surface is ( k_G<0 k_G<0 ), or how locally cylindrical or parabolic ( k_G=0 k_G=0 ) the surface is. In the discrete setting, one definition for a \u201cdiscrete Gaussian curvature\u201d on a triangle mesh is via a vertex\u2019s angular deficit : k_G(v_i) = 2\u03c0 - \\sum\\limits_{j\\in N(i)}\u03b8_{ij}, k_G(v_i) = 2\u03c0 - \\sum\\limits_{j\\in N(i)}\u03b8_{ij}, where N(i) N(i) are the triangles incident on vertex i i and \u03b8_{ij} \u03b8_{ij} is the angle at vertex i i in triangle j j 3 . Just like the continuous analog, our discrete Gaussian curvature reveals elliptic, hyperbolic and parabolic vertices on the domain, as demonstrated in Example 202 . The GaussianCurvature example computes discrete Gaussian curvature and visualizes it in pseudocolor.","title":"Gaussian Curvature"},{"location":"tutorial/#curvature-directions","text":"The two principal curvatures (k_1,k_2) (k_1,k_2) at a point on a surface measure how much the surface bends in different directions. The directions of maximum and minimum (signed) bending are called principal directions and are always orthogonal. Mean curvature is defined as the average of principal curvatures: H = \\frac{1}{2}(k_1 + k_2). H = \\frac{1}{2}(k_1 + k_2). One way to extract mean curvature is by examining the Laplace-Beltrami operator applied to the surface positions. The result is a so-called mean-curvature normal: -\\Delta \\mathbf{x} = H \\mathbf{n}. -\\Delta \\mathbf{x} = H \\mathbf{n}. It is easy to compute this on a discrete triangle mesh in libigl using the cotangent Laplace-Beltrami operator 3 . #include <igl/cotmatrix.h> #include <igl/massmatrix.h> #include <igl/invert_diag.h> ... MatrixXd HN ; SparseMatrix < double > L , M , Minv ; igl :: cotmatrix ( V , F , L ); igl :: massmatrix ( V , F , igl :: MASSMATRIX_TYPE_VORONOI , M ); igl :: invert_diag ( M , Minv ); HN = - Minv * ( L * V ); H = HN . rowwise (). norm (); //up to sign Combined with the angle defect definition of discrete Gaussian curvature, one can define principal curvatures and use least squares fitting to find directions 3 . Alternatively, a robust method for determining principal curvatures is via quadric fitting 5 . In the neighborhood around every vertex, a best-fit quadric is found and principal curvature values and directions are analytically computed on this quadric ( Example 203 ). The CurvatureDirections example computes principal curvatures via quadric fitting and visualizes mean curvature in pseudocolor and principal directions with a cross field.","title":"Curvature Directions"},{"location":"tutorial/#gradient","text":"Scalar functions on a surface can be discretized as a piecewise linear function with values defined at each mesh vertex: f(\\mathbf{x}) \\approx \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i, f(\\mathbf{x}) \\approx \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i, where \\phi_i \\phi_i is a piecewise linear hat function defined by the mesh so that for each triangle \\phi_i \\phi_i is the linear function which is one only at vertex i i and zero at the other corners. Hat function \\phi_i \\phi_i is one at vertex i i , zero at all other vertices, and linear on incident triangles. Thus gradients of such piecewise linear functions are simply sums of gradients of the hat functions: \\nabla f(\\mathbf{x}) \\approx \\nabla \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i = \\sum\\limits_{i=1}^n \\nabla \\phi_i(\\mathbf{x})\\, f_i. \\nabla f(\\mathbf{x}) \\approx \\nabla \\sum\\limits_{i=1}^n \\phi_i(\\mathbf{x})\\, f_i = \\sum\\limits_{i=1}^n \\nabla \\phi_i(\\mathbf{x})\\, f_i. This reveals that the gradient is a linear function of the vector of f_i f_i values. Because the \\phi_i \\phi_i are linear in each triangle, their gradients are constant in each triangle. Thus our discrete gradient operator can be written as a matrix multiplication taking vertex values to triangle values: \\nabla f \\approx \\mathbf{G}\\,\\mathbf{f}, \\nabla f \\approx \\mathbf{G}\\,\\mathbf{f}, where \\mathbf{f} \\mathbf{f} is n\\times 1 n\\times 1 and \\mathbf{G} \\mathbf{G} is an md\\times n md\\times n sparse matrix. This matrix \\mathbf{G} \\mathbf{G} can be derived geometrically, e.g. ch. 2 1 . Libigl\u2019s grad function computes \\mathbf{G} \\mathbf{G} for triangle and tetrahedral meshes ( Example 204 ): The Gradient example computes gradients of an input function on a mesh and visualizes the vector field.","title":"Gradient"},{"location":"tutorial/#laplacian","text":"The discrete Laplacian is an essential geometry processing tool. Many interpretations and flavors of the Laplace and Laplace-Beltrami operator exist. In open Euclidean space, the Laplace operator is the usual divergence of gradient (or equivalently the Laplacian of a function is the trace of its Hessian): \\Delta f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}. \\Delta f = \\frac{\\partial^2 f}{\\partial x^2} + \\frac{\\partial^2 f}{\\partial y^2} + \\frac{\\partial^2 f}{\\partial z^2}. The Laplace-Beltrami operator generalizes this to surfaces. When considering piecewise-linear functions on a triangle mesh, a discrete Laplacian may be derived in a variety of ways. The most popular in geometry processing is the so-called ``cotangent Laplacian\u2019\u2019 \\mathbf{L} \\mathbf{L} , arising simultaneously from FEM, DEC and applying divergence theorem to vertex one-rings. As a linear operator taking vertex values to vertex values, the Laplacian \\mathbf{L} \\mathbf{L} is a n\\times n n\\times n matrix with elements: L_{ij} = \\begin{cases}j \\in N(i) &\\cot \\alpha_{ij} + \\cot \\beta_{ij},\\\\ j \\notin N(i) & 0,\\\\ i = j & -\\sum\\limits_{k\\neq i} L_{ik}, \\end{cases} L_{ij} = \\begin{cases}j \\in N(i) &\\cot \\alpha_{ij} + \\cot \\beta_{ij},\\\\ j \\notin N(i) & 0,\\\\ i = j & -\\sum\\limits_{k\\neq i} L_{ik}, \\end{cases} where N(i) N(i) are the vertices adjacent to (neighboring) vertex i i , and \\alpha_{ij},\\beta_{ij} \\alpha_{ij},\\beta_{ij} are the angles opposite to edge {ij} {ij} . This formula leads to a typical half-edge style implementation for constructing \\mathbf{L} \\mathbf{L} : for ( int i : vertices ) { for ( int j : one_ring ( i )) { for ( int k : triangle_on_edge ( i , j )) { L ( i , j ) += cot ( angle ( i , j , k )); L ( i , i ) -= cot ( angle ( i , j , k )); } } } Similarly as before, it may seem to loop over one-rings without having an half-edge data structure. However, this is not the case, since the Laplacian may be built by summing together contributions for each triangle, much in spirit with its FEM discretization of the Dirichlet energy (sum of squared gradients): for ( triangle t : triangles ) { for ( edge i , j : t ) { L ( i , j ) += cot ( angle ( i , j , k )); L ( j , i ) += cot ( angle ( i , j , k )); L ( i , i ) -= cot ( angle ( i , j , k )); L ( j , j ) -= cot ( angle ( i , j , k )); } } Libigl implements discrete \u201ccotangent\u201d Laplacians for triangles meshes and tetrahedral meshes, building both with fast geometric rules rather than \u201cby the book\u201d FEM construction which involves many (small) matrix inversions, cf. 6 . The operator applied to mesh vertex positions amounts to smoothing by flowing the surface along the mean curvature normal direction ( Example 205 ). Note that this is equivalent to minimizing surface area. The Laplacian example computes conformalized mean curvature flow using the cotangent Laplacian 2 .","title":"Laplacian"},{"location":"tutorial/#mass-matrix","text":"The mass matrix \\mathbf{M} \\mathbf{M} is another n \\times n n \\times n matrix which takes vertex values to vertex values. From an FEM point of view, it is a discretization of the inner-product: it accounts for the area around each vertex. Consequently, \\mathbf{M} \\mathbf{M} is often a diagonal matrix, such that M_{ii} M_{ii} is the barycentric or voronoi area around vertex i i in the mesh 3 . The inverse of this matrix is also very useful as it transforms integrated quantities into point-wise quantities, e.g.: \\Delta f \\approx \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f}. \\Delta f \\approx \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f}. In general, when encountering squared quantities integrated over the surface, the mass matrix will be used as the discretization of the inner product when sampling function values at vertices: \\int_S x\\, y\\ dA \\approx \\mathbf{x}^T\\mathbf{M}\\,\\mathbf{y}. \\int_S x\\, y\\ dA \\approx \\mathbf{x}^T\\mathbf{M}\\,\\mathbf{y}. An alternative mass matrix \\mathbf{T} \\mathbf{T} is a md \\times md md \\times md matrix which takes triangle vector values to triangle vector values. This matrix represents an inner-product accounting for the area associated with each triangle (i.e. the triangles true area).","title":"Mass Matrix"},{"location":"tutorial/#alternative-construction-of-laplacian","text":"An alternative construction of the discrete cotangent Laplacian is by \u201csquaring\u201d the discrete gradient operator. This may be derived by applying Green\u2019s identity (ignoring boundary conditions for the moment): \\int_S \\|\\nabla f\\|^2 dA = \\int_S f \\Delta f dA \\int_S \\|\\nabla f\\|^2 dA = \\int_S f \\Delta f dA Or in matrix form which is immediately translatable to code: \\mathbf{f}^T \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{f} = \\mathbf{f}^T \\mathbf{M} \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f} = \\mathbf{f}^T \\mathbf{L} \\mathbf{f}. \\mathbf{f}^T \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{f} = \\mathbf{f}^T \\mathbf{M} \\mathbf{M}^{-1} \\mathbf{L} \\mathbf{f} = \\mathbf{f}^T \\mathbf{L} \\mathbf{f}. So we have that \\mathbf{L} = \\mathbf{G}^T \\mathbf{T} \\mathbf{G} \\mathbf{L} = \\mathbf{G}^T \\mathbf{T} \\mathbf{G} . This also hints that we may consider \\mathbf{G}^T \\mathbf{G}^T as a discrete divergence operator, since the Laplacian is the divergence of the gradient. Naturally, \\mathbf{G}^T \\mathbf{G}^T is a n \\times md n \\times md sparse matrix which takes vector values stored at triangle faces to scalar divergence values at vertices.","title":"Alternative Construction Of Laplacian"},{"location":"tutorial/#exact-discrete-geodesic-distances","text":"The discrete geodesic distance between two points is the length of the shortest path between then restricted to the surface. For triangle meshes, such a path is made of a set of segments which can be either edges of the mesh or crossing a triangle. Libigl includes a wrapper for the exact geodesic algorithm 4 developed by Danil Kirsanov ( https://code.google.com/archive/p/geodesic/ ), exposing it through an Eigen-based API. The function igl :: exact_geodesic ( V , F , VS , FS , VT , FT , d ); computes the closest geodesic distances of each vertex in VT or face in FT, from the source vertices VS or faces FS of the input mesh V,F. The output is written in the vector d, which lists first the distances for the vertices in VT, and then for the faces in FT. For example, if you want to compute the distance from the vertex with id vid , to all vertices of F you can use: Eigen :: VectorXi VS , FS , VT , FT ; // The selected vertex is the source VS . resize ( 1 ); VS << vid ; // All vertices are the targets VT . setLinSpaced ( V . rows (), 0 , V . rows () -1 ); Eigen :: VectorXd d ; igl :: exact_geodesic ( V , F , VS , FS , VT , FT , d ); [Example 206 allows to interactively pick the source vertex and displays the distance using a periodic color pattern.](images/geodesicdistance.jpg)","title":"Exact Discrete Geodesic Distances"},{"location":"tutorial/#chapter-3-matrices-and-linear-algebra","text":"Libigl relies heavily on the Eigen library for dense and sparse linear algebra routines. Besides geometry processing routines, libigl has linear algebra routines which bootstrap Eigen and make it feel even more similar to a high-level algebra library such as Matlab.","title":"Chapter 3: Matrices And Linear Algebra"},{"location":"tutorial/#slice","text":"A very familiar and powerful routine in Matlab is array slicing. This allows reading from or writing to a possibly non-contiguous sub-matrix. Let\u2019s consider the Matlab code: B = A ( R , C ); If A is a m \\times n m \\times n matrix and R is a j j -long list of row-indices (between 1 and m m ) and C is a k k -long list of column-indices, then as a result B will be a j \\times k j \\times k matrix drawing elements from A according to R and C . In libigl, the same functionality is provided by the slice function ( Example 301 ): VectorXi R , C ; MatrixXd A , B ; ... igl :: slice ( A , R , C , B ); Note that A and B could also be sparse matrices. Similarly, consider the Matlab code: A ( R , C ) = B ; Now, the selection is on the left-hand side so the j \\times k j \\times k matrix B is being written into the submatrix of A determined by R and C . This functionality is provided in libigl using slice_into : igl :: slice_into ( B , R , C , A ); The example Slice shows how to use igl::slice to change the colors for triangles on a mesh.","title":"Slice"},{"location":"tutorial/#sort","text":"Matlab and other higher-level languages make it very easy to extract indices of sorting and comparison routines. For example in Matlab, one can write: [ Y , I ] = sort ( X , 1 , 'ascend' ); so if X is a m \\times n m \\times n matrix then Y will also be an m \\times n m \\times n matrix with entries sorted along dimension 1 in 'ascend' ing order. The second output I is a m \\times n m \\times n matrix of indices such that Y(i,j) = X(I(i,j),j); . That is, I reveals how X is sorted into Y . This same functionality is supported in libigl: igl :: sort ( X , 1 , true , Y , I ); Similarly, sorting entire rows can be accomplished in Matlab using: [ Y , I ] = sortrows ( X , 'ascend' ); where now I is a m m vector of indices such that Y = X(I,:) . In libigl, this is supported with igl :: sortrows ( X , true , Y , I ); where again I reveals the index of sort so that it can be reproduced with igl::slice(X,I,1,Y) . Analogous functions are available in libigl for: max , min , and unique . The example Sort shows how to use igl::sortrows to pseudocolor triangles according to their barycenters\u2019 sorted order ( Example 302 ).","title":"Sort"},{"location":"tutorial/#other-matlab-style-functions","text":"Libigl implements a variety of other routines with the same api and functionality as common Matlab functions. Name Description igl::all Whether all elements are non-zero (true) igl::any Whether any elements are non-zero (true) igl::cat Concatenate two matrices (especially useful for dealing with Eigen sparse matrices) igl::ceil Round entries up to nearest integer igl::cumsum Cumulative sum of matrix elements igl::colon Act like Matlab\u2019s : , similar to Eigen\u2019s LinSpaced igl::components Connected components of graph (cf. Matlab\u2019s graphconncomp ) igl::count Count non-zeros in rows or columns igl::cross Cross product per-row igl::cumsum Cumulative summation igl::dot dot product per-row igl::eigs Solve sparse eigen value problem igl::find Find subscripts of non-zero entries igl::floor Round entries down to nearest integer igl::histc Counting occurrences for building a histogram igl::hsv_to_rgb Convert HSV colors to RGB (cf. Matlab\u2019s hsv2rgb ) igl::intersect Set intersection of matrix elements. igl::isdiag Determine whether matrix is diagonal igl::ismember Determine whether elements in A occur in B igl::jet Quantized colors along the rainbow. igl::max Compute maximum entry per row or column igl::median Compute the median per column igl::min Compute minimum entry per row or column igl::mod Compute per element modulo igl::mode Compute the mode per column igl::null Compute the null space basis of a matrix igl::nchoosek Compute all k-size combinations of n-long vector igl::orth Orthogonalization of a basis igl::parula Generate a quantized colormap from blue to yellow igl::pinv Compute Moore-Penrose pseudoinverse igl::randperm Generate a random permutation of [0,\u2026,n-1] igl::rgb_to_hsv Convert RGB colors to HSV (cf. Matlab\u2019s rgb2hsv ) igl::repmat Repeat a matrix along columns and rows igl::round Per-element round to whole number igl::setdiff Set difference of matrix elements igl::setunion Set union of matrix elements igl::setxor Set exclusive \u201cor\u201d of matrix elements igl::slice Slice parts of matrix using index lists: (cf. Matlab\u2019s B = A(I,J) ) igl::slice_mask Slice parts of matrix using boolean masks: (cf. Matlab\u2019s B = A(M,N) ) igl::slice_into Slice left-hand side of matrix assignment using index lists (cf. Matlab\u2019s B(I,J) = A ) igl::sort Sort elements or rows of matrix igl::speye Identity as sparse matrix igl::sum Sum along columns or rows (of sparse matrix) igl::unique Extract unique elements or rows of matrix","title":"Other Matlab-style Functions"},{"location":"tutorial/#laplace-equation","text":"A common linear system in geometry processing is the Laplace equation: \u2206z = 0 \u2206z = 0 subject to some boundary conditions, for example Dirichlet boundary conditions (fixed value): \\left.z\\right|_{\\partial{S}} = z_{bc} \\left.z\\right|_{\\partial{S}} = z_{bc} In the discrete setting, the linear system can be written as: \\mathbf{L} \\mathbf{z} = \\mathbf{0} \\mathbf{L} \\mathbf{z} = \\mathbf{0} where \\mathbf{L} \\mathbf{L} is the n \\times n n \\times n discrete Laplacian and \\mathbf{z} \\mathbf{z} is a vector of per-vertex values. Most of \\mathbf{z} \\mathbf{z} correspond to interior vertices and are unknown, but some of \\mathbf{z} \\mathbf{z} represent values at boundary vertices. Their values are known so we may move their corresponding terms to the right-hand side. Conceptually, this is very easy if we have sorted \\mathbf{z} \\mathbf{z} so that interior vertices come first and then boundary vertices: \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\\\ \\mathbf{L}_{b,in} & \\mathbf{L}_{b,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\left(\\begin{array}{c} \\mathbf{0}_{in}\\\\ \\mathbf{z}_{bc}\\end{array}\\right) \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\\\ \\mathbf{L}_{b,in} & \\mathbf{L}_{b,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\left(\\begin{array}{c} \\mathbf{0}_{in}\\\\ \\mathbf{z}_{bc}\\end{array}\\right) The bottom block of equations is no longer meaningful so we\u2019ll only consider the top block: \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\mathbf{0}_{in} \\left(\\begin{array}{cc} \\mathbf{L}_{in,in} & \\mathbf{L}_{in,b}\\end{array}\\right) \\left(\\begin{array}{c} \\mathbf{z}_{in}\\\\ \\mathbf{z}_{b}\\end{array}\\right) = \\mathbf{0}_{in} We can move the known values to the right-hand side: \\mathbf{L}_{in,in} \\mathbf{z}_{in} = - \\mathbf{L}_{in,b} \\mathbf{z}_{b} \\mathbf{L}_{in,in} \\mathbf{z}_{in} = - \\mathbf{L}_{in,b} \\mathbf{z}_{b} Finally we can solve this equation for the unknown values at interior vertices \\mathbf{z}_{in} \\mathbf{z}_{in} . However, our vertices will often not be sorted in this way. One option would be to sort V , then proceed as above and then unsort the solution Z to match V . However, this solution is not very general. With array slicing no explicit sort is needed. Instead we can slice-out submatrix blocks ( \\mathbf{L}_{in,in} \\mathbf{L}_{in,in} , \\mathbf{L}_{in,b} \\mathbf{L}_{in,b} , etc.) and follow the linear algebra above directly. Then we can slice the solution into the rows of Z corresponding to the interior vertices ( Example 303 ). The LaplaceEquation example solves a Laplace equation with Dirichlet boundary conditions.","title":"Laplace Equation"},{"location":"tutorial/#quadratic-energy-minimization","text":"The same Laplace equation may be equivalently derived by minimizing Dirichlet energy subject to the same boundary conditions: \\mathop{\\text{minimize }}_z \\frac{1}{2}\\int\\limits_S \\|\\nabla z\\|^2 dA \\mathop{\\text{minimize }}_z \\frac{1}{2}\\int\\limits_S \\|\\nabla z\\|^2 dA On our discrete mesh, recall that this becomes \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{G}^T \\mathbf{D} \\mathbf{G} \\mathbf{z} \\rightarrow \\mathop{\\text{minimize }}_\\mathbf{z} \\mathbf{z}^T \\mathbf{L} \\mathbf{z} \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{G}^T \\mathbf{D} \\mathbf{G} \\mathbf{z} \\rightarrow \\mathop{\\text{minimize }}_\\mathbf{z} \\mathbf{z}^T \\mathbf{L} \\mathbf{z} The general problem of minimizing some energy over a mesh subject to fixed value boundary conditions is so wide spread that libigl has a dedicated api for solving such systems. Let us consider a general quadratic minimization problem subject to different common constraints: \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant}, \\mathop{\\text{minimize }}_\\mathbf{z} \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant}, subject to \\mathbf{z}_b = \\mathbf{z}_{bc} \\text{ and } \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq}, \\mathbf{z}_b = \\mathbf{z}_{bc} \\text{ and } \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq}, where \\mathbf{Q} \\mathbf{Q} is a (usually sparse) n \\times n n \\times n positive semi-definite matrix of quadratic coefficients (Hessian), \\mathbf{B} \\mathbf{B} is a n \\times 1 n \\times 1 vector of linear coefficients, \\mathbf{z}_b \\mathbf{z}_b is a |b| \\times 1 |b| \\times 1 portion of \\mathbf{z} \\mathbf{z} corresponding to boundary or fixed vertices, \\mathbf{z}_{bc} \\mathbf{z}_{bc} is a |b| \\times 1 |b| \\times 1 vector of known values corresponding to \\mathbf{z}_b \\mathbf{z}_b , \\mathbf{A}_{eq} \\mathbf{A}_{eq} is a (usually sparse) m \\times n m \\times n matrix of linear equality constraint coefficients (one row per constraint), and \\mathbf{B}_{eq} \\mathbf{B}_{eq} is a m \\times 1 m \\times 1 vector of linear equality constraint right-hand side values. This specification is overly general as we could write \\mathbf{z}_b = \\mathbf{z}_{bc} \\mathbf{z}_b = \\mathbf{z}_{bc} as rows of \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq} \\mathbf{A}_{eq} \\mathbf{z} = \\mathbf{B}_{eq} , but these fixed value constraints appear so often that they merit a dedicated place in the API. In libigl, solving such quadratic optimization problems is split into two routines: precomputation and solve. Precomputation only depends on the quadratic coefficients, known value indices and linear constraint coefficients: igl :: min_quad_with_fixed_data mqwf ; igl :: min_quad_with_fixed_precompute ( Q , b , Aeq , true , mqwf ); The output is a struct mqwf which contains the system matrix factorization and is used during solving with arbitrary linear terms, known values, and constraint in the right-hand sides: igl :: min_quad_with_fixed_solve ( mqwf , B , bc , Beq , Z ); The output Z is a n \\times 1 n \\times 1 vector of solutions with fixed values correctly placed to match the mesh vertices V .","title":"Quadratic Energy Minimization"},{"location":"tutorial/#linear-equality-constraints","text":"We saw above that min_quad_with_fixed_* in libigl provides a compact way to solve general quadratic programs. Let\u2019s consider another example, this time with active linear equality constraints. Specifically let\u2019s solve the bi-Laplace equation or equivalently minimize the Laplace energy: \\Delta^2 z = 0 \\leftrightarrow \\mathop{\\text{minimize }}\\limits_z \\frac{1}{2} \\int\\limits_S (\\Delta z)^2 dA \\Delta^2 z = 0 \\leftrightarrow \\mathop{\\text{minimize }}\\limits_z \\frac{1}{2} \\int\\limits_S (\\Delta z)^2 dA subject to fixed value constraints and a linear equality constraint: z_{a} = 1, z_{b} = -1 z_{a} = 1, z_{b} = -1 and z_{c} = z_{d} z_{c} = z_{d} . Notice that we can rewrite the last constraint in the familiar form from above: z_{c} - z_{d} = 0. z_{c} - z_{d} = 0. Now we can assembly Aeq as a 1 \\times n 1 \\times n sparse matrix with a coefficient 1 1 in the column corresponding to vertex c c and a -1 -1 at d d . The right-hand side Beq is simply zero. Internally, min_quad_with_fixed_* solves using the Lagrange Multiplier method. This method adds additional variables for each linear constraint (in general a m \\times 1 m \\times 1 vector of variables \\lambda \\lambda ) and then solves the saddle problem: \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant} + \\lambda^T\\left(\\mathbf{A}_{eq} \\mathbf{z} - \\mathbf{B}_{eq}\\right) \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2}\\mathbf{z}^T \\mathbf{Q} \\mathbf{z} + \\mathbf{z}^T \\mathbf{B} + \\text{constant} + \\lambda^T\\left(\\mathbf{A}_{eq} \\mathbf{z} - \\mathbf{B}_{eq}\\right) This can be rewritten in a more familiar form by stacking \\mathbf{z} \\mathbf{z} and \\lambda \\lambda into one (m+n) \\times 1 (m+n) \\times 1 vector of unknowns: \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2} \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{cc} \\mathbf{Q} & \\mathbf{A}_{eq}^T\\\\ \\mathbf{A}_{eq} & 0 \\end{array} \\right) \\left( \\begin{array}{c} \\mathbf{z}\\\\ \\lambda \\end{array} \\right) + \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{c} \\mathbf{B}\\\\ -\\mathbf{B}_{eq} \\end{array} \\right) + \\text{constant} \\mathop{\\text{find saddle }}_{\\mathbf{z},\\lambda}\\, \\frac{1}{2} \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{cc} \\mathbf{Q} & \\mathbf{A}_{eq}^T\\\\ \\mathbf{A}_{eq} & 0 \\end{array} \\right) \\left( \\begin{array}{c} \\mathbf{z}\\\\ \\lambda \\end{array} \\right) + \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\begin{array}{c} \\mathbf{B}\\\\ -\\mathbf{B}_{eq} \\end{array} \\right) + \\text{constant} Differentiating with respect to \\left( \\mathbf{z}^T \\lambda^T \\right) \\left( \\mathbf{z}^T \\lambda^T \\right) reveals a linear system and we can solve for \\mathbf{z} \\mathbf{z} and \\lambda \\lambda . The only difference from the straight quadratic minimization system, is that this saddle problem system will not be positive definite. Thus, we must use a different factorization technique (LDLT rather than LLT): libigl\u2019s min_quad_with_fixed_precompute automatically chooses the correct solver in the presence of linear equality constraints ( Example 304 ). The example LinearEqualityConstraints first solves with just fixed value constraints (left: 1 and -1 on the left hand and foot respectively), then solves with an additional linear equality constraint (right: points on right hand and foot constrained to be equal).","title":"Linear Equality Constraints"},{"location":"tutorial/#quadratic-programming","text":"We can generalize the quadratic optimization in the previous section even more by allowing inequality constraints. Specifically box constraints (lower and upper bounds): \\mathbf{l} \\le \\mathbf{z} \\le \\mathbf{u}, \\mathbf{l} \\le \\mathbf{z} \\le \\mathbf{u}, where \\mathbf{l},\\mathbf{u} \\mathbf{l},\\mathbf{u} are n \\times 1 n \\times 1 vectors of lower and upper bounds and general linear inequality constraints: \\mathbf{A}_{ieq} \\mathbf{z} \\le \\mathbf{B}_{ieq}, \\mathbf{A}_{ieq} \\mathbf{z} \\le \\mathbf{B}_{ieq}, where \\mathbf{A}_{ieq} \\mathbf{A}_{ieq} is a k \\times n k \\times n matrix of linear coefficients and \\mathbf{B}_{ieq} \\mathbf{B}_{ieq} is a k \\times 1 k \\times 1 matrix of constraint right-hand sides. Again, we are overly general as the box constraints could be written as rows of the linear inequality constraints, but bounds appear frequently enough to merit a dedicated api. Libigl implements its own active set routine for solving quadratric programs (QPs). This algorithm works by iteratively \u201cactivating\u201d violated inequality constraints by enforcing them as equalities and \u201cdeactivating\u201d constraints which are no longer needed. After deciding which constraints are active at each iteration, the problem reduces to a quadratic minimization subject to linear equality constraints, and the method from the previous section is invoked. This is repeated until convergence. Currently the implementation is efficient for box constraints and sparse non-overlapping linear inequality constraints. Unlike alternative interior-point methods, the active set method benefits from a warm-start (initial guess for the solution vector \\mathbf{z} \\mathbf{z} ). igl :: active_set_params as ; // Z is optional initial guess and output igl :: active_set ( Q , B , b , bc , Aeq , Beq , Aieq , Bieq , lx , ux , as , Z ); Example 305 uses an active set solver to optimize discrete biharmonic kernels 9 at multiple scales .","title":"Quadratic Programming"},{"location":"tutorial/#eigen-decomposition","text":"Libigl has rudimentary support for extracting eigen pairs of a generalized eigen value problem: Ax = \\lambda B x Ax = \\lambda B x where A A is a sparse symmetric matrix and B B is a sparse positive definite matrix. Most commonly in geometry processing, we let A=L A=L the cotangent Laplacian and B=M B=M the per-vertex mass matrix (e.g. 10 ). Typically applications will make use of the low frequency eigen modes. Analogous to the Fourier decomposition, a function f f on a surface can be represented via its spectral decomposition of the eigen modes of the Laplace-Beltrami: f = \\sum\\limits_{i=1}^\\infty a_i \\phi_i f = \\sum\\limits_{i=1}^\\infty a_i \\phi_i where each \\phi_i \\phi_i is an eigen function satisfying: \\Delta \\phi_i = \\lambda_i \\phi_i \\Delta \\phi_i = \\lambda_i \\phi_i and a_i a_i are scalar coefficients. For a discrete triangle mesh, a completely analogous decomposition exists, albeit with finite sum: \\mathbf{f} = \\sum\\limits_{i=1}^n a_i \\phi_i \\mathbf{f} = \\sum\\limits_{i=1}^n a_i \\phi_i where now a column vector of values at vertices \\mathbf{f} \\in \\mathcal{R}^n \\mathbf{f} \\in \\mathcal{R}^n specifies a piecewise linear function and \\phi_i \\in \\mathcal{R}^n \\phi_i \\in \\mathcal{R}^n is an eigen vector satisfying: \\mathbf{L} \\phi_i = \\lambda_i \\mathbf{M} \\phi_i \\mathbf{L} \\phi_i = \\lambda_i \\mathbf{M} \\phi_i . Note that Vallet & Levy 10 propose solving a symmetrized standard eigen problem \\mathbf{M}^{-1/2}\\mathbf{L}\\mathbf{M}^{-1/2} \\phi_i = \\lambda_i \\phi_i \\mathbf{M}^{-1/2}\\mathbf{L}\\mathbf{M}^{-1/2} \\phi_i = \\lambda_i \\phi_i . Libigl implements a generalized eigen problem solver so this unnecessary symmetrization can be avoided. Often the sum above is truncated to the first k k eigen vectors. If the low frequency modes are chosen, i.e. those corresponding to small \\lambda_i \\lambda_i values, then this truncation effectively regularizes \\mathbf{f} \\mathbf{f} to smooth, slowly changing functions over the mesh (e.g. 8 ). Modal analysis and model subspaces have been used frequently in real-time deformation (e.g. 7 ). In Example 306 ), the first 5 eigen vectors of the discrete Laplace-Beltrami operator are computed and displayed in pseudo-color atop the beetle. Eigen vectors are computed using igl::eigs (mirroring MATLAB\u2019s eigs ). The 5 eigen vectors are placed into the columns of U and the eigen values are placed into the entries of S : SparseMatrix < double > L , M ; igl :: cotmatrix ( V , F , L ); igl :: massmatrix ( V , F , igl :: MASSMATRIX_TYPE_DEFAULT , M ); Eigen :: MatrixXd U ; Eigen :: VectorXd S ; igl :: eigs ( L , M , 5 , igl :: EIGS_TYPE_SM , U , S ); ( Example 306 ) Low frequency eigen vectors of the discrete Laplace-Beltrami operator vary smoothly and slowly over the Beetle . .md-nav--secondary .md-nav__list .md-nav__list .md-nav__list { display: none }","title":"Eigen Decomposition"},{"location":"tutorial/#chapter-4-shape-deformation","text":"Modern mesh-based shape deformation methods satisfy user deformation constraints at handles (selected vertices or regions on the mesh) and propagate these handle deformations to the rest of shape smoothly and without removing or distorting details . Libigl provides implementations of a variety of state-of-the-art deformation techniques, ranging from quadratic mesh-based energy minimizers, to skinning methods, to non-linear elasticity-inspired techniques.","title":"Chapter 4: Shape Deformation"},{"location":"tutorial/#biharmonic-deformation","text":"The period of research between 2000 and 2010 produced a collection of techniques that cast the problem of handle-based shape deformation as a quadratic energy minimization problem or equivalently the solution to a linear partial differential equation. There are many flavors of these techniques, but a prototypical subset are those that consider solutions to the bi-Laplace equation, that is a biharmonic function 11 . This fourth-order PDE provides sufficient flexibility in boundary conditions to ensure C^1 C^1 continuity at handle constraints (in the limit under refinement) 15 .","title":"Biharmonic Deformation"},{"location":"tutorial/#biharmonic-surfaces","text":"Let us first begin our discussion of biharmonic deformation , by considering biharmonic surfaces . We will casually define biharmonic surfaces as surface whose position functions are biharmonic with respect to some initial parameterization: \\Delta^2 \\mathbf{x}' = 0 \\Delta^2 \\mathbf{x}' = 0 and subject to some handle constraints, conceptualized as \u201cboundary conditions\u201d: \\mathbf{x}'_{b} = \\mathbf{x}_{bc}. \\mathbf{x}'_{b} = \\mathbf{x}_{bc}. where \\mathbf{x}' \\mathbf{x}' is the unknown 3D position of a point on the surface. So we are asking that the bi-Laplacian of each of spatial coordinate function to be zero. In libigl, one can solve a biharmonic problem with igl::harmonic and setting k=2 k=2 ( bi -harmonic): // U_bc contains deformation of boundary vertices b igl :: harmonic ( V , F , b , U_bc , 2 , U ); This produces a smooth surface that interpolates the handle constraints, but all original details on the surface will be smoothed away . Most obviously, if the original surface is not already biharmonic, then giving all handles the identity deformation (keeping them at their rest positions) will not reproduce the original surface. Rather, the result will be the biharmonic surface that does interpolate those handle positions. Thus, we may conclude that this is not an intuitive technique for shape deformation.","title":"Biharmonic Surfaces"},{"location":"tutorial/#biharmonic-deformation-fields","text":"Now we know that one useful property for a deformation technique is \u201crest pose reproduction\u201d: applying no deformation to the handles should apply no deformation to the shape. To guarantee this by construction we can work with deformation fields (ie. displacements) \\mathbf{d} \\mathbf{d} rather than directly with positions \\mathbf{x} \\mathbf{x} . Then the deformed positions can be recovered as \\mathbf{x}' = \\mathbf{x}+\\mathbf{d}. \\mathbf{x}' = \\mathbf{x}+\\mathbf{d}. A smooth deformation field \\mathbf{d} \\mathbf{d} which interpolates the deformation fields of the handle constraints will impose a smooth deformed shape \\mathbf{x}' \\mathbf{x}' . Naturally, we consider biharmonic deformation fields : \\Delta^2 \\mathbf{d} = 0 \\Delta^2 \\mathbf{d} = 0 subject to the same handle constraints, but rewritten in terms of their implied deformation field at the boundary (handles): \\mathbf{d}_b = \\mathbf{x}_{bc} - \\mathbf{x}_b. \\mathbf{d}_b = \\mathbf{x}_{bc} - \\mathbf{x}_b. Again we can use igl::harmonic with k=2 k=2 , but this time solve for the deformation field and then recover the deformed positions: // U_bc contains deformation of boundary vertices b D_bc = U_bc - igl :: slice ( V , b , 1 ); igl :: harmonic ( V , F , b , D_bc , 2 , D ); U = V + D ; The BiharmonicDeformation example deforms a statue\u2019s head as a biharmonic surface (top) and using a biharmonic displacements (bottom).","title":"Biharmonic Deformation Fields"},{"location":"tutorial/#relationship-to-differential-coordinates-and-laplacian-surface-editing","text":"Biharmonic functions (whether positions or displacements) are solutions to the bi-Laplace equation, but also minimizers of the \u201cLaplacian energy\u201d. For example, for displacements \\mathbf{d} \\mathbf{d} , the energy reads \\int\\limits_S \\|\\Delta \\mathbf{d}\\|^2 dA, \\int\\limits_S \\|\\Delta \\mathbf{d}\\|^2 dA, where we define \\Delta \\mathbf{d} \\Delta \\mathbf{d} to simply apply the Laplacian coordinate-wise. By linearity of the Laplace(-Beltrami) operator we can reexpress this energy in terms of the original positions \\mathbf{x} \\mathbf{x} and the unknown positions \\mathbf{x}' = \\mathbf{x} - \\mathbf{d} \\mathbf{x}' = \\mathbf{x} - \\mathbf{d} : \\int\\limits_S \\|\\Delta (\\mathbf{x}' - \\mathbf{x})\\|^2 dA = \\int\\limits_S \\|\\Delta \\mathbf{x}' - \\Delta \\mathbf{x})\\|^2 dA. \\int\\limits_S \\|\\Delta (\\mathbf{x}' - \\mathbf{x})\\|^2 dA = \\int\\limits_S \\|\\Delta \\mathbf{x}' - \\Delta \\mathbf{x})\\|^2 dA. In the early work of Sorkine et al., the quantities \\Delta \\mathbf{x}' \\Delta \\mathbf{x}' and \\Delta \\mathbf{x} \\Delta \\mathbf{x} were dubbed \u201cdifferential coordinates\u201d 21 . Their deformations (without linearized rotations) is thus equivalent to biharmonic deformation fields.","title":"Relationship To \"differential Coordinates\" And Laplacian Surface Editing"},{"location":"tutorial/#polyharmonic-deformation","text":"We can generalize biharmonic deformation by considering different powers of the Laplacian, resulting in a series of PDEs of the form: \\Delta^k \\mathbf{d} = 0. \\Delta^k \\mathbf{d} = 0. with k\\in{1,2,3,\\dots} k\\in{1,2,3,\\dots} . The choice of k k determines the level of continuity at the handles. In particular, k=1 k=1 implies C^0 C^0 at the boundary, k=2 k=2 implies C^1 C^1 , k=3 k=3 implies C^2 C^2 and in general k k implies C^{k-1} C^{k-1} . int k = 2 ; // or 1,3,4,... igl :: harmonic ( V , F , b , bc , k , Z ); The PolyharmonicDeformation example deforms a flat domain (left) into a bump as a solution to various k k -harmonic PDEs.","title":"Polyharmonic Deformation"},{"location":"tutorial/#bounded-biharmonic-weights","text":"In computer animation, shape deformation is often referred to as \u201cskinning\u201d. Constraints are posed as relative rotations of internal rigid \u201cbones\u201d inside a character. The deformation method, or skinning method, determines how the surface of the character (i.e. its skin) should move as a function of the bone rotations. The most popular technique is linear blend skinning. Each point on the shape computes its new location as a linear combination of bone transformations: \\mathbf{x}' = \\sum\\limits_{i = 1}^m w_i(\\mathbf{x}) \\mathbf{T}_i \\left(\\begin{array}{c}\\mathbf{x}_i\\\\1\\end{array}\\right), \\mathbf{x}' = \\sum\\limits_{i = 1}^m w_i(\\mathbf{x}) \\mathbf{T}_i \\left(\\begin{array}{c}\\mathbf{x}_i\\\\1\\end{array}\\right), where w_i(\\mathbf{x}) w_i(\\mathbf{x}) is the scalar weight function of the ith bone evaluated at \\mathbf{x} \\mathbf{x} and \\mathbf{T}_i \\mathbf{T}_i is the bone transformation as a 4 \\times 3 4 \\times 3 matrix. This formula is embarassingly parallel (computation at one point does not depend on shared data need by computation at another point). It is often implemented as a vertex shader. The weights and rest positions for each vertex are sent as vertex shader attributes and bone transformations are sent as uniforms . Then vertices are transformed within the vertex shader, just in time for rendering. As the skinning formula is linear (hence its name), we can write it as matrix multiplication: \\mathbf{X}' = \\mathbf{M} \\mathbf{T}, \\mathbf{X}' = \\mathbf{M} \\mathbf{T}, where \\mathbf{X}' \\mathbf{X}' is n \\times 3 n \\times 3 stack of deformed positions as row vectors, \\mathbf{M} \\mathbf{M} is a n \\times m\\cdot dim n \\times m\\cdot dim matrix containing weights and rest positions and \\mathbf{T} \\mathbf{T} is a m\\cdot (dim+1) \\times dim m\\cdot (dim+1) \\times dim stack of transposed bone transformations. Traditionally, the weight functions w_j w_j are painted manually by skilled rigging professionals. Modern techniques now exist to compute weight functions automatically given the shape and a description of the skeleton (or in general any handle structure such as a cage, collection of points, selected regions, etc.). Bounded biharmonic weights are one such technique that casts weight computation as a constrained optimization problem 13 . The weights enforce smoothness by minimizing the familiar Laplacian energy: \\sum\\limits_{i = 1}^m \\int_S (\\Delta w_i)^2 dA \\sum\\limits_{i = 1}^m \\int_S (\\Delta w_i)^2 dA subject to constraints which enforce interpolation of handle constraints: w_i(\\mathbf{x}) = \\begin{cases} 1 & \\text{ if } \\mathbf{x} \\in H_i\\\\ 0 & \\text{ otherwise } \\end{cases}, w_i(\\mathbf{x}) = \\begin{cases} 1 & \\text{ if } \\mathbf{x} \\in H_i\\\\ 0 & \\text{ otherwise } \\end{cases}, where H_i H_i is the ith handle, and constraints which enforce non-negativity, parition of unity and encourage sparsity: 0\\le w_i \\le 1 0\\le w_i \\le 1 and \\sum\\limits_{i=1}^m w_i = 1. \\sum\\limits_{i=1}^m w_i = 1. This is a quadratic programming problem and libigl solves it using its active set solver or by calling out to Mosek . The example BoundedBiharmonicWeights computes weights for a tetrahedral mesh given a skeleton (top) and then animates a linear blend skinning deformation (bottom).","title":"Bounded Biharmonic Weights"},{"location":"tutorial/#dual-quaternion-skinning","text":"Even with high quality weights, linear blend skinning is limited. In particular, it suffers from known artifacts stemming from blending rotations as matrices: a weight combination of rotation matrices is not necessarily a rotation. Consider an equal blend between rotating by -\\pi/2 -\\pi/2 and by \\pi/2 \\pi/2 about the z z -axis. Intuitively one might expect to get the identity matrix, but instead the blend is a degenerate matrix scaling the x x and y y coordinates by zero: 0.5\\left(\\begin{array}{ccc}0&-1&0\\\\1&0&0\\\\0&0&1\\end{array}\\right)+ 0.5\\left(\\begin{array}{ccc}0&1&0\\\\-1&0&0\\\\0&0&1\\end{array}\\right)= \\left(\\begin{array}{ccc}0&0&0\\\\0&0&0\\\\0&0&1\\end{array}\\right) 0.5\\left(\\begin{array}{ccc}0&-1&0\\\\1&0&0\\\\0&0&1\\end{array}\\right)+ 0.5\\left(\\begin{array}{ccc}0&1&0\\\\-1&0&0\\\\0&0&1\\end{array}\\right)= \\left(\\begin{array}{ccc}0&0&0\\\\0&0&0\\\\0&0&1\\end{array}\\right) In practice, this means the shape shrinks and collapses in regions where bone weights overlap: near joints. Dual quaternion skinning presents a solution 17 . This method represents rigid transformations as a pair of unit quaternions, \\hat{\\mathbf{q}} \\hat{\\mathbf{q}} . The linear blend skinning formula is replaced with a linear blend of dual quaternions: \\mathbf{x}' = \\cfrac{\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}} {\\left\\|\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}\\right\\|} \\mathbf{x}, \\mathbf{x}' = \\cfrac{\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}} {\\left\\|\\sum\\limits_{i=1}^m w_i(\\mathbf{x})\\hat{\\mathbf{q}_i}\\right\\|} \\mathbf{x}, where \\hat{\\mathbf{q}_i} \\hat{\\mathbf{q}_i} is the dual quaternion representation of the rigid transformation of bone i i . The normalization forces the result of the linear blending to again be a unit dual quaternion and thus also a rigid transformation. Like linear blend skinning, dual quaternion skinning is best performed in the vertex shader. The only difference being that bone transformations are sent as dual quaternions rather than affine transformation matrices. Libigl supports CPU-side dual quaternion skinning with the igl::dqs function, which takes a more traditional representation of rigid transformations as input and internally converts to the dual quaternion representation before blending: // vQ is a list of rotations as quaternions // vT is a list of translations igl :: dqs ( V , W , vQ , vT , U ); The example DualQuaternionSkinning compares linear blend skinning (top) to dual quaternion skinning (bottom), highlighting LBS\u2019s candy wrapper effect (middle) and joint collapse (right).","title":"Dual Quaternion Skinning"},{"location":"tutorial/#as-rigid-as-possible","text":"Skinning and other linear methods for deformation are inherently limited. Difficult arises especially when large rotations are imposed by the handle constraints. In the context of energy-minimization approaches, the problem stems from comparing positions (our displacements) in the coordinate frame of the undeformed shape. These quadratic energies are at best invariant to global rotations of the entire shape, but not smoothly varying local rotations. Thus linear techniques will not produce non-trivial bending and twisting. Furthermore, when considering solid shapes (e.g. discretized with tetrahedral meshes) linear methods struggle to maintain local volume, and they often suffer from shrinking and bulging artifacts. Non-linear deformation techniques present a solution to these problems. They work by comparing the deformation of a mesh vertex to its rest position rotated to a new coordinate frame which best matches the deformation. The non-linearity stems from the mutual dependence of the deformation and the best-fit rotation. These techniques are often labeled \u201cas-rigid-as-possible\u201d as they penalize the sum of all local deformations\u2019 deviations from rotations. To arrive at such an energy, let\u2019s consider a simple per-triangle energy: E_\\text{linear}(\\mathbf{X}') = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) - \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2 E_\\text{linear}(\\mathbf{X}') = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) - \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2 where \\mathbf{X}' \\mathbf{X}' are the mesh\u2019s unknown deformed vertex positions, t t is a triangle in a list of triangles T T , a_t a_t is the area of triangle t t and \\{i,j\\} \\{i,j\\} is an edge in triangle t t . Thus, this energy measures the norm of change between an edge vector in the original mesh \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right) \\left(\\mathbf{x}_i - \\mathbf{x}_j\\right) and the unknown mesh \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right) . This energy is not rotation invariant. If we rotate the mesh by 90 degrees the change in edge vectors not aligned with the axis of rotation will be large, despite the overall deformation being perfectly rigid. So, the \u201cas-rigid-as-possible\u201d solution is to append auxiliary variables \\mathbf{R}_t \\mathbf{R}_t for each triangle t t which are constrained to be rotations. Then the energy is rewritten, this time comparing deformed edge vectors to their rotated rest counterparts: E_\\text{arap}(\\mathbf{X}',\\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\}) = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right)- \\mathbf{R}_t\\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2. E_\\text{arap}(\\mathbf{X}',\\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\}) = \\sum\\limits_{t \\in T} a_t \\sum\\limits_{\\{i,j\\} \\in t} w_{ij} \\left\\| \\left(\\mathbf{x}'_i - \\mathbf{x}'_j\\right)- \\mathbf{R}_t\\left(\\mathbf{x}_i - \\mathbf{x}_j\\right)\\right\\|^2. The separation into the primary vertex position variables \\mathbf{X}' \\mathbf{X}' and the rotations \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} lead to strategy for optimization, too. If the rotations \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} \\{\\mathbf{R}_1,\\dots,\\mathbf{R}_{|T|}\\} are held fixed then the energy is quadratic in the remaining variables \\mathbf{X}' \\mathbf{X}' and can be optimized by solving a (sparse) global linear system. Alternatively, if \\mathbf{X}' \\mathbf{X}' are held fixed then each rotation is the solution to a localized Procrustes problem (found via 3 \\times 3 3 \\times 3 SVD or polar decompostion). These two steps\u2014local and global\u2014each weakly decrease the energy, thus we may safely iterate them until convergence. The different flavors of \u201cas-rigid-as-possible\u201d depend on the dimension and codimension of the domain and the edge-sets T T . The proposed surface manipulation technique by Sorkine and Alexa 22 , considers T T to be the set of sets of edges emanating from each vertex (spokes). Later, Chao et al. derived the relationship between \u201cas-rigid-as-possible\u201d mesh energies and co-rotational elasticity considering 0-codimension elements as edge-sets: triangles in 2D and tetrahedra in 3D 12 . They also showed how Sorkine and Alexa\u2019s edge-sets are not a discretization of a continuous energy, proposing instead edge-sets for surfaces containing all edges of elements incident on a vertex (spokes and rims). They show that this amounts to measuring bending, albeit in a discretization-dependent way. Libigl, supports these common flavors. Selecting one is a matter of setting the energy type before the precompuation phase: igl :: ARAPData arap_data ; arap_data . energy = igl :: ARAP_ENERGY_TYPE_SPOKES ; //arap_data.energy = igl::ARAP_ENERGY_TYPE_SPOKES_AND_RIMS; //arap_data.energy = igl::ARAP_ENERGY_TYPE_ELEMENTS; //triangles or tets igl :: arap_precomputation ( V , F , dim , b , arap_data ); Just like igl::min_quad_with_fixed_* , this precomputation phase only depends on the mesh, fixed vertex indices b and the energy parameters. To solve with certain constraints on the positions of vertices in b , we may call: igl :: arap_solve ( bc , arap_data , U ); which uses U as an initial guess and then computes the solution into it. Libigl\u2019s implementation of as-rigid-as-possible deformation takes advantage of the highly optimized singular value decomposition code from McAdams et al. 20 which leverages SSE intrinsics. The example AsRigidAsPossible deforms a surface as if it were made of an elastic material The concept of local rigidity will be revisited shortly in the context of surface parameterization.","title":"As-rigid-as-possible"},{"location":"tutorial/#fast-automatic-skinning-transformations","text":"Non-linear optimization is, unsurprisingly, slower than its linear cousins. In the case of the as-rigid-as-possible optimization, the bottleneck is typically the large number of polar decompositions necessary to recover best fit rotations for each edge-set (i.e. for each triangle, tetrahedron, or vertex cell). Even if this code is optimized, the number of primary degrees of freedom is tied to the discretization level, despite the deformations\u2019 low frequency behavior. This invites two routes toward fast non-linear optimization. First, is it necessary (or even advantageous) to find so many best-fit rotations? Second, can we reduce the degrees of freedom to better reflect the frequency of the desired deformations. Taken in turn, these optimizations culminate in a method which optimizes over the space of linear blend skinning deformations spanned by high-quality weights (i.e. manually painted ones or bounded biharmonic weights). This space is a low-dimensional subspace of all possible mesh deformations, captured by writing linear blend skinning in matrix form: \\mathbf{X}' = \\mathbf{M}\\mathbf{T} \\mathbf{X}' = \\mathbf{M}\\mathbf{T} where the mesh vertex positions in the n \\times 3 n \\times 3 matrix \\mathbf{X}' \\mathbf{X}' are replaced by a linear combination of a small number of degrees of freedom in the (3+1)m \\times 3 (3+1)m \\times 3 stack of transposed \u201chandle\u201d transformations. Swapping in \\mathbf{M}\\mathbf{T} \\mathbf{M}\\mathbf{T} for \\mathbf{X}' \\mathbf{X}' in the ARAP energies above immediately sees performance gains during the global solve step as m << n m << n . The complexity of the local step\u2014fitting rotations\u2014is still bound to the original mesh discretization. However, if the skinning is well behaved, we can make the assumption that places on the shape with similar skinning weights will deform similarly and thus imply similar best-fit rotations. Therefore, we cluster edge-sets according to their representation in weight-space : where a vertex \\mathbf{x} \\mathbf{x} takes the coordinates [w_1(\\mathbf{x}),w_2(\\mathbf{x}),\\dots,w_m(\\mathbf{x})] [w_1(\\mathbf{x}),w_2(\\mathbf{x}),\\dots,w_m(\\mathbf{x})] . The number of clustered edge-sets show diminishing returns on the deformation quality so we may choose a small number of clusters, proportional to the number of skinning weight functions (rather than the number of discrete mesh vertices). This proposed deformation model 14 , can simultaneously be seen as a fast, subspace optimization for ARAP and as an automatic method for finding the best skinning transformation degrees of freedom. A variety of user interfaces are supported via linear equality constraints on the skinning transformations associated with handles. To fix a transformation entirely we simply add the constraint: \\left(\\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{T}}_i^T, \\left(\\begin{array}{cccc} 1 & 0 & 0 & 0\\\\ 0 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{T}}_i^T, where \\hat{\\mathbf{T}}_i^T \\hat{\\mathbf{T}}_i^T is the (3+1) \\times 3 (3+1) \\times 3 transposed fixed transformation for handle i i . To fix only the origin of a handle, we add a constraint requiring the transformation to interpolate a point in space (typically the centroid of all points with w_i = 1 w_i = 1 : \\mathbf{c}'^T\\mathbf{T}_i^T = \\mathbf{c}^T, \\mathbf{c}'^T\\mathbf{T}_i^T = \\mathbf{c}^T, where \\mathbf{c}^T \\mathbf{c}^T is the 1 \\times (3+1) 1 \\times (3+1) position of the point at rest in transposed homogeneous coordinates, and \\mathbf{c}'^T \\mathbf{c}'^T the point given by the user. We can similarly fix just the linear part of the transformation at a handle, freeing the translation component (producing a \u201cchickenhead\u201d effect): \\left(\\begin{array}{cccc} 1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&1&0\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{L}}_i^T, \\left(\\begin{array}{cccc} 1&0&0&0\\\\ 0&1&0&0\\\\ 0&0&1&0\\end{array}\\right) \\mathbf{T}_i^T = \\hat{\\mathbf{L}}_i^T, where \\hat{\\mathbf{L}}_i^T \\hat{\\mathbf{L}}_i^T is the fixed 3 \\times 3 3 \\times 3 linear part of the transformation at handle i i . And lastly we can allow the user to entirely free the transformation\u2019s degrees of freedom, delegating the optimization to find the best possible values for all elements. To do this, we simply abstain from adding a corresponding constraint.","title":"Fast Automatic Skinning Transformations"},{"location":"tutorial/#arap-with-grouped-edge-sets","text":"Being a subspace method, an immediate disadvantage is the reduced degrees of freedom. This brings performance, but in some situations limits behavior too much. In such cases one can use the skinning subspace to build an effective clustering of rotation edge-sets for a traditional ARAP optimization: forgoing the subspace substitution. This has a two-fold effect. The cost of the rotation fitting, local step drastically reduces, and the deformations are \u201cregularized\u201d according the clusters. From a high level point of view, if the clusters are derived from skinning weights, then they will discourage bending, especially along isolines of the weight functions. If handles are not known in advance, one could also cluster according to a \u201cgeodesic embedding\u201d like the biharmonic distance embedding. In this light, we can think of the \u201cspokes+rims\u201d style surface ARAP as a (slight and redundant) clustering of the per-triangle edge-sets. The example FastAutomaticSkinningTransformations compares a full (slow) ARAP deformation on a detailed shape (left of middle), to ARAP with grouped rotation edge sets (right of middle), to the very fast subpsace method (right).","title":"Arap With Grouped Edge-sets"},{"location":"tutorial/#biharmonic-coordinates","text":"Linear blend skinning (as above ) deforms a mesh by propagating full affine transformations at handles (bones, points, regions, etc.) to the rest of the shape via weights. Another deformation framework, called \u201cgeneralized barycentric coordinates\u201d, is a special case of linear blend skinning 16 : transformations are restricted to pure translations and weights are required to retain affine precision . This latter requirement means that we can write the rest-position of any vertex in the mesh as the weighted combination of the control handle locations: \\mathbf{x} = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i, \\mathbf{x} = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i, where \\mathbf{c}_i \\mathbf{c}_i is the rest position of the i i th control point. This simplifies the deformation formula at run-time. We can simply take the new position of each point of the shape to be the weighted combination of the translated control point positions: \\mathbf{x}' = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i'. \\mathbf{x}' = \\sum\\limits_{i=1}^m w_i(\\mathbf{x}) * \\mathbf{c}_i'. There are many different flavors of \u201cgeneralized barycentric coordinates\u201d (see table in \u201cAutomatic Methods\u201d section, 16 ). The vague goal of \u201cgeneralized barycentric coordinates\u201d is to capture as many properties of simplicial barycentric coordinates (e.g. for triangles in 2D and tetrahedral in 3D) for larger sets of points or polyhedra. Some generalized barycentric coordinates can be computed in closed form; others require optimization-based precomputation. Nearly all flavors require connectivity information describing how the control points form a external polyhedron around the input shape: a cage. However, a recent techinique does not require a cage 23 . This method ensures affine precision during optimization over weights of a smoothness energy with affine functions in its kernel: \\mathop{\\text{min}}_\\mathbf{W}\\,\\, \\text{trace}(\\frac{1}{2}\\mathbf{W}^T \\mathbf{A} \\mathbf{W}), \\text{subject to: } \\mathbf{C} = \\mathbf{W}\\mathbf{C} \\mathop{\\text{min}}_\\mathbf{W}\\,\\, \\text{trace}(\\frac{1}{2}\\mathbf{W}^T \\mathbf{A} \\mathbf{W}), \\text{subject to: } \\mathbf{C} = \\mathbf{W}\\mathbf{C} subject to interpolation constraints at selected vertices. If \\mathbf{A} \\mathbf{A} has affine functions in its kernel\u2014that is, if \\mathbf{A}\\mathbf{V} = 0 \\mathbf{A}\\mathbf{V} = 0 \u2014then the weights \\mathbf{W} \\mathbf{W} will retain affine precision and we\u2019ll have that: \\mathbf{V} = \\mathbf{W}\\mathbf{C} \\mathbf{V} = \\mathbf{W}\\mathbf{C} the matrix form of the equality above. The proposed way to define \\mathbf{A} \\mathbf{A} is to construct a matrix \\mathbf{K} \\mathbf{K} that measures the Laplacian at all interior vertices and at all boundary vertices . The usual definition of the discrete Laplacian (e.g. what libigl returns from igl::cotmatrix ), measures the Laplacian of a function for interior vertices, but measures the Laplacian of a function minus the normal derivative of a function for boundary vertices. Thus, we can let: \\mathbf{K} = \\mathbf{L} + \\mathbf{N} \\mathbf{K} = \\mathbf{L} + \\mathbf{N} where \\mathbf{L} \\mathbf{L} is the usual Laplacian and \\mathbf{N} \\mathbf{N} is matrix that computes normal derivatives of a piecewise-linear function at boundary vertices of a mesh. Then \\mathbf{A} \\mathbf{A} is taken as quadratic form computing the square of the integral-average of \\mathbf{K} \\mathbf{K} applied to a function and integrated over the mesh: \\mathbf{A} = (\\mathbf{M}^{-1}\\mathbf{K})^2_\\mathbf{M} = \\mathbf{K}^T \\mathbf{M}^{-1} \\mathbf{K}. \\mathbf{A} = (\\mathbf{M}^{-1}\\mathbf{K})^2_\\mathbf{M} = \\mathbf{K}^T \\mathbf{M}^{-1} \\mathbf{K}. Since the Laplacian \\mathbf{K} \\mathbf{K} is a second-order derivative it measures zero on affine functions, thus \\mathbf{A} \\mathbf{A} has affine functions in its null space. A short derivation proves that this implies \\mathbf{W} \\mathbf{W} will be affine precise (see 23 ). Minimizers of this \u201csquared Laplacian\u201d energy are in some sense discrete biharmonic functions . Thus they\u2019re dubbed \u201cbiharmonic coordinates\u201d (not the same as bounded biharmonic weights , which are not generalized barycentric coordinates). In libigl, one can compute biharmonic coordinates given a mesh (V,F) and a list S of selected control points or control regions (which act like skinning handles): igl :: biharmonic_coordinates ( V , F , S , W ); ( Example 407 ) shows a physics simulation on a coarse orange mesh. The vertices of this mesh become control points for a biharmonic coordinates deformation of the blue high-resolution mesh.","title":"Biharmonic Coordinates"},{"location":"tutorial/#direct-delta-mush","text":"To produce a smooth deformation, linear blend skinning requires smooth skinning weights. These could be painted manually or computed automatically (e.g., using Bounded Biharmonic Weights 13 ). Even still, linear blend skinning suffers from shrinkage and collapse artifacts due to its inherent linearity (see earlier ). \u201cDirect Delta Mush\u201d 18 skinning attempts to solve both of these issues by providing a direct skinning method that takes as input a rig with piecewise-constant weight functions (weights are either =0 =0 or =1 =1 everywhere). Direct delta mush is an adaptation of a less performant method called simply \u201cDelta Mush\u201d 19 . The computation of Delta Mush separates into \u201cbind pose\u201d precomputation and runtime evaluation. At bind time, Laplacian smoothing is conducted on the bind pose, moving each vertex from its rest position \\mathbf{v}_i \\mathbf{v}_i to a new position \\tilde{\\mathbf{v}}_i \\tilde{\\mathbf{v}}_i . The \u201cdelta\u201d describing undoing this smoothing procedure, is computed and stored in a local coordinate frame associated with the vertex: \\delta_i = \\mathbf{T}_i^{-1} (\\mathbf{v}_i - \\tilde{\\mathbf{v}}_i). \\delta_i = \\mathbf{T}_i^{-1} (\\mathbf{v}_i - \\tilde{\\mathbf{v}}_i). At run time, the mesh is deformed using linear blend skinning and piecewise-constant weights. Near bones, the deformation is perfectly rigid, while near joints where bones meet, the mesh tears apart with a sudden change to the next rigid transformation. The same amount of Laplacian smoothing is applied at run time to this posed mesh. Moving each vertex to a location \\tilde{\\mathbf{u}}_i \\tilde{\\mathbf{u}}_i . A local frame \\mathbf{S}_i \\mathbf{S}_i is computed at this location and the cached deltas are adding in this resolved frame to restore the shape\u2019s original details: \\mathbf{u}_i = \\tilde{\\mathbf{u}}_i + \\mathbf{S}_i \\delta_i. \\mathbf{u}_i = \\tilde{\\mathbf{u}}_i + \\mathbf{S}_i \\delta_i. The key insight of \u201cDelta Mush\u201d is that Laplacian smoothing acts similarly on the rest and posed models. The key insight of \u201cDirect Delta Mush\u201d is that this process of Laplacian smoothing at runtime is nearly linear and local frames can be computed in a embarrassingly parallel fashion using SVD (cf. ARAP ). Direct delta mush moves the smoothing step into precomputation, resulting in \u201cvector-valued\u201d skinning weights per-vertex per-bone, stored in a matrix \\Omega \\Omega . In libigl, for a mesh (V,F) and (e.g., piecewise-constant) weights W this precomputation is computed using: igl :: direct_delta_mush_precomputation ( V , F , Wsparse , p , lambda , kappa , alpha , Omega ); the parameters p, lambda, kappa, alpha control the smoothness and compactness of the resulting deformation. The precomputation\u2019s output is the matrix Omega . At runtime, \\Omega \\Omega is used to deform the mesh to its final locations. In libigl, this is computed using: igl :: direct_delta_mush ( V , T_list , Omega , U ); where T_list is the input pose (affine) transformations associated with each bone and the final locations are stored in U . ( Example 408 ) Direct Delta Mush. (left) input piecewise-rigid skinning, (middle) skeleton animation, (right) smooth Direct Delta Mush skinning","title":"Direct Delta Mush"},{"location":"tutorial/#mesh-deformation-with-kelvinlet","text":"Kelvinlets 24 is a technique for real-time physically based volume sculpting of virtual elastic materials. The technique treats meshes as fluids made of compressible materials and deforms them by advecting points along a displacement field. It relies on analytical solutions to the equations of elasticity.","title":"Mesh Deformation with Kelvinlet"},{"location":"tutorial/#a-quick-primer-on-linear-elastostatics-25","text":"The equilibrium state of linear elasticity is determined by a displacement field \\mathbf{u} : R^3 \\rightarrow R^3 \\mathbf{u} : R^3 \\rightarrow R^3 that minimizes the elastic potential energy E(\\mathbf{u}) = \\frac{\\mu}{2}\\left\\|\\nabla\\mathbf{u}\\right\\|^2 + \\frac{\\mu}{2(1-2\\nu)}\\left\\|\\nabla \\cdot \\mathbf{u}\\right\\|^2 - \\langle\\mathbf{b}, \\mathbf{u}\\rangle E(\\mathbf{u}) = \\frac{\\mu}{2}\\left\\|\\nabla\\mathbf{u}\\right\\|^2 + \\frac{\\mu}{2(1-2\\nu)}\\left\\|\\nabla \\cdot \\mathbf{u}\\right\\|^2 - \\langle\\mathbf{b}, \\mathbf{u}\\rangle where \\mu \\mu is the elastic shear modulus, \\nu \\nu is the Poisson ratio, and \\mathbf{b} \\mathbf{b} represents the external body forces. The first term controls the smoothness of the displacement field, the second term penalizes infinitesimal volume change, and the last term indicates the external body forces to be counteracted. One can associate the optimal displacement field with the solution to the critical point of the above equation, also known as the Navier-Cauchy equation: \\mu\\Delta\\mathbf{u} + \\frac{\\mu}{(1 - 2\\nu)}\\nabla(\\nabla \\cdot \\mathbf{u}) + \\mathbf{b} = 0 \\mu\\Delta\\mathbf{u} + \\frac{\\mu}{(1 - 2\\nu)}\\nabla(\\nabla \\cdot \\mathbf{u}) + \\mathbf{b} = 0 The Kelvinlet is the solution to the Navier-Cauchy equation in the case of a concentrated body load due to a force vector \\mathbf{f} \\mathbf{f} at a point \\mathbf{x}_{0} \\mathbf{x}_{0} , i.e., where \\mathbf{b}(\\mathbf{x}) = \\mathbf{f} \\delta(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{b}(\\mathbf{x}) = \\mathbf{f} \\delta(\\mathbf{x} \u2212 \\mathbf{x}_{0}) and can be written as: \\mathbf{u}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r}I + \\frac{\\mathbf{b}}{\\mathit{r}^3}\\mathbf{r}\\mathbf{r}^{t}\\right] \\mathbf{f} \\equiv \\mathbf{K}(\\mathbf{r})\\mathbf{f} \\mathbf{u}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r}I + \\frac{\\mathbf{b}}{\\mathit{r}^3}\\mathbf{r}\\mathbf{r}^{t}\\right] \\mathbf{f} \\equiv \\mathbf{K}(\\mathbf{r})\\mathbf{f} where \\mathbf{K} \\mathbf{K} is the Kelvinlet function, \\mathbf{r} = \\mathbf{x} \u2212 \\mathbf{x}_{0} \\mathbf{r} = \\mathbf{x} \u2212 \\mathbf{x}_{0} is the relative position vector from the load location \\mathbf{x}_{0} \\mathbf{x}_{0} to an observation point \\mathbf{x} \\mathbf{x} , \\mathit{r} \\mathit{r} is the norm of \\mathbf{r} \\mathbf{r} , a = \\frac{1}{4\\pi\\mu} a = \\frac{1}{4\\pi\\mu} and b = \\frac{a}{(1-\\nu)} b = \\frac{a}{(1-\\nu)} The displacement field \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) deforms a point \\mathbf{x} \\mathbf{x} in a linear elastic material to \\mathbf{x} + \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{x} + \\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) . The associated deformation gradient is then defined by a 3\u00d73 3\u00d73 matrix of the form \\mathbf{G}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) = \\mathbf{I} + \\nabla\\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) \\mathbf{G}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) = \\mathbf{I} + \\nabla\\mathbf{u}(\\mathbf{x} \u2212 \\mathbf{x}_{0}) . This gradient \\mathbf{G}(\\mathbf{r}) \\mathbf{G}(\\mathbf{r}) determines the different properties of the displacement field \\mathbf{u(\\mathbf{r})} \\mathbf{u(\\mathbf{r})} . For instance, the skew-symmetric part of \\nabla\\mathbf{u}(\\mathbf{r}) \\nabla\\mathbf{u}(\\mathbf{r}) indicates the rotation induced by \\mathbf{u(\\mathbf{r})} \\mathbf{u(\\mathbf{r})} , while its symmetric part corresponds to the elastic strain and determines the stretching. The strain tensor can also be decomposed into a trace term that represents the scaling of the volume of the elastic medium, and a traceless term that represents the pinching deformation. This forms the fundamentals of the Kelvinlet brushes.","title":"A quick primer on linear elastostatics 25"},{"location":"tutorial/#regularized-kelvinlets","text":"The concentrated body load at a single point \\mathbf{x}_{0} \\mathbf{x}_{0} introduces a singularity to the Kelvinlet solution at \\mathbf{x}_{0} \\mathbf{x}_{0} . For this reason, the kelvinlet equation is modified to: \\mathbf{u_{\\epsilon}}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r_{\\epsilon}}I + \\frac{\\mathbf{b}}{\\mathit{r_{\\epsilon}}^3}\\mathbf{r_{\\epsilon}}\\mathbf{r_{\\epsilon}}^{t} + \\frac{a}{2}\\frac{\\epsilon^2}{r_{\\epsilon}^3}I\\right] \\equiv \\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{f} \\mathbf{u_{\\epsilon}}(\\mathbf{r}) = \\left[ \\frac{(a - b)}{r_{\\epsilon}}I + \\frac{\\mathbf{b}}{\\mathit{r_{\\epsilon}}^3}\\mathbf{r_{\\epsilon}}\\mathbf{r_{\\epsilon}}^{t} + \\frac{a}{2}\\frac{\\epsilon^2}{r_{\\epsilon}^3}I\\right] \\equiv \\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{f} where \\mathbf{r}_{\\epsilon} = \\sqrt{r^2 + \\epsilon^2} \\mathbf{r}_{\\epsilon} = \\sqrt{r^2 + \\epsilon^2} is the regularized distance, \\epsilon > 0 \\epsilon > 0 is the radius of the sculpting brush. Thus, given a force vector \\mathbf{f} \\mathbf{f} , the displacement for any point in R^3 R^3 can be calculated, thus defining the physically based space deformation. In practice, the force vector is parameterized in terms of the brush tip displacement \\mathbf{\\bar{u}} \\mathbf{\\bar{u}} . To this end, we can expand the regularized kelvinlet equation with the constraint \\mathbf{u}_{\\epsilon}(0) = \\mathbf{\\bar{u}} \\mathbf{u}_{\\epsilon}(0) = \\mathbf{\\bar{u}} to end up with \\mathbf{u_{\\epsilon}} = c\\epsilon\\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{\\bar{u}} \\mathbf{u_{\\epsilon}} = c\\epsilon\\mathbf{K_{\\epsilon}}(\\mathbf{r})\\mathbf{\\bar{u}} where c = 2/(3a - 2b) c = 2/(3a - 2b) Kelvinlets of different radial scales can be linearly combined to construct brushes with arbitrarily fast decays: \\mathbf{u}_{\\epsilon_{1},..\\epsilon_{n}}(\\mathbf{r}) = c \\left( \\sum_{i} \\frac{w_{i}}{\\epsilon_{i}}\\right)^{-1} \\left[\\sum_{i} w_{i}\\mathbf{K_{\\epsilon_{i}}}(\\mathbf{r}) \\right] \\mathbf{\\bar{u}} \\mathbf{u}_{\\epsilon_{1},..\\epsilon_{n}}(\\mathbf{r}) = c \\left( \\sum_{i} \\frac{w_{i}}{\\epsilon_{i}}\\right)^{-1} \\left[\\sum_{i} w_{i}\\mathbf{K_{\\epsilon_{i}}}(\\mathbf{r}) \\right] \\mathbf{\\bar{u}} where w_{i} w_{i} are weights and \\epsilon_{i} < \\epsilon_{i+1} \\epsilon_{i} < \\epsilon_{i+1} . Due to the superposition principle, these compound brushes still satisfy the Navier-Cauchy equation. Regularized kelvinlets can further be extended by replacing the vector-based load distribution with a matrix-based distribution to achieve non-affine transformations like twist, pinch, and scale as described earlier. In libigl, this is computed using: igl :: KelvinletParams < double > brushParams { brushRadius , scale , brushType }; igl :: kelvinlets ( V , origin , forceVec , forceMatrix , brushParams , result ); where brushRadius, scale, brushType correspond to \\epsilon \\epsilon , the falloff, and operation(grab, pinch, scale, twist). ( Example 409 ) pinch, twist, grab and scale in action","title":"Regularized kelvinlets"},{"location":"tutorial/#chapter-5-parametrization","text":"In computer graphics, we denote as surface parametrization a map from the surface to \\(\\mathbf{R}^2\\). It is usually encoded by a new set of 2D coordinates for each vertex of the mesh (and possibly also by a new set of faces in one to one correspondence with the faces of the original surface). Note that this definition is the inverse of the classical differential geometry definition. A parametrization has many applications, ranging from texture mapping to surface remeshing. Many algorithms have been proposed, and they can be broadly divided in four families: Single patch, fixed boundary : these algorithm can parametrize a disk-like part of the surface given fixed 2D positions for its boundary. These algorithms are efficient and simple, but they usually produce high-distortion maps due to the fixed boundary. Single patch, free boundary: these algorithms let the boundary deform freely, greatly reducing the map distortion. Care should be taken to prevent the border from self-intersecting. Global parametrization : these algorithms work on meshes with arbitrary genus. They initially cut the mesh in multiple patches that can be separately parametrized. The generated maps are discontinuous on the cuts (often referred as seams ). Global seamless parametrization : these are global parametrization algorithm that hides the seams, making the parametrization \u201ccontinuous\u201d, under specific assumptions that we will discuss later.","title":"Chapter 5: Parametrization"},{"location":"tutorial/#harmonic-parametrization","text":"Harmonic parametrization 28 is a single patch, fixed boundary parametrization algorithm that computes the 2D coordinates of the flattened mesh as two harmonic functions. The algorithm is divided in 3 steps: Detect of the boundary vertices Map the boundary vertices to a circle Compute two harmonic functions (one for u and one for the v coordinate). The harmonic functions use the fixed vertices on the circle as boundary constraints. The algorithm can be coded using libigl as follows: Eigen :: VectorXi bnd ; igl :: boundary_loop ( V , F , bnd ); Eigen :: MatrixXd bnd_uv ; igl :: map_vertices_to_circle ( V , bnd , bnd_uv ); igl :: harmonic ( V , F , bnd , bnd_uv , 1 , V_uv ); where bnd contains the indices of the boundary vertices, bnd_uv their position on the UV plane, and \u201c1\u201d denotes that we want to compute an harmonic function (2 will be for biharmonic, 3 for triharmonic, etc.). Note that each of the three functions is designed to be reusable in other parametrization algorithms. A UV parametrization can be visualized in the viewer with: viewer . data (). set_uv ( V_uv ); The UV coordinates are then used to apply a procedural checkerboard texture to the mesh ( Example 501 ). ( Example 501 ) Harmonic parametrization. (left) mesh with texture, (right) UV parametrization with texture","title":"Harmonic Parametrization"},{"location":"tutorial/#least-squares-conformal-maps","text":"Least squares conformal maps parametrization 29 minimizes the conformal (angular) distortion of the parametrization. Differently from harmonic parametrization, it does not need to have a fixed boundary. LSCM minimizes the following energy: \\[ E_{LSCM}(\\mathbf{u},\\mathbf{v}) = \\int_X \\frac{1}{2}| \\nabla \\mathbf{u}^{\\perp} - \\nabla \\mathbf{v} |^2 dA \\] which can be rewritten in matrix form as 32 : \\[ E_{LSCM}(\\mathbf{u},\\mathbf{v}) = \\frac{1}{2} [\\mathbf{u},\\mathbf{v}]^t (L_c - 2A) [\\mathbf{u},\\mathbf{v}] \\] where L_c L_c is the cotangent Laplacian matrix and A A is a matrix such that [\\mathbf{u},\\mathbf{v}]^t A [\\mathbf{u},\\mathbf{v}] [\\mathbf{u},\\mathbf{v}]^t A [\\mathbf{u},\\mathbf{v}] is equal to the vector area of the mesh. Using libigl, this matrix energy can be written in a few lines of code. The cotangent matrix can be computed using igl::cotmatrix : SparseMatrix < double > L ; igl :: cotmatrix ( V , F , L ); Note that we want to apply the Laplacian matrix to the u and v coordinates at the same time, thus we need to extend it taking the left Kronecker product with a 2x2 identity matrix: SparseMatrix < double > L_flat ; igl :: repdiag ( L , 2 , L_flat ); The area matrix is computed with igl::vector_area_matrix : SparseMatrix < double > A ; igl :: vector_area_matrix ( F , A ); The final energy matrix is L_{flat} - 2A L_{flat} - 2A . Note that in this case we do not need to fix the boundary. To remove the null space of the energy and make the minimum unique, it is sufficient to fix two arbitrary vertices to two arbitrary positions. The full source code is provided in Example 502 . ( Example 502 ) LSCM parametrization. (left) mesh with texture, (right) UV parametrization","title":"Least Squares Conformal Maps"},{"location":"tutorial/#as-rigid-as-possible-parametrization","text":"As-rigid-as-possible parametrization 31 is a powerful single-patch, non-linear algorithm to compute a parametrization that strives to preserve distances (and thus angles). The idea is very similar to ARAP surface deformation: each triangle is mapped to the plane trying to preserve its original shape, up to a rigid rotation. The algorithm can be implemented reusing the functions discussed in the deformation chapter: igl::arap_precomputation and igl::arap_solve . The only difference is that the optimization has to be done in 2D instead of 3D and that we need to compute a starting point. While for 3D deformation the optimization is bootstrapped with the original mesh, this is not the case for ARAP parametrization since the starting point must be a 2D mesh. In Example 503 , we initialize the optimization with harmonic parametrization. Similarly to LSCM, the boundary is free to deform to minimize the distortion. ( Example 503 ) As-Rigid-As-Possible parametrization. (left) mesh with texture, (right) UV parametrization with texture","title":"As-rigid-as-possible Parametrization"},{"location":"tutorial/#n-rotationally-symmetric-tangent-fields","text":"The design of tangent fields is a basic tool used to design guidance fields for uniform quadrilateral and hexahedral remeshing. Libigl contains an implementation of all the state-of-the-art algorithms to design N-RoSy fields and their generalizations. In libigl, tangent unit-length vector fields are piece-wise constant on the faces of a triangle mesh, and they are described by one or more vectors per-face. The function igl :: nrosy ( V , F , b , bc , b_soft , b_soft_weight , bc_soft , N , 0.5 , output_field , output_singularities ); creates a smooth unit-length vector field (N=1) starting from a sparse set of constrained faces, whose indices are listed in b and their constrained value is specified in bc. The functions supports soft_constraints (b_soft, b_soft_weight, bc_soft), and returns the interpolated field for each face of the triangle mesh (output_field), plus the singularities of the field (output_singularities). Design of a unit-length vector field The singularities are vertices where the field vanishes (highlighted in red in the figure above). igl::nrosy can also generate N-RoSy fields 30 , which are a generalization of vector fields where in every face the vector is defined up to a constant rotation of 2\\pi / N 2\\pi / N . As can be observed in the following figure, the singularities of the fields generated with different N are of different types and they appear in different positions. Design of a 2-,4- and 9-RoSy field We demonstrate how to call and plot N-RoSy fields in Example 504 , where the degree of the field can be change pressing the number keys. igl::nrosy implements the algorithm proposed in 26 . N-RoSy fields can also be interpolated with many other algorithms, see the library libdirectional for a reference implementation of the most popular ones. For a complete categorization of fields used in various applications see Vaxman et al. 2016 34 .","title":"N-rotationally Symmetric Tangent Fields"},{"location":"tutorial/#global-seamless-integer-grid-parametrization","text":"The previous parametrization methods were focusing on creating parametrizations of surface patches aimed at texture mapping or baking of other surface properties such as normals and high-frequency details. Global, seamless parametrization aims at parametrizing complex shapes with a parametrization that is aligned with a given set of directions for the purpose of surface remeshing. In libigl, we provide a reference implementation of the pipeline proposed in the mixed integer quadrangulation paper 26 . The first step involves the design of a 4-RoSy field (sometimes called cross field) that describes the alignment of the edges of the desired quadrilateral remeshing. The field constraints are usually manually specified or extracted from the principal curvature directions. In Example 506 , we simply fix one face in a random direction. Initial cross field prescribing the edge alignment.","title":"Global, Seamless Integer-grid Parametrization"},{"location":"tutorial/#combing-and-cutting","text":"Given the cross field, we now want to cut the surface so that it becomes homeomorphic to a disk. While this could be done directly on the cross-field, we opt to perform this operation on its bisector field (a copy of the field rotated by 45 degrees) since it is more stable and generic. Working on the bisectors allow us to take as input generalized, non-orthogonal and non-unit length cross fields. We thus rotate the field, Bisector field. and we remove the rotation ambiguity by assigning to each face a u and a v direction. The assignment is done with a breadth-first search starting from a random face. Combed bisector field. You can imagine this process as combing a hairy surface: you will be able to comb part of it, but at some point you will not be able to consistently comb the entire surface ( Hairy ball theorem ). The discontinuities in the combing define the cut graph: Cut graph. Finally, we rotate the combed field by 45 degrees to undo the initial degrees rotation: Combed cross field. The combed cross field can be seen as the ideal Jacobian of the parametrization that will be computed in the next section.","title":"Combing And Cutting"},{"location":"tutorial/#poisson-parametrization","text":"The mesh is cut along the seams and a parametrization is computed trying to find two scalar functions whose gradient matches the combed cross field directions. This is a classical Poisson problem, that is solved minimizing the following quadratic energy: \\[ E(\\mathbf{u},\\mathbf{v}) = |\\nabla \\mathbf{u} - X_u|^2 + |\\nabla \\mathbf{v} - X_v|^2 \\] where X_u X_u and X_u X_u denotes the combed cross field. Solving this problem generates a parametrization whose u and v isolines are aligned with the input cross field. Poisson parametrization. We hide the seams by adding integer constraints to the Poisson problem that align the isolines on both sides of each seam 26 . Seamless Poisson parametrization. Note that this parametrization can only be used for remeshing purposes, since it contains many overlaps. Seamless Poisson parametrization (in 2D). A quad mesh can be extracted from this parametrization using libQEx (not included in libigl). The full pipeline is implemented in Example 505 .","title":"Poisson Parametrization"},{"location":"tutorial/#anisotropic-remeshing","text":"Anisotropic and non-uniform quad remeshing is important to concentrate the elements in the regions with more details. It is possible to extend the MIQ quad meshing framework to generate anisotropic quad meshes using a mesh deformation approach 33 . The input of the anisotropic remeshing algorithm is a sparse set of constraints that define the shape and scale of the desired quads. This can be encoded as a frame field, which is a pair of non-orthogonal and non-unit length vectors. The frame field can be interpolated by decomposing it in a 4-RoSy field and a unique affine transformation. The two parts can then be interpolated separately, using igl::nrosy for the cross field, and an harmonic interpolant for the affine part. Interpolation of a frame field. Colors on the vectors denote the desired scale. The red faces contains the frame field constraints. After the interpolation, the surface is warped to transform each frame into an orthogonal and unit length cross (i.e. removing the scaling and skewness from the frame). This deformation defines a new embedding (and a new metric) for the surface. The surface is deformed to transform the frame field in a cross field. The deformed surface can the be isotropically remeshed using the MIQ algorithm that has been presented in the previous section. The deformed surface is isotropically remeshed. The UV coordinates of the deformed surface can then be used to transport the parametrization to the original surface, where the isolines will trace a quad mesh whose elements are similar to the shape prescribed in the input frame field. The global parametrization is lifted to the original surface to create the anisotropic quad meshing. Our implementation ( Example 506 ) uses MIQ to generate the UV parametrization, but other algorithms could be applied: the only desiderata is that the generated quad mesh should be as isotropic as possible.","title":"Anisotropic Remeshing"},{"location":"tutorial/#planarization","text":"A quad mesh can be transformed in a planar quad mesh with Shape-Up 27 , a local/global approach that uses the global step to enforce surface continuity and the local step to enforce planarity. Example 507 planarizes a quad mesh until it satisfies a user-given planarity threshold. A non-planar quad mesh (left) is planarized using the libigl function igl::planarize (right). The colors represent the planarity of the quads.","title":"Planarization"},{"location":"tutorial/#chapter-6-external-libraries","text":"An additional positive side effect of using matrices as basic types is that it is easy to exchange data between libigl and other software and libraries.","title":"Chapter 6: External Libraries"},{"location":"tutorial/#state-serialization","text":"Geometry processing applications often require a considerable amount of computational time and/or manual input. Serializing the state of the application is a simple strategy to greatly increase the development efficiency. It allows to quickly start debugging just before the crash happens, avoiding to wait for the precomputation to take place every time and it also makes your experiments reproducible, allowing to quickly test algorithms variants on the same input data. Serialization is often not considered in geometry processing due to the extreme difficulty in serializing pointer-based data structures, such as an half-edge data structure ( OpenMesh , CGAL ), or a pointer based indexed structure ( VCG ). In libigl, serialization is much simpler, since the majority of the functions use basic types, and pointers are used in very rare cases (usually to interface with external libraries). Libigl bundles a simple and self-contained binary and XML serialization framework, that drastically reduces the overhead required to add serialization to your applications. To de-/serialize a set of variables use the following method: #include \"igl/serialize.h\" bool b = true ; unsigned int num = 10 ; std :: vector < float > vec = { 0.1 , 0.002 , 5.3 }; // use overwrite = true for the first serialization to create or overwrite an // existing file igl :: serialize ( b , \"B\" , \"filename\" , true ); // append following serialization to existing file igl :: serialize ( num , \"Number\" , \"filename\" ); igl :: serialize ( vec , \"VectorName\" , \"filename\" ); // deserialize back to variables igl :: deserialize ( b , \"B\" , \"filename\" ); igl :: deserialize ( num , \"Number\" , \"filename\" ); igl :: deserialize ( vec , \"VectorName\" , \"filename\" ); Currently all fundamental data types (bool, int, float, double, \u2026) are supported, as well as std::string, basic STL containers, dense and sparse Eigen matrices and nestings of those. Some limitations apply to pointers. Currently, loops or many to one type of link structures are not handled correctly. Each pointer is assumed to point to a different independent object. Uninitialized pointers must be set to nullptr before de-/serialization to avoid memory leaks. Cross-platform issues like little-, big-endianess is currently not supported. To make user defined types serializable, just derive from igl::Serializable and trivially implementing the InitSerialization method. Assume that the state of your application is a mesh and a set of integer ids: #include \"igl/serialize.h\" struct State : public igl :: Serializable { Eigen :: MatrixXd V ; Eigen :: MatrixXi F ; std :: vector < int > ids ; void InitSerialization () { this -> Add ( V , \"V\" ); this -> Add ( F , \"F\" ); this -> Add ( ids , \"ids\" ); } }; If you need more control over the serialization of your types, you can override the following functions or directly inherit from the interface igl::SerializableBase . bool Serializable::PreSerialization () const ; void Serializable::PostSerialization () const ; bool Serializable::PreDeserialization (); void Serializable::PostDeserialization (); Alternatively, if you want a non-intrusive way of serializing your state you can overload the following functions: namespace igl { namespace serialization { template <> inline void serialize ( const State & obj , std :: vector < char >& buffer ) { :: igl :: serialize ( obj . V , std :: string ( \"V\" ), buffer ); :: igl :: serialize ( obj . F , std :: string ( \"F\" ), buffer ); :: igl :: serialize ( obj . ids , std :: string ( \"ids\" ), buffer ); } template <> inline void deserialize ( State & obj , const std :: vector < char >& buffer ) { :: igl :: deserialize ( obj . V , std :: string ( \"V\" ), buffer ); :: igl :: deserialize ( obj . F , std :: string ( \"F\" ), buffer ); :: igl :: deserialize ( obj . ids , std :: string ( \"ids\" ), buffer ); } } } Equivalently, you can use the following macros: SERIALIZE_TYPE ( State , SERIALIZE_MEMBER ( V ) SERIALIZE_MEMBER ( F ) SERIALIZE_MEMBER_NAME ( ids , \"ids\" ) ) All the former code is for binary serialization which is especially useful if you have to handle larger data where the loading and saving times become more important. For cases where you want to read and edit the serialized data by hand we provide a serialization to XML files which is based on the library tinyxml2 . There you also have the option to create a partial binary serialization of your data by using the binary parameter, exposed in the function serialize_xml() : #include \"igl/xml/serialize_xml.h\" int number ; // binary = false, overwrite = true igl :: serialize_xml ( vec , \"VectorXML\" , xmlFile , false , true ); // binary = true, overwrite = true igl :: serialize_xml ( vec , \"VectorBin\" , xmlFile , true , true ); igl :: deserialize_xml ( vec , \"VectorXML\" , xmlFile ); igl :: deserialize_xml ( vec , \"VectorBin\" , xmlFile ); For user defined types derive from XMLSerializable . The code snippets above are extracted from Example 601 . We strongly suggest that you make the entire state of your application always serializable since it will save you a lot of troubles when you will be preparing figures for a scientific report. It is very common to have to do small changes to figures, and being able to serialize the entire state just before you take screenshots will save you many painful hours before a submission deadline.","title":"State Serialization"},{"location":"tutorial/#mixing-matlab-code","text":"Libigl can be interfaced with Matlab to offload numerically heavy computation to a Matlab script. The major advantage of this approach is that you will be able to develop efficient and complex user-interfaces in C++, while exploring the syntax and fast protototyping features of matlab. In particular, the use of an external Matlab script in a libigl application allows to change the Matlab code while the C++ application is running, greatly increasing coding efficiency. We demonstrate how to integrate Matlab in a libigl application in Example 602 . The example uses Matlab to compute the Eigenfunctions of the discrete Laplacian operator, relying on libigl for mesh IO, visualization and for computing the Laplacian operator. Libigl can connect to an existing instance of Matlab (or launching a new one on Linux/MacOSX) using: igl :: mlinit ( & engine ); The cotangent Laplacian is computed using igl::cotmatrix and uploaded to the Matlab workspace: igl :: cotmatrix ( V , F , L ); igl :: mlsetmatrix ( & engine , \"L\" , L ); It is now possible to use any Matlab function on the data. For example, we can see the sparsity pattern of L using spy: igl :: mleval ( & engine , \"spy(L)\" ); The Matlab spy function is called from a libigl-based application. The results of Matlab computations can be returned back to the C++ application igl :: mleval ( & engine , \"[EV,~] = eigs(-L,10,'sm')\" ); igl :: mlgetmatrix ( & engine , \"EV\" , EV ); and plotted using the libigl viewer. Eigenfunctions of the Laplacian computed in Matlab, plotted in the libigl viewer.","title":"Mixing Matlab Code"},{"location":"tutorial/#saving-a-matlab-workspace","text":"To aid debugging, libigl also supplies functions to write Matlab .mat \u201cWorkspaces\u201d. This C++ snippet saves a mesh and it\u2019s sparse Laplacian matrix to a file: igl :: readOFF ( TUTORIAL_SHARED_PATH \"/fertility.off\" , V , F ); igl :: cotmatrix ( V , F , L ); igl :: MatlabWorkspace mw ; mw . save ( V , \"V\" ); mw . save_index ( F , \"F\" ); mw . save ( L , \"L\" ); mw . write ( \"fertility.mat\" ); Then this workspace can be loaded into a Matlab IDE: load fertility . mat The igl::MatlabWorkspace depends on Matlab libraries to compile and run, but\u2014in contrast to the engine routines above\u2014will avoid launching a Matlab instance upon execution.","title":"Saving A Matlab Workspace"},{"location":"tutorial/#dumping-eigen-matrices-to-copy-and-paste-into-matlab","text":"Eigen supplies a sophisticated API for printing its matrix types to the screen. Libigl has wrapped up a particularly useful formatting which makes it simple to copy standard output from a C++ program into a Matlab IDE. The code: igl :: readOFF ( TUTORIAL_SHARED_PATH \"/2triangles.off\" , V , F ); igl :: cotmatrix ( V , F , L ); std :: cout << igl :: matlab_format ( V , \"V\" ) << std :: endl ; std :: cout << igl :: matlab_format (( F . array () + 1 ). eval (), \"F\" ) << std :: endl ; std :: cout << igl :: matlab_format ( L , \"L\" ) << std :: endl ; produces the output: V = [ 0 0 0 1 0 0 1 1 1 2 1 0 ]; F = [ 1 2 3 2 4 3 ]; LIJV = [ 1 1 - 0.7071067811865476 2 1 0.7071067811865475 3 1 1.570092458683775e-16 1 2 0.7071067811865475 2 2 - 1.638010440969447 3 2 0.6422285251880865 4 2 0.2886751345948129 1 3 1.570092458683775e-16 2 3 0.6422285251880865 3 3 - 0.9309036597828995 4 3 0.2886751345948129 2 4 0.2886751345948129 3 4 0.2886751345948129 4 4 - 0.5773502691896258 ]; L = sparse ( LIJV (:, 1 ), LIJV (:, 2 ), LIJV (:, 3 )); which is easily copied and pasted into Matlab for debugging, etc.","title":"Dumping Eigen Matrices To Copy And Paste Into Matlab"},{"location":"tutorial/#calling-libigl-functions-from-matlab","text":"It is also possible to call libigl functions from matlab, compiling them as MEX functions. This can be used to offload to C++ code the computationally intensive parts of a Matlab application. We provide a wrapper for igl::readOBJ in Example 603 . We plan to provide wrappers for all our functions in the future, if you are interested in this feature (or if you want to help implementing it) please let us know.","title":"Calling Libigl Functions From Matlab"},{"location":"tutorial/#triangulation-of-closed-polygons","text":"The generation of high-quality triangle and tetrahedral meshes is a very common task in geometry processing. We provide wrappers in libigl to triangle and Tetgen . A triangle mesh with a given boundary can be created with: igl :: triangulate ( V , E , H , V2 , F2 , \"a0.005q\" ); where E is a set of boundary edges (#E by 2), H is a set of 2D positions of points contained in holes of the triangulation (#H by 2) and ( V2 , F2 ) is the generated triangulation. Additional parameters can be passed to triangle , to control the quality: \"a0.005q\" enforces a bound on the maximal area of the triangles and a minimal angle of 20 degrees. In Example 604 , the interior of a square (excluded a smaller square in its interior) is triangulated. Triangulation of the interior of a polygon.","title":"Triangulation Of Closed Polygons"},{"location":"tutorial/#tetrahedralization-of-closed-surfaces","text":"Similarly, the interior of a closed manifold surface can be tetrahedralized using the function igl::tetrahedralize which wraps the Tetgen library ( Example 605 ): igl :: tetrahedralize ( V , F , \"pq1.414\" , TV , TT , TF ); Tetrahedralization of the interior of a surface mesh.","title":"Tetrahedralization Of Closed Surfaces"},{"location":"tutorial/#baking-ambient-occlusion","text":"Ambient occlusion is a rendering technique used to calculate the exposure of each point in a surface to ambient lighting. It is usually encoded as a scalar (normalized between 0 and 1) associated with the vertice of a mesh. Formally, ambient occlusion is defined as: \\[ A_p = \\frac{1}{\\pi} \\int_\\omega V_{p,\\omega}(n \\cdot \\omega) d\\omega \\] where V_{p,\\omega} V_{p,\\omega} is the visibility function at p, defined to be zero if p is occluded in the direction \\omega \\omega and one otherwise, and d\\omega d\\omega is the infinitesimal solid angle step of the integration variable \\omega \\omega . The integral is usually approximated by casting rays in random directions around each vertex. This approximation can be computed using the function: igl :: ambient_occlusion ( V , F , V_samples , N_samples , 500 , AO ); that given a scene described in V and F , computes the ambient occlusion of the points in V_samples whose associated normals are N_samples . The number of casted rays can be controlled (usually at least 300-500 rays are required to get a smooth result) and the result is returned in AO , as a single scalar for each sample. Ambient occlusion can be used to darken the surface colors, as shown in Example 606 A mesh rendered without (left) and with (right) ambient occlusion.","title":"Baking Ambient Occlusion"},{"location":"tutorial/#screen-capture","text":"Libigl supports read and writing to .png files via the stb image code. With the viewer used in this tutorial, it is possible to render the scene in a memory buffer using the function, igl::opengl::ViewerCore::draw_buffer : // Allocate temporary buffers for 1280x800 image Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > R ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > G ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > B ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > A ( 1280 , 800 ); // Draw the scene in the buffers viewer . core . draw_buffer ( viewer . data (), false , R , G , B , A ); // Save it to a PNG igl :: png :: writePNG ( R , G , B , A , \"out.png\" ); In Example 607 a scene is rendered in a temporary png and used to texture a quadrilateral.","title":"Screen Capture"},{"location":"tutorial/#off-screen-rendering-using-ray-tracing-with-embree","text":"If libigl is compiled without OpenGL support, or when the interactive viewer is not practical, it is still possible to render view in memory using Embree library. Currently only triangular meshes are supported. The usage is very similar to the Screen Capture tutorial. // Create embree renderer object igl :: embree :: EmbreeRenderer er ; // Specify mesh, tell embree to optimize for static scene er . set_mesh ( V , F , true ); // Specify scalar data, use JET color map to convert to colors er . set_data ( K , igl :: COLOR_MAP_TYPE_JET ); // Since the render is not interactive, need to specify scene parameters // the default view is identical to the interactive viewer Eigen :: Matrix3d rot_matrix ; // Specify rotation matrix: // 10 degrees around X axis // 5 degrees around Y axis // 4 degrees around Z axis rot_matrix = Eigen :: AngleAxisd ( 10 * igl :: PI / 180.0 , Eigen :: Vector3d :: UnitX ()) * Eigen :: AngleAxisd ( 5 * igl :: PI / 180.0 , Eigen :: Vector3d :: UnitY ()) * Eigen :: AngleAxisd ( 4 * igl :: PI / 180.0 , Eigen :: Vector3d :: UnitZ ()); er . set_rot ( rot_matrix ); // Specify relative zoom factor er . set_zoom ( 1.5 ); // Request orthographic projection er . set_orthographic ( false ); // Allocate temporary buffers for 1280x800 image Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > R ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > G ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > B ( 1280 , 800 ); Eigen :: Matrix < unsigned char , Eigen :: Dynamic , Eigen :: Dynamic > A ( 1280 , 800 ); // Render view er . render_buffer ( R , G , B , A ); // Save it to a PNG igl :: png :: writePNG ( R , G , B , A , png_file ); Fertility statue showing curvature as scalar field, rendered with embree In Example 608 a scene is rendered in a memory buffer and saved as png file.","title":"Off-screen rendering using ray tracing with Embree"},{"location":"tutorial/#boolean-operations-on-meshes","text":"Constructive solid geometry (CSG) is a technique to define a complex surface as the result of a number of set operations on solid regions of space: union, intersection, set difference, symmetric difference, complement. Typically, CSG libraries represent the inputs and outputs to these operations implicitly : the solid A A is defined as the open set of points \\mathbf{x} \\mathbf{x} for which some function a(\\mathbf{x}) a(\\mathbf{x}) \u201creturns true\u201d. The surface of this shape is the closure of all points x x in A A . With this sort of representation, boolean operations are straightforward. For example, the union of solids A A and B B is simply A \\cup B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ or } b(\\mathbf{x})\\}, A \\cup B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ or } b(\\mathbf{x})\\}, the intersection is A \\cap B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and } b(\\mathbf{x})\\}, A \\cap B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and } b(\\mathbf{x})\\}, the difference A A minus B B is A \\setminus B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and _not_ } b(\\mathbf{x})\\}, A \\setminus B = \\{\\mathbf{x} \\left.\\right| a(\\mathbf{x}) \\text{ and _not_ } b(\\mathbf{x})\\}, and the symmetric difference (XOR) is A \\triangle B = \\{\\mathbf{x} \\left.\\right| \\text{either } a(\\mathbf{x}) \\text{ or } b(\\mathbf{x}) \\text{ but not both }\\}. A \\triangle B = \\{\\mathbf{x} \\left.\\right| \\text{either } a(\\mathbf{x}) \\text{ or } b(\\mathbf{x}) \\text{ but not both }\\}. Stringing together many of these operations, one can design quite complex shapes. A typical CSG library might only keep explicit base-case representations of canonical shapes: half-spaces, quadrics, etc. In libigl, we currently do not have an implicit surface representation. Instead we expect our users to be working with explicit triangle mesh boundary representations of solid shapes. CSG operations are much hard to compute robustly with boundary representations, but are nonetheless useful. To compute a boolean operation on a triangle mesh with vertices VA and triangles FA and another mesh VB and FB , libigl first computes a unified \u201cmesh arrangement\u201d (see 36 []) with vertices V and triangles F where all triangle-triangle intersections have been \u201cresolved\u201d. That is, edges and vertices are added exactly at the intersection lines, so the resulting non-manifold mesh (V,F) has no self-intersections. Then libigl labels each \u201ccell\u201d bounded by surfaces of the arrangement according to its winding number vector : winding number with respect to each input mesh (w_A,w_B) (w_A,w_B) . Finally, according to the desired operation (e.g. union, intersection) the boundary of the corresponding cells are extracted. Calling libigl\u2019s boolean operations is simple. To compute the union of (VA,FA) and (VB,FB) into a new mesh (VC,FC) , use: igl :: copyleft :: cgal :: mesh_boolean ( VA , FA , VB , FB , MESH_BOOLEAN_TYPE_UNION , VC , FC ); The following figure shows each boolean operation on two meshes. The example Boolean conducts boolean operations on the Cheburashka (red) and Knight (green). From left to right: union, intersection, set minus, symmetric difference (XOR), \u201cresolve\u201d. Bottom row reveals inner surfaces, darker color indicates back-facing triangles. The union, symmetric difference and \u201cresolve\u201d have the same outward appearance, but differ in their treatment of internal structures. The union has no internal surfaces: the triangles are not included in the output. The symmetric difference is the same set of triangles as the \u201cresolve\u201d, but internal surfaces have been reversed in orientation, indicating that the solid result of the operation. The \u201cresolve\u201d operation is not really a boolean operation, it is simply the result of resolving all intersections and gluing together coincident vertices, maintaining original triangle orientations. Libigl also provides a wrapper igl::copyleft::cork::mesh_boolean to the cork , which is typically faster, but is not always robust.","title":"Boolean Operations On Meshes"},{"location":"tutorial/#csg-tree","text":"The previous section discusses using igl::copyleft::cgal::mesh_boolean to compute the result of a single boolean operation on two input triangle meshes. When employing constructive solid geometry (CSG) as a modeling paradigm, shapes are represented as the result of many such binary operations. The sequence is stored in a binary tree. Libigl uses exact arithmetic internally to construct the intermediary boolean results robustly. \u201cRounding\u201d this result to floating point (even double precision) would cause problems if re-injected into a further boolean operation. To facilitate CSG tree operations and encourage callers not to call igl::copyleft::cgal::mesh_boolean multiple times explicitly, libigl implements a class igl::copyleft::cgal::CSGTree . Leaf nodes of this class are simply \u201csolid\u201d meshes (otherwise good input to igl::copyleft::cgal::mesh_boolean ). Interior nodes of the tree combine two children with a boolean operation. Using the intializer list constructor it is easy to hard-code specific tree constructions. Here\u2019s an example taking the intersection of a cube A and sphere B minus the union of three cylinders: // Compute result of (A \u2229 B) \\ ((C \u222a D) \u222a E) igl :: copyleft :: cgal :: CSGTree < MatrixXi > CSGTree = { { { VA , FA },{ VB , FB }, \"i\" },{ { { VC , FC },{ VD , FD }, \"u\" }, { VE , FE }, \"u\" }, \"m\" }; A CSG Tree represents a shape as a combination of binary boolean operations Example 610 computes each intermediary CSG result and then the final composite. Example 610 computes complex CSG Tree operation on 5 input meshes.","title":"Csg Tree"},{"location":"tutorial/#chapter-7-miscellaneous","text":"Libigl contains a wide variety of geometry processing tools and functions for dealing with meshes and the linear algebra related to them: far too many to discuss in this introductory tutorial. We\u2019ve pulled out a couple of the interesting functions in this chapter to highlight.","title":"Chapter 7: Miscellaneous"},{"location":"tutorial/#mesh-statistics","text":"Libigl contains various mesh statistics, including face angles, face areas and the detection of singular vertices, which are vertices with more or less than 6 neighbours in triangulations or 4 in quadrangulations. The example Statistics computes these quantities and does a basic statistic analysis that allows to estimate the isometry and regularity of a mesh: Irregular vertices: 136 /2400 ( 5 .67% ) Areas ( Min/Max ) /Avg_Area Sigma: 0 .01/5.33 ( 0 .87 ) Angles in degrees ( Min/Max ) Sigma: 17 .21/171.79 ( 15 .36 ) The first row contains the number and percentage of irregular vertices, which is particularly important for quadrilateral meshes when they are used to define subdivision surfaces: every singular point will result in a point of the surface that is only C^1. The second row reports the area of the minimal element, maximal element and the standard deviation. These numbers are normalized by the mean area, so in the example above 5.33 max area means that the biggest face is 5 times larger than the average face. An ideal isotropic mesh would have both min and max area close to 1. The third row measures the face angles, which should be close to 60 degrees (90 for quads) in a perfectly regular triangulation. For FEM purposes, the closer the angles are to 60 degrees the more stable will the optimization be. In this case, it is clear that the mesh is of bad quality and it will probably result in artifacts if used for solving PDEs.","title":"Mesh Statistics"},{"location":"tutorial/#generalized-winding-number","text":"The problem of tetrahedralizing the interior of closed watertight surface mesh is a difficult, but well-posed problem (see our Tetgen wrappers ). But black-box tet-meshers like TetGen will refuse input triangle meshes with self-intersections, open boundaries, non-manifold edges from multiple connected components. The problem is two-fold: self-intersections present contradictory facet constraints and self-intersections/open-boundaries/non-manifold edges make the problem of determining inside from outside ill-posed without further assumptions. The first problem is easily solved by \u201cresolving\u201d all self-intersections. That is, meshing intersecting triangles so that intersects occur exactly at edges and vertices. This is accomplished using igl::selfintersect . TetGen can usually tetrahedralize the convex hull of this \u201cresolved\u201d mesh, and then the problem becomes determining which of these tets are inside the input mesh and which are outside. That is, which should be kept and which should be removed. The \u201cGeneralized Winding Number\u201d is a robust method for determined inside and outside for troublesome meshes 40 . The generalized winding number with respect to (V,F) at some point \\mathbf{p} \\in \\mathcal{R}^3 \\mathbf{p} \\in \\mathcal{R}^3 is defined as scalar function: w(\\mathbf{p}) = \\sum\\limits_{f_i\\in F} \\frac{1}{4\\pi}\\Omega_{f_i}(\\mathbf{p}) w(\\mathbf{p}) = \\sum\\limits_{f_i\\in F} \\frac{1}{4\\pi}\\Omega_{f_i}(\\mathbf{p}) where \\Omega_{f_i} \\Omega_{f_i} is the solid angle subtended by f_i f_i (the ith face in F ) at the point \\mathbf{p} \\mathbf{p} . This solid angle contribution is a simple, closed-form expression involving atan2 and some dot-products. If (V,F) does form a closed watertight surface, then w(\\mathbf{p})=1 w(\\mathbf{p})=1 if \\mathbf{p} \\mathbf{p} lies inside (V,F) and w(\\mathbf{p})=0 w(\\mathbf{p})=0 if outside (V,F) . If (V,F) is closed but overlaps itself then w(\\mathbf{p}) w(\\mathbf{p}) is an integer value counting how many (signed) times (V,F) wraps around \\mathbf{p} \\mathbf{p} . Finally, if (V,F) is not closed or not even manifold (but at least consistently oriented), then w(\\mathbf{p}) w(\\mathbf{p}) tends smoothly toward 1 as \\mathbf{p} \\mathbf{p} is more inside (V,F) , and toward 0 as \\mathbf{p} \\mathbf{p} is more outside. Example 702 computes the generalized winding number function for a tetrahedral mesh inside a cat with holes and self intersections (gold). The silver mesh is surface of the extracted interior tets, and slices show the winding number function on all tets in the convex hull: blue (~0), green (~1), yellow (~2).","title":"Generalized Winding Number"},{"location":"tutorial/#mesh-decimation","text":"The study of mesh simplification or decimation is nearly as old as meshes themselves. Given a high resolution mesh with too many triangles, find a \u201cwell approximating\u201d low resolution mesh with far fewer triangles. By now there are a variety of different paradigms for solving this problem and state-of-the-art methods are fairly advanced. One family of mesh decimation methods operates by successively remove elements from the mesh. In particular, Hoppe advocates for successively remove or rather collapsing edges 39 []. The generic form of this technique is to construct a sequence of n meshes from the initial high-resolution mesh M_0 M_0 to the lowest resolution mesh M_n M_n by collapsing a single edge: M_0 \\mathop{\\longrightarrow}_\\text{edge collapse} M_1 \\mathop{\\longrightarrow}_\\text{edge collapse} \\dots \\mathop{\\longrightarrow}_\\text{edge collapse} M_{n-1} \\mathop{\\longrightarrow}_\\text{edge collapse} M_n. M_0 \\mathop{\\longrightarrow}_\\text{edge collapse} M_1 \\mathop{\\longrightarrow}_\\text{edge collapse} \\dots \\mathop{\\longrightarrow}_\\text{edge collapse} M_{n-1} \\mathop{\\longrightarrow}_\\text{edge collapse} M_n. Hoppe\u2019s original method and subsequent follow-up works propose various ways to choose the next edge to collapse in this sequence. Using a cost-based paradigm, one can maintain a priority queue of edges based on their \u201ccost\u201d (how much \u201cworse\u201d will my approximation be if I remove this edge?). The cheapest edge is collapsed and costs of neighboring edges are updated. In order to maintain the topology (e.g. if the mesh is combinatorially as sphere or a torus etc.), one should assign infinite cost to edges whose collapse would alter the mesh topology. Indeed this happens if and only if the number of mutual neighbors of the endpoints of the collapsing edge is not exactly two! If there exists a third shared vertex, then another face will be removed, but 2 edges will be removed. This can result in unwanted holes or non-manifold \u201cflaps\u201d. A valid edge collapse and an invalid edge collapse. There is also a one-off condition that no edges of a tetrahedron should be collapsed. Because libigl (purposefully) does not center its implementations around a dynamic mesh data structure (e.g. half-edge datastructure), support for topology changes are limited. Nonetheless, libigl has support for isolated edge collapses, sequences of edge-collapses (each in O(log) time) and priority queue based decimation. The simplest is igl::decimation . By calling igl :: decimate ( V , F , 1000 , U , G ); the mesh (V,F) will be decimated to a new mesh (U,G) so that G has at most 1000 faces. This uses default (naive) criteria for determining the cost of an edge collapse and the placement of the merged vertex. Shortest edges are collapsed first, and merged vertices are placed at edge midpoints. One can also provide function handles ( c++ lambda functions are convenient here) cost_and_placement and stopping_condition for determining the cost/placement of an edge collapse and the stopping condition respectively. For example, the default version above is implemented as: igl :: decimate ( V , F , shortest_edge_and_midpoint , max_m , U , G ); where shortest_edge_and_midpoint assign the edge\u2019s length as cost and its midpoint as the merged vertex placement and max_m counts the current number of faces (valid collapses decrease count by 2) and returns true if the count drops below m=1000 . One can also scratch deeper inside the decimation loop and call igl::collapse_edge directly. In order to operate efficiently, this routine needs more than the usual (V,F) mesh representation. We need E a list of edge indices, where E.row(i) --> [s,d] ; we need EMAP which maps the \u201chalf\u201d-edges of each triangle in F to its corresponding edge in E so that E.row(EMAP(f+i*F.rows)) --> [s,d] if the edge across from the ith corner of the fth face is [s,d] (up to orientation); we need EF and EI which keep track of the faces incident on each edge and across from which corner of those faces the edges appears, so that EF(e,o) = f and EI(e,o) = i means that the edge E.row(e) --> [s,d] appears in the fth face across from its ith corner (for o=0 the edge orientations should match, for o=1 the orientations are opposite). When a collapse occurs, the sizes of the F , E , etc. matrices do not change. Rather rows corresponding to \u201cremoved\u201d faces and edges are set to a special constant value IGL_COLLAPSE_EDGE_NULL . Doing this ensures that we\u2019re able to remove edges in truly constant time O(1). Conveniently IGL_COLLAPSE_EDGE_NULL==0 . This means most OPENGL style renderings of F will simply draw a bunch of 0-area triangles at the first vertex. The following will collapse the first edge and place its merged vertex at the origin: igl :: collapse_edge ( 0 , RowVector3d ( 0 , 0 , 0 ), V , F , E , EMAP , EF , EI ); If valid, then V , F , E , EF , EI are adjusted accordingly. This is powerful, but low level. To build a decimator around this you\u2019d need to keep track which edges are left to collapse and which to collapse next. Fortunately, libigl also exposes a priority queue based edge collapse with function handles to adjust costs and placements. The priority queue is implemented as a (ordered) set Q or (cost,edge index) pairs and a list of iterators Qit so that Qit[e] reveals the iterator in Q corresponding to the eth edge. Placements are stored in a #E list of positions C . When the following is called: igl :: collapse_edge ( cost_and_placement , V , F , E , EMAP , EF , EI , Q , Qit , C ); the lowest cost edge collapse according to Q is attempted. If valid, then V , F ,etc. are adjusted accordingly and that edge is \u201cpopped\u201d from Q . Using Qit its neighboring edges are also popped from Q and re-inserted after updating their costs according to cost_and_placement , new placements are remembered in C . If not valid, then the edge is \u201cpopped\u201d from Q and reinserted with infinite cost. Example 703 conducts edge collapses on the fertility model. The Example 703 demonstrates using this priority queue based approach with the simple shortest-edge-midpoint cost/placement strategy discussed above.","title":"Mesh Decimation"},{"location":"tutorial/#signed-distances","text":"In the Generalized Winding Number section , we examined a robust method for determining whether points lie inside or outside of a given triangle soup mesh. Libigl complements this algorithm with accelerated signed and unsigned distance queries and \u201cin element\u201d queries for planar triangle meshes and 3D tetrahedral meshes. These routines make use of libigl\u2019s general purpose axis-aligned bounding box hierarchy ( igl/AABB.h ). This class is lightweight and\u2014by design\u2014does not store a copy of the mesh (taking it as inputs to its member functions instead).","title":"Signed Distances"},{"location":"tutorial/#point-location","text":"For tetrahedral meshes, this is useful for \u201cin element\u201d or \u201cpoint location\u201d queries: given a point \\mathbf{q}\\in\\mathcal{R}^3 \\mathbf{q}\\in\\mathcal{R}^3 and a tetrahedral mesh (V,T) (V,T) determine in which tetrahedron \\mathbf{q} \\mathbf{q} lies. This is accomplished in libigl for a tet mesh V,T and a list of query points in the rows of Q via the igl::in_element() : // Initialize AABB tree igl :: AABB < MatrixXd , 3 > tree ; tree . init ( V , T ); VectorXi I ; igl :: in_element ( V , T , Q , tree , I ); the resulting vector I is a list of indices into T revealing the first tetrahedron found to contain the corresponding point in Q . For overlapping meshes, a point \\mathbf{q} \\mathbf{q} may belong to more than one tetrahedron. In those cases, one can find them all (not just the first) by using the igl::in_element overload with a SparseMatrix as the output: SparseMatrix < int > I ; igl :: in_element ( V , T , Q , tree , I ); now each row of I reveals whether each tet contains the corresponding row in Q : I(q,e)!=0 means that point q is in element e .","title":"Point Location"},{"location":"tutorial/#closest-points","text":"For Triangle meshes, we use the AABB tree to accelerate point-mesh closest point queries: given a mesh (V,F) (V,F) and a query point \\mathbf{q}\\in\\mathcal{R}^3 \\mathbf{q}\\in\\mathcal{R}^3 find the closest point \\mathbf{c} \\in (V,F) \\mathbf{c} \\in (V,F) (where \\mathbf{c} \\mathbf{c} is not necessarily a vertex of (V,F) (V,F) ). This is accomplished for a triangle mesh V,F and a list of points in the rows of P via igl::point_mesh_squared_distance : VectorXd sqrD ; VectorXi I ; MatrixXd C ; igl :: point_mesh_squared_distance ( P , V , F , sqrD , I , C ); the output sqrD contains the (unsigned) squared distance from each point in P to its closest point given in C which lies on the element in F given by I (e.g. from which one could recover barycentric coordinates, using igl::barycentric_coordinates ). If the mesh V,F is static, but the point set P is changing dynamically then it\u2019s best to reuse the AABB hierarchy that\u2019s being built during igl::point_mesh_squared_distance : igl :: AABB tree ; tree . init ( V , F ); tree . squared_distance ( V , F , P , sqrD , I , C ); ... // P changes, but (V,F) does not tree . squared_distance ( V , F , P , sqrD , I , C );","title":"Closest Points"},{"location":"tutorial/#signed-distance","text":"Finally, from the closest point or the winding number it\u2019s possible to sign this distance. In igl::signed_distance we provide two methods for signing: the so-called \u201cpseudo-normal test\u201d 37 [] and the generalized winding number 40 []. The pseudo-normal test (see also igl::pseudonormal_test ) assumes the input mesh is a watertight (closed, non-self-intersecting, manifold) mesh. Then given a query point \\mathbf{q} \\mathbf{q} and its closest point \\mathbf{c} \\in (V,F) \\mathbf{c} \\in (V,F) , it carefully chooses an outward normal \\mathbf{n} \\mathbf{n} at \\mathbf{c} \\mathbf{c} so that \\text{sign}(\\mathbf{q}-\\mathbf{c})\\cdot \\mathbf{n} \\text{sign}(\\mathbf{q}-\\mathbf{c})\\cdot \\mathbf{n} reveals whether \\mathbf{q} \\mathbf{q} is inside (V,F) (V,F) : -1, or outside: +1. This is a fast O(1) O(1) test once \\mathbf{c} \\mathbf{c} is located, but may fail if V,F is not watertight. An alternative is to use the generalized winding number to determine the sign. This is very robust to unclean meshes V,F but slower: something like O(\\sqrt{n}) O(\\sqrt{n}) once \\mathbf{c} \\mathbf{c} is located. In either case, the interface via igl::signed_distance is: // Choose type of signing to use igl :: SignedDistanceType type = SIGNED_DISTANCE_TYPE_PSEUDONORMAL ; igl :: signed_distance ( P , V , F , sign_type , S , I , C , N ); the outputs are as above for igl::point_mesh_squared_distance but now S contains signed (unsquared) distances and the extra output N (only set when type == SIGNED_DISTANCE_TYPE_PSEUDON ) contains the normals used for signing with the pseudo-normal test. Example 704 computes signed distance on slices through the bunny.","title":"Signed Distance"},{"location":"tutorial/#marching-cubes","text":"Often 3D data is captured as scalar field defined over space f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} . Lurking within this field, iso-surfaces of the scalar field are often salient geometric objects. The iso-surface at value v v is composed of all points \\mathbf{x} \\mathbf{x} in \\mathcal{R}^3 \\mathcal{R}^3 such that f(\\mathbf{x}) = v f(\\mathbf{x}) = v . A core problem in geometry processing is to extract an iso-surface as a triangle mesh for further mesh-based processing or visualization. This is referred to as iso-contouring. \u201cMarching Cubes\u201d 42 is a famous method for iso-contouring tri-linear functions f f on a regular lattice (aka grid). The core idea of this method is to contour the iso-surface passing through each cell (if it does at all) with a predefined topology (aka connectivity) chosen from a look up table depending on the function values at each vertex of the cell. The method iterates (\u201cmarches\u201d) over all cells (\u201ccubes\u201d) in the grid and stitches together the final, watertight mesh. In libigl, igl::marching_cubes constructs a triangle mesh (V,F) from an input scalar field S sampled at vertex locations GV of a nx by ny by nz regular grid: igl :: marching_cubes ( S , GV , nx , ny , nz , V , F ); ( Example 705 ) samples signed distance to the input mesh (left) and then reconstructs the surface using marching cubes to contour the 0-level set (center). For comparison, clamping this signed distance field to an indicator function and contouring reveals serious aliasing artifacts.","title":"Marching Cubes"},{"location":"tutorial/#facet-orientation","text":"Models from the web occasionally arrive unorientated in the sense that the orderings of each triangles vertices do not consistently agree. Determining a consistent facet orientation for a mesh is essential for two-sided lighting (e.g., a cloth with red velvet on one side and gold silk on the other side) and for inside-outside determination(e.g., using generalized winding numbers ). For (open) surfaces representing two-sided sheets, libigl provides a routine to force consistent orientations within each orientable patch ( igl::orientable_patches ) of a mesh: igl :: bfs_orient ( F , FF , C ); This simple routine will use breadth-first search on each patch of the mesh to enforce a consistent facet orientation in the output faces FF . For (closed or nearly closed) surfaces representing the boundary of a solid object, libigl provides a routine to reorient faces so that the vertex ordering corresponds to a counter-clockwise ordering of the vertices with a right-hand-rule normal pointing outward. This method 45 [] assumes that most of the universe is empty . That is, most points in space are outside of the solid object than inside. Points are sampled over surface patches. For each sample point, rays are shot into both hemispheres to compute average of the (distance weighted) ambient occlusion on each side. A patch is oriented so that the outward side is less occluded (lighter, i.e., facing more void space). igl :: embree :: reorient_facets_raycast ( V , F , FF , I ); The boolean vector I reveals which rows of F have been flipped in FF . ( Example 706 ) loads a truck model with inconsistent orientations (back facing triangles shown darker). Orientable patches are uniquely colored and then oriented to face outward (middle left). Alternatively, each individual triangle is considered a \u201cpatch\u201d (middle right) and oriented outward independently.","title":"Facet Orientation"},{"location":"tutorial/#swept-volume","text":"The swept volume S S of a moving solid object A A can be defined as any point in space such that at one moment in time the point lies inside the solid. In other words, it is the union of the solid object transformed by the rigid motion f(t) f(t) over time: S = \\bigcup \\limits_{t\\in [0,1]} f(t) A. S = \\bigcup \\limits_{t\\in [0,1]} f(t) A. The surface of the swept volume of a solid bounded by a triangle mesh undergoing a rigid motion with non-trivial rotation is not a surface exactly representably by triangle mesh: it will be a piecewise-ruled surface. To see this, consider the surface swept by a single edge\u2019s line segment as it performs a screw motion. This means that if we\u2019d like to the surface of the swept volume of a triangle mesh undergoing a rigid motion and we\u2019d like the output to be another triangle mesh, then we\u2019re going to have to be happy with some amount of approximation error. With this in mind, the simplest method for computing an approximate swept volume is by exploiting an alternative definition of the swept volume based on signed distances: S = \\left\\{ \\mathbf{p}\\ \\middle| \\ d(\\mathbf{p},\\partial S) < 0 \\right\\} = \\left\\{ \\mathbf{p}\\ \\middle|\\ \\min\\limits_{t \\in [0,1]} d(\\mathbf{p},f(t)\\ \\partial A) < 0 \\right\\} S = \\left\\{ \\mathbf{p}\\ \\middle| \\ d(\\mathbf{p},\\partial S) < 0 \\right\\} = \\left\\{ \\mathbf{p}\\ \\middle|\\ \\min\\limits_{t \\in [0,1]} d(\\mathbf{p},f(t)\\ \\partial A) < 0 \\right\\} If \\partial A \\partial A is a triangle mesh, then we can approximate this by 1) discretizing time at a finite step of steps [0,\\Delta t,2\\Delta t, \\dots, 1] [0,\\Delta t,2\\Delta t, \\dots, 1] and by 2) discretizing space with a regular grid and representing the distance field using trilinear interpolation of grid values. Finally the output mesh, \\partial S \\partial S is approximated by contouring using Marching Cubes 42 . This method is similar to one described by Schroeder et al. in 1994 44 , and the one used in conjunction with boolean operations by Garg et al. 2016 38 . In libigl, if your input solid\u2019s surface is represented by (V,F) then the output surface mesh will be (SV,SF) after calling: igl :: copyleft :: swept_volume ( V , F , num_time_steps , grid_size , isolevel , SV , SF ); The isolevel parameter can be set to zero to approximate the exact swept volume, greater than zero to approximate a positive offset of the swept volume or less than zero to approximate a negative offset. ( Example 707 ) computes the surface of the swept volume (silver) of the bunny model undergoing a rigid motion (gold).","title":"Swept Volume"},{"location":"tutorial/#picking","text":"Picking vertices and faces using the mouse is very common in geometry processing applications. While this might seem a simple operation, its implementation is not straightforward. Libigl contains a function that solves this problem using the Embree raycaster. Its usage is demonstrated in Example 708 : bool hit = igl :: unproject_onto_mesh ( Vector2f ( x , y ), F , viewer . core . view * viewer . core . model , viewer . core . proj , viewer . core . viewport , * ei , fid , bc ); This function casts a ray from the view plane in the view direction. Variables x and y are the mouse screen coordinates; view , model , proj are the view, model and projection matrix respectively; viewport is the viewport in OpenGL format; ei contains a Bounding Volume Hierarchy constructed by Embree, and fid and bc are the picked face and barycentric coordinate of the picked position, respectively. ( Example 708 ) Picking via ray casting. The selected faces are colored in red.","title":"Picking"},{"location":"tutorial/#scalable-locally-injective-maps","text":"The Scalable Locally Injective Maps 43 algorithm allows to compute locally injective maps on massive datasets. The algorithm shares many similarities with ARAP, but uses a reweighting scheme to minimize arbitrary distortion energies, including those that prevent the introduction of flips. Example 709 contains three demos: (1) an example of large scale 2D parametrization, (2) an example of 2D deformation with soft constraints, and (3) an example of 3D deformation with soft constraints. The implementation in libigl is self-contained and relies on Eigen for the solution of the linear system used in the global step. An optimized version that relies on Pardiso is available here . A locally injective parametrization of a mesh with 50k faces is computed using the SLIM algorithm in 10 iterations.","title":"Scalable Locally Injective Maps"},{"location":"tutorial/#simplicial-complex-augmentation-framework-for-bijective-maps","text":"The Simplicial Complex Augmentation Framework 49 algorithm allows to compute bijective maps efficiently and robustly. The algorithm constructed a scaffold structure to take advantage of efficient locally injective mapping algorithms like SLIM, guarantees a overlapping free map with low distortion while being efficient and scalable. Example 710 contains a demo of bijective parameterizing a camel mesh.","title":"Simplicial Complex Augmentation Framework For Bijective Maps"},{"location":"tutorial/#subdivision-surfaces","text":"Given a coarse mesh (aka cage) with vertices V and faces F , one can create a higher-resolution mesh with more vertices and faces by subdividing every face. That is, each coarse triangle in the input is replaced by many smaller triangles. Libigl has three different methods for subdividing a triangle mesh. An \u201cin plane\u201d subdivision method will not change the point set or carrier surface of the mesh. New vertices are added on the planes of existing triangles and vertices surviving from the original mesh are not moved. By adding new faces, a subdivision algorithm changes the combinatorics of the mesh. The change in combinatorics and the formula for positioning the high-resolution vertices is called the \u201csubdivision rule\u201d. For example, in the in plane subdivision method of igl::upsample , vertices are added at the midpoint of every edge: v_{ab} = \\frac{1}{2}(v_a + v_b) v_{ab} = \\frac{1}{2}(v_a + v_b) and each triangle (i_a,i_b,i_c) (i_a,i_b,i_c) is replaced with four triangles: (i_a,i_{ab},i_{ca}) (i_a,i_{ab},i_{ca}) , (i_b,i_{bc},i_{ab}) (i_b,i_{bc},i_{ab}) , (i_{ab},i_{bc},i_{ca}) (i_{ab},i_{bc},i_{ca}) , and (i_{bc},i_{c},i_{ca}) (i_{bc},i_{c},i_{ca}) . This process may be applied recursively, resulting in a finer and finer mesh. The subdivision method of igl::loop is not in plane. The vertices of the refined mesh are moved to weight combinations of their neighbors: the mesh is smoothed as it is refined 41 . This and other smooth subdivision methods can be understood as generalizations of spline curves to surfaces. In particular the Loop subdivision method will converge to a C^1 C^1 surface as we consider the limit of recursive applications of subdivision. Away from \u201cirregular\u201d or \u201cextraordinary\u201d vertices (vertices of the original cage with valence not equal to 6), the surface is C^2 C^2 . The combinatorics (connectivity and number of faces) of igl::loop and igl::upsample are identical: the only difference is that the vertices have been smoothed in igl::loop . Finally, libigl also implements a form of in plane \u201cfalse barycentric subdivision\u201d in igl::false_barycentric_subdivision . This method simply adds the barycenter of every triangle as a new vertex v_{abc} v_{abc} and replaces each triangle with three triangles (i_a,i_b,i_{abc}) (i_a,i_b,i_{abc}) , (i_b,i_c,i_{abc}) (i_b,i_c,i_{abc}) , and (i_c,i_a,i_{abc}) (i_c,i_a,i_{abc}) . In contrast to igl::upsample , this method will create triangles with smaller and smaller internal angles and new vertices will sample the carrier surfaces with extreme bias. The original coarse mesh and three different subdivision methods: igl::upsample , igl::loop and igl::false_barycentric_subdivision .","title":"Subdivision Surfaces"},{"location":"tutorial/#data-smoothing","text":"A noisy function f f defined on a surface \\Omega \\Omega can be smoothed using an energy minimization that balances a smoothing term E_S E_S with a quadratic fitting term: u = \\operatorname{argmin}_u \\alpha E_S(u) + (1-\\alpha)\\int_\\Omega ||u-f||^2 dx u = \\operatorname{argmin}_u \\alpha E_S(u) + (1-\\alpha)\\int_\\Omega ||u-f||^2 dx The parameter \\alpha \\alpha determines how aggressively the function is smoothed. A classical choice for the smoothness energy is the Laplacian energy of the function with zero Neumann boundary conditions, which is a form of the biharmonic energy. It is constructed using the cotangent Laplacian L and the mass matrix M : QL = L'*(M\\L) . Because of the implicit zero Neumann boundary conditions however, the function behavior is significantly warped at the boundary if f f does not have zero normal gradient at the boundary. In 51 it is suggested to use the Biharmonic energy with natural Hessian boundary conditions instead, which corresponds to the Hessian energy with the matrix QH = H'*(M2\\H) , where H is a finite element Hessian and M2 is a stacked mass matrix. The matrices H and QH are implemented in libigl as igl::hessian and igl::hessian_energy respectively. An example of how to use the function is given in Example 712 . In the following image the differences between the Laplacian energy with zero Neumann boundary conditions and the Hessian energy can be clearly seen: whereas the zero Neumann boundary condition in the third image bias the isolines of the function to be perpendicular to the boundary, the Hessian energy gives an unbiased result. ( Example 712 ) From left to right: a function on the beetle mesh, the function with added noise, the result of smoothing with the Laplacian energy and zero Neumann boundary conditions, and the result of smoothing with the Hessian energy.","title":"Data Smoothing"},{"location":"tutorial/#shapeup-projections","text":"Our input is a set of points P_0 P_0 (not necessarily part of any mesh), and a set of constraints S=\\left\\{S_1,S_2,...S_m\\right\\} S=\\left\\{S_1,S_2,...S_m\\right\\} , where each constraint is defined on a different, and sparse, subset of P_0 P_0 . We wish to create a new set of points P P that are close to the original set P_0 P_0 (each point with corresponding indices), while adhering to the constraints. Other objectives, such as smoothness, can be employed. The constraints can be nonlinear, which makes the problem nonconvex, difficult, and without a guaranteed global optimum. A very popular lightweight approach to such problems is a local-global iterative algorithm, comprising these two steps: For iteration k k : 1. Local step : compute the projections of the set P_{k-1} P_{k-1} onto S S , individually per constraint; that would mean fragmenting each point that appears in multiple constraints. That can be a nonlinear operation, but if the constraints are sparse, it is a a set of many small systems. 2. Global step : integrate the set P_k P_k to be as close as possible to the projected fragmented set, with auxiliary objective functions possible. That results in a global, but quadratic objective function. Moreover, the resulting linear system has a constant matrix, and therefore can be pre-factored. The version we implement in libigl is the general version described by 27 , and is in two files: <igl/shapeup.h> and <igl/shapeup_local_projections.h> . A demo implementing regularity constraints (creating a mesh in which each face is as regular as possible) is in Example 713 . The local step is instantiated by a function of type igl::shapeup_projection_function . The global step is done by two functions: igl::shapeup_precomputation() , which precomputes the matrices required for the global step, and igl::shapeup_solve() , which solves the problem, according to the initial solution P_0 P_0 and the input local projection function. The data struct igl::ShapeUpData contains the information necessary to run the algorithm, and can be configured; for instance, the self-explanatory variable Maxiterations . The global step minimizes the following energy: E_{total}=\\lambda_{shape}E_{shape}+\\lambda_{close}E_{close}+\\lambda_{smooth}E_{smooth}, E_{total}=\\lambda_{shape}E_{shape}+\\lambda_{close}E_{close}+\\lambda_{smooth}E_{smooth}, where the \\lambda \\lambda coefficients are encoded in igl::ShapeUpData , and can be updated prior to calling igl::shapeup_precomputation() . The E_{shape} E_{shape} component is the integration energy (fitting P_k P_k to the local projections). The E_{close} E_{close} component is adherence to positional constraints, given by b and bc parameters. The E_{smooth} E_{smooth} component is an optional objective function, to minimize differences (in the Dirichlet sense) between points, encodes by \u201cedges\u201d in parameter E . Both E_{close} E_{close} and E_{shape} E_{shape} are also weighted by wClose and wShape function parameters, respectively. ( Example 713 ) The half-tunnel mesh (left) has been optimized to be almost perfectly regular (right). The color scale is between \\lbrack 0,0.05 \\rbrack \\lbrack 0,0.05 \\rbrack , measuring the average normalized deviation of the angles of each face from 90^{\\circ} 90^{\\circ} .","title":"Shapeup Projections"},{"location":"tutorial/#marching-tetrahedra","text":"Often 3D data is captured as scalar field defined over space f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} f(\\mathbf{x}) : \\mathcal{R}^3 \\rightarrow \\mathcal{R} . Lurking within this field, iso-surfaces of the scalar field are often salient geometric objects. The iso-surface at value v v is composed of all points \\mathbf{x} \\mathbf{x} in \\mathcal{R}^3 \\mathcal{R}^3 such that f(\\mathbf{x}) = v f(\\mathbf{x}) = v . A core problem in geometry processing is to extract an iso-surface as a triangle mesh for further mesh-based processing or visualization. This is referred to as iso-contouring. \u201cMarching Tetrahedra\u201d 46 is a famous method for iso-contouring tri-linear functions f f on a 3D simplicial complex (aka a tet mesh). The core idea of this method is to contour the iso-surface passing through each cell (if it does at all) with a predefined topology (aka connectivity) chosen from a look up table depending on the function values at each vertex of the cell. The method iterates (\u201cmarches\u201d) over all cells (\u201ctetrahedra\u201d) in the complex and stitches together the final mesh. In libigl, igl::marching_tets constructs a triangle mesh (V,F) approximating the iso-level set for the value isovalue from an input scalar field S sampled at the vertices of a tet mesh locations (TV, TT) : igl :: marching_tets ( TV , TT , S , isovalue , V , F );","title":"Marching Tetrahedra"},{"location":"tutorial/#implicit-function-meshing","text":"715_MeshImplicitFunction Entry Missing","title":"Implicit Function Meshing"},{"location":"tutorial/#heat-method-for-fast-geodesic-distance-approximation","text":"In the Exact Discrete Geodesic Distances example above, geodesic distances are computed exactly . This is an expensive operation: O(n\u00b2 log(n)) O(n\u00b2 log(n)) for a mesh with n n edges. In 2013, Crane et al. 47 proposed a method to compute approximate geodesic distances much faster by solving heat equation on the surface, filtering the result and then reconstructing a smooth solution by solving a Poisson equation. The method begins with the observation of Varadhan that the geodesic distance d(\\mathbf{x},\\mathbf{y}) d(\\mathbf{x},\\mathbf{y}) between two points \\mathbf{x} \\mathbf{x} and \\mathbf{y} \\mathbf{y} is equal to the square root of the logarithm of the heat diffused from \\mathbf{x} \\mathbf{x} to \\mathbf{y} \\mathbf{y} after a time t t : \\[ d(\\mathbf{x},\\mathbf{y}) = \\lim_{t\u21920} \\sqrt{ -4 t \\log k_{t,\\mathbf{x}} (\\mathbf{y}) }, \\] where k_{t,\\mathbf{x}} k_{t,\\mathbf{x}} is the heat kernel . We can think of this heat diffusion problem as placing a hot needle on \\mathbf{x} \\mathbf{x} and then after t t seconds, measuring the temperature at point \\mathbf{y} \\mathbf{y} . On triangle meshes we know how to solve the heat equation for any finite time t t : \\[ (-\\mathbf{L}+\\frac{1}{t}\\mathbf{M}) \\mathbf{u} = \u03b4_{x}, \\] where \\mathbf{L} \u2208 \\mathbb{R}^{n\u00d7n} \\mathbf{L} \u2208 \\mathbb{R}^{n\u00d7n} is the discrete Laplacian matrix, \\mathbf{M} \u2208 \\mathbb{R}^{n\u00d7n} \\mathbf{M} \u2208 \\mathbb{R}^{n\u00d7n} is the discrete mass matrix, \\mathbf{u} \u2208 \\mathbb{R}^n \\mathbf{u} \u2208 \\mathbb{R}^n are the resulting temperatures at each vertex, and \u03b4_x \u2208 \\mathbb{R}^n \u03b4_x \u2208 \\mathbb{R}^n is a vector of all zeros except a one at the vertex at the source \\mathbf{x} \\mathbf{x} . If we had sufficient numerical accuracy and precision, we could simply evaluate \\sqrt{-4 t \\log u} \\sqrt{-4 t \\log u} for a small time parameter t t . The problem observed by Crane et al. is that our numerical accuracy of the value of \\mathbf{u} \\mathbf{u} is far from sufficient. However, the direction of the gradient \u2207 \\mathbf{u} \u2207 \\mathbf{u} is surprisingly accurate. Hence, their idea is to acquire the gradient of \\mathbf{u} \\mathbf{u} , normalize these vectors to get a gradient direction (unit vector). And then solve a Poisson equation to integrate these directions into actual distance values. This method involves inverting n\u00d7n n\u00d7n sparse matrices (a O(n^{1.\\cdots}) O(n^{1.\\cdots}) operation), but if Cholesky factorizations are used then the factorization is precomputation that can be reused even if the source of the geodesic distances is changed. For a new source, only back-substitution needs to be performed. In libigl, you can compute approximate geodesic distances for a mesh ( V , F ) from a list of source vertex indices gamma into a vector D using this method via two steps: igl :: HeatGeodesicsData < double > data ; igl :: heat_geodesics_precompute ( V , F , data ); ... igl :: heat_geodesics_solve ( data , gamma , D ); ) ([Example 716 loads a mesh and computes approximate geodesics distances from wherever the user clicks.](images/heat-geodesic-beetle.gif)","title":"Heat Method For Fast Geodesic Distance Approximation"},{"location":"tutorial/#intrinsic-delaunay-triangulation","text":"The original heat method for geodesic distances works well on regular, unbiased meshes: i.e., where the finite-element cotangent and mass matrices are well-behaved. For poor quality meshes, however, this method may show arbitrarily poor results. Increasing the time parameter t t can reduce this instability but but simultaneously smoothes the resulting approximate distances. Instead, one avenue of improvement is to employ the so-called intrinsic Delaunay triangulation discrete Laplace operator 48 . Since the cotangent Laplacian only depends on the edge-lengths of a triangle mesh, this new operator will be constructed by intrinsically flipping edges and recording changes to edge-lengths. Edges are flipped until every edge is locally Delaunay (i.e., its corresponding cotangent weights are positive). You can compute the intrinsic Delaunay triangulation of mesh ( V , F ) in libigl using: Eigen :: MatrixXd l ; igl :: edge_lengths ( V , F , l ); Eigen :: MatrixXd l_intrinsic ; Eigen :: MatrixXi F_intrinsic ; igl :: intrinsic_delaunay_triangulation ( l , F , l_intrinsic , F_intrinsic ); Notice that the mesh vertex positions V are not used, since this is a purely intrinsic operation. The method inputs and outputs edge-lengths and triangle indices. You may construct the intrinsic Delaunay cotangent Laplacian matrix directly using: Eigen :: SparseMatrix < double > L ; igl :: intrinsic_delaunay_cotmatrix ( V , F , L ); And finally you can compute heat geodesics using this matrix via: igl :: HeatGeodesicsData < double > data ; data . use_intrinsic_delaunay = true ; igl :: heat_geodesics_precompute ( V , F , data ); ... igl :: heat_geodesics_solve ( data , gamma , D );","title":"Intrinsic Delaunay Triangulation"},{"location":"tutorial/#fast-winding-number-for-soups-and-clouds","text":"In 2018, Barill et al. 50 demonstrated how to significantly expediate the computation of the generalized winding numbers mentioned above. The original definition of generalized winding numbers for triangle meshes is also extended to (oriented) point clouds.","title":"Fast Winding Number For Soups And Clouds"},{"location":"tutorial/#soups","text":"For triangle soups, the exact divide-and-conquer approach of 40 ideally scales logarithmically O(\\log{n}) O(\\log{n}) in the number of triangles. However, this method has failure modes where the computation becomes linear O(n) O(n) . This can be dramatically improved with a tree method similar to those used in n-body graviational system simulations or electrostatics problems. The result is approximate, but much more closely follows a O(\\log{n}) O(\\log{n}) trend and with much smaller constant factors. ) ([Example 717 loads a mesh, samples 1,000,000 random queries and then discards all those outside the given model.](images/bunny-fwn-soup.jpg) Computing fast winding numbers for soups has two steps: building the tree data structure and then evaluating at query points. In libigl, this is programmed as follows: igl :: FastWindingNumberBVH fwn_bvh ; igl :: fast_winding_number ( V . cast < float > (), F , 2 , fwn_bvh ); Eigen :: VectorXf W ; igl :: fast_winding_number ( fwn_bvh , 2 , Q . cast < float > (), W );","title":"Soups"},{"location":"tutorial/#clouds","text":"For point clouds, the process is similar, but more precomputation may be necessary. The winding number for point clouds is defined so long as each point comes with an outward-facing normal and an area value. Areas can be estimated by using a libigl function that computes a tangents space Voronoi diagram for each point igl::copyleft::cgal::point_areas . This function in turn relies on first computing k nearest neighbors igl::knn . And that function and the eventual winding number computation uses libigl\u2019s igl::octree as a bounding volume hierarchy. To estimate areas use for a point cloud P with normals N use: // Build octree std :: vector < std :: vector < int > > O_PI ; Eigen :: MatrixXi O_CH ; Eigen :: MatrixXd O_CN ; Eigen :: VectorXd O_W ; igl :: octree ( P , O_PI , O_CH , O_CN , O_W ); Eigen :: VectorXd A ; { Eigen :: MatrixXi I ; igl :: knn ( P , 20 , O_PI , O_CH , O_CN , O_W , I ); // CGAL is only used to help get point areas igl :: copyleft :: cgal :: point_areas ( P , I , N , A ); } Then it is possible to compute fast winding numbers for a list of queries Q : Eigen :: MatrixXd O_CM ; Eigen :: VectorXd O_R ; Eigen :: MatrixXd O_EC ; igl :: fast_winding_number ( P , N , A , O_PI , O_CH , 2 , O_CM , O_R , O_EC ); Eigen :: VectorXd W ; igl :: fast_winding_number ( P , N , A , O_PI , O_CH , O_CM , O_R , O_EC , Q , 2 , W );","title":"Clouds"},{"location":"tutorial/#iterative-closest-point","text":"718_IterativeClosestPoint Entry Missing","title":"Iterative Closest Point"},{"location":"tutorial/#exploded-view","text":"719_ExplodedView Entry Missing","title":"Exploded View"},{"location":"tutorial/#blue-noise-surface-sampling","text":"720_BlueNoise Entry Missing","title":"Blue Noise Surface Sampling"},{"location":"tutorial/#vector-field-smoothing","text":"721_VectorFieldSmoothing Entry Missing","title":"Vector Field Smoothing"},{"location":"tutorial/#vector-parallel-transport","text":"722_VectorParallelTransport Entry Missing","title":"Vector Parallel Transport"},{"location":"tutorial/#outlook-for-continuing-development","text":"Libigl is in active development, and we plan to focus on the following features in the next months: A better and more consistent documentation , plus extending this tutorial to cover more libigl features. Implement a mixed-integer solver which only uses Eigen to remove the dependency on CoMiSo. Improve the robustness and performance of the active set QP solver. In particular, handle linearly dependent constraints. Implement more mesh analysis functions, including structural analysis for masonry and 3D-printability analysis. Increase support for point clouds and general polygonal meshes. Wrangle/unify the many bounding volume hierarchies that now exist within libigl. What would you like to see in libigl? Contact us! or post a feature request . We encourage you to contribute to the library and to report problems and bugs. The best way to contribute new feature or bug fixes is to fork the libigl repository and to open a pull request on our github repository .","title":"Outlook For Continuing Development"},{"location":"tutorial/#past-libigl-courses-at-conferences","text":"This tutorial was originally presented by Daniele Panozzo and Alec Jacobson at SGP Graduate School 2014. It has also been presented at SGP 2017 ( video ), ACM SIGGRAPH Asia 2017, Eurographics 2019, and SGP 2020.","title":"Past Libigl Courses At Conferences"},{"location":"tutorial/#references","text":"Alec Jacobson, Algorithms and Interfaces for Real-Time Deformation of 2D and 3D Shapes , 2013. \u21a9 Michael Kazhdan, Jake Solomon, Mirela Ben-Chen, Can Mean-Curvature Flow Be Made Non-Singular , 2012. \u21a9 Mark Meyer, Mathieu Desbrun, Peter Schr\u00f6der and Alan H. Barr, Discrete Differential-Geometry Operators for Triangulated 2-Manifolds , 2003. \u21a9 \u21a9 \u21a9 \u21a9 Joseph S. B. Mitchell, David M. Mount, Christos H. Papadimitriou. The Discrete Geodesic Problem , 1987 \u21a9 Daniele Panozzo, Enrico Puppo, Luigi Rocca, Efficient Multi-scale Curvature and Crease Estimation , 2010. \u21a9 Andrei Sharf, Thomas Lewiner, Gil Shklarski, Sivan Toledo, and Daniel Cohen-Or. Interactive topology-aware surface reconstruction , 2007. \u21a9 Jernej Barbic and Doug James. Real-Time Subspace Integration for St.Venant-Kirchhoff Deformable Models , 2005. \u21a9 Klaus Hildebrandt, Christian Schulz, Christoph von Tycowicz, and Konrad Polthier. Interactive Surface Modeling using Modal Analysis , 2011. \u21a9 Raid M. Rustamov, Multiscale Biharmonic Kernels , 2011. \u21a9 Bruno Vallet and Bruno L\u00e9vy. Spectral Geometry Processing with Manifold Harmonics , 2008. \u21a9 \u21a9 Mario Botsch and Leif Kobbelt. An Intuitive Framework for Real-Time Freeform Modeling , 2004. \u21a9 Isaac Chao, Ulrich Pinkall, Patrick Sanan, Peter Schr\u00f6der. A Simple Geometric Model for Elastic Deformations , 2010. \u21a9 Alec Jacobson, Ilya Baran, Jovan Popovi\u0107, and Olga Sorkine. Bounded Biharmonic Weights for Real-Time Deformation , 2011. \u21a9 \u21a9 Alec Jacobson, Ilya Baran, Ladislav Kavan, Jovan Popovi\u0107, and Olga Sorkine. Fast Automatic Skinning Transformations , 2012. \u21a9 Alec Jacobson, Elif Tosun, Olga Sorkine, and Denis Zorin. Mixed Finite Elements for Variational Surface Modeling , 2010. \u21a9 Alec Jacobson, Zhigang Deng, Ladislav Kavan, J.P. Lewis. Skinning: Real-Time Shape Deformation , 2014. \u21a9 \u21a9 Ladislav Kavan, Steven Collins, Jiri Zara, and Carol O\u2019Sullivan. Geometric Skinning with Approximate Dual Quaternion Blending , 2008. \u21a9 Binh Huy Le, J.P. Lewis. Direct delta mush skinning and variants , 2019. \u21a9 Joe Mancewicz, Matt L. Derksen, Hans Rijpkema, and Cyrus A. Wilson. Delta Mush: smoothing deformations while preserving detail , 2014. \u21a9 Alexa McAdams, Andrew Selle, Rasmus Tamstorf, Joseph Teran, Eftychios Sifakis. Computing the Singular Value Decomposition of 3x3 matrices with minimal branching and elementary floating point operations , 2011. \u21a9 Olga Sorkine, Yaron Lipman, Daniel Cohen-Or, Marc Alexa, Christian R\u00f6ssl and Hans-Peter Seidel. Laplacian Surface Editing , 2004. \u21a9 Olga Sorkine and Marc Alexa. As-rigid-as-possible Surface Modeling , 2007. \u21a9 Yu Wang, Alec Jacobson, Jernej Barbic, Ladislav Kavan. Linear Subspace Design for Real-Time Shape Deformation , 2015 \u21a9 \u21a9 Fernando de Goes, Doug L. James. Regularized Kelvinlets: Sculpting Brushes based on Fundamental Solutions of Elasticity , 2017 \u21a9 W. S. Slaughter. The Linearized Theory of Elasticity , 2002 \u21a9 David Bommes, Henrik Zimmer, Leif Kobbelt. Mixed-integer quadrangulation , 2009. \u21a9 \u21a9 \u21a9 Sofien Bouaziz, Mario Deuss, Yuliy Schwartzburg, Thibaut Weise, Mark Pauly Shape-Up: Shaping Discrete Geometry with Projections , 2012 \u21a9 \u21a9 Matthias Eck, Tony DeRose, Tom Duchamp, Hugues Hoppe, Michael Lounsbery, Werner Stuetzle. Multiresolution Analysis of Arbitrary Meshes , 2005. \u21a9 Bruno L\u00e9vy, Sylvain Petitjean, Nicolas Ray, J\u00e9rome Maillot. Least Squares Conformal Maps, for Automatic Texture Atlas Generation , 2002. \u21a9 Nicolas Ray, Bruno Vallet, Wan Chiu Li, Bruno L\u00e9vy. N-Symmetry Direction Field Design , 2008. \u21a9 Ligang Liu, Lei Zhang, Yin Xu, Craig Gotsman, Steven J. Gortler. A Local/Global Approach to Mesh Parameterization , 2008. \u21a9 Patrick Mullen, Yiying Tong, Pierre Alliez, Mathieu Desbrun. Spectral Conformal Parameterization , 2008. \u21a9 Daniele Panozzo, Enrico Puppo, Marco Tarini, Olga Sorkine-Hornung. Frame Fields: Anisotropic and Non-Orthogonal Cross Fields , 2014. \u21a9 Amir Vaxman, Marcel Campen, Olga Diamanti, Daniele Panozzo, David Bommes, Klaus Hildebrandt, Mirela Ben-Chen. Directional Field Synthesis, Design, and Processing , 2016 \u21a9 Christian Sch\u00fcller, Ladislav Kavan, Daniele Panozzo, Olga Sorkine-Hornung. Locally Injective Mappings , 2013. \u21a9 Qingnan Zhou, Eitan Grinspun, Denis Zorin. Mesh Arrangements for Solid Geometry , 2016 \u21a9 J Andreas Baerentzen and Henrik Aanaes. Signed distance computation using the angle weighted pseudonormal , 2005. \u21a9 Akash Garg, Alec Jacobson, Eitan Grinspun. Computational Design of Reconfigurables , 2016 \u21a9 Hugues Hoppe. Progressive Meshes , 1996 \u21a9 Alec Jacobson, Ladislav Kavan, and Olga Sorkine. Robust Inside-Outside Segmentation using Generalized Winding Numbers , 2013. \u21a9 \u21a9 \u21a9 Charles Loop. Smooth Subdivision Surfaces Based on Triangles , 1987. \u21a9 W.E. Lorensen and Harvey E. Cline. Marching cubes: A high resolution 3d surface construction algorithm , 1987. \u21a9 \u21a9 Michael Rabinovich, Roi Poranne, Daniele Panozzo, Olga Sorkine-Hornung. Scalable Locally Injective Mappings , 2016. \u21a9 William J. Schroeder, William E. Lorensen, and Steve Linthicum. Implicit Modeling of Swept Surfaces and Volumes , 1994. \u21a9 Kenshi Takayama, Alec Jacobson, Ladislav Kavan, Olga Sorkine-Hornung. A Simple Method for Correcting Facet Orientations in Polygon Meshes Based on Ray Casting , 2014. \u21a9 G.M. Treece, R.W. Prager, and A.H.Gee Regularised marching tetrahedra: improved iso-surface extraction , 1999. \u21a9 Keenan Crane, Clarisse Weischedel, and Max Wardetzky. Geodesics in Heat: A New Approach to Computing Distance Based on Heat Flow , 2013. \u21a9 Alexander I. Bobenko and Boris A. Springborn. A discrete Laplace-Beltrami operator for simplicial surfaces , 2005. \u21a9 Zhongshi Jiang, Scott Schaefer, Daniele Panozzo. SCAF: Simplicial Complex Augmentation Framework for Bijective Maps , 2017 \u21a9 Gavin Barill, Neil G. Dickson, Ryan Schmidt, David I.W. Levin, Alec Jacobson. Fast Winding Numbers for Soups and Clouds , 2018. \u21a9 Oded Stein, Eitan Grinspun, Max Wardetzky, Alec Jacobson. Natural Boundary Conditions for Smoothing in Geometry Processing , 2018. \u21a9","title":"References"},{"location":"unit-tests/","text":"Unit Tests for libigl \u00b6 The libigl unit test are included in the main repository inside the tests folder. There is a CMake flag to enable/disable the testings LIBIGL_BUILD_TESTS which is disabled by default when libigl is not a toplevel project , that is when you are using libigl as a library in your own project. Tip Before writing any new unit test, be sure you are up-to-date with the master branch to use the latest version of libigl available. Dependencies \u00b6 Catch2 is an auto-downloaded dependency. Build And Test \u00b6 Use cmake to generate a Makefile that will build and test upon issuing make : mkdir build cd build cmake .. Then build and test with make make test This will first compile the tests and then immediately run the tests. If tests are succeeding you should see output similar to: Test project /usr/local/libigl-unit-tests/build Start 1: run_igl_mosek_tests 1/4 Test #1: run_igl_mosek_tests ..............***Exception: Other 0.00 sec Start 2: run_igl_boolean_tests 2/4 Test #2: run_igl_boolean_tests ............ Passed 1.12 sec Start 3: run_igl_cgal_tests 3/4 Test #3: run_igl_cgal_tests ............... Passed 2.46 sec Start 4: run_igl_tests We refer to the Catch2 manual for additional options. Generating New Tests \u00b6 To create a new test, just create a file with the same name of the file you want to test inside the include\\igl in the tests folder. Then just add #include <test_common.h> TEST_CASE ( \"<function_name> <possible description>\" , \"[igl]\" ) { //test code goes here } You can use functions like test_common::assert_eq to assert equality between two Eigen matrices. The cumsum test is a good simple example of a test case. Many libigl functions act on triangle meshes, you can use igl::read_triangle_mesh(test_common::data_path(\"cube.obj\"), V, F) to load a triangle mesh located in the test data folder. Note The data used for testing is not in the main libigl repository. Instead it is contained in the libigl-tests-data repository. It is automatically downloaded when LIBIGL_BUILD_TESTS is enabled. Conventions \u00b6 When naming a test for a function igl::extra::function_name use: TEST_CASE ( \"function_name: my_description\" , \"[igl/extra]\" ) { ... } where my_description can be used to identify the type of unit test being run on the function function_name . Example \u00b6 The test for igl::copyleft::cgal::order_facets_around_edges in include/igl/copyleft/cgal/order_facets_around_edges.cpp is: TEST_CASE ( \"copyleft_cgal_order_facets_around_edges: Simple\" , \"[igl/copyleft/cgal]\" ) { ... } which tests this function on example data containing a triplet of faces. Guarantees \u00b6 None. (Obviously?) The presence of a unit test here for some function (e.g., igl::cotmatrix ) is not a guarantee or even an endorsement of the notion that the libigl function igl::cotmatrix is bug free or \u201cfully tested\u201d or \u201cheavily tested\u201d or even \u201cadequately tested\u201d. Need Work? \u00b6 Some of the most used libigl functions grep -hr \"^#include \\\"\" ../libigl/include/igl | sed -e 's/\\(\\.\\.\\/\\)//g' | sort | uniq -c | sort still don\u2019t have unit tests.","title":"Unit Tests"},{"location":"unit-tests/#unit-tests-for-libigl","text":"The libigl unit test are included in the main repository inside the tests folder. There is a CMake flag to enable/disable the testings LIBIGL_BUILD_TESTS which is disabled by default when libigl is not a toplevel project , that is when you are using libigl as a library in your own project. Tip Before writing any new unit test, be sure you are up-to-date with the master branch to use the latest version of libigl available.","title":"Unit Tests for libigl"},{"location":"unit-tests/#dependencies","text":"Catch2 is an auto-downloaded dependency.","title":"Dependencies"},{"location":"unit-tests/#build-and-test","text":"Use cmake to generate a Makefile that will build and test upon issuing make : mkdir build cd build cmake .. Then build and test with make make test This will first compile the tests and then immediately run the tests. If tests are succeeding you should see output similar to: Test project /usr/local/libigl-unit-tests/build Start 1: run_igl_mosek_tests 1/4 Test #1: run_igl_mosek_tests ..............***Exception: Other 0.00 sec Start 2: run_igl_boolean_tests 2/4 Test #2: run_igl_boolean_tests ............ Passed 1.12 sec Start 3: run_igl_cgal_tests 3/4 Test #3: run_igl_cgal_tests ............... Passed 2.46 sec Start 4: run_igl_tests We refer to the Catch2 manual for additional options.","title":"Build And Test"},{"location":"unit-tests/#generating-new-tests","text":"To create a new test, just create a file with the same name of the file you want to test inside the include\\igl in the tests folder. Then just add #include <test_common.h> TEST_CASE ( \"<function_name> <possible description>\" , \"[igl]\" ) { //test code goes here } You can use functions like test_common::assert_eq to assert equality between two Eigen matrices. The cumsum test is a good simple example of a test case. Many libigl functions act on triangle meshes, you can use igl::read_triangle_mesh(test_common::data_path(\"cube.obj\"), V, F) to load a triangle mesh located in the test data folder. Note The data used for testing is not in the main libigl repository. Instead it is contained in the libigl-tests-data repository. It is automatically downloaded when LIBIGL_BUILD_TESTS is enabled.","title":"Generating New Tests"},{"location":"unit-tests/#conventions","text":"When naming a test for a function igl::extra::function_name use: TEST_CASE ( \"function_name: my_description\" , \"[igl/extra]\" ) { ... } where my_description can be used to identify the type of unit test being run on the function function_name .","title":"Conventions"},{"location":"unit-tests/#example","text":"The test for igl::copyleft::cgal::order_facets_around_edges in include/igl/copyleft/cgal/order_facets_around_edges.cpp is: TEST_CASE ( \"copyleft_cgal_order_facets_around_edges: Simple\" , \"[igl/copyleft/cgal]\" ) { ... } which tests this function on example data containing a triplet of faces.","title":"Example"},{"location":"unit-tests/#guarantees","text":"None. (Obviously?) The presence of a unit test here for some function (e.g., igl::cotmatrix ) is not a guarantee or even an endorsement of the notion that the libigl function igl::cotmatrix is bug free or \u201cfully tested\u201d or \u201cheavily tested\u201d or even \u201cadequately tested\u201d.","title":"Guarantees"},{"location":"unit-tests/#need-work","text":"Some of the most used libigl functions grep -hr \"^#include \\\"\" ../libigl/include/igl | sed -e 's/\\(\\.\\.\\/\\)//g' | sort | uniq -c | sort still don\u2019t have unit tests.","title":"Need Work?"},{"location":"website/","text":"Building the Website \u00b6 For developers who want to contribute to the website/documentation of libigl. The website is now hosted in its own repository separate from the main libigl repository. Simple Workflow \u00b6 For simple edits to the website, you can directly edit the pages online: Write your changes to the markdown file on github: Preview the modified page on github: Finally, commit the changes to a new branch/fork and let github create a pull request with your changes: Feel free to make your changes locally, and use something like dynamic previews in VS Code to preview your changes. The files are just markdown so anything should work! For more complicated changes (e.g. to render math equations), you may want to run mkdocs to preview the final website. Final Website Preview \u00b6 For more complicated changes, you may want to preview the website locally on your machine while editing its content. You will need to run mkdocs to do this. If you want to preview the website locally on your machine, you will need to run mkdocs Prerequisites \u00b6 Install Conda \u00b6 If you do not already have it, install miniconda on your machine. Instructions for Windows Option 1: Using Chocolatey : choco install -y miniconda3 Option 2: Using Scoop : # Add the extras bucket scoop bucket add extras scoop install miniconda3 Option 3: Manual Installation Instructions for macOS Option 1: Using Homebrew Cask: brew cask install miniconda Option 2: Manual Installation wget https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh bash Miniconda3-latest-MacOSX-x86_64.sh Instructions for Ubuntu/Debian Download the public GPG key and add the conda repository to the sources list # Install our public GPG key to trusted store curl https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc | gpg --dearmor > conda.gpg install -o root -g root -m 644 conda.gpg /usr/share/keyrings/conda-archive-keyring.gpg # Check whether fingerprint is correct (will output an error message otherwise) gpg --keyring /usr/share/keyrings/conda-archive-keyring.gpg --no-default-keyring --fingerprint 34161F5BF5EB1D4BFBBB8F0A8AEB4F8B29D82806 # Add our Debian repo echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/conda-archive-keyring.gpg] https://repo.anaconda.com/pkgs/misc/debrepo/conda stable main\" > /etc/apt/sources.list.d/conda.list **NB:** If you receive a Permission denied error when trying to run the above command ( because ` /etc/apt/sources.list.d/conda.list ` is write protected ) , try using the following command instead: echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/conda-archive-keyring.gpg] https://repo.anaconda.com/pkgs/misc/debrepo/conda stable main\" | sudo tee -a /etc/apt/sources.list.d/conda.list Install the conda package manager: # Install it! apt update apt install conda Instructions for RedHat/CentOS/Fedora Download the GPG key and add a repository configuration file for conda # Import our GPG public key rpm --import https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc # Add the Anaconda repository cat <<EOF > /etc/yum/repos.d/conda.repo [conda] name=Conda baseurl=https://repo.anaconda.com/pkgs/misc/rpmrepo/conda enabled=1 gpgcheck=1 gpgkey=https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc EOF Install the conda package manager: yum install conda Instructions for generic Linux Manual installation : wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh Create/Update Conda Environment \u00b6 conda env update -f conda.yml Render the Website \u00b6 Activate the conda environment installed on the previous step: conda activate libigl-website Preview the website locally (run this command in the root folder of the libigl project): mkdocs serve Tip Dead links can be checked using the LinkChecker tool. Run the website locally, then run LinkChecker on it: linkchecker http://127.0.0.1:8000 Deployment \u00b6 Deployment has been automated through the use of GitHub Actions. The configuration file is located here . References \u00b6 Miniconda MkDocs Material Theme","title":"Building the Website"},{"location":"website/#building-the-website","text":"For developers who want to contribute to the website/documentation of libigl. The website is now hosted in its own repository separate from the main libigl repository.","title":"Building the Website"},{"location":"website/#simple-workflow","text":"For simple edits to the website, you can directly edit the pages online: Write your changes to the markdown file on github: Preview the modified page on github: Finally, commit the changes to a new branch/fork and let github create a pull request with your changes: Feel free to make your changes locally, and use something like dynamic previews in VS Code to preview your changes. The files are just markdown so anything should work! For more complicated changes (e.g. to render math equations), you may want to run mkdocs to preview the final website.","title":"Simple Workflow"},{"location":"website/#final-website-preview","text":"For more complicated changes, you may want to preview the website locally on your machine while editing its content. You will need to run mkdocs to do this. If you want to preview the website locally on your machine, you will need to run mkdocs","title":"Final Website Preview"},{"location":"website/#prerequisites","text":"","title":"Prerequisites"},{"location":"website/#install-conda","text":"If you do not already have it, install miniconda on your machine. Instructions for Windows Option 1: Using Chocolatey : choco install -y miniconda3 Option 2: Using Scoop : # Add the extras bucket scoop bucket add extras scoop install miniconda3 Option 3: Manual Installation Instructions for macOS Option 1: Using Homebrew Cask: brew cask install miniconda Option 2: Manual Installation wget https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh bash Miniconda3-latest-MacOSX-x86_64.sh Instructions for Ubuntu/Debian Download the public GPG key and add the conda repository to the sources list # Install our public GPG key to trusted store curl https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc | gpg --dearmor > conda.gpg install -o root -g root -m 644 conda.gpg /usr/share/keyrings/conda-archive-keyring.gpg # Check whether fingerprint is correct (will output an error message otherwise) gpg --keyring /usr/share/keyrings/conda-archive-keyring.gpg --no-default-keyring --fingerprint 34161F5BF5EB1D4BFBBB8F0A8AEB4F8B29D82806 # Add our Debian repo echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/conda-archive-keyring.gpg] https://repo.anaconda.com/pkgs/misc/debrepo/conda stable main\" > /etc/apt/sources.list.d/conda.list **NB:** If you receive a Permission denied error when trying to run the above command ( because ` /etc/apt/sources.list.d/conda.list ` is write protected ) , try using the following command instead: echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/conda-archive-keyring.gpg] https://repo.anaconda.com/pkgs/misc/debrepo/conda stable main\" | sudo tee -a /etc/apt/sources.list.d/conda.list Install the conda package manager: # Install it! apt update apt install conda Instructions for RedHat/CentOS/Fedora Download the GPG key and add a repository configuration file for conda # Import our GPG public key rpm --import https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc # Add the Anaconda repository cat <<EOF > /etc/yum/repos.d/conda.repo [conda] name=Conda baseurl=https://repo.anaconda.com/pkgs/misc/rpmrepo/conda enabled=1 gpgcheck=1 gpgkey=https://repo.anaconda.com/pkgs/misc/gpgkeys/anaconda.asc EOF Install the conda package manager: yum install conda Instructions for generic Linux Manual installation : wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh","title":"Install Conda"},{"location":"website/#createupdate-conda-environment","text":"conda env update -f conda.yml","title":"Create/Update Conda Environment"},{"location":"website/#render-the-website","text":"Activate the conda environment installed on the previous step: conda activate libigl-website Preview the website locally (run this command in the root folder of the libigl project): mkdocs serve Tip Dead links can be checked using the LinkChecker tool. Run the website locally, then run LinkChecker on it: linkchecker http://127.0.0.1:8000","title":"Render the Website"},{"location":"website/#deployment","text":"Deployment has been automated through the use of GitHub Actions. The configuration file is located here .","title":"Deployment"},{"location":"website/#references","text":"Miniconda MkDocs Material Theme","title":"References"},{"location":"file-formats/","text":"libigl file formats \u00b6 .bf ASCII files for representing skeletal bone \u201cforests\u201d .dmat uncompressed ASCII/binary files for dense matrices .ele Element (triangle or tet) list. This format comes in similar flavors: tetgen\u2019s , stellar\u2019s , and triangle\u2019s . The formats of TetGen and stellar are identical upto conventions on index ordering and number of allowed attributes (unverified). .face TetGen\u2019s file format for simplicial facets. .mesh Medit\u2019s triangle surface mesh + tetrahedral volume mesh file format, see page 33, section 7.2.1 .msh Gmsh finite element mesh generator legacy version 2 file format. This format is very flexible and supports mixture of various elements, each vertex and each element can also have arbitrary number of scalar or vector fields defined, also elements are assigned integer tags to define sub meshes. Currently only triangular and tetrahedral elements are supported. Both ASCII and binary encodings are supported. .node List of points (vertices). Described identically (upto accepted dimensions, use of attributes and boundary markers) by Triangle , TetGen , and Stellar . .off Geomview\u2019s polyhedral file format .obj Wavefront object file format. Usually unsafe to assume anything more than vertex positions and triangle indices are supported .ply Polygon File Format, supporting ASCII and binary encoding. Each vertex and element can have artitrary number of additional properties. .png Portable Network Graphics image file. libigl supports png image files via the stb image library. Alpha channels and compression are supported. .poly Piecewise-linear complex. This format comes in many similar but importantly different flavors: triangle\u2019s , tetgen\u2019s , pyramid/SVR\u2019s .rbr ASCII files for saving state of ReAntTweakBar .stl 3D Systems\u2019CAD and 3D printing mesh file format. ASCII and binary versions. .tga Truevision TGA or TARGA image file format. IGLLIB supports only very basic reading and writing RGB/RGBA files without colormaps and (unverified) run-length compression. .tgf ASCII files for representing control handle graphs .wrl VRML (Virtual Reality Modeling Language) file format for 3D scenes. .xml XMLSerializer\u2019s file format containing the serialization of object data structures. Triangle mesh file format performance \u00b6 .obj and .off file formats support meshes with arbitrary polygon degrees. However, often we are only working with triangle meshes. Further, .obj files do not have useful headers revealing the number of elements. For triangle meshes, .off and .obj are inferior file formats to the .mesh file format. The current (version 0.1.6) IO functions for these file formats perform as follows for reading and writing a 300,000 triangle mesh: writeOBJ: 1.33742 secs writeOFF: 0.510111 secs writeMESH: 0.218139 secs readOBJ: 1.3782 secs readOFF: 0.691496 secs readMESH: 0.242315 secs This reveals that .mesh is 6.5x faster than .obj and about 2.5x faster than .off. While .obj files support normals, it is typically much faster to (re)compute normals from the geometry using per_face_normals , per_vertex_normals , per_corner_normals than to read and write them to files. It gets even better if you\u2019re willing to use a nonstandard format. If your triangle mesh is in ( V , F ) then you can read and write those variables as dense matrices of doubles to .dmat uncompressed binary files. This not only ensures perfect precision but also big speed ups. On that same 300,000 triangle mesh, .dmat achieves: writeDMAT: 0.0384338 secs readDMAT: 0.0117921 secs This reveals that binary .dmat files are 34x/116x faster at writing and reading than .obj and a hefty 5x/20x over .mesh. In this case it may pay to compute normals once into N and also read and write it to a .dmat file.","title":"Index"},{"location":"file-formats/#libigl-file-formats","text":".bf ASCII files for representing skeletal bone \u201cforests\u201d .dmat uncompressed ASCII/binary files for dense matrices .ele Element (triangle or tet) list. This format comes in similar flavors: tetgen\u2019s , stellar\u2019s , and triangle\u2019s . The formats of TetGen and stellar are identical upto conventions on index ordering and number of allowed attributes (unverified). .face TetGen\u2019s file format for simplicial facets. .mesh Medit\u2019s triangle surface mesh + tetrahedral volume mesh file format, see page 33, section 7.2.1 .msh Gmsh finite element mesh generator legacy version 2 file format. This format is very flexible and supports mixture of various elements, each vertex and each element can also have arbitrary number of scalar or vector fields defined, also elements are assigned integer tags to define sub meshes. Currently only triangular and tetrahedral elements are supported. Both ASCII and binary encodings are supported. .node List of points (vertices). Described identically (upto accepted dimensions, use of attributes and boundary markers) by Triangle , TetGen , and Stellar . .off Geomview\u2019s polyhedral file format .obj Wavefront object file format. Usually unsafe to assume anything more than vertex positions and triangle indices are supported .ply Polygon File Format, supporting ASCII and binary encoding. Each vertex and element can have artitrary number of additional properties. .png Portable Network Graphics image file. libigl supports png image files via the stb image library. Alpha channels and compression are supported. .poly Piecewise-linear complex. This format comes in many similar but importantly different flavors: triangle\u2019s , tetgen\u2019s , pyramid/SVR\u2019s .rbr ASCII files for saving state of ReAntTweakBar .stl 3D Systems\u2019CAD and 3D printing mesh file format. ASCII and binary versions. .tga Truevision TGA or TARGA image file format. IGLLIB supports only very basic reading and writing RGB/RGBA files without colormaps and (unverified) run-length compression. .tgf ASCII files for representing control handle graphs .wrl VRML (Virtual Reality Modeling Language) file format for 3D scenes. .xml XMLSerializer\u2019s file format containing the serialization of object data structures.","title":"libigl file formats"},{"location":"file-formats/#triangle-mesh-file-format-performance","text":".obj and .off file formats support meshes with arbitrary polygon degrees. However, often we are only working with triangle meshes. Further, .obj files do not have useful headers revealing the number of elements. For triangle meshes, .off and .obj are inferior file formats to the .mesh file format. The current (version 0.1.6) IO functions for these file formats perform as follows for reading and writing a 300,000 triangle mesh: writeOBJ: 1.33742 secs writeOFF: 0.510111 secs writeMESH: 0.218139 secs readOBJ: 1.3782 secs readOFF: 0.691496 secs readMESH: 0.242315 secs This reveals that .mesh is 6.5x faster than .obj and about 2.5x faster than .off. While .obj files support normals, it is typically much faster to (re)compute normals from the geometry using per_face_normals , per_vertex_normals , per_corner_normals than to read and write them to files. It gets even better if you\u2019re willing to use a nonstandard format. If your triangle mesh is in ( V , F ) then you can read and write those variables as dense matrices of doubles to .dmat uncompressed binary files. This not only ensures perfect precision but also big speed ups. On that same 300,000 triangle mesh, .dmat achieves: writeDMAT: 0.0384338 secs readDMAT: 0.0117921 secs This reveals that binary .dmat files are 34x/116x faster at writing and reading than .obj and a hefty 5x/20x over .mesh. In this case it may pay to compute normals once into N and also read and write it to a .dmat file.","title":"Triangle mesh file format performance"},{"location":"file-formats/bf/","text":".bf - bone forests \u00b6 A .bf file contains a \u201cbone forest\u201d. Normally a skeleton for linear blend skinning is a \u201cbone tree\u201d with a single root. But this format may store multiple trees, hence a forest. Each line contains data about a vertex (joint) of the bone forest: [weight index] [parent index] [x] [y] [z] [undocument optional data] Indices begin with 0. The weight index is -1 if the bone does not have an associated weight. The parent index is -1 for root nodes. The x,y,z coordinates are offset vectors from this joint\u2019s parent\u2019s location (for roots, an offset from the origin).","title":"bf"},{"location":"file-formats/bf/#bf-bone-forests","text":"A .bf file contains a \u201cbone forest\u201d. Normally a skeleton for linear blend skinning is a \u201cbone tree\u201d with a single root. But this format may store multiple trees, hence a forest. Each line contains data about a vertex (joint) of the bone forest: [weight index] [parent index] [x] [y] [z] [undocument optional data] Indices begin with 0. The weight index is -1 if the bone does not have an associated weight. The parent index is -1 for root nodes. The x,y,z coordinates are offset vectors from this joint\u2019s parent\u2019s location (for roots, an offset from the origin).","title":".bf - bone forests"},{"location":"file-formats/dmat/","text":".dmat - dense matrices \u00b6 A .dmat file contains a dense matrix in column major order. It can contain ASCII or binary data. Note that it is uncompressed so binary only reduces the file size by 50%. But writing and reading binary is usually faster. In MATLAB, binary is almost 100x faster. ASCII \u00b6 The first line is a header containing: [#cols] [#rows] Then the coefficients are printed in column-major order separated by spaces. Binary \u00b6 Binary files will also contain the ascii header, but it should read: 0 0 Then there should be another header containing the size of the binary part: [#cols] [#rows] Then coefficients are written in column-major order in Little-endian 8-byte double precision IEEE floating point format. Note: Line endings must be '\\n' aka char(10) aka line feeds.","title":"dmat"},{"location":"file-formats/dmat/#dmat-dense-matrices","text":"A .dmat file contains a dense matrix in column major order. It can contain ASCII or binary data. Note that it is uncompressed so binary only reduces the file size by 50%. But writing and reading binary is usually faster. In MATLAB, binary is almost 100x faster.","title":".dmat - dense matrices"},{"location":"file-formats/dmat/#ascii","text":"The first line is a header containing: [#cols] [#rows] Then the coefficients are printed in column-major order separated by spaces.","title":"ASCII"},{"location":"file-formats/dmat/#binary","text":"Binary files will also contain the ascii header, but it should read: 0 0 Then there should be another header containing the size of the binary part: [#cols] [#rows] Then coefficients are written in column-major order in Little-endian 8-byte double precision IEEE floating point format. Note: Line endings must be '\\n' aka char(10) aka line feeds.","title":"Binary"},{"location":"file-formats/rbr/","text":".rbr - ReAntTweakbar state file \u00b6 An .rbr file contains the saved values of the ReAntTweakBar class. It is used to load and save variables (and states specified via callbacks) stored in an AntTweakBar GUI. Each line contains the name of the AntTweakBar item, the type of item and the value as a string: [name]: [type] [value] As per AntTweakBar\u2019s own advice, names should not contain spaces. Names should also not contain colons ( : ). An example of a line looks like: my_rotation: TW_TYPE_QUAT4 0.0111272 -0.00101157 0.00648534 -0.999917 Not all AntTweakBar types are currently supported. See igl/ReAntTweakbar.h for an up-to-date list of supported types.","title":"rbr"},{"location":"file-formats/rbr/#rbr-reanttweakbar-state-file","text":"An .rbr file contains the saved values of the ReAntTweakBar class. It is used to load and save variables (and states specified via callbacks) stored in an AntTweakBar GUI. Each line contains the name of the AntTweakBar item, the type of item and the value as a string: [name]: [type] [value] As per AntTweakBar\u2019s own advice, names should not contain spaces. Names should also not contain colons ( : ). An example of a line looks like: my_rotation: TW_TYPE_QUAT4 0.0111272 -0.00101157 0.00648534 -0.999917 Not all AntTweakBar types are currently supported. See igl/ReAntTweakbar.h for an up-to-date list of supported types.","title":".rbr - ReAntTweakbar state file"},{"location":"file-formats/tgf/","text":".tgf - control handle graphs \u00b6 A .tgf file contains a graph of describing a set of control handles/structures: point controls, bones of a skeleton and cages made of \u201ccage edges\u201d. The first part of the file consists of lines regarding each vertex of the graph. Each line reads: [index] [x] [y] [z] [undocument optional data] Indices begin with 1 and should proceed in order. Then there should be a line with a sole: # The next section concerns the edges of the graph. Each line corresponds to an edge: [source index] [dest index] [is bone] [is pseudo-edge] [is cage edge] [undocument other data] Bone edges trump pseudo and cage edges.","title":"tgf"},{"location":"file-formats/tgf/#tgf-control-handle-graphs","text":"A .tgf file contains a graph of describing a set of control handles/structures: point controls, bones of a skeleton and cages made of \u201ccage edges\u201d. The first part of the file consists of lines regarding each vertex of the graph. Each line reads: [index] [x] [y] [z] [undocument optional data] Indices begin with 1 and should proceed in order. Then there should be a line with a sole: # The next section concerns the edges of the graph. Each line corresponds to an edge: [source index] [dest index] [is bone] [is pseudo-edge] [is cage edge] [undocument other data] Bone edges trump pseudo and cage edges.","title":".tgf - control handle graphs"},{"location":"file-formats/xml/","text":".xml - serialization format \u00b6 A .xml file contains the serialization of an object data structure generated with the XMLSerializer: The top level elements represent the groups in which the object are organised. The object names are unique within these groups. <group1> <object1 val=\"value of object 1\"/> <object2 val=\"value of object 2\"/> </group1> <group2> <object1 val=\"value of object 1\"/> </group2> An object can be of following type: Basic types: char, char*, std::string, bool, usigned int, int, float, double STL containers: std::array, std::vector, std::pair Eigen types: Eigen::Matrix, Eigen::SparseMatrix User defined types: XMLSerializable*. There can also be a hierarchical structure like vector<int> , this will result in the following serialization: <group> <vector size=\"3\"> <value0 val=\"1\"/> <value1 val=\"2\"/> <value2 val=\"3\"/> </vector> </group> An example of a serialization of an instance of the class Test class Test{ int var1; vector&ltfloat> vec1; }; is shown here: <group> <Test> <var1 val=\"0\"> <vec1 size=\"2\"> <value0 val=\"1\"/> <value1 val=\"2\"/> </vector> </Test> </group> In the following we show the serialization of Eigen matrices. Eigen::Matrix<int,4,3> : <group> <matrix row=\"4\" col=\"3\" matrix=\" 1,2,3, 4,5,6, 7,8,9, 10,11,12/> </group> Eigen::SparseMatrix<int> (3x3 identity saved as triplets of the non-zero entries): <group> <matrix row=\"3\" col=\"3\" matrix=\" 0,0,1, 1,1,1, 2,2,1/> </group>","title":"xml"},{"location":"file-formats/xml/#xml-serialization-format","text":"A .xml file contains the serialization of an object data structure generated with the XMLSerializer: The top level elements represent the groups in which the object are organised. The object names are unique within these groups. <group1> <object1 val=\"value of object 1\"/> <object2 val=\"value of object 2\"/> </group1> <group2> <object1 val=\"value of object 1\"/> </group2> An object can be of following type: Basic types: char, char*, std::string, bool, usigned int, int, float, double STL containers: std::array, std::vector, std::pair Eigen types: Eigen::Matrix, Eigen::SparseMatrix User defined types: XMLSerializable*. There can also be a hierarchical structure like vector<int> , this will result in the following serialization: <group> <vector size=\"3\"> <value0 val=\"1\"/> <value1 val=\"2\"/> <value2 val=\"3\"/> </vector> </group> An example of a serialization of an instance of the class Test class Test{ int var1; vector&ltfloat> vec1; }; is shown here: <group> <Test> <var1 val=\"0\"> <vec1 size=\"2\"> <value0 val=\"1\"/> <value1 val=\"2\"/> </vector> </Test> </group> In the following we show the serialization of Eigen matrices. Eigen::Matrix<int,4,3> : <group> <matrix row=\"4\" col=\"3\" matrix=\" 1,2,3, 4,5,6, 7,8,9, 10,11,12/> </group> Eigen::SparseMatrix<int> (3x3 identity saved as triplets of the non-zero entries): <group> <matrix row=\"3\" col=\"3\" matrix=\" 0,0,1, 1,1,1, 2,2,1/> </group>","title":".xml - serialization format"}]}